(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],2:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @providesModule EventListener
 * @typechecks
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function (target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function () {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function () {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function (target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function () {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function () {}
};

module.exports = EventListener;
}).call(this,require('_process'))

},{"./emptyFunction":9,"_process":30}],3:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

'use strict';

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;
},{}],4:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelize
 * @typechecks
 */

"use strict";

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;
},{}],5:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelizeStyleName
 * @typechecks
 */

'use strict';

var camelize = require('./camelize');

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;
},{"./camelize":4}],6:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule containsNode
 * @typechecks
 */

'use strict';

var isTextNode = require('./isTextNode');

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 *
 * @param {?DOMNode} outerNode Outer DOM node.
 * @param {?DOMNode} innerNode Inner DOM node.
 * @return {boolean} True if `outerNode` contains or is `innerNode`.
 */
function containsNode(_x, _x2) {
  var _again = true;

  _function: while (_again) {
    var outerNode = _x,
        innerNode = _x2;
    _again = false;

    if (!outerNode || !innerNode) {
      return false;
    } else if (outerNode === innerNode) {
      return true;
    } else if (isTextNode(outerNode)) {
      return false;
    } else if (isTextNode(innerNode)) {
      _x = outerNode;
      _x2 = innerNode.parentNode;
      _again = true;
      continue _function;
    } else if (outerNode.contains) {
      return outerNode.contains(innerNode);
    } else if (outerNode.compareDocumentPosition) {
      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
    } else {
      return false;
    }
  }
}

module.exports = containsNode;
},{"./isTextNode":19}],7:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createArrayFromMixed
 * @typechecks
 */

'use strict';

var toArray = require('./toArray');

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return(
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;
},{"./toArray":27}],8:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule createNodesFromMarkup
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var createArrayFromMixed = require('./createArrayFromMixed');
var getMarkupWrap = require('./getMarkupWrap');
var invariant = require('./invariant');

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = createArrayFromMixed(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":3,"./createArrayFromMixed":7,"./getMarkupWrap":13,"./invariant":17,"_process":30}],9:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyFunction
 */

"use strict";

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
function emptyFunction() {}

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],10:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyObject
 */

'use strict';

var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
}).call(this,require('_process'))

},{"_process":30}],11:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule focusNode
 */

'use strict';

/**
 * @param {DOMElement} node input/textarea to focus
 */
function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;
},{}],12:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getActiveElement
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 */
'use strict';

function getActiveElement() /*?DOMElement*/{
  if (typeof document === 'undefined') {
    return null;
  }
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;
},{}],13:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getMarkupWrap
 */

/*eslint-disable fb-www/unsafe-html */

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var invariant = require('./invariant');

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
}).call(this,require('_process'))

},{"./ExecutionEnvironment":3,"./invariant":17,"_process":30}],14:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getUnboundedScrollPosition
 * @typechecks
 */

'use strict';

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */
function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;
},{}],15:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenate
 * @typechecks
 */

'use strict';

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;
},{}],16:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule hyphenateStyleName
 * @typechecks
 */

'use strict';

var hyphenate = require('./hyphenate');

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;
},{"./hyphenate":15}],17:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

function invariant(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
}).call(this,require('_process'))

},{"_process":30}],18:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isNode
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
'use strict';

function isNode(object) {
  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;
},{}],19:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextNode
 * @typechecks
 */

'use strict';

var isNode = require('./isNode');

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;
},{"./isNode":18}],20:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyMirror
 * @typechecks static-only
 */

'use strict';

var invariant = require('./invariant');

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function (obj) {
  var ret = {};
  var key;
  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;
}).call(this,require('_process'))

},{"./invariant":17,"_process":30}],21:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule keyOf
 */

/**
 * Allows extraction of a minified key. Let's the build system minify keys
 * without losing the ability to dynamically use key strings as values
 * themselves. Pass in an object with a single key/val pair and it will return
 * you the string key of that single record. Suppose you want to grab the
 * value for a key 'className' inside of an object. Key/val minification may
 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
 * reuse those resolutions.
 */
"use strict";

var keyOf = function (oneKeyObj) {
  var key;
  for (key in oneKeyObj) {
    if (!oneKeyObj.hasOwnProperty(key)) {
      continue;
    }
    return key;
  }
  return null;
};

module.exports = keyOf;
},{}],22:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule mapObject
 */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Executes the provided `callback` once for each enumerable own property in the
 * object and constructs a new object from the results. The `callback` is
 * invoked with three arguments:
 *
 *  - the property value
 *  - the property name
 *  - the object being traversed
 *
 * Properties that are added after the call to `mapObject` will not be visited
 * by `callback`. If the values of existing properties are changed, the value
 * passed to `callback` will be the value at the time `mapObject` visits them.
 * Properties that are deleted before being visited are not visited.
 *
 * @grep function objectMap()
 * @grep function objMap()
 *
 * @param {?object} object
 * @param {function} callback
 * @param {*} context
 * @return {?object}
 */
function mapObject(object, callback, context) {
  if (!object) {
    return null;
  }
  var result = {};
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result[name] = callback.call(context, object[name], name, object);
    }
  }
  return result;
}

module.exports = mapObject;
},{}],23:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule memoizeStringOnly
 * @typechecks static-only
 */

'use strict';

/**
 * Memoizes the return value of a function that accepts one string argument.
 *
 * @param {function} callback
 * @return {function}
 */
function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;
},{}],24:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performance
 * @typechecks
 */

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};
},{"./ExecutionEnvironment":3}],25:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule performanceNow
 * @typechecks
 */

'use strict';

var performance = require('./performance');

var performanceNow;

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (performance.now) {
  performanceNow = function () {
    return performance.now();
  };
} else {
  performanceNow = function () {
    return Date.now();
  };
}

module.exports = performanceNow;
},{"./performance":24}],26:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shallowEqual
 * @typechecks
 * 
 */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  var bHasOwnProperty = hasOwnProperty.bind(objB);
  for (var i = 0; i < keysA.length; i++) {
    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;
},{}],27:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule toArray
 * @typechecks
 */

'use strict';

var invariant = require('./invariant');

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
  // old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;

  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;

  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

module.exports = toArray;
}).call(this,require('_process'))

},{"./invariant":17,"_process":30}],28:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule warning
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  warning = function (condition, format) {
    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    }
  };
}

module.exports = warning;
}).call(this,require('_process'))

},{"./emptyFunction":9,"_process":30}],29:[function(require,module,exports){
//! moment.js
//! version : 2.12.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    function isUndefined(input) {
        return input === void 0;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (firstTime) {
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function isObject(input) {
        return Object.prototype.toString.call(input) === '[object Object]';
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    // internal storage for locale config files
    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale');
                config = mergeConfigs(locales[name]._config, config);
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    config = mergeConfigs(locales[config.parentLocale]._config, config);
                } else {
                    // treat as if there is no base config
                    deprecateSimple('parentLocaleUndefined',
                            'specified parentLocale is not defined yet');
                }
            }
            locales[name] = new Locale(config);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale;
            if (locales[name] != null) {
                config = mergeConfigs(locales[name]._config, config);
            }
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function locale_locales__listLocales() {
        return Object.keys(locales);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function get_set__set (mom, unit, value) {
        if (mom.isValid()) {
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        return isArray(this._months) ? this._months[m.month()] :
            this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (typeof value !== 'number') {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')$', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')$', 'i');
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        //the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // constant that refers to the ISO standard
    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        if (!valid__isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             if (this.isValid() && other.isValid()) {
                 return other < this ? this : other;
             } else {
                 return valid__createInvalid();
             }
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return valid__createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
            } else if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(matchOffset, this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-)?P(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)W)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return +this > +localInput;
        } else {
            return +localInput < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return +this < +localInput;
        } else {
            return +this.clone().endOf(units) < +localInput;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return +this === +localInput;
        } else {
            inputMs = +localInput;
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input,units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input,units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            delta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 local__createLocal(time).isValid())) {
            return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        return isArray(this._weekdays) ? this._weekdays[m.day()] :
            this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = local__createLocal([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add               = add_subtract__add;
    momentPrototype__proto.calendar          = moment_calendar__calendar;
    momentPrototype__proto.clone             = clone;
    momentPrototype__proto.diff              = diff;
    momentPrototype__proto.endOf             = endOf;
    momentPrototype__proto.format            = format;
    momentPrototype__proto.from              = from;
    momentPrototype__proto.fromNow           = fromNow;
    momentPrototype__proto.to                = to;
    momentPrototype__proto.toNow             = toNow;
    momentPrototype__proto.get               = getSet;
    momentPrototype__proto.invalidAt         = invalidAt;
    momentPrototype__proto.isAfter           = isAfter;
    momentPrototype__proto.isBefore          = isBefore;
    momentPrototype__proto.isBetween         = isBetween;
    momentPrototype__proto.isSame            = isSame;
    momentPrototype__proto.isSameOrAfter     = isSameOrAfter;
    momentPrototype__proto.isSameOrBefore    = isSameOrBefore;
    momentPrototype__proto.isValid           = moment_valid__isValid;
    momentPrototype__proto.lang              = lang;
    momentPrototype__proto.locale            = locale;
    momentPrototype__proto.localeData        = localeData;
    momentPrototype__proto.max               = prototypeMax;
    momentPrototype__proto.min               = prototypeMin;
    momentPrototype__proto.parsingFlags      = parsingFlags;
    momentPrototype__proto.set               = getSet;
    momentPrototype__proto.startOf           = startOf;
    momentPrototype__proto.subtract          = add_subtract__subtract;
    momentPrototype__proto.toArray           = toArray;
    momentPrototype__proto.toObject          = toObject;
    momentPrototype__proto.toDate            = toDate;
    momentPrototype__proto.toISOString       = moment_format__toISOString;
    momentPrototype__proto.toJSON            = toJSON;
    momentPrototype__proto.toString          = toString;
    momentPrototype__proto.unix              = unix;
    momentPrototype__proto.valueOf           = to_type__valueOf;
    momentPrototype__proto.creationData      = creationData;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months            =        localeMonths;
    prototype__proto._months           = defaultLocaleMonths;
    prototype__proto.monthsShort       =        localeMonthsShort;
    prototype__proto._monthsShort      = defaultLocaleMonthsShort;
    prototype__proto.monthsParse       =        localeMonthsParse;
    prototype__proto._monthsRegex      = defaultMonthsRegex;
    prototype__proto.monthsRegex       = monthsRegex;
    prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
    prototype__proto.monthsShortRegex  = monthsShortRegex;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes <= 1           && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   <= 1           && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    <= 1           && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  <= 1           && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   <= 1           && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.12.0';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.now                   = now;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.updateLocale          = updateLocale;
    utils_hooks__hooks.locales               = locale_locales__listLocales;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
    utils_hooks__hooks.prototype             = momentPrototype;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],30:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],31:[function(require,module,exports){
'use strict';

module.exports = require('react/lib/ReactDOM');

},{"react/lib/ReactDOM":66}],32:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule AutoFocusUtils
 * @typechecks static-only
 */

'use strict';

var ReactMount = require('./ReactMount');

var findDOMNode = require('./findDOMNode');
var focusNode = require('fbjs/lib/focusNode');

var Mixin = {
  componentDidMount: function () {
    if (this.props.autoFocus) {
      focusNode(findDOMNode(this));
    }
  }
};

var AutoFocusUtils = {
  Mixin: Mixin,

  focusDOMComponent: function () {
    focusNode(ReactMount.getNode(this._rootNodeID));
  }
};

module.exports = AutoFocusUtils;
},{"./ReactMount":96,"./findDOMNode":139,"fbjs/lib/focusNode":11}],33:[function(require,module,exports){
/**
 * Copyright 2013-2015 Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule BeforeInputEventPlugin
 * @typechecks static-only
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var FallbackCompositionState = require('./FallbackCompositionState');
var SyntheticCompositionEvent = require('./SyntheticCompositionEvent');
var SyntheticInputEvent = require('./SyntheticInputEvent');

var keyOf = require('fbjs/lib/keyOf');

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

var topLevelTypes = EventConstants.topLevelTypes;

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBeforeInput: null }),
      captured: keyOf({ onBeforeInputCapture: null })
    },
    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionEnd: null }),
      captured: keyOf({ onCompositionEndCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionStart: null }),
      captured: keyOf({ onCompositionStartCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCompositionUpdate: null }),
      captured: keyOf({ onCompositionUpdateCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionStart:
      return eventTypes.compositionStart;
    case topLevelTypes.topCompositionEnd:
      return eventTypes.compositionEnd;
    case topLevelTypes.topCompositionUpdate:
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topKeyUp:
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case topLevelTypes.topKeyDown:
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case topLevelTypes.topKeyPress:
    case topLevelTypes.topMouseDown:
    case topLevelTypes.topBlur:
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {DOMEventTarget} topLevelTarget The listening component root node.
 * @param {string} topLevelTargetID ID of `topLevelTarget`.
 * @param {object} nativeEvent Native browser event.
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case topLevelTypes.topCompositionEnd:
      return getDataFromCustomEvent(nativeEvent);
    case topLevelTypes.topKeyPress:
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case topLevelTypes.topTextInput:
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  if (currentComposition) {
    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case topLevelTypes.topPaste:
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case topLevelTypes.topKeyPress:
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case topLevelTypes.topCompositionEnd:
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {DOMEventTarget} topLevelTarget The listening component root node.
 * @param {string} topLevelTargetID ID of `topLevelTarget`.
 * @param {object} nativeEvent Native browser event.
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
  }
};

module.exports = BeforeInputEventPlugin;
},{"./EventConstants":45,"./EventPropagators":49,"./FallbackCompositionState":50,"./SyntheticCompositionEvent":121,"./SyntheticInputEvent":125,"fbjs/lib/ExecutionEnvironment":3,"fbjs/lib/keyOf":21}],34:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSProperty
 */

'use strict';

/**
 * CSS properties which accept numbers but are not in units of "px".
 */
var isUnitlessNumber = {
  animationIterationCount: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  stopOpacity: true,
  strokeDashoffset: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;
},{}],35:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CSSPropertyOperations
 * @typechecks static-only
 */

'use strict';

var CSSProperty = require('./CSSProperty');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactPerf = require('./ReactPerf');

var camelizeStyleName = require('fbjs/lib/camelizeStyleName');
var dangerousStyleValue = require('./dangerousStyleValue');
var hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');
var memoizeStringOnly = require('fbjs/lib/memoizeStringOnly');
var warning = require('fbjs/lib/warning');

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if (process.env.NODE_ENV !== 'production') {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};

  var warnHyphenatedStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
  };

  var warnBadVendoredStyleName = function (name) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
  };

  var warnStyleValueWithSemicolon = function (name, value) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
  };

  /**
   * @param {string} name
   * @param {*} value
   */
  var warnValidStyle = function (name, value) {
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @return {?string}
   */
  createMarkupForStyles: function (styles) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (process.env.NODE_ENV !== 'production') {
        warnValidStyle(styleName, styleValue);
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   */
  setValueForStyles: function (node, styles) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      if (process.env.NODE_ENV !== 'production') {
        warnValidStyle(styleName, styles[styleName]);
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
      if (styleName === 'float') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
  setValueForStyles: 'setValueForStyles'
});

module.exports = CSSPropertyOperations;
}).call(this,require('_process'))

},{"./CSSProperty":34,"./ReactPerf":102,"./dangerousStyleValue":136,"_process":30,"fbjs/lib/ExecutionEnvironment":3,"fbjs/lib/camelizeStyleName":5,"fbjs/lib/hyphenateStyleName":16,"fbjs/lib/memoizeStringOnly":23,"fbjs/lib/warning":28}],36:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule CallbackQueue
 */

'use strict';

var PooledClass = require('./PooledClass');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */
function CallbackQueue() {
  this._callbacks = null;
  this._contexts = null;
}

assign(CallbackQueue.prototype, {

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */
  enqueue: function (callback, context) {
    this._callbacks = this._callbacks || [];
    this._contexts = this._contexts || [];
    this._callbacks.push(callback);
    this._contexts.push(context);
  },

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */
  notifyAll: function () {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    if (callbacks) {
      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i]);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  },

  /**
   * Resets the internal queue.
   *
   * @internal
   */
  reset: function () {
    this._callbacks = null;
    this._contexts = null;
  },

  /**
   * `PooledClass` looks for this.
   */
  destructor: function () {
    this.reset();
  }

});

PooledClass.addPoolingTo(CallbackQueue);

module.exports = CallbackQueue;
}).call(this,require('_process'))

},{"./Object.assign":53,"./PooledClass":54,"_process":30,"fbjs/lib/invariant":17}],37:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ChangeEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPluginHub = require('./EventPluginHub');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactUpdates = require('./ReactUpdates');
var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');
var isEventSupported = require('./isEventSupported');
var isTextInputElement = require('./isTextInputElement');
var keyOf = require('fbjs/lib/keyOf');

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onChange: null }),
      captured: keyOf({ onChangeCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementID = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementID = null;
}

function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topChange) {
    return topLevelTargetID;
  }
}
function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events
  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
}

/**
 * (For old IE.) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp = {
  get: function () {
    return activeElementValueProp.get.call(this);
  },
  set: function (val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For old IE.) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetID) {
  activeElement = target;
  activeElementID = targetID;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
  // on DOM elements
  Object.defineProperty(activeElement, 'value', newValueProp);
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For old IE.) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;
  activeElement.detachEvent('onpropertychange', handlePropertyChange);

  activeElement = null;
  activeElementID = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For old IE.) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topInput) {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return topLevelTargetID;
  }
}

// For IE8 and IE9.
function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topFocus) {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
  } else if (topLevelType === topLevelTypes.topBlur) {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementID;
    }
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
  if (topLevelType === topLevelTypes.topClick) {
    return topLevelTargetID;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {

    var getTargetIDFunc, handleEventFunc;
    if (shouldUseChangeEvent(topLevelTarget)) {
      if (doesChangeEventBubble) {
        getTargetIDFunc = getTargetIDForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(topLevelTarget)) {
      if (isInputEventSupported) {
        getTargetIDFunc = getTargetIDForInputEvent;
      } else {
        getTargetIDFunc = getTargetIDForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(topLevelTarget)) {
      getTargetIDFunc = getTargetIDForClickEvent;
    }

    if (getTargetIDFunc) {
      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
      if (targetID) {
        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
        event.type = 'change';
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
    }
  }

};

module.exports = ChangeEventPlugin;
},{"./EventConstants":45,"./EventPluginHub":46,"./EventPropagators":49,"./ReactUpdates":114,"./SyntheticEvent":123,"./getEventTarget":145,"./isEventSupported":150,"./isTextInputElement":151,"fbjs/lib/ExecutionEnvironment":3,"fbjs/lib/keyOf":21}],38:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ClientReactRootIndex
 * @typechecks
 */

'use strict';

var nextReactRootIndex = 0;

var ClientReactRootIndex = {
  createReactRootIndex: function () {
    return nextReactRootIndex++;
  }
};

module.exports = ClientReactRootIndex;
},{}],39:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMChildrenOperations
 * @typechecks static-only
 */

'use strict';

var Danger = require('./Danger');
var ReactMultiChildUpdateTypes = require('./ReactMultiChildUpdateTypes');
var ReactPerf = require('./ReactPerf');

var setInnerHTML = require('./setInnerHTML');
var setTextContent = require('./setTextContent');
var invariant = require('fbjs/lib/invariant');

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
function insertChildAt(parentNode, childNode, index) {
  // By exploiting arrays returning `undefined` for an undefined index, we can
  // rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. However, using `undefined` is not allowed by all
  // browsers so we must replace it with `null`.

  // fix render order error in safari
  // IE8 will throw error when index out of list size.
  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);

  parentNode.insertBefore(childNode, beforeChild);
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,

  updateTextContent: setTextContent,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markupList List of markup strings.
   * @internal
   */
  processUpdates: function (updates, markupList) {
    var update;
    // Mapping from parent IDs to initial child orderings.
    var initialChildren = null;
    // List of children that will be moved or removed.
    var updatedChildren = null;

    for (var i = 0; i < updates.length; i++) {
      update = updates[i];
      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
        var updatedIndex = update.fromIndex;
        var updatedChild = update.parentNode.childNodes[updatedIndex];
        var parentID = update.parentID;

        !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;

        initialChildren = initialChildren || {};
        initialChildren[parentID] = initialChildren[parentID] || [];
        initialChildren[parentID][updatedIndex] = updatedChild;

        updatedChildren = updatedChildren || [];
        updatedChildren.push(updatedChild);
      }
    }

    var renderedMarkup;
    // markupList is either a list of markup or just a list of elements
    if (markupList.length && typeof markupList[0] === 'string') {
      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
    } else {
      renderedMarkup = markupList;
    }

    // Remove updated children first so that `toIndex` is consistent.
    if (updatedChildren) {
      for (var j = 0; j < updatedChildren.length; j++) {
        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
      }
    }

    for (var k = 0; k < updates.length; k++) {
      update = updates[k];
      switch (update.type) {
        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
          break;
        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
          break;
        case ReactMultiChildUpdateTypes.SET_MARKUP:
          setInnerHTML(update.parentNode, update.content);
          break;
        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
          setTextContent(update.parentNode, update.content);
          break;
        case ReactMultiChildUpdateTypes.REMOVE_NODE:
          // Already removed by the for-loop above.
          break;
      }
    }
  }

};

ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
  updateTextContent: 'updateTextContent'
});

module.exports = DOMChildrenOperations;
}).call(this,require('_process'))

},{"./Danger":42,"./ReactMultiChildUpdateTypes":98,"./ReactPerf":102,"./setInnerHTML":155,"./setTextContent":156,"_process":30,"fbjs/lib/invariant":17}],40:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMProperty
 * @typechecks static-only
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_ATTRIBUTE: 0x1,
  MUST_USE_PROPERTY: 0x2,
  HAS_SIDE_EFFECTS: 0x4,
  HAS_BOOLEAN_VALUE: 0x8,
  HAS_NUMERIC_VALUE: 0x10,
  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };

      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;

      if (process.env.NODE_ENV !== 'production') {
        DOMProperty.getPossibleStandardName[lowerCased] = propName;
      }

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
        if (process.env.NODE_ENV !== 'production') {
          DOMProperty.getPossibleStandardName[attributeName] = propName;
        }
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty.properties[propName] = propertyInfo;
    }
  }
};
var defaultValueCache = {};

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseAttribute:
   *   Whether the property must be accessed and mutated using `*Attribute()`.
   *   (This includes anything that fails `<propName> in <element>`.)
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasSideEffects:
   *   Whether or not setting a value causes side effects such as triggering
   *   resources to be loaded or text selection changes. If true, we read from
   *   the DOM before updating to ensure that the value is only set if it has
   *   changed.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   * @type {Object}
   */
  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  /**
   * Returns the default property value for a DOM property (i.e., not an
   * attribute). Most default values are '' or false, but not all. Worse yet,
   * some (in particular, `type`) vary depending on the type of element.
   *
   * TODO: Is it better to grab all the possible properties when creating an
   * element to avoid having to create the same element twice?
   */
  getDefaultValueForProperty: function (nodeName, prop) {
    var nodeDefaults = defaultValueCache[nodeName];
    var testElement;
    if (!nodeDefaults) {
      defaultValueCache[nodeName] = nodeDefaults = {};
    }
    if (!(prop in nodeDefaults)) {
      testElement = document.createElement(nodeName);
      nodeDefaults[prop] = testElement[prop];
    }
    return nodeDefaults[prop];
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
}).call(this,require('_process'))

},{"_process":30,"fbjs/lib/invariant":17}],41:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DOMPropertyOperations
 * @typechecks static-only
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactPerf = require('./ReactPerf');

var quoteAttributeValueForBrowser = require('./quoteAttributeValueForBrowser');
var warning = require('fbjs/lib/warning');

// Simplified subset
var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

if (process.env.NODE_ENV !== 'production') {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true
  };
  var warnedProperties = {};

  var warnUnknownProperty = function (name) {
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return;
    }

    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // For now, only warn when we have a suggested correction. This prevents
    // logging too much when using transferPropsTo.
    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
  };
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function (node, id) {
    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    } else if (process.env.NODE_ENV !== 'production') {
      warnUnknownProperty(name);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function (name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
      } else if (propertyInfo.mustUseAttribute) {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      } else {
        var propName = propertyInfo.propertyName;
        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
        // property type before comparing; only `value` does and is string.
        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
          // Contrary to `setAttribute`, object properties are properly
          // `toString`ed by IE8/9.
          node[propName] = value;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      DOMPropertyOperations.setValueForAttribute(node, name, value);
    } else if (process.env.NODE_ENV !== 'production') {
      warnUnknownProperty(name);
    }
  },

  setValueForAttribute: function (node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseAttribute) {
        node.removeAttribute(propertyInfo.attributeName);
      } else {
        var propName = propertyInfo.propertyName;
        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
          node[propName] = defaultValue;
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    } else if (process.env.NODE_ENV !== 'production') {
      warnUnknownProperty(name);
    }
  }

};

ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
  setValueForProperty: 'setValueForProperty',
  setValueForAttribute: 'setValueForAttribute',
  deleteValueForProperty: 'deleteValueForProperty'
});

module.exports = DOMPropertyOperations;
}).call(this,require('_process'))

},{"./DOMProperty":40,"./ReactPerf":102,"./quoteAttributeValueForBrowser":153,"_process":30,"fbjs/lib/warning":28}],42:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Danger
 * @typechecks static-only
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var createNodesFromMarkup = require('fbjs/lib/createNodesFromMarkup');
var emptyFunction = require('fbjs/lib/emptyFunction');
var getMarkupWrap = require('fbjs/lib/getMarkupWrap');
var invariant = require('fbjs/lib/invariant');

var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
var RESULT_INDEX_ATTR = 'data-danger-index';

/**
 * Extracts the `nodeName` from a string of markup.
 *
 * NOTE: Extracting the `nodeName` does not require a regular expression match
 * because we make assumptions about React-generated markup (i.e. there are no
 * spaces surrounding the opening tag and there is at least one attribute).
 *
 * @param {string} markup String of markup.
 * @return {string} Node name of the supplied markup.
 * @see http://jsperf.com/extract-nodename
 */
function getNodeName(markup) {
  return markup.substring(1, markup.indexOf(' '));
}

var Danger = {

  /**
   * Renders markup into an array of nodes. The markup is expected to render
   * into a list of root nodes. Also, the length of `resultList` and
   * `markupList` should be the same.
   *
   * @param {array<string>} markupList List of markup strings to render.
   * @return {array<DOMElement>} List of rendered nodes.
   * @internal
   */
  dangerouslyRenderMarkup: function (markupList) {
    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
    var nodeName;
    var markupByNodeName = {};
    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
    for (var i = 0; i < markupList.length; i++) {
      !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
      nodeName = getNodeName(markupList[i]);
      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
      markupByNodeName[nodeName][i] = markupList[i];
    }
    var resultList = [];
    var resultListAssignmentCount = 0;
    for (nodeName in markupByNodeName) {
      if (!markupByNodeName.hasOwnProperty(nodeName)) {
        continue;
      }
      var markupListByNodeName = markupByNodeName[nodeName];

      // This for-in loop skips the holes of the sparse array. The order of
      // iteration should follow the order of assignment, which happens to match
      // numerical index order, but we don't rely on that.
      var resultIndex;
      for (resultIndex in markupListByNodeName) {
        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
          var markup = markupListByNodeName[resultIndex];

          // Push the requested markup with an additional RESULT_INDEX_ATTR
          // attribute.  If the markup does not start with a < character, it
          // will be discarded below (with an appropriate console.error).
          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
          // This index will be parsed back out below.
          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
        }
      }

      // Render each group of markup with similar wrapping `nodeName`.
      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
      );

      for (var j = 0; j < renderNodes.length; ++j) {
        var renderNode = renderNodes[j];
        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {

          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
          renderNode.removeAttribute(RESULT_INDEX_ATTR);

          !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;

          resultList[resultIndex] = renderNode;

          // This should match resultList.length and markupList.length when
          // we're done.
          resultListAssignmentCount += 1;
        } else if (process.env.NODE_ENV !== 'production') {
          console.error('Danger: Discarding unexpected node:', renderNode);
        }
      }
    }

    // Although resultList was populated out of order, it should now be a dense
    // array.
    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;

    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;

    return resultList;
  },

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
    !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;

    var newChild;
    if (typeof markup === 'string') {
      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
    } else {
      newChild = markup;
    }
    oldChild.parentNode.replaceChild(newChild, oldChild);
  }

};

module.exports = Danger;
}).call(this,require('_process'))

},{"_process":30,"fbjs/lib/ExecutionEnvironment":3,"fbjs/lib/createNodesFromMarkup":8,"fbjs/lib/emptyFunction":9,"fbjs/lib/getMarkupWrap":13,"fbjs/lib/invariant":17}],43:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule DefaultEventPluginOrder
 */

'use strict';

var keyOf = require('fbjs/lib/keyOf');

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */
var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];

module.exports = DefaultEventPluginOrder;
},{"fbjs/lib/keyOf":21}],44:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EnterLeaveEventPlugin
 * @typechecks static-only
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPropagators = require('./EventPropagators');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');

var ReactMount = require('./ReactMount');
var keyOf = require('fbjs/lib/keyOf');

var topLevelTypes = EventConstants.topLevelTypes;
var getFirstReactDOM = ReactMount.getFirstReactDOM;

var eventTypes = {
  mouseEnter: {
    registrationName: keyOf({ onMouseEnter: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  },
  mouseLeave: {
    registrationName: keyOf({ onMouseLeave: null }),
    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
  }
};

var extractedEvents = [null, null];

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (topLevelTarget.window === topLevelTarget) {
      // `topLevelTarget` is probably a window object.
      win = topLevelTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = topLevelTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    var fromID = '';
    var toID = '';
    if (topLevelType === topLevelTypes.topMouseOut) {
      from = topLevelTarget;
      fromID = topLevelTargetID;
      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
      if (to) {
        toID = ReactMount.getID(to);
      } else {
        to = win;
      }
      to = to || win;
    } else {
      from = win;
      to = topLevelTarget;
      toID = topLevelTargetID;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = from;
    leave.relatedTarget = to;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = to;
    enter.relatedTarget = from;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);

    extractedEvents[0] = leave;
    extractedEvents[1] = enter;

    return extractedEvents;
  }

};

module.exports = EnterLeaveEventPlugin;
},{"./EventConstants":45,"./EventPropagators":49,"./ReactMount":96,"./SyntheticMouseEvent":127,"fbjs/lib/keyOf":21}],45:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventConstants
 */

'use strict';

var keyMirror = require('fbjs/lib/keyMirror');

var PropagationPhases = keyMirror({ bubbled: null, captured: null });

/**
 * Types of raw signals from the browser caught at the top level.
 */
var topLevelTypes = keyMirror({
  topAbort: null,
  topBlur: null,
  topCanPlay: null,
  topCanPlayThrough: null,
  topChange: null,
  topClick: null,
  topCompositionEnd: null,
  topCompositionStart: null,
  topCompositionUpdate: null,
  topContextMenu: null,
  topCopy: null,
  topCut: null,
  topDoubleClick: null,
  topDrag: null,
  topDragEnd: null,
  topDragEnter: null,
  topDragExit: null,
  topDragLeave: null,
  topDragOver: null,
  topDragStart: null,
  topDrop: null,
  topDurationChange: null,
  topEmptied: null,
  topEncrypted: null,
  topEnded: null,
  topError: null,
  topFocus: null,
  topInput: null,
  topKeyDown: null,
  topKeyPress: null,
  topKeyUp: null,
  topLoad: null,
  topLoadedData: null,
  topLoadedMetadata: null,
  topLoadStart: null,
  topMouseDown: null,
  topMouseMove: null,
  topMouseOut: null,
  topMouseOver: null,
  topMouseUp: null,
  topPaste: null,
  topPause: null,
  topPlay: null,
  topPlaying: null,
  topProgress: null,
  topRateChange: null,
  topReset: null,
  topScroll: null,
  topSeeked: null,
  topSeeking: null,
  topSelectionChange: null,
  topStalled: null,
  topSubmit: null,
  topSuspend: null,
  topTextInput: null,
  topTimeUpdate: null,
  topTouchCancel: null,
  topTouchEnd: null,
  topTouchMove: null,
  topTouchStart: null,
  topVolumeChange: null,
  topWaiting: null,
  topWheel: null
});

var EventConstants = {
  topLevelTypes: topLevelTypes,
  PropagationPhases: PropagationPhases
};

module.exports = EventConstants;
},{"fbjs/lib/keyMirror":20}],46:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginHub
 */

'use strict';

var EventPluginRegistry = require('./EventPluginRegistry');
var EventPluginUtils = require('./EventPluginUtils');
var ReactErrorUtils = require('./ReactErrorUtils');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

/**
 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
 *   hierarchy given ids of the logical DOM elements involved.
 */
var InstanceHandle = null;

function validateInstanceHandle() {
  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
  process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {object} InjectedMount
     * @public
     */
    injectMount: EventPluginUtils.injection.injectMount,

    /**
     * @param {object} InjectedInstanceHandle
     * @public
     */
    injectInstanceHandle: function (InjectedInstanceHandle) {
      InstanceHandle = InjectedInstanceHandle;
      if (process.env.NODE_ENV !== 'production') {
        validateInstanceHandle();
      }
    },

    getInstanceHandle: function () {
      if (process.env.NODE_ENV !== 'production') {
        validateInstanceHandle();
      }
      return InstanceHandle;
    },

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,

  registrationNameModules: EventPluginRegistry.registrationNameModules,

  /**
   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {?function} listener The callback to store.
   */
  putListener: function (id, registrationName, listener) {
    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : invariant(false) : undefined;

    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[id] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(id, registrationName, listener);
    }
  },

  /**
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (id, registrationName) {
    var bankForRegistrationName = listenerBank[registrationName];
    return bankForRegistrationName && bankForRegistrationName[id];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {string} id ID of the DOM element.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (id, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(id, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      delete bankForRegistrationName[id];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {string} id ID of the DOM element.
   */
  deleteAllListeners: function (id) {
    for (var registrationName in listenerBank) {
      if (!listenerBank[registrationName][id]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(id, registrationName);
      }

      delete listenerBank[registrationName][id];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function (simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }

};

module.exports = EventPluginHub;
}).call(this,require('_process'))

},{"./EventPluginRegistry":47,"./EventPluginUtils":48,"./ReactErrorUtils":87,"./accumulateInto":133,"./forEachAccumulated":141,"_process":30,"fbjs/lib/invariant":17,"fbjs/lib/warning":28}],47:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginRegistry
 * @typechecks static-only
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * Injectable ordering of event plugins.
 */
var EventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!EventPluginOrder) {
    // Wait until an `EventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var PluginModule = namesToPlugins[pluginName];
    var pluginIndex = EventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
    var publishedEvents = PluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, PluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (InjectedEventPluginOrder) {
    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
    // Clone the ordering so it cannot be dynamically mutated.
    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var PluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
        namesToPlugins[pluginName] = PluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    for (var phase in dispatchConfig.phasedRegistrationNames) {
      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
        continue;
      }
      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
      if (PluginModule) {
        return PluginModule;
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    EventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }
  }

};

module.exports = EventPluginRegistry;
}).call(this,require('_process'))

},{"_process":30,"fbjs/lib/invariant":17}],48:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPluginUtils
 */

'use strict';

var EventConstants = require('./EventConstants');
var ReactErrorUtils = require('./ReactErrorUtils');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Injected dependencies:
 */

/**
 * - `Mount`: [required] Module that can convert between React dom IDs and
 *   actual node references.
 */
var injection = {
  Mount: null,
  injectMount: function (InjectedMount) {
    injection.Mount = InjectedMount;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
    }
  }
};

var topLevelTypes = EventConstants.topLevelTypes;

function isEndish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
}

function isMoveish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
}
function isStartish(topLevelType) {
  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
}

var validateEventDispatches;
if (process.env.NODE_ENV !== 'production') {
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchIDs = event._dispatchIDs;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var idsIsArr = Array.isArray(dispatchIDs);
    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {string} domID DOM id to pass to the callback.
 */
function executeDispatch(event, simulated, listener, domID) {
  var type = event.type || 'unknown-event';
  event.currentTarget = injection.Mount.getNode(domID);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
  }
  event._dispatchListeners = null;
  event._dispatchIDs = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchIDs = event._dispatchIDs;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and IDs are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchIDs[i])) {
        return dispatchIDs[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchIDs)) {
      return dispatchIDs;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchIDs = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchID = event._dispatchIDs;
  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
  event._dispatchListeners = null;
  event._dispatchIDs = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getNode: function (id) {
    return injection.Mount.getNode(id);
  },
  getID: function (node) {
    return injection.Mount.getID(node);
  },

  injection: injection
};

module.exports = EventPluginUtils;
}).call(this,require('_process'))

},{"./EventConstants":45,"./ReactErrorUtils":87,"_process":30,"fbjs/lib/invariant":17,"fbjs/lib/warning":28}],49:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventPropagators
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPluginHub = require('./EventPluginHub');

var warning = require('fbjs/lib/warning');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');

var PropagationPhases = EventConstants.PropagationPhases;
var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(id, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(id, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(domID, upwards, event) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
  }
  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
  var listener = listenerAtPhase(domID, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(id, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(id, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event.dispatchMarker, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
}).call(this,require('_process'))

},{"./EventConstants":45,"./EventPluginHub":46,"./accumulateInto":133,"./forEachAccumulated":141,"_process":30,"fbjs/lib/warning":28}],50:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FallbackCompositionState
 * @typechecks static-only
 */

'use strict';

var PooledClass = require('./PooledClass');

var assign = require('./Object.assign');
var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

assign(FallbackCompositionState.prototype, {
  destructor: function () {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;
},{"./Object.assign":53,"./PooledClass":54,"./getTextContentAccessor":148}],51:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule HTMLDOMPropertyConfig
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var hasSVG;
if (ExecutionEnvironment.canUseDOM) {
  var implementation = document.implementation;
  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
}

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
  Properties: {
    /**
     * Standard Properties
     */
    accept: null,
    acceptCharset: null,
    accessKey: null,
    action: null,
    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    allowTransparency: MUST_USE_ATTRIBUTE,
    alt: null,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: null,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    cellPadding: null,
    cellSpacing: null,
    charSet: MUST_USE_ATTRIBUTE,
    challenge: MUST_USE_ATTRIBUTE,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    classID: MUST_USE_ATTRIBUTE,
    // To set className on SVG elements, it's necessary to use .setAttribute;
    // this works on HTML elements too in all browsers except IE8. Conveniently,
    // IE8 doesn't support SVG and so we can simply use the attribute in
    // browsers that support SVG and the property in browsers that don't,
    // regardless of whether the element is HTML or SVG.
    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: null,
    content: null,
    contentEditable: null,
    contextMenu: MUST_USE_ATTRIBUTE,
    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    coords: null,
    crossOrigin: null,
    data: null, // For `<object />` acts as `src`.
    dateTime: MUST_USE_ATTRIBUTE,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: null,
    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: null,
    encType: null,
    form: MUST_USE_ATTRIBUTE,
    formAction: MUST_USE_ATTRIBUTE,
    formEncType: MUST_USE_ATTRIBUTE,
    formMethod: MUST_USE_ATTRIBUTE,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: MUST_USE_ATTRIBUTE,
    frameBorder: MUST_USE_ATTRIBUTE,
    headers: null,
    height: MUST_USE_ATTRIBUTE,
    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    high: null,
    href: null,
    hrefLang: null,
    htmlFor: null,
    httpEquiv: null,
    icon: null,
    id: MUST_USE_PROPERTY,
    inputMode: MUST_USE_ATTRIBUTE,
    integrity: null,
    is: MUST_USE_ATTRIBUTE,
    keyParams: MUST_USE_ATTRIBUTE,
    keyType: MUST_USE_ATTRIBUTE,
    kind: null,
    label: null,
    lang: null,
    list: MUST_USE_ATTRIBUTE,
    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    low: null,
    manifest: MUST_USE_ATTRIBUTE,
    marginHeight: null,
    marginWidth: null,
    max: null,
    maxLength: MUST_USE_ATTRIBUTE,
    media: MUST_USE_ATTRIBUTE,
    mediaGroup: null,
    method: null,
    min: null,
    minLength: MUST_USE_ATTRIBUTE,
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: null,
    nonce: MUST_USE_ATTRIBUTE,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: null,
    pattern: null,
    placeholder: null,
    poster: null,
    preload: null,
    radioGroup: null,
    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    rel: null,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: MUST_USE_ATTRIBUTE,
    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: null,
    sandbox: null,
    scope: null,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: null,
    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: null,
    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
    sizes: MUST_USE_ATTRIBUTE,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: null,
    src: null,
    srcDoc: MUST_USE_PROPERTY,
    srcLang: null,
    srcSet: MUST_USE_ATTRIBUTE,
    start: HAS_NUMERIC_VALUE,
    step: null,
    style: null,
    summary: null,
    tabIndex: null,
    target: null,
    title: null,
    type: null,
    useMap: null,
    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
    width: MUST_USE_ATTRIBUTE,
    wmode: MUST_USE_ATTRIBUTE,
    wrap: null,

    /**
     * RDFa Properties
     */
    about: MUST_USE_ATTRIBUTE,
    datatype: MUST_USE_ATTRIBUTE,
    inlist: MUST_USE_ATTRIBUTE,
    prefix: MUST_USE_ATTRIBUTE,
    // property is also supported for OpenGraph in meta tags.
    property: MUST_USE_ATTRIBUTE,
    resource: MUST_USE_ATTRIBUTE,
    'typeof': MUST_USE_ATTRIBUTE,
    vocab: MUST_USE_ATTRIBUTE,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: MUST_USE_ATTRIBUTE,
    autoCorrect: MUST_USE_ATTRIBUTE,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: null,
    // color is for Safari mask-icon link
    color: null,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: MUST_USE_ATTRIBUTE,
    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
    itemType: MUST_USE_ATTRIBUTE,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: MUST_USE_ATTRIBUTE,
    itemRef: MUST_USE_ATTRIBUTE,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: null,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: MUST_USE_ATTRIBUTE,
    // IE-only attribute that controls focus behavior
    unselectable: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {
    autoComplete: 'autocomplete',
    autoFocus: 'autofocus',
    autoPlay: 'autoplay',
    autoSave: 'autosave',
    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
    encType: 'encoding',
    hrefLang: 'hreflang',
    radioGroup: 'radiogroup',
    spellCheck: 'spellcheck',
    srcDoc: 'srcdoc',
    srcSet: 'srcset'
  }
};

module.exports = HTMLDOMPropertyConfig;
},{"./DOMProperty":40,"fbjs/lib/ExecutionEnvironment":3}],52:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule LinkedValueUtils
 * @typechecks static-only
 */

'use strict';

var ReactPropTypes = require('./ReactPropTypes');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
}

var propTypes = {
  value: function (props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function (props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: ReactPropTypes.func
};

var loggedTypeFailures = {};
function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  checkPropTypes: function (tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum(owner);
        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function (inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

module.exports = LinkedValueUtils;
}).call(this,require('_process'))

},{"./ReactPropTypeLocations":104,"./ReactPropTypes":105,"_process":30,"fbjs/lib/invariant":17,"fbjs/lib/warning":28}],53:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Object.assign
 */

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign

'use strict';

function assign(target, sources) {
  if (target == null) {
    throw new TypeError('Object.assign target cannot be null or undefined');
  }

  var to = Object(target);
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
    var nextSource = arguments[nextIndex];
    if (nextSource == null) {
      continue;
    }

    var from = Object(nextSource);

    // We don't currently support accessors nor proxies. Therefore this
    // copy cannot throw. If we ever supported this then we must handle
    // exceptions and side-effects. We don't support symbols so they won't
    // be transferred.

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
  }

  return to;
}

module.exports = assign;
},{}],54:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule PooledClass
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances (optional).
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler,
  fiveArgumentPooler: fiveArgumentPooler
};

module.exports = PooledClass;
}).call(this,require('_process'))

},{"_process":30,"fbjs/lib/invariant":17}],55:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule React
 */

'use strict';

var ReactDOM = require('./ReactDOM');
var ReactDOMServer = require('./ReactDOMServer');
var ReactIsomorphic = require('./ReactIsomorphic');

var assign = require('./Object.assign');
var deprecated = require('./deprecated');

// `version` will be added here by ReactIsomorphic.
var React = {};

assign(React, ReactIsomorphic);

assign(React, {
  // ReactDOM
  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),

  // ReactDOMServer
  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
});

React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;

module.exports = React;
},{"./Object.assign":53,"./ReactDOM":66,"./ReactDOMServer":76,"./ReactIsomorphic":94,"./deprecated":137}],56:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserComponentMixin
 */

'use strict';

var ReactInstanceMap = require('./ReactInstanceMap');

var findDOMNode = require('./findDOMNode');
var warning = require('fbjs/lib/warning');

var didWarnKey = '_getDOMNodeDidWarn';

var ReactBrowserComponentMixin = {
  /**
   * Returns the DOM node rendered by this component.
   *
   * @return {DOMElement} The root node of this component.
   * @final
   * @protected
   */
  getDOMNode: function () {
    process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
    this.constructor[didWarnKey] = true;
    return findDOMNode(this);
  }
};

module.exports = ReactBrowserComponentMixin;
}).call(this,require('_process'))

},{"./ReactInstanceMap":93,"./findDOMNode":139,"_process":30,"fbjs/lib/warning":28}],57:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactBrowserEventEmitter
 * @typechecks static-only
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPluginHub = require('./EventPluginHub');
var EventPluginRegistry = require('./EventPluginRegistry');
var ReactEventEmitterMixin = require('./ReactEventEmitterMixin');
var ReactPerf = require('./ReactPerf');
var ViewportMetrics = require('./ViewportMetrics');

var assign = require('./Object.assign');
var isEventSupported = require('./isEventSupported');

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    var topLevelTypes = EventConstants.topLevelTypes;
    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === topLevelTypes.topWheel) {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === topLevelTypes.topScroll) {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening[topLevelTypes.topBlur] = true;
          isListening[topLevelTypes.topFocus] = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (!isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  },

  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,

  registrationNameModules: EventPluginHub.registrationNameModules,

  putListener: EventPluginHub.putListener,

  getListener: EventPluginHub.getListener,

  deleteListener: EventPluginHub.deleteListener,

  deleteAllListeners: EventPluginHub.deleteAllListeners

});

ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
  putListener: 'putListener',
  deleteListener: 'deleteListener'
});

module.exports = ReactBrowserEventEmitter;
},{"./EventConstants":45,"./EventPluginHub":46,"./EventPluginRegistry":47,"./Object.assign":53,"./ReactEventEmitterMixin":88,"./ReactPerf":102,"./ViewportMetrics":132,"./isEventSupported":150}],58:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildReconciler
 * @typechecks static-only
 */

'use strict';

var ReactReconciler = require('./ReactReconciler');

var instantiateReactComponent = require('./instantiateReactComponent');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

function instantiateChild(childInstances, child, name) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, null);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context) {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};
    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextChildren, transaction, context) {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return null;
    }
    var name;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      var prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          ReactReconciler.unmountComponent(prevChild, name);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, null);
        nextChildren[name] = nextChildInstance;
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        ReactReconciler.unmountComponent(prevChildren[name]);
      }
    }
    return nextChildren;
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild);
      }
    }
  }

};

module.exports = ReactChildReconciler;
}).call(this,require('_process'))

},{"./ReactReconciler":107,"./instantiateReactComponent":149,"./shouldUpdateReactComponent":157,"./traverseAllChildren":158,"_process":30,"fbjs/lib/warning":28}],59:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildren
 */

'use strict';

var PooledClass = require('./PooledClass');
var ReactElement = require('./ReactElement');

var emptyFunction = require('fbjs/lib/emptyFunction');
var traverseAllChildren = require('./traverseAllChildren');

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func;
  var context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result;
  var keyPrefix = bookKeeping.keyPrefix;
  var func = bookKeeping.func;
  var context = bookKeeping.context;

  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;
},{"./PooledClass":54,"./ReactElement":83,"./traverseAllChildren":158,"fbjs/lib/emptyFunction":9}],60:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactClass
 */

'use strict';

var ReactComponent = require('./ReactComponent');
var ReactElement = require('./ReactElement');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var assign = require('./Object.assign');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var keyMirror = require('fbjs/lib/keyMirror');
var keyOf = require('fbjs/lib/keyOf');
var warning = require('fbjs/lib/warning');

var MIXINS_KEY = keyOf({ mixins: null });

/**
 * Policies that describe methods in `ReactClassInterface`.
 */
var SpecPolicy = keyMirror({
  /**
   * These methods may be defined only once by the class specification or mixin.
   */
  DEFINE_ONCE: null,
  /**
   * These methods may be defined by both the class specification and mixins.
   * Subsequent definitions will be chained. These methods must return void.
   */
  DEFINE_MANY: null,
  /**
   * These methods are overriding the base class.
   */
  OVERRIDE_BASE: null,
  /**
   * These methods are similar to DEFINE_MANY, except we assume they return
   * objects. We try to merge the keys of the return values of all the mixed in
   * functions. If there is a key conflict we throw.
   */
  DEFINE_MANY_MERGED: null
});

var injectedMixins = [];

var warnedSetProps = false;
function warnSetProps() {
  if (!warnedSetProps) {
    warnedSetProps = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
  }
}

/**
 * Composite components are higher-level components that compose other composite
 * or native components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: SpecPolicy.DEFINE_MANY,

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: SpecPolicy.DEFINE_MANY,

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * @return {object}
   * @optional
   */
  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: SpecPolicy.DEFINE_ONCE,

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: SpecPolicy.DEFINE_MANY,

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: SpecPolicy.OVERRIDE_BASE

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
    }
    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
    }
    Constructor.contextTypes = assign({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
    }
    Constructor.propTypes = assign({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: function () {} };

// noop
function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but not in __DEV__
      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
    }
  }
}

function validateMethodOverride(proto, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (proto.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classses.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    return;
  }

  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;

  var proto = Constructor.prototype;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    validateMethodOverride(proto, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isAlreadyDefined = proto.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        if (!proto.__reactAutoBindMap) {
          proto.__reactAutoBindMap = {};
        }
        proto.__reactAutoBindMap[name] = property;
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if (process.env.NODE_ENV !== 'production') {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = (name in RESERVED_SPEC_KEYS);
    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;

    var isInherited = (name in Constructor);
    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if (process.env.NODE_ENV !== 'production') {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    /* eslint-disable block-scoped-var, no-undef */
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
      } else if (!args.length) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
      /* eslint-enable */
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  for (var autoBindKey in component.__reactAutoBindMap) {
    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
      var method = component.__reactAutoBindMap[autoBindKey];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback);
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    return this.updater.isMounted(this);
  },

  /**
   * Sets a subset of the props.
   *
   * @param {object} partialProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */
  setProps: function (partialProps, callback) {
    if (process.env.NODE_ENV !== 'production') {
      warnSetProps();
    }
    this.updater.enqueueSetProps(this, partialProps);
    if (callback) {
      this.updater.enqueueCallback(this, callback);
    }
  },

  /**
   * Replace all the props.
   *
   * @param {object} newProps Subset of the next props.
   * @param {?function} callback Called after props are updated.
   * @final
   * @public
   * @deprecated
   */
  replaceProps: function (newProps, callback) {
    if (process.env.NODE_ENV !== 'production') {
      warnSetProps();
    }
    this.updater.enqueueReplaceProps(this, newProps);
    if (callback) {
      this.updater.enqueueCallback(this, callback);
    }
  }
};

var ReactClassComponent = function () {};
assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    var Constructor = function (props, context, updater) {
      // This constructor is overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindMap) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;

      this.state = initialState;
    };
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;
}).call(this,require('_process'))

},{"./Object.assign":53,"./ReactComponent":61,"./ReactElement":83,"./ReactNoopUpdateQueue":100,"./ReactPropTypeLocationNames":103,"./ReactPropTypeLocations":104,"_process":30,"fbjs/lib/emptyObject":10,"fbjs/lib/invariant":17,"fbjs/lib/keyMirror":20,"fbjs/lib/keyOf":21,"fbjs/lib/warning":28}],61:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponent
 */

'use strict';

var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var canDefineProperty = require('./canDefineProperty');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
  }
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback);
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback);
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if (process.env.NODE_ENV !== 'production') {
  var deprecatedAPIs = {
    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
    setProps: ['setProps', 'Instead, call render again at the top level.']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;
}).call(this,require('_process'))

},{"./ReactNoopUpdateQueue":100,"./canDefineProperty":135,"_process":30,"fbjs/lib/emptyObject":10,"fbjs/lib/invariant":17,"fbjs/lib/warning":28}],62:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentBrowserEnvironment
 */

'use strict';

var ReactDOMIDOperations = require('./ReactDOMIDOperations');
var ReactMount = require('./ReactMount');

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {

  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,

  /**
   * If a particular environment requires that some resources be cleaned up,
   * specify this in the injected Mixin. In the DOM, we would likely want to
   * purge any cached node ID lookups.
   *
   * @private
   */
  unmountIDFromEnvironment: function (rootNodeID) {
    ReactMount.purgeID(rootNodeID);
  }

};

module.exports = ReactComponentBrowserEnvironment;
},{"./ReactDOMIDOperations":71,"./ReactMount":96}],63:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentEnvironment
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

var injected = false;

var ReactComponentEnvironment = {

  /**
   * Optionally injectable environment dependent cleanup hook. (server vs.
   * browser etc). Example: A browser system caches DOM nodes based on component
   * ID and must remove that cache entry when this instance is unmounted.
   */
  unmountIDFromEnvironment: null,

  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkupByID: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }

};

module.exports = ReactComponentEnvironment;
}).call(this,require('_process'))

},{"_process":30,"fbjs/lib/invariant":17}],64:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCompositeComponent
 */

'use strict';

var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactElement = require('./ReactElement');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactPerf = require('./ReactPerf');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdateQueue = require('./ReactUpdateQueue');

var assign = require('./Object.assign');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var warning = require('fbjs/lib/warning');

function getDeclarationErrorAddendum(component) {
  var owner = component._currentElement._owner || null;
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap.get(this)._currentElement.type;
  return Component(this.props, this.context, this.updater);
};

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponentMixin = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = null;
    this._instance = null;

    // See ReactUpdateQueue
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedComponent = null;

    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (rootID, transaction, context) {
    this._context = context;
    this._mountOrder = nextMountID++;
    this._rootNodeID = rootID;

    var publicProps = this._processProps(this._currentElement.props);
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    // Initialize the public class
    var inst;
    var renderedElement;

    // This is a way to detect if Component is a stateless arrow function
    // component, which is not newable. It might not be 100% reliable but is
    // something we can do until we start detecting that Component extends
    // React.Component. We already assume that typeof Component === 'function'.
    var canInstantiate = ('prototype' in Component);

    if (canInstantiate) {
      if (process.env.NODE_ENV !== 'production') {
        ReactCurrentOwner.current = this;
        try {
          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
        } finally {
          ReactCurrentOwner.current = null;
        }
      } else {
        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
      }
    }

    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
      renderedElement = inst;
      inst = new StatelessComponent(Component);
    }

    if (process.env.NODE_ENV !== 'production') {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      if (inst.render == null) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
      } else {
        // We support ES6 inheriting from React.Component, the module pattern,
        // and stateless components, but not ES6 classes that don't extend
        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
      }
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = ReactUpdateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if (process.env.NODE_ENV !== 'production') {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    if (inst.componentWillMount) {
      inst.componentWillMount();
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    this._renderedComponent = this._instantiateReactComponent(renderedElement);

    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
    if (inst.componentDidMount) {
      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
    }

    return markup;
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function () {
    var inst = this._instance;

    if (inst.componentWillUnmount) {
      inst.componentWillUnmount();
    }

    ReactReconciler.unmountComponent(this._renderedComponent);
    this._renderedComponent = null;
    this._instance = null;

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = null;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var maskedContext = null;
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    if (process.env.NODE_ENV !== 'production') {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext = inst.getChildContext && inst.getChildContext();
    if (childContext) {
      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
      if (process.env.NODE_ENV !== 'production') {
        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
      }
      return assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Processes props by setting default values for unspecified props and
   * asserting that the props are valid. Does not mutate its argument; returns
   * a new props object with defaults merged in.
   *
   * @param {object} newProps
   * @return {object}
   * @private
   */
  _processProps: function (newProps) {
    if (process.env.NODE_ENV !== 'production') {
      var Component = this._currentElement.type;
      if (Component.propTypes) {
        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
      }
    }
    return newProps;
  },

  /**
   * Assert that the props are valid
   *
   * @param {object} propTypes Map of prop name to a ReactPropType
   * @param {object} props
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkPropTypes: function (propTypes, props, location) {
    // TODO: Stop validating prop types here and only use the element
    // validation.
    var componentName = this.getName();
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error;
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
          error = propTypes[propName](props, propName, componentName, location);
        } catch (ex) {
          error = ex;
        }
        if (error instanceof Error) {
          // We may want to extend this logic for similar errors in
          // top-level render calls, so I'm abstracting it away into
          // a function to minimize refactoring in the future
          var addendum = getDeclarationErrorAddendum(this);

          if (location === ReactPropTypeLocations.prop) {
            // Preface gives us something to blacklist in warning module
            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
          } else {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
          }
        }
      }
    }
  },

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
    }

    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;

    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
    var nextProps;

    // Distinguish between a props update versus a simple state update
    if (prevParentElement === nextParentElement) {
      // Skip checking prop types again -- we don't read inst.props to avoid
      // warning for DOM component props in this upgrade
      nextProps = nextParentElement.props;
    } else {
      nextProps = this._processProps(nextParentElement.props);
      // An update here will schedule an update but immediately set
      // _pendingStateQueue which will ensure that any state updates gets
      // immediately reconciled instead of waiting for the next batch.

      if (inst.componentWillReceiveProps) {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);

    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
    }

    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      inst.componentWillUpdate(nextProps, nextState, nextContext);
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();
    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      // These two IDs are actually the same! But nothing should rely on that.
      var thisID = this._rootNodeID;
      var prevComponentID = prevComponentInstance._rootNodeID;
      ReactReconciler.unmountComponent(prevComponentInstance);

      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
    }
  },

  /**
   * @protected
   */
  _replaceNodeWithMarkupByID: function (prevComponentID, nextMarkup) {
    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedComponent = inst.render();
    if (process.env.NODE_ENV !== 'production') {
      // We allow auto-mocks to proceed as if they're returning null.
      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedComponent = null;
      }
    }

    return renderedComponent;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedComponent;
    ReactCurrentOwner.current = this;
    try {
      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
    } finally {
      ReactCurrentOwner.current = null;
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
    return renderedComponent;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
    var publicComponentInstance = component.getPublicInstance();
    if (process.env.NODE_ENV !== 'production') {
      var componentName = component && component.getName ? component.getName() : 'a component';
      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
    }
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    var inst = this._instance;
    if (inst instanceof StatelessComponent) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null

};

ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
  mountComponent: 'mountComponent',
  updateComponent: 'updateComponent',
  _renderValidatedComponent: '_renderValidatedComponent'
});

var ReactCompositeComponent = {

  Mixin: ReactCompositeComponentMixin

};

module.exports = ReactCompositeComponent;
}).call(this,require('_process'))

},{"./Object.assign":53,"./ReactComponentEnvironment":63,"./ReactCurrentOwner":65,"./ReactElement":83,"./ReactInstanceMap":93,"./ReactPerf":102,"./ReactPropTypeLocationNames":103,"./ReactPropTypeLocations":104,"./ReactReconciler":107,"./ReactUpdateQueue":113,"./shouldUpdateReactComponent":157,"_process":30,"fbjs/lib/emptyObject":10,"fbjs/lib/invariant":17,"fbjs/lib/warning":28}],65:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCurrentOwner
 */

'use strict';

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;
},{}],66:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOM
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactDOMTextComponent = require('./ReactDOMTextComponent');
var ReactDefaultInjection = require('./ReactDefaultInjection');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMount = require('./ReactMount');
var ReactPerf = require('./ReactPerf');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdates = require('./ReactUpdates');
var ReactVersion = require('./ReactVersion');

var findDOMNode = require('./findDOMNode');
var renderSubtreeIntoContainer = require('./renderSubtreeIntoContainer');
var warning = require('fbjs/lib/warning');

ReactDefaultInjection.inject();

var render = ReactPerf.measure('React', 'render', ReactMount.render);

var React = {
  findDOMNode: findDOMNode,
  render: render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
/* eslint-enable camelcase */
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    CurrentOwner: ReactCurrentOwner,
    InstanceHandles: ReactInstanceHandles,
    Mount: ReactMount,
    Reconciler: ReactReconciler,
    TextComponent: ReactDOMTextComponent
  });
}

if (process.env.NODE_ENV !== 'production') {
  var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

    // First check if devtools is not installed
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    // If we're in IE8, check to see if we are in compatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,

    // shams
    Object.create, Object.freeze];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
        break;
      }
    }
  }
}

module.exports = React;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":65,"./ReactDOMTextComponent":77,"./ReactDefaultInjection":80,"./ReactInstanceHandles":92,"./ReactMount":96,"./ReactPerf":102,"./ReactReconciler":107,"./ReactUpdates":114,"./ReactVersion":115,"./findDOMNode":139,"./renderSubtreeIntoContainer":154,"_process":30,"fbjs/lib/ExecutionEnvironment":3,"fbjs/lib/warning":28}],67:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMButton
 */

'use strict';

var mouseListenerNames = {
  onClick: true,
  onDoubleClick: true,
  onMouseDown: true,
  onMouseMove: true,
  onMouseUp: true,

  onClickCapture: true,
  onDoubleClickCapture: true,
  onMouseDownCapture: true,
  onMouseMoveCapture: true,
  onMouseUpCapture: true
};

/**
 * Implements a <button> native component that does not receive mouse events
 * when `disabled` is set.
 */
var ReactDOMButton = {
  getNativeProps: function (inst, props, context) {
    if (!props.disabled) {
      return props;
    }

    // Copy the props, except the mouse listeners
    var nativeProps = {};
    for (var key in props) {
      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
        nativeProps[key] = props[key];
      }
    }

    return nativeProps;
  }
};

module.exports = ReactDOMButton;
},{}],68:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMComponent
 * @typechecks static-only
 */

/* global hasOwnProperty:true */

'use strict';

var AutoFocusUtils = require('./AutoFocusUtils');
var CSSPropertyOperations = require('./CSSPropertyOperations');
var DOMProperty = require('./DOMProperty');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var EventConstants = require('./EventConstants');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactDOMButton = require('./ReactDOMButton');
var ReactDOMInput = require('./ReactDOMInput');
var ReactDOMOption = require('./ReactDOMOption');
var ReactDOMSelect = require('./ReactDOMSelect');
var ReactDOMTextarea = require('./ReactDOMTextarea');
var ReactMount = require('./ReactMount');
var ReactMultiChild = require('./ReactMultiChild');
var ReactPerf = require('./ReactPerf');
var ReactUpdateQueue = require('./ReactUpdateQueue');

var assign = require('./Object.assign');
var canDefineProperty = require('./canDefineProperty');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var invariant = require('fbjs/lib/invariant');
var isEventSupported = require('./isEventSupported');
var keyOf = require('fbjs/lib/keyOf');
var setInnerHTML = require('./setInnerHTML');
var setTextContent = require('./setTextContent');
var shallowEqual = require('fbjs/lib/shallowEqual');
var validateDOMNesting = require('./validateDOMNesting');
var warning = require('fbjs/lib/warning');

var deleteListener = ReactBrowserEventEmitter.deleteListener;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { 'string': true, 'number': true };

var CHILDREN = keyOf({ children: null });
var STYLE = keyOf({ style: null });
var HTML = keyOf({ __html: null });

var ELEMENT_NODE_TYPE = 1;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

var legacyPropsDescriptor;
if (process.env.NODE_ENV !== 'production') {
  legacyPropsDescriptor = {
    props: {
      enumerable: false,
      get: function () {
        var component = this._reactInternalComponent;
        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
        return component._currentElement.props;
      }
    }
  };
}

function legacyGetDOMNode() {
  if (process.env.NODE_ENV !== 'production') {
    var component = this._reactInternalComponent;
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  return this;
}

function legacyIsMounted() {
  var component = this._reactInternalComponent;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  return !!component;
}

function legacySetStateEtc() {
  if (process.env.NODE_ENV !== 'production') {
    var component = this._reactInternalComponent;
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
}

function legacySetProps(partialProps, callback) {
  var component = this._reactInternalComponent;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  if (!component) {
    return;
  }
  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
  if (callback) {
    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
  }
}

function legacyReplaceProps(partialProps, callback) {
  var component = this._reactInternalComponent;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
  }
  if (!component) {
    return;
  }
  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
  if (callback) {
    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
  }
}

function friendlyStringify(obj) {
  if (typeof obj === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined becauses undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (process.env.NODE_ENV !== 'production') {
    if (voidElementTags[component._tag]) {
      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
    }
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
  }
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
  }
  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
}

function enqueuePutListener(id, registrationName, listener, transaction) {
  if (process.env.NODE_ENV !== 'production') {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
  }
  var container = ReactMount.findReactContainerForID(id);
  if (container) {
    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
    listenTo(registrationName, doc);
  }
  transaction.getReactMountReady().enqueue(putListener, {
    id: id,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
  var node = ReactMount.getNode(inst._rootNodeID);
  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;

  switch (inst._tag) {
    case 'iframe':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
      break;
    case 'video':
    case 'audio':

      inst._wrapperState.listeners = [];
      // create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
        }
      }

      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
      break;
  }
}

function mountReadyInputWrapper() {
  ReactDOMInput.mountReadyWrapper(this);
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special cased tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};

// NOTE: menuitem's close tag should be omitted, but that causes problems.
var newlineEatingTags = {
  'listing': true,
  'pre': true,
  'textarea': true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = assign({
  'menuitem': true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = ({}).hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
    validatedTagCache[tag] = true;
  }
}

function processChildContextDev(context, inst) {
  // Pass down our tag name to child components for validation purposes
  context = assign({}, context);
  var info = context[validateDOMNesting.ancestorInfoContextKey];
  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
  return context;
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(tag) {
  validateDangerousTag(tag);
  this._tag = tag.toLowerCase();
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._rootNodeID = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._nodeWithLegacyProperties = null;
  if (process.env.NODE_ENV !== 'production') {
    this._unprocessedContextDev = null;
    this._processedContextDev = null;
  }
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {

  construct: function (element) {
    this._currentElement = element;
  },

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {string} rootID The root DOM ID for this node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (rootID, transaction, context) {
    this._rootNodeID = rootID;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'iframe':
      case 'img':
      case 'form':
      case 'video':
      case 'audio':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'button':
        props = ReactDOMButton.getNativeProps(this, props, context);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, context);
        props = ReactDOMInput.getNativeProps(this, props, context);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, context);
        props = ReactDOMOption.getNativeProps(this, props, context);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, context);
        props = ReactDOMSelect.getNativeProps(this, props, context);
        context = ReactDOMSelect.processChildContext(this, props, context);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, context);
        props = ReactDOMTextarea.getNativeProps(this, props, context);
        break;
    }

    assertValidProps(this, props);
    if (process.env.NODE_ENV !== 'production') {
      if (context[validateDOMNesting.ancestorInfoContextKey]) {
        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      this._unprocessedContextDev = context;
      this._processedContextDev = processChildContextDev(context, this);
      context = this._processedContextDev;
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
      var el = ownerDocument.createElement(this._currentElement.type);
      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
      // Populate node cache
      ReactMount.getID(el);
      this._updateDOMProperties({}, props, transaction, el);
      this._createInitialChildren(transaction, props, context, el);
      mountImage = el;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'input':
        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
      // falls through
      case 'button':
      case 'select':
      case 'textarea':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if (process.env.NODE_ENV !== 'production') {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (propKey !== CHILDREN) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
    return ret + ' ' + markupForID;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function (transaction, props, context, el) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        setInnerHTML(el, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        setTextContent(el, contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          el.appendChild(mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a native DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'button':
        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
        break;
      case 'input':
        ReactDOMInput.updateWrapper(this);
        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
        break;
    }

    if (process.env.NODE_ENV !== 'production') {
      // If the context is reference-equal to the old one, pass down the same
      // processed object so the update bailout in ReactReconciler behaves
      // correctly (and identically in dev and prod). See #5005.
      if (this._unprocessedContextDev !== context) {
        this._unprocessedContextDev = context;
        this._processedContextDev = processChildContextDev(context, this);
      }
      context = this._processedContextDev;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction, null);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    if (!canDefineProperty && this._nodeWithLegacyProperties) {
      this._nodeWithLegacyProperties.props = nextProps;
    }

    if (this._tag === 'select') {
      // <select> value update needs to occur after <option> children
      // reconciliation
      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function (lastProps, nextProps, transaction, node) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        DOMPropertyOperations.deleteValueForProperty(node, propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if (process.env.NODE_ENV !== 'production') {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this._rootNodeID, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        if (propKey === CHILDREN) {
          nextProp = null;
        }
        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        if (!node) {
          node = ReactMount.getNode(this._rootNodeID);
        }
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertantly setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      if (!node) {
        node = ReactMount.getNode(this._rootNodeID);
      }
      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
    } else if (nextChildren != null) {
      this.updateChildren(nextChildren, transaction, context);
    }
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function () {
    switch (this._tag) {
      case 'iframe':
      case 'img':
      case 'form':
      case 'video':
      case 'audio':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'input':
        ReactDOMInput.unmountWrapper(this);
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
        !false ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
        break;
    }

    this.unmountChildren();
    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
    this._rootNodeID = null;
    this._wrapperState = null;
    if (this._nodeWithLegacyProperties) {
      var node = this._nodeWithLegacyProperties;
      node._reactInternalComponent = null;
      this._nodeWithLegacyProperties = null;
    }
  },

  getPublicInstance: function () {
    if (!this._nodeWithLegacyProperties) {
      var node = ReactMount.getNode(this._rootNodeID);

      node._reactInternalComponent = this;
      node.getDOMNode = legacyGetDOMNode;
      node.isMounted = legacyIsMounted;
      node.setState = legacySetStateEtc;
      node.replaceState = legacySetStateEtc;
      node.forceUpdate = legacySetStateEtc;
      node.setProps = legacySetProps;
      node.replaceProps = legacyReplaceProps;

      if (process.env.NODE_ENV !== 'production') {
        if (canDefineProperty) {
          Object.defineProperties(node, legacyPropsDescriptor);
        } else {
          // updateComponent will update this property on subsequent renders
          node.props = this._currentElement.props;
        }
      } else {
        // updateComponent will update this property on subsequent renders
        node.props = this._currentElement.props;
      }

      this._nodeWithLegacyProperties = node;
    }
    return this._nodeWithLegacyProperties;
  }

};

ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
  mountComponent: 'mountComponent',
  updateComponent: 'updateComponent'
});

assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;
}).call(this,require('_process'))

},{"./AutoFocusUtils":32,"./CSSPropertyOperations":35,"./DOMProperty":40,"./DOMPropertyOperations":41,"./EventConstants":45,"./Object.assign":53,"./ReactBrowserEventEmitter":57,"./ReactComponentBrowserEnvironment":62,"./ReactDOMButton":67,"./ReactDOMInput":72,"./ReactDOMOption":73,"./ReactDOMSelect":74,"./ReactDOMTextarea":78,"./ReactMount":96,"./ReactMultiChild":97,"./ReactPerf":102,"./ReactUpdateQueue":113,"./canDefineProperty":135,"./escapeTextContentForBrowser":138,"./isEventSupported":150,"./setInnerHTML":155,"./setTextContent":156,"./validateDOMNesting":159,"_process":30,"fbjs/lib/invariant":17,"fbjs/lib/keyOf":21,"fbjs/lib/shallowEqual":26,"fbjs/lib/warning":28}],69:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMFactories
 * @typechecks static-only
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactElementValidator = require('./ReactElementValidator');

var mapObject = require('fbjs/lib/mapObject');

/**
 * Create a factory that creates HTML tag elements.
 *
 * @param {string} tag Tag name (e.g. `div`).
 * @private
 */
function createDOMFactory(tag) {
  if (process.env.NODE_ENV !== 'production') {
    return ReactElementValidator.createFactory(tag);
  }
  return ReactElement.createFactory(tag);
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories = mapObject({
  a: 'a',
  abbr: 'abbr',
  address: 'address',
  area: 'area',
  article: 'article',
  aside: 'aside',
  audio: 'audio',
  b: 'b',
  base: 'base',
  bdi: 'bdi',
  bdo: 'bdo',
  big: 'big',
  blockquote: 'blockquote',
  body: 'body',
  br: 'br',
  button: 'button',
  canvas: 'canvas',
  caption: 'caption',
  cite: 'cite',
  code: 'code',
  col: 'col',
  colgroup: 'colgroup',
  data: 'data',
  datalist: 'datalist',
  dd: 'dd',
  del: 'del',
  details: 'details',
  dfn: 'dfn',
  dialog: 'dialog',
  div: 'div',
  dl: 'dl',
  dt: 'dt',
  em: 'em',
  embed: 'embed',
  fieldset: 'fieldset',
  figcaption: 'figcaption',
  figure: 'figure',
  footer: 'footer',
  form: 'form',
  h1: 'h1',
  h2: 'h2',
  h3: 'h3',
  h4: 'h4',
  h5: 'h5',
  h6: 'h6',
  head: 'head',
  header: 'header',
  hgroup: 'hgroup',
  hr: 'hr',
  html: 'html',
  i: 'i',
  iframe: 'iframe',
  img: 'img',
  input: 'input',
  ins: 'ins',
  kbd: 'kbd',
  keygen: 'keygen',
  label: 'label',
  legend: 'legend',
  li: 'li',
  link: 'link',
  main: 'main',
  map: 'map',
  mark: 'mark',
  menu: 'menu',
  menuitem: 'menuitem',
  meta: 'meta',
  meter: 'meter',
  nav: 'nav',
  noscript: 'noscript',
  object: 'object',
  ol: 'ol',
  optgroup: 'optgroup',
  option: 'option',
  output: 'output',
  p: 'p',
  param: 'param',
  picture: 'picture',
  pre: 'pre',
  progress: 'progress',
  q: 'q',
  rp: 'rp',
  rt: 'rt',
  ruby: 'ruby',
  s: 's',
  samp: 'samp',
  script: 'script',
  section: 'section',
  select: 'select',
  small: 'small',
  source: 'source',
  span: 'span',
  strong: 'strong',
  style: 'style',
  sub: 'sub',
  summary: 'summary',
  sup: 'sup',
  table: 'table',
  tbody: 'tbody',
  td: 'td',
  textarea: 'textarea',
  tfoot: 'tfoot',
  th: 'th',
  thead: 'thead',
  time: 'time',
  title: 'title',
  tr: 'tr',
  track: 'track',
  u: 'u',
  ul: 'ul',
  'var': 'var',
  video: 'video',
  wbr: 'wbr',

  // SVG
  circle: 'circle',
  clipPath: 'clipPath',
  defs: 'defs',
  ellipse: 'ellipse',
  g: 'g',
  image: 'image',
  line: 'line',
  linearGradient: 'linearGradient',
  mask: 'mask',
  path: 'path',
  pattern: 'pattern',
  polygon: 'polygon',
  polyline: 'polyline',
  radialGradient: 'radialGradient',
  rect: 'rect',
  stop: 'stop',
  svg: 'svg',
  text: 'text',
  tspan: 'tspan'

}, createDOMFactory);

module.exports = ReactDOMFactories;
}).call(this,require('_process'))

},{"./ReactElement":83,"./ReactElementValidator":84,"_process":30,"fbjs/lib/mapObject":22}],70:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMFeatureFlags
 */

'use strict';

var ReactDOMFeatureFlags = {
  useCreateElement: false
};

module.exports = ReactDOMFeatureFlags;
},{}],71:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMIDOperations
 * @typechecks static-only
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var ReactMount = require('./ReactMount');
var ReactPerf = require('./ReactPerf');

var invariant = require('fbjs/lib/invariant');

/**
 * Errors for properties that should not be updated with `updatePropertyByID()`.
 *
 * @type {object}
 * @private
 */
var INVALID_PROPERTY_ERRORS = {
  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
  style: '`style` must be set using `updateStylesByID()`.'
};

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a DOM node with new property values. This should only be used to
   * update DOM properties in `DOMProperty`.
   *
   * @param {string} id ID of the node to update.
   * @param {string} name A valid property name, see `DOMProperty`.
   * @param {*} value New value of the property.
   * @internal
   */
  updatePropertyByID: function (id, name, value) {
    var node = ReactMount.getNode(id);
    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;

    // If we're updating to null or undefined, we should remove the property
    // from the DOM node instead of inadvertantly setting to a string. This
    // brings us in line with the same behavior we have on initial render.
    if (value != null) {
      DOMPropertyOperations.setValueForProperty(node, name, value);
    } else {
      DOMPropertyOperations.deleteValueForProperty(node, name);
    }
  },

  /**
   * Replaces a DOM node that exists in the document with markup.
   *
   * @param {string} id ID of child to be replaced.
   * @param {string} markup Dangerous markup to inject in place of child.
   * @internal
   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
   */
  dangerouslyReplaceNodeWithMarkupByID: function (id, markup) {
    var node = ReactMount.getNode(id);
    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
  },

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @param {array<string>} markup List of markup strings.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (updates, markup) {
    for (var i = 0; i < updates.length; i++) {
      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
    }
    DOMChildrenOperations.processUpdates(updates, markup);
  }
};

ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
});

module.exports = ReactDOMIDOperations;
}).call(this,require('_process'))

},{"./DOMChildrenOperations":39,"./DOMPropertyOperations":41,"./ReactMount":96,"./ReactPerf":102,"_process":30,"fbjs/lib/invariant":17}],72:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMInput
 */

'use strict';

var ReactDOMIDOperations = require('./ReactDOMIDOperations');
var LinkedValueUtils = require('./LinkedValueUtils');
var ReactMount = require('./ReactMount');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');

var instancesByReactID = {};

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput.updateWrapper(this);
  }
}

/**
 * Implements an <input> native component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getNativeProps: function (inst, props, context) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var nativeProps = assign({}, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return nativeProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
    }

    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.defaultChecked || false,
      initialValue: defaultValue != null ? defaultValue : null,
      onChange: _handleChange.bind(inst)
    };
  },

  mountReadyWrapper: function (inst) {
    // Can't be in mountWrapper or else server rendering leaks.
    instancesByReactID[inst._rootNodeID] = inst;
  },

  unmountWrapper: function (inst) {
    delete instancesByReactID[inst._rootNodeID];
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
    }

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactMount.getNode(this._rootNodeID);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React with non-React.
      var otherID = ReactMount.getID(otherNode);
      !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
      var otherInstance = instancesByReactID[otherID];
      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

module.exports = ReactDOMInput;
}).call(this,require('_process'))

},{"./LinkedValueUtils":52,"./Object.assign":53,"./ReactDOMIDOperations":71,"./ReactMount":96,"./ReactUpdates":114,"_process":30,"fbjs/lib/invariant":17}],73:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMOption
 */

'use strict';

var ReactChildren = require('./ReactChildren');
var ReactDOMSelect = require('./ReactDOMSelect');

var assign = require('./Object.assign');
var warning = require('fbjs/lib/warning');

var valueContextKey = ReactDOMSelect.valueContextKey;

/**
 * Implements an <option> native component that warns when `selected` is set.
 */
var ReactDOMOption = {
  mountWrapper: function (inst, props, context) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
    }

    // Look up whether this option is 'selected' via context
    var selectValue = context[valueContextKey];

    // If context key is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === '' + props.value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === '' + props.value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  getNativeProps: function (inst, props, context) {
    var nativeProps = assign({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      nativeProps.selected = inst._wrapperState.selected;
    }

    var content = '';

    // Flatten children and warn if they aren't strings or numbers;
    // invalid types are ignored.
    ReactChildren.forEach(props.children, function (child) {
      if (child == null) {
        return;
      }
      if (typeof child === 'string' || typeof child === 'number') {
        content += child;
      } else {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
      }
    });

    if (content) {
      nativeProps.children = content;
    }

    return nativeProps;
  }

};

module.exports = ReactDOMOption;
}).call(this,require('_process'))

},{"./Object.assign":53,"./ReactChildren":59,"./ReactDOMSelect":74,"_process":30,"fbjs/lib/warning":28}],74:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelect
 */

'use strict';

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactMount = require('./ReactMount');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var warning = require('fbjs/lib/warning');

var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils.getValue(props);

    if (value != null) {
      updateOptions(this, Boolean(props.multiple), value);
    }
  }
}

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils.checkPropTypes('select', props, owner);

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    if (props.multiple) {
      process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
    } else {
      process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactMount.getNode(inst._rootNodeID).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> native component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = {
  valueContextKey: valueContextKey,

  getNativeProps: function (inst, props, context) {
    return assign({}, props, {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      checkSelectPropTypes(inst, props);
    }

    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      onChange: _handleChange.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };
  },

  processChildContext: function (inst, props, context) {
    // Pass down initial value so initial generated markup has correct
    // `selected` attributes
    var childContext = assign({}, context);
    childContext[valueContextKey] = inst._wrapperState.initialValue;
    return childContext;
  },

  postUpdateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // After the initial mount, we control selected-ness manually so don't pass
    // the context value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  this._wrapperState.pendingUpdate = true;
  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

module.exports = ReactDOMSelect;
}).call(this,require('_process'))

},{"./LinkedValueUtils":52,"./Object.assign":53,"./ReactMount":96,"./ReactUpdates":114,"_process":30,"fbjs/lib/warning":28}],75:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMSelection
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var getNodeForCharacterOffset = require('./getNodeForCharacterOffset');
var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (typeof offsets.end === 'undefined') {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;
},{"./getNodeForCharacterOffset":147,"./getTextContentAccessor":148,"fbjs/lib/ExecutionEnvironment":3}],76:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMServer
 */

'use strict';

var ReactDefaultInjection = require('./ReactDefaultInjection');
var ReactServerRendering = require('./ReactServerRendering');
var ReactVersion = require('./ReactVersion');

ReactDefaultInjection.inject();

var ReactDOMServer = {
  renderToString: ReactServerRendering.renderToString,
  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
  version: ReactVersion
};

module.exports = ReactDOMServer;
},{"./ReactDefaultInjection":80,"./ReactServerRendering":111,"./ReactVersion":115}],77:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextComponent
 * @typechecks static-only
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactMount = require('./ReactMount');

var assign = require('./Object.assign');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var setTextContent = require('./setTextContent');
var validateDOMNesting = require('./validateDOMNesting');

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings in elements so that they can undergo
 * the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function (props) {
  // This constructor and its argument is currently used by mocks.
};

assign(ReactDOMTextComponent.prototype, {

  /**
   * @param {ReactText} text
   * @internal
   */
  construct: function (text) {
    // TODO: This is really a ReactText (ReactNode), not a ReactElement
    this._currentElement = text;
    this._stringText = '' + text;

    // Properties
    this._rootNodeID = null;
    this._mountIndex = 0;
  },

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (rootID, transaction, context) {
    if (process.env.NODE_ENV !== 'production') {
      if (context[validateDOMNesting.ancestorInfoContextKey]) {
        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
      }
    }

    this._rootNodeID = rootID;
    if (transaction.useCreateElement) {
      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
      var el = ownerDocument.createElement('span');
      DOMPropertyOperations.setAttributeForID(el, rootID);
      // Populate node cache
      ReactMount.getID(el);
      setTextContent(el, this._stringText);
      return el;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this in a `span` for the reasons stated above, but
        // since this is a situation where React won't take over (static pages),
        // we can simply return the text as it is.
        return escapedText;
      }

      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var node = ReactMount.getNode(this._rootNodeID);
        DOMChildrenOperations.updateTextContent(node, nextStringText);
      }
    }
  },

  unmountComponent: function () {
    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
  }

});

module.exports = ReactDOMTextComponent;
}).call(this,require('_process'))

},{"./DOMChildrenOperations":39,"./DOMPropertyOperations":41,"./Object.assign":53,"./ReactComponentBrowserEnvironment":62,"./ReactMount":96,"./escapeTextContentForBrowser":138,"./setTextContent":156,"./validateDOMNesting":159,"_process":30}],78:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMTextarea
 */

'use strict';

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMIDOperations = require('./ReactDOMIDOperations');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea.updateWrapper(this);
  }
}

/**
 * Implements a <textarea> native component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = {
  getNativeProps: function (inst, props, context) {
    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.
    var nativeProps = assign({}, props, {
      defaultValue: undefined,
      value: undefined,
      children: inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return nativeProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
    }

    var defaultValue = props.defaultValue;
    // TODO (yungsters): Remove support for children content in <textarea>.
    var children = props.children;
    if (children != null) {
      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
      }
      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
      if (Array.isArray(children)) {
        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
        children = children[0];
      }

      defaultValue = '' + children;
    }
    if (defaultValue == null) {
      defaultValue = '';
    }
    var value = LinkedValueUtils.getValue(props);

    inst._wrapperState = {
      // We save the initial value so that `ReactDOMComponent` doesn't update
      // `textContent` (unnecessary since we update value).
      // The initial value can be a boolean or object so that's why it's
      // forced to be a string.
      initialValue: '' + (value != null ? value : defaultValue),
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);
  ReactUpdates.asap(forceUpdateIfMounted, this);
  return returnValue;
}

module.exports = ReactDOMTextarea;
}).call(this,require('_process'))

},{"./LinkedValueUtils":52,"./Object.assign":53,"./ReactDOMIDOperations":71,"./ReactUpdates":114,"_process":30,"fbjs/lib/invariant":17,"fbjs/lib/warning":28}],79:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultBatchingStrategy
 */

'use strict';

var ReactUpdates = require('./ReactUpdates');
var Transaction = require('./Transaction');

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      callback(a, b, c, d, e);
    } else {
      transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
},{"./Object.assign":53,"./ReactUpdates":114,"./Transaction":131,"fbjs/lib/emptyFunction":9}],80:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultInjection
 */

'use strict';

var BeforeInputEventPlugin = require('./BeforeInputEventPlugin');
var ChangeEventPlugin = require('./ChangeEventPlugin');
var ClientReactRootIndex = require('./ClientReactRootIndex');
var DefaultEventPluginOrder = require('./DefaultEventPluginOrder');
var EnterLeaveEventPlugin = require('./EnterLeaveEventPlugin');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var HTMLDOMPropertyConfig = require('./HTMLDOMPropertyConfig');
var ReactBrowserComponentMixin = require('./ReactBrowserComponentMixin');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
var ReactDOMComponent = require('./ReactDOMComponent');
var ReactDOMTextComponent = require('./ReactDOMTextComponent');
var ReactEventListener = require('./ReactEventListener');
var ReactInjection = require('./ReactInjection');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMount = require('./ReactMount');
var ReactReconcileTransaction = require('./ReactReconcileTransaction');
var SelectEventPlugin = require('./SelectEventPlugin');
var ServerReactRootIndex = require('./ServerReactRootIndex');
var SimpleEventPlugin = require('./SimpleEventPlugin');
var SVGDOMPropertyConfig = require('./SVGDOMPropertyConfig');

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
  ReactInjection.EventPluginHub.injectMount(ReactMount);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);

  if (process.env.NODE_ENV !== 'production') {
    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
    if (/[?&]react_perf\b/.test(url)) {
      var ReactDefaultPerf = require('./ReactDefaultPerf');
      ReactDefaultPerf.start();
    }
  }
}

module.exports = {
  inject: inject
};
}).call(this,require('_process'))

},{"./BeforeInputEventPlugin":33,"./ChangeEventPlugin":37,"./ClientReactRootIndex":38,"./DefaultEventPluginOrder":43,"./EnterLeaveEventPlugin":44,"./HTMLDOMPropertyConfig":51,"./ReactBrowserComponentMixin":56,"./ReactComponentBrowserEnvironment":62,"./ReactDOMComponent":68,"./ReactDOMTextComponent":77,"./ReactDefaultBatchingStrategy":79,"./ReactDefaultPerf":81,"./ReactEventListener":89,"./ReactInjection":90,"./ReactInstanceHandles":92,"./ReactMount":96,"./ReactReconcileTransaction":106,"./SVGDOMPropertyConfig":116,"./SelectEventPlugin":117,"./ServerReactRootIndex":118,"./SimpleEventPlugin":119,"_process":30,"fbjs/lib/ExecutionEnvironment":3}],81:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerf
 * @typechecks static-only
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactDefaultPerfAnalysis = require('./ReactDefaultPerfAnalysis');
var ReactMount = require('./ReactMount');
var ReactPerf = require('./ReactPerf');

var performanceNow = require('fbjs/lib/performanceNow');

function roundFloat(val) {
  return Math.floor(val * 100) / 100;
}

function addValue(obj, key, val) {
  obj[key] = (obj[key] || 0) + val;
}

var ReactDefaultPerf = {
  _allMeasurements: [], // last item in the list is the current one
  _mountStack: [0],
  _injected: false,

  start: function () {
    if (!ReactDefaultPerf._injected) {
      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
    }

    ReactDefaultPerf._allMeasurements.length = 0;
    ReactPerf.enableMeasure = true;
  },

  stop: function () {
    ReactPerf.enableMeasure = false;
  },

  getLastMeasurements: function () {
    return ReactDefaultPerf._allMeasurements;
  },

  printExclusive: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
    console.table(summary.map(function (item) {
      return {
        'Component class name': item.componentName,
        'Total inclusive time (ms)': roundFloat(item.inclusive),
        'Exclusive mount time (ms)': roundFloat(item.exclusive),
        'Exclusive render time (ms)': roundFloat(item.render),
        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
        'Render time per instance (ms)': roundFloat(item.render / item.count),
        'Instances': item.count
      };
    }));
    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
    // number.
  },

  printInclusive: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
    console.table(summary.map(function (item) {
      return {
        'Owner > component': item.componentName,
        'Inclusive time (ms)': roundFloat(item.time),
        'Instances': item.count
      };
    }));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  getMeasurementsSummaryMap: function (measurements) {
    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
    return summary.map(function (item) {
      return {
        'Owner > component': item.componentName,
        'Wasted time (ms)': item.time,
        'Instances': item.count
      };
    });
  },

  printWasted: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  printDOM: function (measurements) {
    measurements = measurements || ReactDefaultPerf._allMeasurements;
    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
    console.table(summary.map(function (item) {
      var result = {};
      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
      result.type = item.type;
      result.args = JSON.stringify(item.args);
      return result;
    }));
    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
  },

  _recordWrite: function (id, fnName, totalTime, args) {
    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
    writes[id] = writes[id] || [];
    writes[id].push({
      type: fnName,
      time: totalTime,
      args: args
    });
  },

  measure: function (moduleName, fnName, func) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var totalTime;
      var rv;
      var start;

      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
        // A "measurement" is a set of metrics recorded for each flush. We want
        // to group the metrics for a given flush together so we can look at the
        // components that rendered and the DOM operations that actually
        // happened to determine the amount of "wasted work" performed.
        ReactDefaultPerf._allMeasurements.push({
          exclusive: {},
          inclusive: {},
          render: {},
          counts: {},
          writes: {},
          displayNames: {},
          totalTime: 0,
          created: {}
        });
        start = performanceNow();
        rv = func.apply(this, args);
        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
        return rv;
      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (fnName === '_mountImageIntoNode') {
          var mountID = ReactMount.getID(args[1]);
          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
          // special format
          args[0].forEach(function (update) {
            var writeArgs = {};
            if (update.fromIndex !== null) {
              writeArgs.fromIndex = update.fromIndex;
            }
            if (update.toIndex !== null) {
              writeArgs.toIndex = update.toIndex;
            }
            if (update.textContent !== null) {
              writeArgs.textContent = update.textContent;
            }
            if (update.markupIndex !== null) {
              writeArgs.markup = args[1][update.markupIndex];
            }
            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
          });
        } else {
          // basic format
          var id = args[0];
          if (typeof id === 'object') {
            id = ReactMount.getID(args[0]);
          }
          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
        }
        return rv;
      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
      fnName === '_renderValidatedComponent')) {

        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
          return func.apply(this, args);
        }

        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
        var isRender = fnName === '_renderValidatedComponent';
        var isMount = fnName === 'mountComponent';

        var mountStack = ReactDefaultPerf._mountStack;
        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];

        if (isRender) {
          addValue(entry.counts, rootNodeID, 1);
        } else if (isMount) {
          entry.created[rootNodeID] = true;
          mountStack.push(0);
        }

        start = performanceNow();
        rv = func.apply(this, args);
        totalTime = performanceNow() - start;

        if (isRender) {
          addValue(entry.render, rootNodeID, totalTime);
        } else if (isMount) {
          var subMountTime = mountStack.pop();
          mountStack[mountStack.length - 1] += totalTime;
          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
          addValue(entry.inclusive, rootNodeID, totalTime);
        } else {
          addValue(entry.inclusive, rootNodeID, totalTime);
        }

        entry.displayNames[rootNodeID] = {
          current: this.getName(),
          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
        };

        return rv;
      } else {
        return func.apply(this, args);
      }
    };
  }
};

module.exports = ReactDefaultPerf;
},{"./DOMProperty":40,"./ReactDefaultPerfAnalysis":82,"./ReactMount":96,"./ReactPerf":102,"fbjs/lib/performanceNow":25}],82:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDefaultPerfAnalysis
 */

'use strict';

var assign = require('./Object.assign');

// Don't try to save users less than 1.2ms (a number I made up)
var DONT_CARE_THRESHOLD = 1.2;
var DOM_OPERATION_TYPES = {
  '_mountImageIntoNode': 'set innerHTML',
  INSERT_MARKUP: 'set innerHTML',
  MOVE_EXISTING: 'move',
  REMOVE_NODE: 'remove',
  SET_MARKUP: 'set innerHTML',
  TEXT_CONTENT: 'set textContent',
  'setValueForProperty': 'update attribute',
  'setValueForAttribute': 'update attribute',
  'deleteValueForProperty': 'remove attribute',
  'setValueForStyles': 'update styles',
  'replaceNodeWithMarkup': 'replace',
  'updateTextContent': 'set textContent'
};

function getTotalTime(measurements) {
  // TODO: return number of DOM ops? could be misleading.
  // TODO: measure dropped frames after reconcile?
  // TODO: log total time of each reconcile and the top-level component
  // class that triggered it.
  var totalTime = 0;
  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    totalTime += measurement.totalTime;
  }
  return totalTime;
}

function getDOMSummary(measurements) {
  var items = [];
  measurements.forEach(function (measurement) {
    Object.keys(measurement.writes).forEach(function (id) {
      measurement.writes[id].forEach(function (write) {
        items.push({
          id: id,
          type: DOM_OPERATION_TYPES[write.type] || write.type,
          args: write.args
        });
      });
    });
  });
  return items;
}

function getExclusiveSummary(measurements) {
  var candidates = {};
  var displayName;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

    for (var id in allIDs) {
      displayName = measurement.displayNames[id].current;

      candidates[displayName] = candidates[displayName] || {
        componentName: displayName,
        inclusive: 0,
        exclusive: 0,
        render: 0,
        count: 0
      };
      if (measurement.render[id]) {
        candidates[displayName].render += measurement.render[id];
      }
      if (measurement.exclusive[id]) {
        candidates[displayName].exclusive += measurement.exclusive[id];
      }
      if (measurement.inclusive[id]) {
        candidates[displayName].inclusive += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[displayName].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (displayName in candidates) {
    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[displayName]);
    }
  }

  arr.sort(function (a, b) {
    return b.exclusive - a.exclusive;
  });

  return arr;
}

function getInclusiveSummary(measurements, onlyClean) {
  var candidates = {};
  var inclusiveKey;

  for (var i = 0; i < measurements.length; i++) {
    var measurement = measurements[i];
    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
    var cleanComponents;

    if (onlyClean) {
      cleanComponents = getUnchangedComponents(measurement);
    }

    for (var id in allIDs) {
      if (onlyClean && !cleanComponents[id]) {
        continue;
      }

      var displayName = measurement.displayNames[id];

      // Inclusive time is not useful for many components without knowing where
      // they are instantiated. So we aggregate inclusive time with both the
      // owner and current displayName as the key.
      inclusiveKey = displayName.owner + ' > ' + displayName.current;

      candidates[inclusiveKey] = candidates[inclusiveKey] || {
        componentName: inclusiveKey,
        time: 0,
        count: 0
      };

      if (measurement.inclusive[id]) {
        candidates[inclusiveKey].time += measurement.inclusive[id];
      }
      if (measurement.counts[id]) {
        candidates[inclusiveKey].count += measurement.counts[id];
      }
    }
  }

  // Now make a sorted array with the results.
  var arr = [];
  for (inclusiveKey in candidates) {
    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
      arr.push(candidates[inclusiveKey]);
    }
  }

  arr.sort(function (a, b) {
    return b.time - a.time;
  });

  return arr;
}

function getUnchangedComponents(measurement) {
  // For a given reconcile, look at which components did not actually
  // render anything to the DOM and return a mapping of their ID to
  // the amount of time it took to render the entire subtree.
  var cleanComponents = {};
  var dirtyLeafIDs = Object.keys(measurement.writes);
  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);

  for (var id in allIDs) {
    var isDirty = false;
    // For each component that rendered, see if a component that triggered
    // a DOM op is in its subtree.
    for (var i = 0; i < dirtyLeafIDs.length; i++) {
      if (dirtyLeafIDs[i].indexOf(id) === 0) {
        isDirty = true;
        break;
      }
    }
    // check if component newly created
    if (measurement.created[id]) {
      isDirty = true;
    }
    if (!isDirty && measurement.counts[id] > 0) {
      cleanComponents[id] = true;
    }
  }
  return cleanComponents;
}

var ReactDefaultPerfAnalysis = {
  getExclusiveSummary: getExclusiveSummary,
  getInclusiveSummary: getInclusiveSummary,
  getDOMSummary: getDOMSummary,
  getTotalTime: getTotalTime
};

module.exports = ReactDefaultPerfAnalysis;
},{"./Object.assign":53}],83:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElement
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');

var assign = require('./Object.assign');
var canDefineProperty = require('./canDefineProperty');

// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

/**
 * Base constructor for all React elements. This is only used to make this
 * work with a dynamic instanceof check. Nothing should live on this prototype.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if (process.env.NODE_ENV !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    Object.freeze(element.props);
    Object.freeze(element);
  }

  return element;
};

ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    ref = config.ref === undefined ? null : config.ref;
    key = config.key === undefined ? null : '' + config.key;
    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (typeof props[propName] === 'undefined') {
        props[propName] = defaultProps[propName];
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);

  if (process.env.NODE_ENV !== 'production') {
    // If the key on the original is valid, then the clone is valid
    newElement._store.validated = oldElement._store.validated;
  }

  return newElement;
};

ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (config.ref !== undefined) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (config.key !== undefined) {
      key = '' + config.key;
    }
    // Remaining properties override existing props
    for (propName in config) {
      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
}).call(this,require('_process'))

},{"./Object.assign":53,"./ReactCurrentOwner":65,"./canDefineProperty":135,"_process":30}],84:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElementValidator
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactCurrentOwner = require('./ReactCurrentOwner');

var canDefineProperty = require('./canDefineProperty');
var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

var loggedTypeFailures = {};

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
  if (addenda === null) {
    // we already showed the warning
    return;
  }
  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
}

/**
 * Shared warning and monitoring code for the key warnings.
 *
 * @internal
 * @param {string} messageType A key used for de-duping warnings.
 * @param {ReactElement} element Component that requires a key.
 * @param {*} parentType element's parent's type.
 * @returns {?object} A set of addenda to use in the warning message, or null
 * if the warning has already been shown before (and shouldn't be shown again).
 */
function getAddendaForKeyUse(messageType, element, parentType) {
  var addendum = getDeclarationErrorAddendum();
  if (!addendum) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      addendum = ' Check the top-level render call using <' + parentName + '>.';
    }
  }

  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
  if (memoizer[addendum]) {
    return null;
  }
  memoizer[addendum] = true;

  var addenda = {
    parentOrOwner: addendum,
    url: ' See https://fb.me/react-warning-keys for more information.',
    childOwner: null
  };

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  return addenda;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Assert that the props are valid
 *
 * @param {string} componentName Name of the component for error messages.
 * @param {object} propTypes Map of prop name to a ReactPropType
 * @param {object} props
 * @param {string} location e.g. "prop", "context", "child context"
 * @private
 */
function checkPropTypes(componentName, propTypes, props, location) {
  for (var propName in propTypes) {
    if (propTypes.hasOwnProperty(propName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
        error = propTypes[propName](props, propName, componentName, location);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error) : undefined;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum();
        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
  }
}

var ReactElementValidator = {

  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if (process.env.NODE_ENV !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":65,"./ReactElement":83,"./ReactPropTypeLocationNames":103,"./ReactPropTypeLocations":104,"./canDefineProperty":135,"./getIteratorFn":146,"_process":30,"fbjs/lib/invariant":17,"fbjs/lib/warning":28}],85:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEmptyComponent
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactEmptyComponentRegistry = require('./ReactEmptyComponentRegistry');
var ReactReconciler = require('./ReactReconciler');

var assign = require('./Object.assign');

var placeholderElement;

var ReactEmptyComponentInjection = {
  injectEmptyComponent: function (component) {
    placeholderElement = ReactElement.createElement(component);
  }
};

var ReactEmptyComponent = function (instantiate) {
  this._currentElement = null;
  this._rootNodeID = null;
  this._renderedComponent = instantiate(placeholderElement);
};
assign(ReactEmptyComponent.prototype, {
  construct: function (element) {},
  mountComponent: function (rootID, transaction, context) {
    ReactEmptyComponentRegistry.registerNullComponentID(rootID);
    this._rootNodeID = rootID;
    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
  },
  receiveComponent: function () {},
  unmountComponent: function (rootID, transaction, context) {
    ReactReconciler.unmountComponent(this._renderedComponent);
    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
    this._rootNodeID = null;
    this._renderedComponent = null;
  }
});

ReactEmptyComponent.injection = ReactEmptyComponentInjection;

module.exports = ReactEmptyComponent;
},{"./Object.assign":53,"./ReactElement":83,"./ReactEmptyComponentRegistry":86,"./ReactReconciler":107}],86:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEmptyComponentRegistry
 */

'use strict';

// This registry keeps track of the React IDs of the components that rendered to
// `null` (in reality a placeholder such as `noscript`)
var nullComponentIDsRegistry = {};

/**
 * @param {string} id Component's `_rootNodeID`.
 * @return {boolean} True if the component is rendered to null.
 */
function isNullComponentID(id) {
  return !!nullComponentIDsRegistry[id];
}

/**
 * Mark the component as having rendered to null.
 * @param {string} id Component's `_rootNodeID`.
 */
function registerNullComponentID(id) {
  nullComponentIDsRegistry[id] = true;
}

/**
 * Unmark the component as having rendered to null: it renders to something now.
 * @param {string} id Component's `_rootNodeID`.
 */
function deregisterNullComponentID(id) {
  delete nullComponentIDsRegistry[id];
}

var ReactEmptyComponentRegistry = {
  isNullComponentID: isNullComponentID,
  registerNullComponentID: registerNullComponentID,
  deregisterNullComponentID: deregisterNullComponentID
};

module.exports = ReactEmptyComponentRegistry;
},{}],87:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactErrorUtils
 * @typechecks
 */

'use strict';

var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {?String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a, b) {
  try {
    return func(a, b);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
    return undefined;
  }
}

var ReactErrorUtils = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

if (process.env.NODE_ENV !== 'production') {
  /**
   * To help development we can get better devtools integration by simulating a
   * real browser event.
   */
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
      var boundFunc = func.bind(null, a, b);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;
}).call(this,require('_process'))

},{"_process":30}],88:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventEmitterMixin
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {object} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native environment event.
   */
  handleTopLevel: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;
},{"./EventPluginHub":46}],89:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactEventListener
 * @typechecks static-only
 */

'use strict';

var EventListener = require('fbjs/lib/EventListener');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var PooledClass = require('./PooledClass');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMount = require('./ReactMount');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var getEventTarget = require('./getEventTarget');
var getUnboundedScrollPosition = require('fbjs/lib/getUnboundedScrollPosition');

var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * Finds the parent React component of `node`.
 *
 * @param {*} node
 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
 *                           is not nested.
 */
function findParent(node) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  var nodeID = ReactMount.getID(node);
  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
  var container = ReactMount.findReactContainerForID(rootID);
  var parent = ReactMount.getFirstReactDOM(container);
  return parent;
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  // TODO: Re-enable event.path handling
  //
  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
  //   // New browsers have a path attribute on native events
  //   handleTopLevelWithPath(bookKeeping);
  // } else {
  //   // Legacy browsers don't have a path attribute on native events
  //   handleTopLevelWithoutPath(bookKeeping);
  // }

  void handleTopLevelWithPath; // temporarily unused
  handleTopLevelWithoutPath(bookKeeping);
}

// Legacy browsers don't have a path attribute on native events
function handleTopLevelWithoutPath(bookKeeping) {
  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = topLevelTarget;
  while (ancestor) {
    bookKeeping.ancestors.push(ancestor);
    ancestor = findParent(ancestor);
  }

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    topLevelTarget = bookKeeping.ancestors[i];
    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

// New browsers have a path attribute on native events
function handleTopLevelWithPath(bookKeeping) {
  var path = bookKeeping.nativeEvent.path;
  var currentNativeTarget = path[0];
  var eventsFired = 0;
  for (var i = 0; i < path.length; i++) {
    var currentPathElement = path[i];
    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
      currentNativeTarget = path[i + 1];
    }
    // TODO: slow
    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
    if (reactParent === currentPathElement) {
      var currentPathElementID = ReactMount.getID(currentPathElement);
      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
      bookKeeping.ancestors.push(currentPathElement);

      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
      eventsFired++;
      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);

      // Jump to the root of this React render tree
      while (currentPathElementID !== newRootID) {
        i++;
        currentPathElement = path[i];
        currentPathElementID = ReactMount.getID(currentPathElement);
      }
    }
  }
  if (eventsFired === 0) {
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} handle Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    var element = handle;
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;
},{"./Object.assign":53,"./PooledClass":54,"./ReactInstanceHandles":92,"./ReactMount":96,"./ReactUpdates":114,"./getEventTarget":145,"fbjs/lib/EventListener":2,"fbjs/lib/ExecutionEnvironment":3,"fbjs/lib/getUnboundedScrollPosition":14}],90:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInjection
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var EventPluginHub = require('./EventPluginHub');
var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactClass = require('./ReactClass');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactNativeComponent = require('./ReactNativeComponent');
var ReactPerf = require('./ReactPerf');
var ReactRootIndex = require('./ReactRootIndex');
var ReactUpdates = require('./ReactUpdates');

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  Class: ReactClass.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  NativeComponent: ReactNativeComponent.injection,
  Perf: ReactPerf.injection,
  RootIndex: ReactRootIndex.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;
},{"./DOMProperty":40,"./EventPluginHub":46,"./ReactBrowserEventEmitter":57,"./ReactClass":60,"./ReactComponentEnvironment":63,"./ReactEmptyComponent":85,"./ReactNativeComponent":99,"./ReactPerf":102,"./ReactRootIndex":109,"./ReactUpdates":114}],91:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInputSelection
 */

'use strict';

var ReactDOMSelection = require('./ReactDOMSelection');

var containsNode = require('fbjs/lib/containsNode');
var focusNode = require('fbjs/lib/focusNode');
var getActiveElement = require('fbjs/lib/getActiveElement');

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function (elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (typeof end === 'undefined') {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && (input.nodeName && input.nodeName.toLowerCase() === 'input')) {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;
},{"./ReactDOMSelection":75,"fbjs/lib/containsNode":6,"fbjs/lib/focusNode":11,"fbjs/lib/getActiveElement":12}],92:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceHandles
 * @typechecks static-only
 */

'use strict';

var ReactRootIndex = require('./ReactRootIndex');

var invariant = require('fbjs/lib/invariant');

var SEPARATOR = '.';
var SEPARATOR_LENGTH = SEPARATOR.length;

/**
 * Maximum depth of traversals before we consider the possibility of a bad ID.
 */
var MAX_TREE_DEPTH = 10000;

/**
 * Creates a DOM ID prefix to use when mounting React components.
 *
 * @param {number} index A unique integer
 * @return {string} React root ID.
 * @internal
 */
function getReactRootIDString(index) {
  return SEPARATOR + index.toString(36);
}

/**
 * Checks if a character in the supplied ID is a separator or the end.
 *
 * @param {string} id A React DOM ID.
 * @param {number} index Index of the character to check.
 * @return {boolean} True if the character is a separator or end of the ID.
 * @private
 */
function isBoundary(id, index) {
  return id.charAt(index) === SEPARATOR || index === id.length;
}

/**
 * Checks if the supplied string is a valid React DOM ID.
 *
 * @param {string} id A React DOM ID, maybe.
 * @return {boolean} True if the string is a valid React DOM ID.
 * @private
 */
function isValidID(id) {
  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
}

/**
 * Checks if the first ID is an ancestor of or equal to the second ID.
 *
 * @param {string} ancestorID
 * @param {string} descendantID
 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
 * @internal
 */
function isAncestorIDOf(ancestorID, descendantID) {
  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
}

/**
 * Gets the parent ID of the supplied React DOM ID, `id`.
 *
 * @param {string} id ID of a component.
 * @return {string} ID of the parent, or an empty string.
 * @private
 */
function getParentID(id) {
  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
}

/**
 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
 * supplied `destinationID`. If they are equal, the ID is returned.
 *
 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
 * @param {string} destinationID ID of the destination node.
 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
 * @private
 */
function getNextDescendantID(ancestorID, destinationID) {
  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
  if (ancestorID === destinationID) {
    return ancestorID;
  }
  // Skip over the ancestor and the immediate separator. Traverse until we hit
  // another separator or we reach the end of `destinationID`.
  var start = ancestorID.length + SEPARATOR_LENGTH;
  var i;
  for (i = start; i < destinationID.length; i++) {
    if (isBoundary(destinationID, i)) {
      break;
    }
  }
  return destinationID.substr(0, i);
}

/**
 * Gets the nearest common ancestor ID of two IDs.
 *
 * Using this ID scheme, the nearest common ancestor ID is the longest common
 * prefix of the two IDs that immediately preceded a "marker" in both strings.
 *
 * @param {string} oneID
 * @param {string} twoID
 * @return {string} Nearest common ancestor ID, or the empty string if none.
 * @private
 */
function getFirstCommonAncestorID(oneID, twoID) {
  var minLength = Math.min(oneID.length, twoID.length);
  if (minLength === 0) {
    return '';
  }
  var lastCommonMarkerIndex = 0;
  // Use `<=` to traverse until the "EOL" of the shorter string.
  for (var i = 0; i <= minLength; i++) {
    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
      lastCommonMarkerIndex = i;
    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
      break;
    }
  }
  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
  return longestCommonID;
}

/**
 * Traverses the parent path between two IDs (either up or down). The IDs must
 * not be the same, and there must exist a parent path between them. If the
 * callback returns `false`, traversal is stopped.
 *
 * @param {?string} start ID at which to start traversal.
 * @param {?string} stop ID at which to end traversal.
 * @param {function} cb Callback to invoke each ID with.
 * @param {*} arg Argument to invoke the callback with.
 * @param {?boolean} skipFirst Whether or not to skip the first node.
 * @param {?boolean} skipLast Whether or not to skip the last node.
 * @private
 */
function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
  start = start || '';
  stop = stop || '';
  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
  var traverseUp = isAncestorIDOf(stop, start);
  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
  // Traverse from `start` to `stop` one depth at a time.
  var depth = 0;
  var traverse = traverseUp ? getParentID : getNextDescendantID;
  for (var id = start;; /* until break */id = traverse(id, stop)) {
    var ret;
    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
      ret = cb(id, traverseUp, arg);
    }
    if (ret === false || id === stop) {
      // Only break //after// visiting `stop`.
      break;
    }
    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
  }
}

/**
 * Manages the IDs assigned to DOM representations of React components. This
 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
 * order to simulate events).
 *
 * @internal
 */
var ReactInstanceHandles = {

  /**
   * Constructs a React root ID
   * @return {string} A React root ID.
   */
  createReactRootID: function () {
    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
  },

  /**
   * Constructs a React ID by joining a root ID with a name.
   *
   * @param {string} rootID Root ID of a parent component.
   * @param {string} name A component's name (as flattened children).
   * @return {string} A React ID.
   * @internal
   */
  createReactID: function (rootID, name) {
    return rootID + name;
  },

  /**
   * Gets the DOM ID of the React component that is the root of the tree that
   * contains the React component with the supplied DOM ID.
   *
   * @param {string} id DOM ID of a React component.
   * @return {?string} DOM ID of the React component that is the root.
   * @internal
   */
  getReactRootIDFromNodeID: function (id) {
    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
      var index = id.indexOf(SEPARATOR, 1);
      return index > -1 ? id.substr(0, index) : id;
    }
    return null;
  },

  /**
   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
   * should would receive a `mouseEnter` or `mouseLeave` event.
   *
   * NOTE: Does not invoke the callback on the nearest common ancestor because
   * nothing "entered" or "left" that element.
   *
   * @param {string} leaveID ID being left.
   * @param {string} enterID ID being entered.
   * @param {function} cb Callback to invoke on each entered/left ID.
   * @param {*} upArg Argument to invoke the callback with on left IDs.
   * @param {*} downArg Argument to invoke the callback with on entered IDs.
   * @internal
   */
  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {
    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
    if (ancestorID !== leaveID) {
      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
    }
    if (ancestorID !== enterID) {
      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
    }
  },

  /**
   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseTwoPhase: function (targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, false);
      traverseParentPath(targetID, '', cb, arg, false, true);
    }
  },

  /**
   * Same as `traverseTwoPhase` but skips the `targetID`.
   */
  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {
    if (targetID) {
      traverseParentPath('', targetID, cb, arg, true, true);
      traverseParentPath(targetID, '', cb, arg, true, true);
    }
  },

  /**
   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
   * example, passing `.0.$row-0.1` would result in `cb` getting called
   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
   *
   * NOTE: This traversal happens on IDs without touching the DOM.
   *
   * @param {string} targetID ID of the target node.
   * @param {function} cb Callback to invoke.
   * @param {*} arg Argument to invoke the callback with.
   * @internal
   */
  traverseAncestors: function (targetID, cb, arg) {
    traverseParentPath('', targetID, cb, arg, true, false);
  },

  getFirstCommonAncestorID: getFirstCommonAncestorID,

  /**
   * Exposed for unit testing.
   * @private
   */
  _getNextDescendantID: getNextDescendantID,

  isAncestorIDOf: isAncestorIDOf,

  SEPARATOR: SEPARATOR

};

module.exports = ReactInstanceHandles;
}).call(this,require('_process'))

},{"./ReactRootIndex":109,"_process":30,"fbjs/lib/invariant":17}],93:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactInstanceMap
 */

'use strict';

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
var ReactInstanceMap = {

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }

};

module.exports = ReactInstanceMap;
},{}],94:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactIsomorphic
 */

'use strict';

var ReactChildren = require('./ReactChildren');
var ReactComponent = require('./ReactComponent');
var ReactClass = require('./ReactClass');
var ReactDOMFactories = require('./ReactDOMFactories');
var ReactElement = require('./ReactElement');
var ReactElementValidator = require('./ReactElementValidator');
var ReactPropTypes = require('./ReactPropTypes');
var ReactVersion = require('./ReactVersion');

var assign = require('./Object.assign');
var onlyChild = require('./onlyChild');

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if (process.env.NODE_ENV !== 'production') {
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Hook for JSX spread, don't use this for anything else.
  __spread: assign
};

module.exports = React;
}).call(this,require('_process'))

},{"./Object.assign":53,"./ReactChildren":59,"./ReactClass":60,"./ReactComponent":61,"./ReactDOMFactories":69,"./ReactElement":83,"./ReactElementValidator":84,"./ReactPropTypes":105,"./ReactVersion":115,"./onlyChild":152,"_process":30}],95:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMarkupChecksum
 */

'use strict';

var adler32 = require('./adler32');

var TAG_END = /\/?>/;

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags and self-closing tags)
    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;
},{"./adler32":134}],96:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMount
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');
var ReactElement = require('./ReactElement');
var ReactEmptyComponentRegistry = require('./ReactEmptyComponentRegistry');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactMarkupChecksum = require('./ReactMarkupChecksum');
var ReactPerf = require('./ReactPerf');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdateQueue = require('./ReactUpdateQueue');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var emptyObject = require('fbjs/lib/emptyObject');
var containsNode = require('fbjs/lib/containsNode');
var instantiateReactComponent = require('./instantiateReactComponent');
var invariant = require('fbjs/lib/invariant');
var setInnerHTML = require('./setInnerHTML');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var validateDOMNesting = require('./validateDOMNesting');
var warning = require('fbjs/lib/warning');

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var nodeCache = {};

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);

/** Mapping from reactRootID to React component instance. */
var instancesByReactRootID = {};

/** Mapping from reactRootID to `container` nodes. */
var containersByReactRootID = {};

if (process.env.NODE_ENV !== 'production') {
  /** __DEV__-only mapping from reactRootID to root elements. */
  var rootElementsByReactRootID = {};
}

// Used to store breadth-first search state in findComponentRoot.
var findComponentRootReusableArray = [];

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

/**
 * @param {DOMElement} container DOM element that may contain a React component.
 * @return {?string} A "reactRoot" ID, if a React component is rendered.
 */
function getReactRootID(container) {
  var rootElement = getReactRootElementInContainer(container);
  return rootElement && ReactMount.getID(rootElement);
}

/**
 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
 * element can return its control whose name or ID equals ATTR_NAME. All
 * DOM nodes support `getAttributeNode` but this can also get called on
 * other objects so just return '' if we're given something other than a
 * DOM node (such as window).
 *
 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
 * @return {string} ID of the supplied `domNode`.
 */
function getID(node) {
  var id = internalGetID(node);
  if (id) {
    if (nodeCache.hasOwnProperty(id)) {
      var cached = nodeCache[id];
      if (cached !== node) {
        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;

        nodeCache[id] = node;
      }
    } else {
      nodeCache[id] = node;
    }
  }

  return id;
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Sets the React-specific ID of the given node.
 *
 * @param {DOMElement} node The DOM node whose ID will be set.
 * @param {string} id The value of the ID attribute.
 */
function setID(node, id) {
  var oldID = internalGetID(node);
  if (oldID !== id) {
    delete nodeCache[oldID];
  }
  node.setAttribute(ATTR_NAME, id);
  nodeCache[id] = node;
}

/**
 * Finds the node with the supplied React-generated DOM ID.
 *
 * @param {string} id A React-generated DOM ID.
 * @return {DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNode(id) {
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * Finds the node with the supplied public React instance.
 *
 * @param {*} instance A public React instance.
 * @return {?DOMElement} DOM node with the suppled `id`.
 * @internal
 */
function getNodeFromInstance(instance) {
  var id = ReactInstanceMap.get(instance)._rootNodeID;
  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
    return null;
  }
  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
    nodeCache[id] = ReactMount.findReactNodeByID(id);
  }
  return nodeCache[id];
}

/**
 * A node is "valid" if it is contained by a currently mounted container.
 *
 * This means that the node does not have to be contained by a document in
 * order to be considered valid.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @param {string} id The expected ID of the node.
 * @return {boolean} Whether the node is contained by a mounted container.
 */
function isValid(node, id) {
  if (node) {
    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;

    var container = ReactMount.findReactContainerForID(id);
    if (container && containsNode(container, node)) {
      return true;
    }
  }

  return false;
}

/**
 * Causes the cache to forget about one React-specific ID.
 *
 * @param {string} id The ID to forget.
 */
function purgeID(id) {
  delete nodeCache[id];
}

var deepestNodeSoFar = null;
function findDeepestCachedAncestorImpl(ancestorID) {
  var ancestor = nodeCache[ancestorID];
  if (ancestor && isValid(ancestor, ancestorID)) {
    deepestNodeSoFar = ancestor;
  } else {
    // This node isn't populated in the cache, so presumably none of its
    // descendants are. Break out of the loop.
    return false;
  }
}

/**
 * Return the deepest cached node whose ID is a prefix of `targetID`.
 */
function findDeepestCachedAncestor(targetID) {
  deepestNodeSoFar = null;
  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);

  var foundNode = deepestNodeSoFar;
  deepestNodeSoFar = null;
  return foundNode;
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {string} rootID DOM ID of the root node.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
  if (ReactDOMFeatureFlags.useCreateElement) {
    context = assign({}, context);
    if (container.nodeType === DOC_NODE_TYPE) {
      context[ownerDocumentContextKey] = container;
    } else {
      context[ownerDocumentContextKey] = container.ownerDocument;
    }
  }
  if (process.env.NODE_ENV !== 'production') {
    if (context === emptyObject) {
      context = {};
    }
    var tag = container.nodeName.toLowerCase();
    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
  }
  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {string} rootID DOM ID of the root node.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* forceHTML */shouldReuseMarkup);
  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container) {
  ReactReconciler.unmountComponent(instance);

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(node) {
  var reactRootID = getReactRootID(node);
  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
}

/**
 * Returns the first (deepest) ancestor of a node which is rendered by this copy
 * of React.
 */
function findFirstReactDOMImpl(node) {
  // This node might be from another React instance, so we make sure not to
  // examine the node cache here
  for (; node && node.parentNode !== node; node = node.parentNode) {
    if (node.nodeType !== 1) {
      // Not a DOMElement, therefore not a React component
      continue;
    }
    var nodeID = internalGetID(node);
    if (!nodeID) {
      continue;
    }
    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);

    // If containersByReactRootID contains the container we find by crawling up
    // the tree, we know that this instance of React rendered the node.
    // nb. isValid's strategy (with containsNode) does not work because render
    // trees may be nested and we don't want a false positive in that case.
    var current = node;
    var lastID;
    do {
      lastID = internalGetID(current);
      current = current.parentNode;
      if (current == null) {
        // The passed-in node has been detached from the container it was
        // originally rendered into.
        return null;
      }
    } while (lastID !== reactRootID);

    if (current === containersByReactRootID[reactRootID]) {
      return node;
    }
  }
  return null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var TopLevelWrapper = function () {};
TopLevelWrapper.prototype.isReactComponent = {};
if (process.env.NODE_ENV !== 'production') {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  // this.props is actually a ReactElement
  return this.props;
};

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {

  TopLevelWrapper: TopLevelWrapper,

  /** Exposed for debugging purposes **/
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, container, callback) {
    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    if (process.env.NODE_ENV !== 'production') {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
    }

    return prevComponent;
  },

  /**
   * Register a component into the instance map and starts scroll value
   * monitoring
   * @param {ReactComponent} nextComponent component instance to render
   * @param {DOMElement} container container to render into
   * @return {string} reactRoot ID prefix
   */
  _registerComponent: function (nextComponent, container) {
    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();

    var reactRootID = ReactMount.registerContainer(container);
    instancesByReactRootID[reactRootID] = nextComponent;
    return reactRootID;
  },

  /**
   * Render a new component into the DOM.
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

    var componentInstance = instantiateReactComponent(nextElement, null);
    var reactRootID = ReactMount._registerComponent(componentInstance, container);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);

    if (process.env.NODE_ENV !== 'production') {
      // Record the root element in case it later gets transplanted.
      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
    }

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
    // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;

    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;

    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);

    var prevComponent = instancesByReactRootID[getReactRootID(container)];

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;

      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (internalGetID(rootElementSibling)) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
            break;
          }
          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Registers a container node into which React components will be rendered.
   * This also creates the "reactRoot" ID that will be assigned to the element
   * rendered within.
   *
   * @param {DOMElement} container DOM element to register as a container.
   * @return {string} The "reactRoot" ID of elements rendered within.
   */
  registerContainer: function (container) {
    var reactRootID = getReactRootID(container);
    if (reactRootID) {
      // If one exists, make sure it is a valid "reactRoot" ID.
      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
    }
    if (!reactRootID) {
      // No valid "reactRoot" ID found, create one.
      reactRootID = ReactInstanceHandles.createReactRootID();
    }
    containersByReactRootID[reactRootID] = container;
    return reactRootID;
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;

    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;

    var reactRootID = getReactRootID(container);
    var component = instancesByReactRootID[reactRootID];
    if (!component) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var containerID = internalGetID(container);
      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
      }

      return false;
    }
    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
    delete instancesByReactRootID[reactRootID];
    delete containersByReactRootID[reactRootID];
    if (process.env.NODE_ENV !== 'production') {
      delete rootElementsByReactRootID[reactRootID];
    }
    return true;
  },

  /**
   * Finds the container DOM element that contains React component to which the
   * supplied DOM `id` belongs.
   *
   * @param {string} id The ID of an element rendered by a React component.
   * @return {?DOMElement} DOM element that contains the `id`.
   */
  findReactContainerForID: function (id) {
    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
    var container = containersByReactRootID[reactRootID];

    if (process.env.NODE_ENV !== 'production') {
      var rootElement = rootElementsByReactRootID[reactRootID];
      if (rootElement && rootElement.parentNode !== container) {
        process.env.NODE_ENV !== 'production' ? warning(
        // Call internalGetID here because getID calls isValid which calls
        // findReactContainerForID (this function).
        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
        var containerChild = container.firstChild;
        if (containerChild && reactRootID === internalGetID(containerChild)) {
          // If the container has a new child with the same ID as the old
          // root element, then rootElementsByReactRootID[reactRootID] is
          // just stale and needs to be updated. The case that deserves a
          // warning is when the container is empty.
          rootElementsByReactRootID[reactRootID] = containerChild;
        } else {
          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
        }
      }
    }

    return container;
  },

  /**
   * Finds an element rendered by React with the supplied ID.
   *
   * @param {string} id ID of a DOM node in the React component.
   * @return {DOMElement} Root DOM node of the React component.
   */
  findReactNodeByID: function (id) {
    var reactRoot = ReactMount.findReactContainerForID(id);
    return ReactMount.findComponentRoot(reactRoot, id);
  },

  /**
   * Traverses up the ancestors of the supplied node to find a node that is a
   * DOM representation of a React component rendered by this copy of React.
   *
   * @param {*} node
   * @return {?DOMEventTarget}
   * @internal
   */
  getFirstReactDOM: function (node) {
    return findFirstReactDOMImpl(node);
  },

  /**
   * Finds a node with the supplied `targetID` inside of the supplied
   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
   * quickly.
   *
   * @param {DOMEventTarget} ancestorNode Search from this root.
   * @pararm {string} targetID ID of the DOM representation of the component.
   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
   * @internal
   */
  findComponentRoot: function (ancestorNode, targetID) {
    var firstChildren = findComponentRootReusableArray;
    var childIndex = 0;

    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;

    if (process.env.NODE_ENV !== 'production') {
      // This will throw on the next line; give an early warning
      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
    }

    firstChildren[0] = deepestAncestor.firstChild;
    firstChildren.length = 1;

    while (childIndex < firstChildren.length) {
      var child = firstChildren[childIndex++];
      var targetChild;

      while (child) {
        var childID = ReactMount.getID(child);
        if (childID) {
          // Even if we find the node we're looking for, we finish looping
          // through its siblings to ensure they're cached so that we don't have
          // to revisit this node again. Otherwise, we make n^2 calls to getID
          // when visiting the many children of a single node in order.

          if (targetID === childID) {
            targetChild = child;
          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
            // If we find a child whose ID is an ancestor of the given ID,
            // then we can be sure that we only want to search the subtree
            // rooted at this child, so we can throw out the rest of the
            // search state.
            firstChildren.length = childIndex = 0;
            firstChildren.push(child.firstChild);
          }
        } else {
          // If this child had no ID, then there's a chance that it was
          // injected automatically by the browser, as when a `<table>`
          // element sprouts an extra `<tbody>` child as a side effect of
          // `.innerHTML` parsing. Optimistically continue down this
          // branch, but not before examining the other siblings.
          firstChildren.push(child.firstChild);
        }

        child = child.nextSibling;
      }

      if (targetChild) {
        // Emptying firstChildren/findComponentRootReusableArray is
        // not necessary for correctness, but it helps the GC reclaim
        // any nodes that were left at the end of the search.
        firstChildren.length = 0;

        return targetChild;
      }
    }

    firstChildren.length = 0;

    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
  },

  _mountImageIntoNode: function (markup, container, shouldReuseMarkup, transaction) {
    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;
        if (process.env.NODE_ENV !== 'production') {
          // because rootMarkup is retrieved from the DOM, various normalizations
          // will have occurred which will not be present in `markup`. Here,
          // insert markup into a <div> or <iframe> depending on the container
          // type to perform the same normalizations before comparing.
          var normalizer;
          if (container.nodeType === ELEMENT_NODE_TYPE) {
            normalizer = document.createElement('div');
            normalizer.innerHTML = markup;
            normalizedMarkup = normalizer.innerHTML;
          } else {
            normalizer = document.createElement('iframe');
            document.body.appendChild(normalizer);
            normalizer.contentDocument.write(markup);
            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
            document.body.removeChild(normalizer);
          }
        }

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;

        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      container.appendChild(markup);
    } else {
      setInnerHTML(container, markup);
    }
  },

  ownerDocumentContextKey: ownerDocumentContextKey,

  /**
   * React ID utilities.
   */

  getReactRootID: getReactRootID,

  getID: getID,

  setID: setID,

  getNode: getNode,

  getNodeFromInstance: getNodeFromInstance,

  isValid: isValid,

  purgeID: purgeID
};

ReactPerf.measureMethods(ReactMount, 'ReactMount', {
  _renderNewRootComponent: '_renderNewRootComponent',
  _mountImageIntoNode: '_mountImageIntoNode'
});

module.exports = ReactMount;
}).call(this,require('_process'))

},{"./DOMProperty":40,"./Object.assign":53,"./ReactBrowserEventEmitter":57,"./ReactCurrentOwner":65,"./ReactDOMFeatureFlags":70,"./ReactElement":83,"./ReactEmptyComponentRegistry":86,"./ReactInstanceHandles":92,"./ReactInstanceMap":93,"./ReactMarkupChecksum":95,"./ReactPerf":102,"./ReactReconciler":107,"./ReactUpdateQueue":113,"./ReactUpdates":114,"./instantiateReactComponent":149,"./setInnerHTML":155,"./shouldUpdateReactComponent":157,"./validateDOMNesting":159,"_process":30,"fbjs/lib/containsNode":6,"fbjs/lib/emptyObject":10,"fbjs/lib/invariant":17,"fbjs/lib/warning":28}],97:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChild
 * @typechecks static-only
 */

'use strict';

var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactMultiChildUpdateTypes = require('./ReactMultiChildUpdateTypes');

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactReconciler = require('./ReactReconciler');
var ReactChildReconciler = require('./ReactChildReconciler');

var flattenChildren = require('./flattenChildren');

/**
 * Updating children of a component may trigger recursive updates. The depth is
 * used to batch recursive updates to render markup more efficiently.
 *
 * @type {number}
 * @private
 */
var updateDepth = 0;

/**
 * Queue of update configuration objects.
 *
 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
 *
 * @type {array<object>}
 * @private
 */
var updateQueue = [];

/**
 * Queue of markup to be rendered.
 *
 * @type {array<string>}
 * @private
 */
var markupQueue = [];

/**
 * Enqueues markup to be rendered and inserted at a supplied index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function enqueueInsertMarkup(parentID, markup, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
    markupIndex: markupQueue.push(markup) - 1,
    content: null,
    fromIndex: null,
    toIndex: toIndex
  });
}

/**
 * Enqueues moving an existing element to another index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function enqueueMove(parentID, fromIndex, toIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
    markupIndex: null,
    content: null,
    fromIndex: fromIndex,
    toIndex: toIndex
  });
}

/**
 * Enqueues removing an element at an index.
 *
 * @param {string} parentID ID of the parent component.
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function enqueueRemove(parentID, fromIndex) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
    markupIndex: null,
    content: null,
    fromIndex: fromIndex,
    toIndex: null
  });
}

/**
 * Enqueues setting the markup of a node.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function enqueueSetMarkup(parentID, markup) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.SET_MARKUP,
    markupIndex: null,
    content: markup,
    fromIndex: null,
    toIndex: null
  });
}

/**
 * Enqueues setting the text content.
 *
 * @param {string} parentID ID of the parent component.
 * @param {string} textContent Text content to set.
 * @private
 */
function enqueueTextContent(parentID, textContent) {
  // NOTE: Null values reduce hidden classes.
  updateQueue.push({
    parentID: parentID,
    parentNode: null,
    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
    markupIndex: null,
    content: textContent,
    fromIndex: null,
    toIndex: null
  });
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue() {
  if (updateQueue.length) {
    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
    clearQueue();
  }
}

/**
 * Clears any enqueued updates.
 *
 * @private
 */
function clearQueue() {
  updateQueue.length = 0;
  markupQueue.length = 0;
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
      if (process.env.NODE_ENV !== 'production') {
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
          } finally {
            ReactCurrentOwner.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, transaction, context) {
      var nextChildren;
      if (process.env.NODE_ENV !== 'production') {
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            nextChildren = flattenChildren(nextNestedChildrenElements);
          } finally {
            ReactCurrentOwner.current = null;
          }
          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
        }
      }
      nextChildren = flattenChildren(nextNestedChildrenElements);
      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;
      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
          var rootID = this._rootNodeID + name;
          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }
      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      updateDepth++;
      var errorThrown = true;
      try {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        ReactChildReconciler.unmountChildren(prevChildren);
        // TODO: The setTextContent operation should be enough
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            this._unmountChild(prevChildren[name]);
          }
        }
        // Set new text content.
        this.setTextContent(nextContent);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function (nextMarkup) {
      updateDepth++;
      var errorThrown = true;
      try {
        var prevChildren = this._renderedChildren;
        // Remove any rendered children.
        ReactChildReconciler.unmountChildren(prevChildren);
        for (var name in prevChildren) {
          if (prevChildren.hasOwnProperty(name)) {
            this._unmountChildByName(prevChildren[name], name);
          }
        }
        this.setMarkup(nextMarkup);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildrenElements, transaction, context) {
      updateDepth++;
      var errorThrown = true;
      try {
        this._updateChildren(nextNestedChildrenElements, transaction, context);
        errorThrown = false;
      } finally {
        updateDepth--;
        if (!updateDepth) {
          if (errorThrown) {
            clearQueue();
          } else {
            processQueue();
          }
        }
      }
    },

    /**
     * Improve performance by isolating this hot code path from the try/catch
     * block in `updateChildren`.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
      this._renderedChildren = nextChildren;
      if (!nextChildren && !prevChildren) {
        return;
      }
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var lastIndex = 0;
      var nextIndex = 0;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          this.moveChild(prevChild, nextIndex, lastIndex);
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            this._unmountChild(prevChild);
          }
          // The child must be instantiated before it's mounted.
          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
        }
        nextIndex++;
      }
      // Remove children that are no longer present.
      for (name in prevChildren) {
        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
          this._unmountChild(prevChildren[name]);
        }
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted.
     *
     * @internal
     */
    unmountChildren: function () {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, mountImage) {
      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child) {
      enqueueRemove(this._rootNodeID, child._mountIndex);
    },

    /**
     * Sets this text content string.
     *
     * @param {string} textContent Text content to set.
     * @protected
     */
    setTextContent: function (textContent) {
      enqueueTextContent(this._rootNodeID, textContent);
    },

    /**
     * Sets this markup string.
     *
     * @param {string} markup Markup to set.
     * @protected
     */
    setMarkup: function (markup) {
      enqueueSetMarkup(this._rootNodeID, markup);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildByNameAtIndex: function (child, name, index, transaction, context) {
      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
      var rootID = this._rootNodeID + name;
      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
      child._mountIndex = index;
      this.createChild(child, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function (child) {
      this.removeChild(child);
      child._mountIndex = null;
    }

  }

};

module.exports = ReactMultiChild;
}).call(this,require('_process'))

},{"./ReactChildReconciler":58,"./ReactComponentEnvironment":63,"./ReactCurrentOwner":65,"./ReactMultiChildUpdateTypes":98,"./ReactReconciler":107,"./flattenChildren":140,"_process":30}],98:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactMultiChildUpdateTypes
 */

'use strict';

var keyMirror = require('fbjs/lib/keyMirror');

/**
 * When a component's children are updated, a series of update configuration
 * objects are created in order to batch and serialize the required changes.
 *
 * Enumerates all the possible types of update configurations.
 *
 * @internal
 */
var ReactMultiChildUpdateTypes = keyMirror({
  INSERT_MARKUP: null,
  MOVE_EXISTING: null,
  REMOVE_NODE: null,
  SET_MARKUP: null,
  TEXT_CONTENT: null
});

module.exports = ReactMultiChildUpdateTypes;
},{"fbjs/lib/keyMirror":20}],99:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNativeComponent
 */

'use strict';

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');

var autoGenerateWrapperClass = null;
var genericComponentClass = null;
// This registry keeps track of wrapper classes around native tags.
var tagToComponentClass = {};
var textComponentClass = null;

var ReactNativeComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  },
  // This accepts a keyed object with classes as values. Each key represents a
  // tag. That particular tag will use this class instead of the generic one.
  injectComponentClasses: function (componentClasses) {
    assign(tagToComponentClass, componentClasses);
  }
};

/**
 * Get a composite component wrapper class for a specific tag.
 *
 * @param {ReactElement} element The tag for which to get the class.
 * @return {function} The React class constructor function.
 */
function getComponentClassForElement(element) {
  if (typeof element.type === 'function') {
    return element.type;
  }
  var tag = element.type;
  var componentClass = tagToComponentClass[tag];
  if (componentClass == null) {
    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
  }
  return componentClass;
}

/**
 * Get a native internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
  return new genericComponentClass(element.type, element.props);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactNativeComponent = {
  getComponentClassForElement: getComponentClassForElement,
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactNativeComponentInjection
};

module.exports = ReactNativeComponent;
}).call(this,require('_process'))

},{"./Object.assign":53,"_process":30,"fbjs/lib/invariant":17}],100:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNoopUpdateQueue
 */

'use strict';

var warning = require('fbjs/lib/warning');

function warnTDZ(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnTDZ(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnTDZ(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnTDZ(publicInstance, 'setState');
  },

  /**
   * Sets a subset of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialProps Subset of the next props.
   * @internal
   */
  enqueueSetProps: function (publicInstance, partialProps) {
    warnTDZ(publicInstance, 'setProps');
  },

  /**
   * Replaces all of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} props New props.
   * @internal
   */
  enqueueReplaceProps: function (publicInstance, props) {
    warnTDZ(publicInstance, 'replaceProps');
  }

};

module.exports = ReactNoopUpdateQueue;
}).call(this,require('_process'))

},{"_process":30,"fbjs/lib/warning":28}],101:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactOwner
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {

  /**
   * @param {?object} object
   * @return {boolean} True if `object` is a valid owner.
   * @final
   */
  isValidOwner: function (object) {
    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
  },

  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
    // Check that `component` is still the current ref because we do not want to
    // detach the ref if another component stole it.
    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }

};

module.exports = ReactOwner;
}).call(this,require('_process'))

},{"_process":30,"fbjs/lib/invariant":17}],102:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPerf
 * @typechecks static-only
 */

'use strict';

/**
 * ReactPerf is a general AOP system designed to measure performance. This
 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
 */
var ReactPerf = {
  /**
   * Boolean to enable/disable measurement. Set to false by default to prevent
   * accidental logging and perf loss.
   */
  enableMeasure: false,

  /**
   * Holds onto the measure function in use. By default, don't measure
   * anything, but we'll override this if we inject a measure function.
   */
  storedMeasure: _noMeasure,

  /**
   * @param {object} object
   * @param {string} objectName
   * @param {object<string>} methodNames
   */
  measureMethods: function (object, objectName, methodNames) {
    if (process.env.NODE_ENV !== 'production') {
      for (var key in methodNames) {
        if (!methodNames.hasOwnProperty(key)) {
          continue;
        }
        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
      }
    }
  },

  /**
   * Use this to wrap methods you want to measure. Zero overhead in production.
   *
   * @param {string} objName
   * @param {string} fnName
   * @param {function} func
   * @return {function}
   */
  measure: function (objName, fnName, func) {
    if (process.env.NODE_ENV !== 'production') {
      var measuredFunc = null;
      var wrapper = function () {
        if (ReactPerf.enableMeasure) {
          if (!measuredFunc) {
            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
          }
          return measuredFunc.apply(this, arguments);
        }
        return func.apply(this, arguments);
      };
      wrapper.displayName = objName + '_' + fnName;
      return wrapper;
    }
    return func;
  },

  injection: {
    /**
     * @param {function} measure
     */
    injectMeasure: function (measure) {
      ReactPerf.storedMeasure = measure;
    }
  }
};

/**
 * Simply passes through the measured function, without measuring it.
 *
 * @param {string} objName
 * @param {string} fnName
 * @param {function} func
 * @return {function}
 */
function _noMeasure(objName, fnName, func) {
  return func;
}

module.exports = ReactPerf;
}).call(this,require('_process'))

},{"_process":30}],103:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocationNames
 */

'use strict';

var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
}).call(this,require('_process'))

},{"_process":30}],104:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocations
 */

'use strict';

var keyMirror = require('fbjs/lib/keyMirror');

var ReactPropTypeLocations = keyMirror({
  prop: null,
  context: null,
  childContext: null
});

module.exports = ReactPropTypeLocations;
},{"fbjs/lib/keyMirror":20}],105:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypes
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getIteratorFn = require('./getIteratorFn');

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};

function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location, propFullName) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns(null));
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!ReactElement.isValidElement(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      var actualClassName = getClassName(props[propName]);
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (propValue === expectedValues[i]) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    return createChainableTypeChecker(function () {
      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
    });
  }

  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName) == null) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function isNode(propValue) {
  switch (typeof propValue) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement.isValidElement(propValue)) {
        return true;
      }

      var iteratorFn = getIteratorFn(propValue);
      if (iteratorFn) {
        var iterator = iteratorFn.call(propValue);
        var step;
        if (iteratorFn !== propValue.entries) {
          while (!(step = iterator.next()).done) {
            if (!isNode(step.value)) {
              return false;
            }
          }
        } else {
          // Iterator will provide entry [k,v] tuples rather than values.
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              if (!isNode(entry[1])) {
                return false;
              }
            }
          }
        }
      } else {
        return false;
      }

      return true;
    default:
      return false;
  }
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

// Returns class name of the object, if any.
function getClassName(propValue) {
  if (!propValue.constructor || !propValue.constructor.name) {
    return '<<anonymous>>';
  }
  return propValue.constructor.name;
}

module.exports = ReactPropTypes;
},{"./ReactElement":83,"./ReactPropTypeLocationNames":103,"./getIteratorFn":146,"fbjs/lib/emptyFunction":9}],106:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconcileTransaction
 * @typechecks static-only
 */

'use strict';

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');
var ReactInputSelection = require('./ReactInputSelection');
var Transaction = require('./Transaction');

var assign = require('./Object.assign');

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction(forceHTML) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
},{"./CallbackQueue":36,"./Object.assign":53,"./PooledClass":54,"./ReactBrowserEventEmitter":57,"./ReactDOMFeatureFlags":70,"./ReactInputSelection":91,"./Transaction":131}],107:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactReconciler
 */

'use strict';

var ReactRef = require('./ReactRef');

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {string} rootID DOM ID of the root node.
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, rootID, transaction, context) {
    var markup = internalInstance.mountComponent(rootID, transaction, context);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    return markup;
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance) {
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent();
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction) {
    internalInstance.performUpdateIfNecessary(transaction);
  }

};

module.exports = ReactReconciler;
},{"./ReactRef":108}],108:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRef
 */

'use strict';

var ReactOwner = require('./ReactOwner');

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  if (element === null || element === false) {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;

  return(
    // This has a few false positives w/r/t empty components.
    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
  );
};

ReactRef.detachRefs = function (instance, element) {
  if (element === null || element === false) {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;
},{"./ReactOwner":101}],109:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactRootIndex
 * @typechecks
 */

'use strict';

var ReactRootIndexInjection = {
  /**
   * @param {function} _createReactRootIndex
   */
  injectCreateReactRootIndex: function (_createReactRootIndex) {
    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
  }
};

var ReactRootIndex = {
  createReactRootIndex: null,
  injection: ReactRootIndexInjection
};

module.exports = ReactRootIndex;
},{}],110:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactServerBatchingStrategy
 * @typechecks
 */

'use strict';

var ReactServerBatchingStrategy = {
  isBatchingUpdates: false,
  batchedUpdates: function (callback) {
    // Don't do anything here. During the server rendering we don't want to
    // schedule any updates. We will simply ignore them.
  }
};

module.exports = ReactServerBatchingStrategy;
},{}],111:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 * @providesModule ReactServerRendering
 */
'use strict';

var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
var ReactElement = require('./ReactElement');
var ReactInstanceHandles = require('./ReactInstanceHandles');
var ReactMarkupChecksum = require('./ReactMarkupChecksum');
var ReactServerBatchingStrategy = require('./ReactServerBatchingStrategy');
var ReactServerRenderingTransaction = require('./ReactServerRenderingTransaction');
var ReactUpdates = require('./ReactUpdates');

var emptyObject = require('fbjs/lib/emptyObject');
var instantiateReactComponent = require('./instantiateReactComponent');
var invariant = require('fbjs/lib/invariant');

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup
 */
function renderToString(element) {
  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;
  try {
    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(false);

    return transaction.perform(function () {
      var componentInstance = instantiateReactComponent(element, null);
      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
      return ReactMarkupChecksum.addChecksumToMarkup(markup);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
    // Revert to the DOM batching strategy since these two renderers
    // currently share these stateful modules.
    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
  }
}

/**
 * @param {ReactElement} element
 * @return {string} the HTML markup, without the extra React ID and checksum
 * (for generating static pages)
 */
function renderToStaticMarkup(element) {
  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;

  var transaction;
  try {
    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);

    var id = ReactInstanceHandles.createReactRootID();
    transaction = ReactServerRenderingTransaction.getPooled(true);

    return transaction.perform(function () {
      var componentInstance = instantiateReactComponent(element, null);
      return componentInstance.mountComponent(id, transaction, emptyObject);
    }, null);
  } finally {
    ReactServerRenderingTransaction.release(transaction);
    // Revert to the DOM batching strategy since these two renderers
    // currently share these stateful modules.
    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
  }
}

module.exports = {
  renderToString: renderToString,
  renderToStaticMarkup: renderToStaticMarkup
};
}).call(this,require('_process'))

},{"./ReactDefaultBatchingStrategy":79,"./ReactElement":83,"./ReactInstanceHandles":92,"./ReactMarkupChecksum":95,"./ReactServerBatchingStrategy":110,"./ReactServerRenderingTransaction":112,"./ReactUpdates":114,"./instantiateReactComponent":149,"_process":30,"fbjs/lib/emptyObject":10,"fbjs/lib/invariant":17}],112:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactServerRenderingTransaction
 * @typechecks
 */

'use strict';

var PooledClass = require('./PooledClass');
var CallbackQueue = require('./CallbackQueue');
var Transaction = require('./Transaction');

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');

/**
 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
 * during the performing of the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  close: emptyFunction
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = false;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
},{"./CallbackQueue":36,"./Object.assign":53,"./PooledClass":54,"./Transaction":131,"fbjs/lib/emptyFunction":9}],113:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdateQueue
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactElement = require('./ReactElement');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactUpdates = require('./ReactUpdates');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function enqueueUpdate(internalInstance) {
  ReactUpdates.enqueueUpdate(internalInstance);
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if (process.env.NODE_ENV !== 'production') {
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
    }
    return null;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    if (process.env.NODE_ENV !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {
    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialProps Subset of the next props.
   * @internal
   */
  enqueueSetProps: function (publicInstance, partialProps) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
    if (!internalInstance) {
      return;
    }
    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
  },

  enqueueSetPropsInternal: function (internalInstance, partialProps) {
    var topLevelWrapper = internalInstance._topLevelWrapper;
    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

    // Merge with the pending element if it exists, otherwise with existing
    // element props.
    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
    var element = wrapElement.props;
    var props = assign({}, element.props, partialProps);
    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

    enqueueUpdate(topLevelWrapper);
  },

  /**
   * Replaces all of the props.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} props New props.
   * @internal
   */
  enqueueReplaceProps: function (publicInstance, props) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
    if (!internalInstance) {
      return;
    }
    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
  },

  enqueueReplacePropsInternal: function (internalInstance, props) {
    var topLevelWrapper = internalInstance._topLevelWrapper;
    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;

    // Merge with the pending element if it exists, otherwise with existing
    // element props.
    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
    var element = wrapElement.props;
    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));

    enqueueUpdate(topLevelWrapper);
  },

  enqueueElementInternal: function (internalInstance, newElement) {
    internalInstance._pendingElement = newElement;
    enqueueUpdate(internalInstance);
  }

};

module.exports = ReactUpdateQueue;
}).call(this,require('_process'))

},{"./Object.assign":53,"./ReactCurrentOwner":65,"./ReactElement":83,"./ReactInstanceMap":93,"./ReactUpdates":114,"_process":30,"fbjs/lib/invariant":17,"fbjs/lib/warning":28}],114:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactUpdates
 */

'use strict';

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactPerf = require('./ReactPerf');
var ReactReconciler = require('./ReactReconciler');
var Transaction = require('./Transaction');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');

var dirtyComponents = [];
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
}

assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};
flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setProps, setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
}).call(this,require('_process'))

},{"./CallbackQueue":36,"./Object.assign":53,"./PooledClass":54,"./ReactPerf":102,"./ReactReconciler":107,"./Transaction":131,"_process":30,"fbjs/lib/invariant":17}],115:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactVersion
 */

'use strict';

module.exports = '0.14.7';
},{}],116:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SVGDOMPropertyConfig
 */

'use strict';

var DOMProperty = require('./DOMProperty');

var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;

var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

var SVGDOMPropertyConfig = {
  Properties: {
    clipPath: MUST_USE_ATTRIBUTE,
    cx: MUST_USE_ATTRIBUTE,
    cy: MUST_USE_ATTRIBUTE,
    d: MUST_USE_ATTRIBUTE,
    dx: MUST_USE_ATTRIBUTE,
    dy: MUST_USE_ATTRIBUTE,
    fill: MUST_USE_ATTRIBUTE,
    fillOpacity: MUST_USE_ATTRIBUTE,
    fontFamily: MUST_USE_ATTRIBUTE,
    fontSize: MUST_USE_ATTRIBUTE,
    fx: MUST_USE_ATTRIBUTE,
    fy: MUST_USE_ATTRIBUTE,
    gradientTransform: MUST_USE_ATTRIBUTE,
    gradientUnits: MUST_USE_ATTRIBUTE,
    markerEnd: MUST_USE_ATTRIBUTE,
    markerMid: MUST_USE_ATTRIBUTE,
    markerStart: MUST_USE_ATTRIBUTE,
    offset: MUST_USE_ATTRIBUTE,
    opacity: MUST_USE_ATTRIBUTE,
    patternContentUnits: MUST_USE_ATTRIBUTE,
    patternUnits: MUST_USE_ATTRIBUTE,
    points: MUST_USE_ATTRIBUTE,
    preserveAspectRatio: MUST_USE_ATTRIBUTE,
    r: MUST_USE_ATTRIBUTE,
    rx: MUST_USE_ATTRIBUTE,
    ry: MUST_USE_ATTRIBUTE,
    spreadMethod: MUST_USE_ATTRIBUTE,
    stopColor: MUST_USE_ATTRIBUTE,
    stopOpacity: MUST_USE_ATTRIBUTE,
    stroke: MUST_USE_ATTRIBUTE,
    strokeDasharray: MUST_USE_ATTRIBUTE,
    strokeLinecap: MUST_USE_ATTRIBUTE,
    strokeOpacity: MUST_USE_ATTRIBUTE,
    strokeWidth: MUST_USE_ATTRIBUTE,
    textAnchor: MUST_USE_ATTRIBUTE,
    transform: MUST_USE_ATTRIBUTE,
    version: MUST_USE_ATTRIBUTE,
    viewBox: MUST_USE_ATTRIBUTE,
    x1: MUST_USE_ATTRIBUTE,
    x2: MUST_USE_ATTRIBUTE,
    x: MUST_USE_ATTRIBUTE,
    xlinkActuate: MUST_USE_ATTRIBUTE,
    xlinkArcrole: MUST_USE_ATTRIBUTE,
    xlinkHref: MUST_USE_ATTRIBUTE,
    xlinkRole: MUST_USE_ATTRIBUTE,
    xlinkShow: MUST_USE_ATTRIBUTE,
    xlinkTitle: MUST_USE_ATTRIBUTE,
    xlinkType: MUST_USE_ATTRIBUTE,
    xmlBase: MUST_USE_ATTRIBUTE,
    xmlLang: MUST_USE_ATTRIBUTE,
    xmlSpace: MUST_USE_ATTRIBUTE,
    y1: MUST_USE_ATTRIBUTE,
    y2: MUST_USE_ATTRIBUTE,
    y: MUST_USE_ATTRIBUTE
  },
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {
    clipPath: 'clip-path',
    fillOpacity: 'fill-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    gradientTransform: 'gradientTransform',
    gradientUnits: 'gradientUnits',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    patternContentUnits: 'patternContentUnits',
    patternUnits: 'patternUnits',
    preserveAspectRatio: 'preserveAspectRatio',
    spreadMethod: 'spreadMethod',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strokeDasharray: 'stroke-dasharray',
    strokeLinecap: 'stroke-linecap',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    textAnchor: 'text-anchor',
    viewBox: 'viewBox',
    xlinkActuate: 'xlink:actuate',
    xlinkArcrole: 'xlink:arcrole',
    xlinkHref: 'xlink:href',
    xlinkRole: 'xlink:role',
    xlinkShow: 'xlink:show',
    xlinkTitle: 'xlink:title',
    xlinkType: 'xlink:type',
    xmlBase: 'xml:base',
    xmlLang: 'xml:lang',
    xmlSpace: 'xml:space'
  }
};

module.exports = SVGDOMPropertyConfig;
},{"./DOMProperty":40}],117:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SelectEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactInputSelection = require('./ReactInputSelection');
var SyntheticEvent = require('./SyntheticEvent');

var getActiveElement = require('fbjs/lib/getActiveElement');
var isTextInputElement = require('./isTextInputElement');
var keyOf = require('fbjs/lib/keyOf');
var shallowEqual = require('fbjs/lib/shallowEqual');

var topLevelTypes = EventConstants.topLevelTypes;

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSelect: null }),
      captured: keyOf({ onSelectCapture: null })
    },
    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
  }
};

var activeElement = null;
var activeElementID = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events.
var hasListener = false;
var ON_SELECT_KEY = keyOf({ onSelect: null });

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    switch (topLevelType) {
      // Track the input node that has focus.
      case topLevelTypes.topFocus:
        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
          activeElement = topLevelTarget;
          activeElementID = topLevelTargetID;
          lastSelection = null;
        }
        break;
      case topLevelTypes.topBlur:
        activeElement = null;
        activeElementID = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case topLevelTypes.topMouseDown:
        mouseDown = true;
        break;
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topMouseUp:
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case topLevelTypes.topSelectionChange:
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function (id, registrationName, listener) {
    if (registrationName === ON_SELECT_KEY) {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;
},{"./EventConstants":45,"./EventPropagators":49,"./ReactInputSelection":91,"./SyntheticEvent":123,"./isTextInputElement":151,"fbjs/lib/ExecutionEnvironment":3,"fbjs/lib/getActiveElement":12,"fbjs/lib/keyOf":21,"fbjs/lib/shallowEqual":26}],118:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ServerReactRootIndex
 * @typechecks
 */

'use strict';

/**
 * Size of the reactRoot ID space. We generate random numbers for React root
 * IDs and if there's a collision the events and DOM update system will
 * get confused. In the future we need a way to generate GUIDs but for
 * now this will work on a smaller scale.
 */
var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);

var ServerReactRootIndex = {
  createReactRootIndex: function () {
    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
  }
};

module.exports = ServerReactRootIndex;
},{}],119:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SimpleEventPlugin
 */

'use strict';

var EventConstants = require('./EventConstants');
var EventListener = require('fbjs/lib/EventListener');
var EventPropagators = require('./EventPropagators');
var ReactMount = require('./ReactMount');
var SyntheticClipboardEvent = require('./SyntheticClipboardEvent');
var SyntheticEvent = require('./SyntheticEvent');
var SyntheticFocusEvent = require('./SyntheticFocusEvent');
var SyntheticKeyboardEvent = require('./SyntheticKeyboardEvent');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');
var SyntheticDragEvent = require('./SyntheticDragEvent');
var SyntheticTouchEvent = require('./SyntheticTouchEvent');
var SyntheticUIEvent = require('./SyntheticUIEvent');
var SyntheticWheelEvent = require('./SyntheticWheelEvent');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getEventCharCode = require('./getEventCharCode');
var invariant = require('fbjs/lib/invariant');
var keyOf = require('fbjs/lib/keyOf');

var topLevelTypes = EventConstants.topLevelTypes;

var eventTypes = {
  abort: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onAbort: true }),
      captured: keyOf({ onAbortCapture: true })
    }
  },
  blur: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onBlur: true }),
      captured: keyOf({ onBlurCapture: true })
    }
  },
  canPlay: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCanPlay: true }),
      captured: keyOf({ onCanPlayCapture: true })
    }
  },
  canPlayThrough: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCanPlayThrough: true }),
      captured: keyOf({ onCanPlayThroughCapture: true })
    }
  },
  click: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onClick: true }),
      captured: keyOf({ onClickCapture: true })
    }
  },
  contextMenu: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onContextMenu: true }),
      captured: keyOf({ onContextMenuCapture: true })
    }
  },
  copy: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCopy: true }),
      captured: keyOf({ onCopyCapture: true })
    }
  },
  cut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onCut: true }),
      captured: keyOf({ onCutCapture: true })
    }
  },
  doubleClick: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDoubleClick: true }),
      captured: keyOf({ onDoubleClickCapture: true })
    }
  },
  drag: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrag: true }),
      captured: keyOf({ onDragCapture: true })
    }
  },
  dragEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnd: true }),
      captured: keyOf({ onDragEndCapture: true })
    }
  },
  dragEnter: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragEnter: true }),
      captured: keyOf({ onDragEnterCapture: true })
    }
  },
  dragExit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragExit: true }),
      captured: keyOf({ onDragExitCapture: true })
    }
  },
  dragLeave: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragLeave: true }),
      captured: keyOf({ onDragLeaveCapture: true })
    }
  },
  dragOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragOver: true }),
      captured: keyOf({ onDragOverCapture: true })
    }
  },
  dragStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDragStart: true }),
      captured: keyOf({ onDragStartCapture: true })
    }
  },
  drop: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDrop: true }),
      captured: keyOf({ onDropCapture: true })
    }
  },
  durationChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onDurationChange: true }),
      captured: keyOf({ onDurationChangeCapture: true })
    }
  },
  emptied: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEmptied: true }),
      captured: keyOf({ onEmptiedCapture: true })
    }
  },
  encrypted: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEncrypted: true }),
      captured: keyOf({ onEncryptedCapture: true })
    }
  },
  ended: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onEnded: true }),
      captured: keyOf({ onEndedCapture: true })
    }
  },
  error: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onError: true }),
      captured: keyOf({ onErrorCapture: true })
    }
  },
  focus: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onFocus: true }),
      captured: keyOf({ onFocusCapture: true })
    }
  },
  input: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onInput: true }),
      captured: keyOf({ onInputCapture: true })
    }
  },
  keyDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyDown: true }),
      captured: keyOf({ onKeyDownCapture: true })
    }
  },
  keyPress: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyPress: true }),
      captured: keyOf({ onKeyPressCapture: true })
    }
  },
  keyUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onKeyUp: true }),
      captured: keyOf({ onKeyUpCapture: true })
    }
  },
  load: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoad: true }),
      captured: keyOf({ onLoadCapture: true })
    }
  },
  loadedData: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadedData: true }),
      captured: keyOf({ onLoadedDataCapture: true })
    }
  },
  loadedMetadata: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadedMetadata: true }),
      captured: keyOf({ onLoadedMetadataCapture: true })
    }
  },
  loadStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onLoadStart: true }),
      captured: keyOf({ onLoadStartCapture: true })
    }
  },
  // Note: We do not allow listening to mouseOver events. Instead, use the
  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
  mouseDown: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseDown: true }),
      captured: keyOf({ onMouseDownCapture: true })
    }
  },
  mouseMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseMove: true }),
      captured: keyOf({ onMouseMoveCapture: true })
    }
  },
  mouseOut: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOut: true }),
      captured: keyOf({ onMouseOutCapture: true })
    }
  },
  mouseOver: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseOver: true }),
      captured: keyOf({ onMouseOverCapture: true })
    }
  },
  mouseUp: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onMouseUp: true }),
      captured: keyOf({ onMouseUpCapture: true })
    }
  },
  paste: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPaste: true }),
      captured: keyOf({ onPasteCapture: true })
    }
  },
  pause: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPause: true }),
      captured: keyOf({ onPauseCapture: true })
    }
  },
  play: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPlay: true }),
      captured: keyOf({ onPlayCapture: true })
    }
  },
  playing: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onPlaying: true }),
      captured: keyOf({ onPlayingCapture: true })
    }
  },
  progress: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onProgress: true }),
      captured: keyOf({ onProgressCapture: true })
    }
  },
  rateChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onRateChange: true }),
      captured: keyOf({ onRateChangeCapture: true })
    }
  },
  reset: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onReset: true }),
      captured: keyOf({ onResetCapture: true })
    }
  },
  scroll: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onScroll: true }),
      captured: keyOf({ onScrollCapture: true })
    }
  },
  seeked: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSeeked: true }),
      captured: keyOf({ onSeekedCapture: true })
    }
  },
  seeking: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSeeking: true }),
      captured: keyOf({ onSeekingCapture: true })
    }
  },
  stalled: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onStalled: true }),
      captured: keyOf({ onStalledCapture: true })
    }
  },
  submit: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSubmit: true }),
      captured: keyOf({ onSubmitCapture: true })
    }
  },
  suspend: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onSuspend: true }),
      captured: keyOf({ onSuspendCapture: true })
    }
  },
  timeUpdate: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTimeUpdate: true }),
      captured: keyOf({ onTimeUpdateCapture: true })
    }
  },
  touchCancel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchCancel: true }),
      captured: keyOf({ onTouchCancelCapture: true })
    }
  },
  touchEnd: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchEnd: true }),
      captured: keyOf({ onTouchEndCapture: true })
    }
  },
  touchMove: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchMove: true }),
      captured: keyOf({ onTouchMoveCapture: true })
    }
  },
  touchStart: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onTouchStart: true }),
      captured: keyOf({ onTouchStartCapture: true })
    }
  },
  volumeChange: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onVolumeChange: true }),
      captured: keyOf({ onVolumeChangeCapture: true })
    }
  },
  waiting: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onWaiting: true }),
      captured: keyOf({ onWaitingCapture: true })
    }
  },
  wheel: {
    phasedRegistrationNames: {
      bubbled: keyOf({ onWheel: true }),
      captured: keyOf({ onWheelCapture: true })
    }
  }
};

var topLevelEventsToDispatchConfig = {
  topAbort: eventTypes.abort,
  topBlur: eventTypes.blur,
  topCanPlay: eventTypes.canPlay,
  topCanPlayThrough: eventTypes.canPlayThrough,
  topClick: eventTypes.click,
  topContextMenu: eventTypes.contextMenu,
  topCopy: eventTypes.copy,
  topCut: eventTypes.cut,
  topDoubleClick: eventTypes.doubleClick,
  topDrag: eventTypes.drag,
  topDragEnd: eventTypes.dragEnd,
  topDragEnter: eventTypes.dragEnter,
  topDragExit: eventTypes.dragExit,
  topDragLeave: eventTypes.dragLeave,
  topDragOver: eventTypes.dragOver,
  topDragStart: eventTypes.dragStart,
  topDrop: eventTypes.drop,
  topDurationChange: eventTypes.durationChange,
  topEmptied: eventTypes.emptied,
  topEncrypted: eventTypes.encrypted,
  topEnded: eventTypes.ended,
  topError: eventTypes.error,
  topFocus: eventTypes.focus,
  topInput: eventTypes.input,
  topKeyDown: eventTypes.keyDown,
  topKeyPress: eventTypes.keyPress,
  topKeyUp: eventTypes.keyUp,
  topLoad: eventTypes.load,
  topLoadedData: eventTypes.loadedData,
  topLoadedMetadata: eventTypes.loadedMetadata,
  topLoadStart: eventTypes.loadStart,
  topMouseDown: eventTypes.mouseDown,
  topMouseMove: eventTypes.mouseMove,
  topMouseOut: eventTypes.mouseOut,
  topMouseOver: eventTypes.mouseOver,
  topMouseUp: eventTypes.mouseUp,
  topPaste: eventTypes.paste,
  topPause: eventTypes.pause,
  topPlay: eventTypes.play,
  topPlaying: eventTypes.playing,
  topProgress: eventTypes.progress,
  topRateChange: eventTypes.rateChange,
  topReset: eventTypes.reset,
  topScroll: eventTypes.scroll,
  topSeeked: eventTypes.seeked,
  topSeeking: eventTypes.seeking,
  topStalled: eventTypes.stalled,
  topSubmit: eventTypes.submit,
  topSuspend: eventTypes.suspend,
  topTimeUpdate: eventTypes.timeUpdate,
  topTouchCancel: eventTypes.touchCancel,
  topTouchEnd: eventTypes.touchEnd,
  topTouchMove: eventTypes.touchMove,
  topTouchStart: eventTypes.touchStart,
  topVolumeChange: eventTypes.volumeChange,
  topWaiting: eventTypes.waiting,
  topWheel: eventTypes.wheel
};

for (var type in topLevelEventsToDispatchConfig) {
  topLevelEventsToDispatchConfig[type].dependencies = [type];
}

var ON_CLICK_KEY = keyOf({ onClick: null });
var onClickListeners = {};

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  /**
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {DOMEventTarget} topLevelTarget The listening component root node.
   * @param {string} topLevelTargetID ID of `topLevelTarget`.
   * @param {object} nativeEvent Native browser event.
   * @return {*} An accumulation of synthetic events.
   * @see {EventPluginHub.extractEvents}
   */
  extractEvents: function (topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case topLevelTypes.topAbort:
      case topLevelTypes.topCanPlay:
      case topLevelTypes.topCanPlayThrough:
      case topLevelTypes.topDurationChange:
      case topLevelTypes.topEmptied:
      case topLevelTypes.topEncrypted:
      case topLevelTypes.topEnded:
      case topLevelTypes.topError:
      case topLevelTypes.topInput:
      case topLevelTypes.topLoad:
      case topLevelTypes.topLoadedData:
      case topLevelTypes.topLoadedMetadata:
      case topLevelTypes.topLoadStart:
      case topLevelTypes.topPause:
      case topLevelTypes.topPlay:
      case topLevelTypes.topPlaying:
      case topLevelTypes.topProgress:
      case topLevelTypes.topRateChange:
      case topLevelTypes.topReset:
      case topLevelTypes.topSeeked:
      case topLevelTypes.topSeeking:
      case topLevelTypes.topStalled:
      case topLevelTypes.topSubmit:
      case topLevelTypes.topSuspend:
      case topLevelTypes.topTimeUpdate:
      case topLevelTypes.topVolumeChange:
      case topLevelTypes.topWaiting:
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case topLevelTypes.topKeyPress:
        // FireFox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topKeyDown:
      case topLevelTypes.topKeyUp:
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case topLevelTypes.topBlur:
      case topLevelTypes.topFocus:
        EventConstructor = SyntheticFocusEvent;
        break;
      case topLevelTypes.topClick:
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case topLevelTypes.topContextMenu:
      case topLevelTypes.topDoubleClick:
      case topLevelTypes.topMouseDown:
      case topLevelTypes.topMouseMove:
      case topLevelTypes.topMouseOut:
      case topLevelTypes.topMouseOver:
      case topLevelTypes.topMouseUp:
        EventConstructor = SyntheticMouseEvent;
        break;
      case topLevelTypes.topDrag:
      case topLevelTypes.topDragEnd:
      case topLevelTypes.topDragEnter:
      case topLevelTypes.topDragExit:
      case topLevelTypes.topDragLeave:
      case topLevelTypes.topDragOver:
      case topLevelTypes.topDragStart:
      case topLevelTypes.topDrop:
        EventConstructor = SyntheticDragEvent;
        break;
      case topLevelTypes.topTouchCancel:
      case topLevelTypes.topTouchEnd:
      case topLevelTypes.topTouchMove:
      case topLevelTypes.topTouchStart:
        EventConstructor = SyntheticTouchEvent;
        break;
      case topLevelTypes.topScroll:
        EventConstructor = SyntheticUIEvent;
        break;
      case topLevelTypes.topWheel:
        EventConstructor = SyntheticWheelEvent;
        break;
      case topLevelTypes.topCopy:
      case topLevelTypes.topCut:
      case topLevelTypes.topPaste:
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (id, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    if (registrationName === ON_CLICK_KEY) {
      var node = ReactMount.getNode(id);
      if (!onClickListeners[id]) {
        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function (id, registrationName) {
    if (registrationName === ON_CLICK_KEY) {
      onClickListeners[id].remove();
      delete onClickListeners[id];
    }
  }

};

module.exports = SimpleEventPlugin;
}).call(this,require('_process'))

},{"./EventConstants":45,"./EventPropagators":49,"./ReactMount":96,"./SyntheticClipboardEvent":120,"./SyntheticDragEvent":122,"./SyntheticEvent":123,"./SyntheticFocusEvent":124,"./SyntheticKeyboardEvent":126,"./SyntheticMouseEvent":127,"./SyntheticTouchEvent":128,"./SyntheticUIEvent":129,"./SyntheticWheelEvent":130,"./getEventCharCode":142,"_process":30,"fbjs/lib/EventListener":2,"fbjs/lib/emptyFunction":9,"fbjs/lib/invariant":17,"fbjs/lib/keyOf":21}],120:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticClipboardEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;
},{"./SyntheticEvent":123}],121:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticCompositionEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;
},{"./SyntheticEvent":123}],122:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticDragEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;
},{"./SyntheticMouseEvent":127}],123:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticEvent
 * @typechecks static-only
 */

'use strict';

var PooledClass = require('./PooledClass');

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 */
function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  this.dispatchConfig = dispatchConfig;
  this.dispatchMarker = dispatchMarker;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
}

assign(SyntheticEvent.prototype, {

  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
    }
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
    }
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else {
      event.cancelBubble = true;
    }
    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      this[propName] = null;
    }
    this.dispatchConfig = null;
    this.dispatchMarker = null;
    this.nativeEvent = null;
  }

});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var prototype = Object.create(Super.prototype);
  assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

module.exports = SyntheticEvent;
}).call(this,require('_process'))

},{"./Object.assign":53,"./PooledClass":54,"_process":30,"fbjs/lib/emptyFunction":9,"fbjs/lib/warning":28}],124:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticFocusEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;
},{"./SyntheticUIEvent":129}],125:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticInputEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;
},{"./SyntheticEvent":123}],126:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticKeyboardEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventCharCode = require('./getEventCharCode');
var getEventKey = require('./getEventKey');
var getEventModifierState = require('./getEventModifierState');

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;
},{"./SyntheticUIEvent":129,"./getEventCharCode":142,"./getEventKey":143,"./getEventModifierState":144}],127:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticMouseEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');
var ViewportMetrics = require('./ViewportMetrics');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;
},{"./SyntheticUIEvent":129,"./ViewportMetrics":132,"./getEventModifierState":144}],128:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticTouchEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;
},{"./SyntheticUIEvent":129,"./getEventModifierState":144}],129:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticUIEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target != null && target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;
},{"./SyntheticEvent":123,"./getEventTarget":145}],130:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule SyntheticWheelEvent
 * @typechecks static-only
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX :
    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY :
    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY :
    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;
},{"./SyntheticMouseEvent":127}],131:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Transaction
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var Mixin = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

var Transaction = {

  Mixin: Mixin,

  /**
   * Token to look for to determine if an error occurred.
   */
  OBSERVED_ERROR: {}

};

module.exports = Transaction;
}).call(this,require('_process'))

},{"_process":30,"fbjs/lib/invariant":17}],132:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ViewportMetrics
 */

'use strict';

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;
},{}],133:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule accumulateInto
 */

'use strict';

var invariant = require('fbjs/lib/invariant');

/**
 *
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  var currentIsArray = Array.isArray(current);
  var nextIsArray = Array.isArray(next);

  if (currentIsArray && nextIsArray) {
    current.push.apply(current, next);
    return current;
  }

  if (currentIsArray) {
    current.push(next);
    return current;
  }

  if (nextIsArray) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
}).call(this,require('_process'))

},{"_process":30,"fbjs/lib/invariant":17}],134:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule adler32
 */

'use strict';

var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    for (; i < Math.min(i + 4096, m); i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

module.exports = adler32;
},{}],135:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule canDefineProperty
 */

'use strict';

var canDefineProperty = false;
if (process.env.NODE_ENV !== 'production') {
  try {
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
}).call(this,require('_process'))

},{"_process":30}],136:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule dangerousStyleValue
 * @typechecks static-only
 */

'use strict';

var CSSProperty = require('./CSSProperty');

var isUnitlessNumber = CSSProperty.isUnitlessNumber;

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
},{"./CSSProperty":34}],137:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule deprecated
 */

'use strict';

var assign = require('./Object.assign');
var warning = require('fbjs/lib/warning');

/**
 * This will log a single deprecation notice per function and forward the call
 * on to the new API.
 *
 * @param {string} fnName The name of the function
 * @param {string} newModule The module that fn will exist in
 * @param {string} newPackage The module that fn will exist in
 * @param {*} ctx The context this forwarded call should run in
 * @param {function} fn The function to forward on to
 * @return {function} The function that will warn once and then call fn
 */
function deprecated(fnName, newModule, newPackage, ctx, fn) {
  var warned = false;
  if (process.env.NODE_ENV !== 'production') {
    var newFn = function () {
      process.env.NODE_ENV !== 'production' ? warning(warned,
      // Require examples in this string must be split to prevent React's
      // build tools from mistaking them for real requires.
      // Otherwise the build tools will attempt to build a '%s' module.
      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
      warned = true;
      return fn.apply(ctx, arguments);
    };
    // We need to make sure all properties of the original fn are copied over.
    // In particular, this is needed to support PropTypes
    return assign(newFn, fn);
  }

  return fn;
}

module.exports = deprecated;
}).call(this,require('_process'))

},{"./Object.assign":53,"_process":30,"fbjs/lib/warning":28}],138:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule escapeTextContentForBrowser
 */

'use strict';

var ESCAPE_LOOKUP = {
  '&': '&amp;',
  '>': '&gt;',
  '<': '&lt;',
  '"': '&quot;',
  '\'': '&#x27;'
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
  return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  return ('' + text).replace(ESCAPE_REGEX, escaper);
}

module.exports = escapeTextContentForBrowser;
},{}],139:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule findDOMNode
 * @typechecks static-only
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactMount = require('./ReactMount');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Returns the DOM node rendered by this element.
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if (process.env.NODE_ENV !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }
  if (ReactInstanceMap.has(componentOrElement)) {
    return ReactMount.getNodeFromInstance(componentOrElement);
  }
  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
  !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
}

module.exports = findDOMNode;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":65,"./ReactInstanceMap":93,"./ReactMount":96,"_process":30,"fbjs/lib/invariant":17,"fbjs/lib/warning":28}],140:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule flattenChildren
 */

'use strict';

var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 */
function flattenSingleChildIntoContext(traverseContext, child, name) {
  // We found a component instance.
  var result = traverseContext;
  var keyUnique = result[name] === undefined;
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
  }
  if (keyUnique && child != null) {
    result[name] = child;
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children) {
  if (children == null) {
    return children;
  }
  var result = {};
  traverseAllChildren(children, flattenSingleChildIntoContext, result);
  return result;
}

module.exports = flattenChildren;
}).call(this,require('_process'))

},{"./traverseAllChildren":158,"_process":30,"fbjs/lib/warning":28}],141:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule forEachAccumulated
 */

'use strict';

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */
var forEachAccumulated = function (arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
};

module.exports = forEachAccumulated;
},{}],142:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventCharCode
 * @typechecks static-only
 */

'use strict';

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */
function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;
},{}],143:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventKey
 * @typechecks static-only
 */

'use strict';

var getEventCharCode = require('./getEventCharCode');

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;
},{"./getEventCharCode":142}],144:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventModifierState
 * @typechecks static-only
 */

'use strict';

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;
},{}],145:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getEventTarget
 * @typechecks static-only
 */

'use strict';

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */
function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;
  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;
},{}],146:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getIteratorFn
 * @typechecks static-only
 */

'use strict';

/* global Symbol */
var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;
},{}],147:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getNodeForCharacterOffset
 */

'use strict';

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */
function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;
},{}],148:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getTextContentAccessor
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;
},{"fbjs/lib/ExecutionEnvironment":3}],149:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule instantiateReactComponent
 * @typechecks static-only
 */

'use strict';

var ReactCompositeComponent = require('./ReactCompositeComponent');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactNativeComponent = require('./ReactNativeComponent');

var assign = require('./Object.assign');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function () {};
assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
  _instantiateReactComponent: instantiateReactComponent
});

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node) {
  var instance;

  if (node === null || node === false) {
    instance = new ReactEmptyComponent(instantiateReactComponent);
  } else if (typeof node === 'object') {
    var element = node;
    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactNativeComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);
    } else {
      instance = new ReactCompositeComponentWrapper();
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactNativeComponent.createInstanceForText(node);
  } else {
    !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : invariant(false) : undefined;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
  }

  // Sets up the instance. This can probably just move into the constructor now.
  instance.construct(node);

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if (process.env.NODE_ENV !== 'production') {
    instance._isOwnerNecessary = false;
    instance._warnedAboutRefsInRender = false;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if (process.env.NODE_ENV !== 'production') {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

module.exports = instantiateReactComponent;
}).call(this,require('_process'))

},{"./Object.assign":53,"./ReactCompositeComponent":64,"./ReactEmptyComponent":85,"./ReactNativeComponent":99,"_process":30,"fbjs/lib/invariant":17,"fbjs/lib/warning":28}],150:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = (eventName in document);

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;
},{"fbjs/lib/ExecutionEnvironment":3}],151:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isTextInputElement
 */

'use strict';

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */
var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
}

module.exports = isTextInputElement;
},{}],152:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule onlyChild
 */
'use strict';

var ReactElement = require('./ReactElement');

var invariant = require('fbjs/lib/invariant');

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection. The current implementation of this
 * function assumes that a single child gets passed without a wrapper, but the
 * purpose of this helper function is to abstract away the particular structure
 * of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactComponent} The first and only `ReactComponent` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
  return children;
}

module.exports = onlyChild;
}).call(this,require('_process'))

},{"./ReactElement":83,"_process":30,"fbjs/lib/invariant":17}],153:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule quoteAttributeValueForBrowser
 */

'use strict';

var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;
},{"./escapeTextContentForBrowser":138}],154:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
* @providesModule renderSubtreeIntoContainer
*/

'use strict';

var ReactMount = require('./ReactMount');

module.exports = ReactMount.renderSubtreeIntoContainer;
},{"./ReactMount":96}],155:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setInnerHTML
 */

/* globals MSApp */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = function (node, html) {
  node.innerHTML = html;
};

// Win8 apps: Allow all html to be inserted
if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
  setInnerHTML = function (node, html) {
    MSApp.execUnsafeLocalFunction(function () {
      node.innerHTML = html;
    });
  };
}

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xFEFF) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
}

module.exports = setInnerHTML;
},{"fbjs/lib/ExecutionEnvironment":3}],156:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule setTextContent
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var setInnerHTML = require('./setInnerHTML');

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;
},{"./escapeTextContentForBrowser":138,"./setInnerHTML":155,"fbjs/lib/ExecutionEnvironment":3}],157:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shouldUpdateReactComponent
 * @typechecks static-only
 */

'use strict';

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */
function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
  return false;
}

module.exports = shouldUpdateReactComponent;
},{}],158:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule traverseAllChildren
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactElement = require('./ReactElement');
var ReactInstanceHandles = require('./ReactInstanceHandles');

var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var SEPARATOR = ReactInstanceHandles.SEPARATOR;
var SUBSEPARATOR = ':';

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var userProvidedKeyEscaperLookup = {
  '=': '=0',
  '.': '=1',
  ':': '=2'
};

var userProvidedKeyEscapeRegex = /[=.:]/g;

var didWarnAboutMaps = false;

function userProvidedKeyEscaper(match) {
  return userProvidedKeyEscaperLookup[match];
}

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  if (component && component.key != null) {
    // Explicit key
    return wrapUserProvidedKey(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * Escape a component key so that it is safe to use in a reactid.
 *
 * @param {*} text Component key to be escaped.
 * @return {string} An escaped string.
 */
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
}

/**
 * Wrap a `key` value explicitly provided by the user to distinguish it from
 * implicitly-generated keys generated by a component's index in its parent.
 *
 * @param {string} key Value of a user-provided `key` attribute
 * @return {string}
 */
function wrapUserProvidedKey(key) {
  return '$' + escapeUserProvidedKey(key);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":65,"./ReactElement":83,"./ReactInstanceHandles":92,"./getIteratorFn":146,"_process":30,"fbjs/lib/invariant":17,"fbjs/lib/warning":28}],159:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule validateDOMNesting
 */

'use strict';

var assign = require('./Object.assign');
var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

var validateDOMNesting = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    parentTag: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function (oldInfo, tag, instance) {
    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.parentTag = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':

      case 'pre':
      case 'listing':

      case 'table':

      case 'hr':

      case 'xmp':

      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function (instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    /*eslint-disable space-after-keywords */
    do {
      /*eslint-enable space-after-keywords */
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.parentTag;
    var parentTag = parentInfo && parentInfo.tag;

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
      } else {
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
      }
    }
  };

  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.parentTag;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;
}).call(this,require('_process'))

},{"./Object.assign":53,"_process":30,"fbjs/lib/emptyFunction":9,"fbjs/lib/warning":28}],160:[function(require,module,exports){
'use strict';

module.exports = require('./lib/React');

},{"./lib/React":55}],161:[function(require,module,exports){
"use strict";

var React = require('react');
var ReactDOM = require('react-dom');
var Events = require('../events');
var User = require('../user');

var App = React.createClass({ displayName: "App",

  // Render the users in order of users in descending order of win ratio
  // renderLeaderboard() {
  //   const output = usersList.sort((a,b) => {
  //     return this.userWinRatio(b) - this.userWinRatio(a);
  //   }).map((user) => {
  //     return <div>
  //       {this.renderUser(user)}
  //     </div>
  //   })
  //   return output;
  // },

  render: function render() {

    return React.createElement("div", { className: "content" }, React.createElement("div", { className: "col" }, React.createElement(Events, null)), React.createElement("div", { className: "col" }, React.createElement(User, null)));
  }
});

ReactDOM.render(React.createElement(App, null), document.querySelector('.container'));

// ReactDOM.render(App, document.querySelector('.container'));

},{"../events":163,"../user":165,"react":160,"react-dom":31}],162:[function(require,module,exports){
"use strict";

var React = require('react');
var classNames = require('classnames');

function getOrdinal(n) {
  var s = ["th", "st", "nd", "rd"],
      v = n % 100;
  return n + (s[(v - 20) % 10] || s[v] || s[0]);
}

function getPosition(points, i) {
  // If player points are the same as previous player points, return "="
  return getOrdinal(i + 1);
}

function EventPlayers(_ref) {
  var event = _ref.event;
  var type = _ref.type;

  var displayEventUsers = event.players.map(function (player, i) {
    var playerResult = void 0;
    playerResult = player.points;
    if (type === 'team' || type === 'race') {
      if (player.points === "1") {
        playerResult = 'W';
      } else {
        playerResult = 'L';
      }
    }
    var winningPoints = getWinner(event.players);
    var classes = classNames('event-player', player.colour, {
      winner: event.winner.includes(player.name)
    });
    var faction = player.faction ? '(' + player.faction + ')' : false;
    return React.createElement("li", { className: classes, key: player.id }, React.createElement("div", { className: "position" }, getPosition(player.points, i)), React.createElement("div", { className: "name" }, player.name, " ", faction), React.createElement("div", { className: "points" }, playerResult), React.createElement("div", { className: "colour" }));
  });

  return React.createElement("ul", { className: "event-players" }, displayEventUsers);
}

module.exports = EventPlayers;

},{"classnames":1,"react":160}],163:[function(require,module,exports){
"use strict";

var React = require('react');
var classNames = require('classnames');
var moment = require('moment');

var EventPlayers = require('../event-players');

function Event() {
  var events = eventsList.map(function (event) {
    var date = moment(event.date).format('Do MMMM YYYY');
    var eventType = _.capitalize(event.type);
    return React.createElement("li", { className: "row event-card", key: event.id }, React.createElement("div", { className: "header" }, React.createElement("div", { className: "image" }), React.createElement("div", { className: "info" }, React.createElement("h2", null, event.gameName), React.createElement("div", { className: "date" }, date), React.createElement("div", { className: "type" }, "Game type: ", eventType))), React.createElement("h3", null, "Players"), React.createElement(EventPlayers, { event: event, type: event.type }));
  });
  return React.createElement("ul", null, events);
}

module.exports = Event;

},{"../event-players":162,"classnames":1,"moment":29,"react":160}],164:[function(require,module,exports){
"use strict";

var React = require('react');
var classNames = require('classnames');

function isNotWinner(user) {
  return function (event) {
    return !event.winner.includes(user.name);
  };
}

function nemesisCount(counts, user) {
  var find = _.find(counts, ['name', user]);

  if (find) {
    find.count += 1;
    return counts;
  }

  return counts.concat({ name: user, count: 1 });
}

function nemesisPicker(nemesii, nemesis) {
  if (nemesii.length === 0) {
    nemesii.push(nemesis);
  } else if (nemesii[0].count < nemesis.count) {
    nemesii = [nemesis];
  } else if (nemesii[0].count === nemesis.count) {
    nemesii.push(nemesis);
  }

  return nemesii;
}

// Experiment to merge the first filter and map of findNemesis
// function filterMap(user) {
//   return (acc, cur) => {
//     if (!cur.winner.includes(user.name)) {
//       acc.push(cur.winner)
//     }
//     return acc;
//   }, []);
// }

function findNemesis(user) {
  var counts = user.events.filter(isNotWinner(user)).map(function (_ref) {
    var winner = _ref.winner;
    return winner;
  }).reduce(function (a, b) {
    return a.concat(b);
  }, []).reduce(nemesisCount, []);

  var nemesii = counts.reduce(nemesisPicker, []);

  if (nemesii.length === 0) {
    return "Won everything";
  }

  return nemesii.map(function (nemesis) {
    return nemesis.name + ' (' + nemesis.count + ') ';
  });
}

function Nemesis(_ref2) {
  var user = _ref2.user;

  return React.createElement("div", { className: "nemesis" }, "Nemesis: ", findNemesis(user));
}

module.exports = Nemesis;

},{"classnames":1,"react":160}],165:[function(require,module,exports){
"use strict";

var React = require('react');
var classNames = require('classnames');

var Nemesis = require('../nemesis');

function User(_ref) {
  var event = _ref.event;

  var output = usersList.map(function (user) {
    // TODO: Extract the whole wins, no. of events and winratio into a component
    var totalGamesWon = 0;
    var totalGamesPlayed = user.events.map(function (userEvent) {
      if (userEvent.winner.includes(user.name)) {
        totalGamesWon += 1;
      }
      return userEvent.gameName + ', ';
    });
    var winRatio = Math.round(totalGamesWon / totalGamesPlayed.length * 100 * 10) / 10;
    return React.createElement("li", { className: "row user-card", key: user.id }, React.createElement("div", { className: "info" }, React.createElement("h2", { className: "name" }, user.name), React.createElement("div", { className: "win-ratio" }, winRatio, "%"), React.createElement("div", { className: "wins" }, totalGamesWon, " of ", totalGamesPlayed.length), React.createElement(Nemesis, { user: user }), React.createElement("div", { className: "all-games" }, "All Games played: ", totalGamesPlayed)));
  });

  return React.createElement("ul", null, output);
}

module.exports = User;

/*
// const x = if (this.userEvents(user).length > 0) {
//   // let games = this.userBestEvent(user).map(val => {
//   //   return <span className="games">
//   //     {val.name} <span className="count">({val.count})</span>
//   //   </span>;
//   // });
//   // if (this.userBestEvent(user).length === 0) {
//   //   games = "No wins yet"
//   // }
//   return <div className="row user-card">
//     <div className="info">
//       <div className="most-wins">Most wins in: {games}</div>
//       <div className="nemesis">Nemesis: {this.userNemesis(user)}</div>
//     </div>
//   </div>
// }
// Which events a user has won
// userWins(user) {
//   let wins = [];
//   eventsList.map(event => {
//     if (event.winner === user.id) {
//       wins.push(event.gameName);
//     }
//   });
//   return wins;
// },



// userNemesis(user) {
//   let didNotWin = [];
//   eventsList.map(event => {
//     if (event.players.includes(user.id) && (user.id != event.winner)) {
//       didNotWin.push(event);
//     }
//   });
//
//   const xs = didNotWin.map(val => {
//     return val.winner;
//   });
//
//   const counts = xs.reduce((a, b, i, array) => {
//     const find = _.find(a, ['winner', array[i]]);
//     if (find) {
//       find.count += 1;
//       return a;
//     } else {
//       return a.concat({winner: array[i], count: 1})
//     }
//   }, []);
//
//   const output = counts.reduce((acc,x) => {
//     if (acc.length === 0) {
//       acc.push(x)
//     } else if (acc[0].count < x.count) {
//       acc = [x];
//     } else if (acc[0].count === x.count) {
//       acc[0].count += 1;
//     }
//     return acc;
//   }, [])
//
//   const final = usersList.map(usr => {
//     const d = output.map(d => {
//       if (usr.id === d.winner) {
//         return usr.name;
//       }
//     });
//     return d;
//   });
//
//   return final;
// },
//
// // Get user's most successful event
// userBestEvent(user) {
//
//   const list = this.userWins(user);
//
//   const counts = list.reduce((a, b, i, array) => {
//     const find = _.find(a, ['name', array[i]]);
//     if (find) {
//       find.count += 1;
//       return a;
//     } else {
//       return a.concat({name: array[i], count: 1})
//     }
//   }, []);
//
//   const output = counts.reduce((acc,x) => {
//     if (acc.length === 0) {
//       acc.push(x)
//     } else if (acc[0].count < x.count) {
//       acc = [x];
//     } else if (acc[0].count === x.count) {
//       acc.push(x);
//     }
//     return acc;
//   }, [])
//
//   return output;
// },
//
// // Calculate percentage win ratio of a user
// userWinRatio(user) {
//   return Math.round(this.userWins(user).length / this.userEvents(user).length * 100 * 10) / 10;
// },

*/

},{"../nemesis":164,"classnames":1,"react":160}]},{},[161])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY2xhc3NuYW1lcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRNYXJrdXBXcmFwLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2lzTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL2tleU1pcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9rZXlPZi5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9tYXBPYmplY3QuanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cuanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwibm9kZV9tb2R1bGVzL2ZianMvbGliL3RvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0F1dG9Gb2N1c1V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9DU1NQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9DYWxsYmFja1F1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9DaGFuZ2VFdmVudFBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvQ2xpZW50UmVhY3RSb290SW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0RPTUNoaWxkcmVuT3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRE9NUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRGFuZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9FdmVudENvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvRXZlbnRQbHVnaW5IdWIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UGx1Z2luVXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0V2ZW50UHJvcGFnYXRvcnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9PYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0QnJvd3NlckNvbXBvbmVudE1peGluLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q2hpbGRSZWNvbmNpbGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENsYXNzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET00uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NQnV0dG9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NRmVhdHVyZUZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01JbnB1dC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NU2VsZWN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01TZXJ2ZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01UZXh0YXJlYS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERlZmF1bHRQZXJmLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50VmFsaWRhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RXJyb3JVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFdmVudEVtaXR0ZXJNaXhpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZUhhbmRsZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0SXNvbW9ycGhpYy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RNb3VudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3ROYXRpdmVDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE93bmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFBlcmYuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RSZWNvbmNpbGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFJlZi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RSb290SW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmcuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VXBkYXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RWZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU2VsZWN0RXZlbnRQbHVnaW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1NlcnZlclJlYWN0Um9vdEluZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9TaW1wbGVFdmVudFBsdWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljQ2xpcGJvYXJkRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvU3ludGhldGljRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY01vdXNlRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY1VJRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9WaWV3cG9ydE1ldHJpY3MuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2FjY3VtdWxhdGVJbnRvLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9hZGxlcjMyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jYW5EZWZpbmVQcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZGVwcmVjYXRlZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9maW5kRE9NTm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvZmxhdHRlbkNoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEV2ZW50S2V5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRFdmVudE1vZGlmaWVyU3RhdGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL3NldFRleHRDb250ZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L3JlYWN0LmpzIiwiL1VzZXJzL3BoaWwvd29yay9fY2hvLmFtL2d1aWxkL3NyYy9jb21wb25lbnRzL2FwcC9hcHAuanN4IiwiL1VzZXJzL3BoaWwvd29yay9fY2hvLmFtL2d1aWxkL3NyYy9jb21wb25lbnRzL2V2ZW50LXBsYXllcnMvaW5kZXguanN4IiwiL1VzZXJzL3BoaWwvd29yay9fY2hvLmFtL2d1aWxkL3NyYy9jb21wb25lbnRzL2V2ZW50cy9pbmRleC5qc3giLCIvVXNlcnMvcGhpbC93b3JrL19jaG8uYW0vZ3VpbGQvc3JjL2NvbXBvbmVudHMvbmVtZXNpcy9pbmRleC5qc3giLCIvVXNlcnMvcGhpbC93b3JrL19jaG8uYW0vZ3VpbGQvc3JjL2NvbXBvbmVudHMvdXNlci9pbmRleC5qc3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdm1IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDblVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsd0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDajhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2oxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25XQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxV0E7QUFDQTtBQUNBO0FBQ0E7O0FDSEEsQUFBWSxBQUFDOztBQUViLElBQU0sQUFBSyxRQUFHLEFBQU8sUUFBQyxBQUFPLEFBQUMsQUFBQztBQUMvQixJQUFNLEFBQVEsV0FBRyxBQUFPLFFBQUMsQUFBVyxBQUFDO0FBQ3JDLElBQU0sQUFBTSxTQUFHLEFBQU8sUUFBQyxBQUFXLEFBQUMsQUFBQztBQUNwQyxJQUFNLEFBQUksT0FBRyxBQUFPLFFBQUMsQUFBUyxBQUFDLEFBQUM7O0FBRWhDLDhCQUErQixhQUFBLEFBQy9CLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUVBOzs7Ozs7Ozs7Ozs7OztBQUFFLEFBQU0sNEJBQUc7O0FBRVAsV0FDRSxvQkFBQSxBQUFJLE9BQUEsRUFBQSxBQUFDLFdBQVMsQUFBQyxBQUFVLGFBQ3ZCLG9CQUFBLEFBQUksT0FBQSxFQUFBLEFBQUMsV0FBUyxBQUFDLEFBQU0sU0FDbkIsb0JBQUMsQUFBTSxRQUFBLEFBQUcsQUFDTixRQUNOLG9CQUFBLEFBQUksT0FBQSxFQUFBLEFBQUMsV0FBUyxBQUFDLEFBQU0sU0FDbkIsb0JBQUMsQUFBSSxNQUFBLEFBQUcsQUFDSixBQUNGLEFBQ04sQUFDTixBQUFHLEFBRUgsQUFBQyxBQUFDLEFBQUMsQUFDSDs7RUE3Qk07O0FBK0JOLEFBQVEsU0FBQyxBQUFNLE9BQUMsb0JBQUMsQUFBRyxLQUFBLEFBQUcsT0FBRSxTQUFRLEFBQUMsY0FBYSxBQUFDLEFBQVksQUFBQyxBQUFDLEFBQUMsQUFFL0QsQUFBOEQ7Ozs7O0FDeEM5RCxBQUFZLEFBQUM7O0FBRWIsSUFBSSxBQUFLLFFBQUcsQUFBTyxRQUFDLEFBQU8sQUFBQyxBQUFDO0FBQzdCLElBQUksQUFBVSxhQUFHLEFBQU8sUUFBQyxBQUFZLEFBQUMsQUFBQzs7QUFFdkMsU0FBUyxBQUFVLFdBQUMsQUFBQztBQUNuQixNQUFJLEFBQUMsSUFBQyxDQUFDLEFBQUksTUFBQyxBQUFJLE1BQUMsQUFBSSxNQUFDLEFBQUksQUFBQztNQUMzQixBQUFDLElBQUMsQUFBQyxJQUFDLEFBQUcsQUFBQyxJQUZhO0FBR3JCLFNBQU8sQUFBQyxLQUFFLEFBQUMsRUFBQyxDQUFDLEFBQUMsSUFBQyxBQUFFLE1BQUUsQUFBRSxBQUFDLE9BQUUsQUFBQyxFQUFDLEFBQUMsQUFBQyxNQUFFLEFBQUMsRUFBQyxBQUFDLEFBQUMsQUFBQyxBQUFDLEFBQ3RDLEFBQUM7OztBQUVELFNBQVMsQUFBVyxZQUFDLEFBQU0sUUFBRSxBQUFDOztBQUU1QixTQUFPLEFBQVUsV0FBRSxBQUFDLElBQUMsQUFBQyxBQUFFLEFBQUMsQUFDM0IsQUFBQyxHQUgrQjs7O0FBS2hDLFNBQVMsQUFBWSxBQUFDO01BQUMsQUFBSztNQUFFLEFBQUksQUFBQzs7QUFDakMsMEJBQTBCLEFBQUssTUFBQyxBQUFPLFFBQUMsQUFBRyxjQUFFLEFBQU0sUUFBRSxBQUFDO0FBQ3BELFFBQUksQUFBWSxBQUFDO0FBQ2pCLEFBQVksbUJBQUcsQUFBTSxPQUFDLEFBQU0sQUFBQztBQUM3QixRQUFJLEFBQUksU0FBSyxBQUFNLFVBQUksQUFBSSxTQUFLLEFBQU0sUUFBRTtBQUN0QyxVQUFJLEFBQU0sT0FBQyxBQUFNLFdBQUssQUFBRztBQUN2QixBQUFZLHVCQUFHLEFBQUcsQUFBQyxBQUNwQixJQUYwQjthQUVwQjtBQUNMLEFBQVksdUJBQUcsQUFBRyxBQUFDLEFBQ3BCLEFBQ0Y7OztBQUNELFFBQU0sQUFBYSxnQkFBRyxBQUFTLFVBQUMsQUFBSyxNQUFDLEFBQU8sQUFBQyxBQUFDO0FBQy9DLDZCQUEyQixBQUFjLGdCQUFFLEFBQU0sT0FBQyxBQUFNLFFBQUU7QUFDeEQsQUFBTSxjQUFFLEFBQUssTUFBQyxBQUFNLE9BQUMsQUFBUSxTQUFDLEFBQU0sT0FBQyxBQUFJLEFBQUMsQUFDM0MsQUFBQyxBQUFDO0tBRmEsQUFBVSxDQUFwQixBQUFPLENBWDRDO0FBY3pELFFBQUksQUFBTyxVQUFHLE1BQUMsQUFBTSxDQUFDLEFBQU8sQUFBSSxnQkFBSSxBQUFNLE9BQUMsQUFBTyxBQUFHLGdCQUFHLEFBQUssQUFBQztBQUMvRCxXQUFPLG9CQUFBLEFBQUcsTUFBQSxFQUFBLEFBQUMsV0FBUyxBQUFFLFNBQU8sQUFBQyxBQUFDLEtBQUEsQUFBRyxBQUFFLE9BQU0sQUFBQyxBQUFJLE1BQzdDLG9CQUFBLEFBQUksT0FBQSxFQUFBLEFBQUMsV0FBUyxBQUFDLEFBQVcsY0FBQSxBQUFDLFlBQVcsQUFBQyxPQUFNLEFBQUMsUUFBTSxBQUFFLEFBQUMsQUFBUSxLQUMvRCxvQkFBQSxBQUFJLE9BQUEsRUFBQSxBQUFDLFdBQVMsQUFBQyxBQUFPLFVBQUEsQUFBQyxPQUFNLEFBQUMsTUFBSSxBQUFDLEtBQUEsQUFBRSxBQUFjLFVBQ25ELG9CQUFBLEFBQUksT0FBQSxFQUFBLEFBQUMsV0FBUyxBQUFDLEFBQVMsWUFBQSxBQUFDLEFBQW1CLGVBQzVDLG9CQUFBLEFBQUksT0FBQSxFQUFBLEFBQUMsV0FBUyxBQUFDLEFBQVMsQUFBTSxBQUMzQixBQUNULEFBQUcsQUFBQyxBQUFDO0dBckJ5QyxDQUF0QyxBQUFpQixDQURZOztBQXdCbkMsU0FBTyxvQkFBQSxBQUFHLE1BQUEsRUFBQSxBQUFDLFdBQVMsQUFBQyxBQUFnQixtQkFDbEMsQUFBa0IsQUFDaEIsQUFBQyxBQUNSLEFBQUM7OztBQUVELEFBQU0sT0FBQyxBQUFPLFVBQUcsQUFBWSxBQUFDOzs7QUM3QzlCLEFBQVksQUFBQzs7QUFFYixJQUFJLEFBQUssUUFBRyxBQUFPLFFBQUMsQUFBTyxBQUFDLEFBQUM7QUFDN0IsSUFBSSxBQUFVLGFBQUcsQUFBTyxRQUFDLEFBQVksQUFBQyxBQUFDO0FBQ3ZDLElBQUksQUFBTSxTQUFHLEFBQU8sUUFBQyxBQUFRLEFBQUMsQUFBQzs7QUFFL0IsSUFBSSxBQUFZLGVBQUcsQUFBTyxRQUFDLEFBQWtCLEFBQUMsQUFBQzs7QUFFL0MsU0FBUyxBQUFLO0FBQ1osZUFBZSxBQUFVLFdBQUMsQUFBRztBQUMzQixRQUFNLEFBQUksT0FBRyxBQUFNLE9BQUMsQUFBSyxNQUFDLEFBQUksQUFBQyxNQUFDLEFBQU0sT0FBQyxBQUFjLEFBQUMsQUFBQztBQUN2RCxRQUFNLEFBQVMsWUFBRyxBQUFDLEVBQUMsQUFBVSxXQUFDLEFBQUssTUFBQyxBQUFJLEFBQUMsQUFBQyxNQUZOO0FBR3JDLFdBQ0Usb0JBQUEsQUFBRyxNQUFBLEVBQUEsQUFBQyxXQUFTLEFBQUMsa0JBQUEsQUFBZ0IsQUFBQyxLQUFBLEFBQUcsQUFBRSxNQUFLLEFBQUMsQUFBSSxNQUM1QyxvQkFBQSxBQUFJLE9BQUEsRUFBQSxBQUFDLFdBQVMsQUFBQyxBQUFTLFlBQ3RCLG9CQUFBLEFBQUksT0FBQSxFQUFBLEFBQUMsV0FBUyxBQUFDLEFBQVEsQUFBTSxZQUM3QixvQkFBQSxBQUFJLE9BQUEsRUFBQSxBQUFDLFdBQVMsQUFBQyxBQUFPLFVBQ3BCLG9CQUFBLEFBQUcsTUFBQSxBQUFDLE1BQUMsQUFBSyxNQUFDLEFBQWMsV0FDekIsb0JBQUEsQUFBSSxPQUFBLEVBQUEsQUFBQyxXQUFTLEFBQUMsQUFBTyxVQUFBLEFBQUMsQUFBVyxPQUNsQyxvQkFBQSxBQUFJLE9BQUEsRUFBQSxBQUFDLFdBQVMsQUFBQyxBQUFPLFVBQUEsZUFBQSxBQUFZLEFBQWdCLEFBQzlDLEFBQ0YsY0FDTixvQkFBQSxBQUFHLE1BQUEsQUFBQyxNQUFBLEFBQVksWUFDaEIsb0JBQUMsQUFBWSxjQUFBLEVBQUEsQUFBQyxPQUFLLEFBQUUsT0FBSyxBQUFDLEFBQUMsTUFBQSxBQUFJLEFBQUUsTUFBSyxBQUFDLEFBQUssQUFBRyxBQUM3QyxBQUNMLEFBQ0gsQUFBQyxBQUFDO0dBakIyQixBQUFLLENBQTdCLEFBQU0sQ0FERztBQW1CZixTQUNFLG9CQUFBLEFBQUcsTUFBQSxBQUFDLE1BQ0QsQUFBTyxBQUNMLEFBQ0wsQUFDSixBQUFDOzs7QUFFRCxBQUFNLE9BQUMsQUFBTyxVQUFHLEFBQUssQUFBQzs7O0FDbEN2QixBQUFZLEFBQUM7O0FBRWIsSUFBSSxBQUFLLFFBQUcsQUFBTyxRQUFDLEFBQU8sQUFBQyxBQUFDO0FBQzdCLElBQUksQUFBVSxhQUFHLEFBQU8sUUFBQyxBQUFZLEFBQUMsQUFBQzs7QUFFdkMsU0FBUyxBQUFXLFlBQUMsQUFBSTttQkFDTixBQUFLLE9BQUUsQUFDdEI7V0FBTyxDQUFDLEFBQUssTUFBQyxBQUFNLE9BQUMsQUFBUSxTQUFDLEFBQUksS0FGWCxBQUN6QixBQUFPLEFBQzhCLEFBQUksQUFBQyxBQUFDLEFBQzFDLEFBQUMsQUFDSixBQUFDOzs7O0FBRUQsU0FBUyxBQUFZLGFBQUMsQUFBTSxRQUFFLEFBQUksTUFBRSxBQUNwQyxBQUFFO01BQUksQUFBSSxPQUFHLEFBQUMsRUFBQyxBQUFJLEtBQUMsQUFBTSxRQUFFLENBQUMsQUFBTSxRQUFFLEFBQUksQUFBQyxBQUFDLEFBQUMsQUFFMUM7O01BQUksQUFBSSxNQUFFLEFBQ1IsQUFBSTtTQUFDLEFBQUssU0FBSSxBQUFDLEFBQUMsQUFDaEI7V0FBTyxBQUFNLEFBQUMsQUFDbEIsQUFBRyxBQUVEOzs7U0FBTyxBQUFNLE9BQUMsQUFBTSxPQUFDLEVBQUUsQUFBSSxNQUFFLEFBQUksTUFBRSxBQUFLLE9BQUUsQUFBQyxBQUFFLEFBQUMsQUFBQyxBQUNqRCxBQUFDOzs7QUFFRCxTQUFTLEFBQWEsY0FBQyxBQUFPLFNBQUUsQUFBTztNQUNqQyxBQUFPLFFBQUMsQUFBTSxXQUFLLEFBQUM7WUFDZCxBQUFJLEtBRFksQUFDeEIsQUFBTyxBQUFNLEFBQU8sQUFBQyxBQUFDLEFBQ3ZCO2FBQVUsQUFBTyxRQUFDLEFBQUMsQUFBQyxHQUFDLEFBQUssUUFBRyxBQUFPLFFBQUMsQUFBSztjQUMvQixDQURMLEFBQXNDLEFBQzNDLEFBQU8sQUFBSSxBQUFPLEFBQUMsQUFBQyxBQUNyQjthQUFVLEFBQU8sUUFBQyxBQUFDLEFBQUMsR0FBQyxBQUFLLFVBQUssQUFBTyxRQUFDLEFBQUs7WUFDbkMsQUFBSSxLQURQLEFBQXdDLEFBQzdDLEFBQU8sQUFBTSxBQUFPLEFBQUMsQUFBQyxBQUMxQixBQUFHLEFBRUQ7OztTQVR1QyxBQUN2QyxBQVFPLEFBQU8sQUFBQyxBQUNqQixBQUFDLEFBRUQsQUFBOEQsQUFDOUQsQUFBNkIsQUFDN0IsQUFBMkIsQUFDM0IsQUFBNkMsQUFDN0MsQUFBNkIsQUFDN0IsQUFBUSxBQUNSLEFBQWtCLEFBQ2xCLEFBQVksQUFDWixBQUFJOzs7Ozs7Ozs7Ozs7O0FBRUosU0FBUyxBQUFXLFlBQUMsQUFBSTtNQUNuQixBQUFNLGNBQVEsQUFBTSxPQUFDLEFBQU0sT0FBQyxBQUFXLFlBQUMsQUFBSSxBQUFDLEFBQUMsT0FBQyxBQUFHLGNBQVcsQUFBSTtRQUMvRCxBQUFNLFNBQUcsQUFBSSxLQUFDLEFBQU0sQUFBQyxBQUN6QjtXQUZXLEFBQUksQUFBc0MsQUFBZ0IsQUFDckUsQUFDTyxBQUFNLEFBQUMsQUFDZixBQUFDO0tBQUMsQUFBTSxpQkFBVyxBQUFDLEdBQUUsQUFBQztXQUNmLEFBQUMsRUFBQyxBQUFNLE9BRFAsQUFBZ0IsQUFDeEIsQUFBZ0IsQUFBQyxBQUFDLEFBQUMsQUFDdkIsQUFBRztLQUFFLEFBQUUsQUFBQyxJQUFDLEFBQU0sT0FBQyxBQUFZLGNBQUUsQUFBRSxBQUFDLEFBQUMsQUFFbEMsQUFBRTs7TUFBSSxBQUFPLFVBQUcsQUFBTSxPQUFDLEFBQU0sT0FBQyxBQUFhLGVBQUUsQUFBRSxBQUFDLEFBQUMsQUFFL0M7O01BQUksQUFBTyxRQUFDLEFBQU0sV0FBSyxBQUFDLEdBQUUsQUFDeEI7V0FBTyxBQUFnQixBQUFDLEFBQzVCLEFBQUcsQUFFRDs7O1NBQU8sQUFBTyxRQUFDLEFBQUcsY0FBVyxBQUFPLFNBQUUsQUFDcEM7V0FBTyxBQUFPLFFBQUMsQUFBSSxPQUFHLEFBQUksT0FBRyxBQUFPLFFBQUMsQUFBSyxRQWZuQixBQUN6QixBQWFtQixBQUM0QixBQUFJLEFBQUMsQUFDbkQsQUFBQyxBQUFDLEFBQ0wsQUFBQzs7OztBQUVELFNBQVMsQUFBTyxRQUFDLEFBQUssT0FBRSxBQUN4QixBQUFFO01BQUksQUFBSSxPQUFHLEFBQUssTUFBQyxBQUFJLEFBQUMsQUFFdEI7O1NBQU8sQUFBSyxNQUFDLEFBQWEsY0FBQyxBQUFLLE9BQUUsRUFBRSxBQUFTLFdBQUUsQUFBUyxBQUFFLGFBQUUsQUFBVyxhQUFFLEFBQVcsWUFBQyxBQUFJLEFBQUMsQUFBQyxBQUFDLEFBQzlGLEFBQUM7OztBQUVELEFBQU0sT0FBQyxBQUFPLFVBQUcsQUFBTyxBQUFDLEFBQ3pCOzs7QUN0RUEsQUFBWSxBQUFDOztBQUViLElBQUksQUFBSyxRQUFHLEFBQU8sUUFBQyxBQUFPLEFBQUMsQUFBQztBQUM3QixJQUFJLEFBQVUsYUFBRyxBQUFPLFFBQUMsQUFBWSxBQUFDLEFBQUM7O0FBRXZDLElBQUksQUFBTyxVQUFHLEFBQU8sUUFBQyxBQUFZLEFBQUMsQUFBQzs7QUFFcEMsU0FBUyxBQUFJLEFBQUM7TUFBQyxBQUFLLEFBQUM7O0FBQ25CLGVBQWUsQUFBUyxVQUFDLEFBQUc7O0FBRTFCLFFBQUksQUFBYSxnQkFBRyxBQUFDLEFBQUM7QUFDdEIsMkJBQXlCLEFBQUksS0FBQyxBQUFNLE9BQUMsQUFBRztBQUN0QyxVQUFJLEFBQVMsVUFBQyxBQUFNLE9BQUMsQUFBUSxTQUFDLEFBQUksS0FBQyxBQUFJLEFBQUM7QUFDdEMsQUFBYSx5QkFBSSxBQUFDLEFBQUMsQUFDcEIsRUFGeUM7O0FBRzFDLEFBQU8sYUFBRyxBQUFTLFVBQUMsQUFBUSxBQUFJLEFBQ2pDLEFBQUMsQUFBQyxnQkFMbUQ7S0FBYixBQUFTLENBQTVDLEFBQWdCLENBSGE7QUFTbkMsUUFBTSxBQUFRLFdBQUcsQUFBSSxLQUFDLEFBQUssTUFBQyxBQUFhLGdCQUFHLEFBQWdCLGlCQUFDLEFBQU0sU0FBRyxBQUFHLE1BQUcsQUFBRSxBQUFDLE1BQUcsQUFBRSxBQUFDO0FBQ3JGLFdBQ0Usb0JBQUEsQUFBRyxNQUFBLEVBQUEsQUFBQyxXQUFTLEFBQUMsaUJBQUEsQUFBZSxBQUFDLEtBQUEsQUFBRyxBQUFFLEtBQUksQUFBQyxBQUFJLE1BQzFDLG9CQUFBLEFBQUksT0FBQSxFQUFBLEFBQUMsV0FBUyxBQUFDLEFBQU8sVUFDcEIsb0JBQUEsQUFBRyxNQUFBLEVBQUEsQUFBQyxXQUFTLEFBQUMsQUFBTyxVQUFBLEFBQUMsS0FBSSxBQUFDLEFBQVUsT0FDckMsb0JBQUEsQUFBSSxPQUFBLEVBQUEsQUFBQyxXQUFTLEFBQUMsQUFBWSxlQUFBLEFBQUMsVUFBUSxBQUFDLEFBQU8sTUFDNUMsb0JBQUEsQUFBSSxPQUFBLEVBQUEsQUFBQyxXQUFTLEFBQUMsQUFBTyxVQUFBLEFBQUMsZUFBYSxBQUFDLFFBQUEsQUFBSyxpQkFBZ0IsQUFBQyxBQUFhLFNBQ3hFLG9CQUFDLEFBQU8sU0FBQSxFQUFBLEFBQUMsTUFBSSxBQUFFLEFBQUssQUFBRyxTQUN2QixvQkFBQSxBQUFJLE9BQUEsRUFBQSxBQUFDLFdBQVMsQUFBQyxBQUFZLGVBQUEsc0JBQUEsQUFBbUIsQUFBdUIsQUFDakUsQUFDSCxBQUNMLEFBQ04sQUFBRyxBQUFDLEFBQUM7R0FyQjBCLEFBQUksQ0FBM0IsQUFBTSxDQURTLEFBQ3ZCOztBQXVCRSxTQUNFLG9CQUFBLEFBQUcsTUFBQSxBQUFDLE1BQ0QsQUFBTyxBQUNMLEFBQ0wsQUFDSixBQUFDOzs7QUFFRCxBQUFNLE9BQUMsQUFBTyxVQUFHLEFBQUksQUFBQyxBQUV0QixBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFDQSxBQUNBLEFBQ0EsQUFFRSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZykpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRMaXN0ZW5lclxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXR0ZW1wdGVkIHRvIGxpc3RlbiB0byBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlIG9uIGEgJyArICdicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY2FwdHVyZSBwaGFzZS4gWW91ciBhcHBsaWNhdGlvbiAnICsgJ3dpbGwgbm90IHJlY2VpdmUgc29tZSBldmVudHMuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGVtcHR5RnVuY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24gKCkge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXhlY3V0aW9uRW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbWVsaXplXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2FtZWxpemVTdHlsZU5hbWVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FtZWxpemUgPSByZXF1aXJlKCcuL2NhbWVsaXplJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1vei10cmFuc2l0aW9uJylcbiAqICAgPCBcIk1velRyYW5zaXRpb25cIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbXMtdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJtc1RyYW5zaXRpb25cIlxuICpcbiAqIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAqIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gY2FtZWxpemUoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplU3R5bGVOYW1lOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjb250YWluc05vZGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICpcbiAqIEBwYXJhbSB7P0RPTU5vZGV9IG91dGVyTm9kZSBPdXRlciBET00gbm9kZS5cbiAqIEBwYXJhbSB7P0RPTU5vZGV9IGlubmVyTm9kZSBJbm5lciBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG91dGVyTm9kZWAgY29udGFpbnMgb3IgaXMgYGlubmVyTm9kZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShfeCwgX3gyKSB7XG4gIHZhciBfYWdhaW4gPSB0cnVlO1xuXG4gIF9mdW5jdGlvbjogd2hpbGUgKF9hZ2Fpbikge1xuICAgIHZhciBvdXRlck5vZGUgPSBfeCxcbiAgICAgICAgaW5uZXJOb2RlID0gX3gyO1xuICAgIF9hZ2FpbiA9IGZhbHNlO1xuXG4gICAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICAgIF94ID0gb3V0ZXJOb2RlO1xuICAgICAgX3gyID0gaW5uZXJOb2RlLnBhcmVudE5vZGU7XG4gICAgICBfYWdhaW4gPSB0cnVlO1xuICAgICAgY29udGludWUgX2Z1bmN0aW9uO1xuICAgIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbnRhaW5zKSB7XG4gICAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gICAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlQXJyYXlGcm9tTWl4ZWRcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJy4vdG9BcnJheScpO1xuXG4vKipcbiAqIFBlcmZvcm0gYSBoZXVyaXN0aWMgdGVzdCB0byBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIFwiYXJyYXktbGlrZVwiLlxuICpcbiAqICAgQSBtb25rIGFza2VkIEpvc2h1LCBhIFplbiBtYXN0ZXIsIFwiSGFzIGEgZG9nIEJ1ZGRoYSBuYXR1cmU/XCJcbiAqICAgSm9zaHUgcmVwbGllZDogXCJNdS5cIlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBpdHMgYXJndW1lbnQgaGFzIFwiYXJyYXkgbmF0dXJlXCI6IGl0IHJldHVybnNcbiAqIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFjdHVhbCBhcnJheSwgYW4gYGFyZ3VtZW50cycgb2JqZWN0LCBvciBhblxuICogSFRNTENvbGxlY3Rpb24gKGUuZy4gbm9kZS5jaGlsZE5vZGVzIG9yIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSkuXG4gKlxuICogSXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIG90aGVyIGFycmF5LWxpa2Ugb2JqZWN0cyBsaWtlIEZpbGVsaXN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNBcnJheU5hdHVyZShvYmopIHtcbiAgcmV0dXJuKFxuICAgIC8vIG5vdCBudWxsL2ZhbHNlXG4gICAgISFvYmogJiYgKFxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXG4gICAgdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicpICYmXG4gICAgLy8gcXVhY2tzIGxpa2UgYW4gYXJyYXlcbiAgICAnbGVuZ3RoJyBpbiBvYmogJiZcbiAgICAvLyBub3Qgd2luZG93XG4gICAgISgnc2V0SW50ZXJ2YWwnIGluIG9iaikgJiZcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXG4gICAgLy8gYSAnc2VsZWN0JyBlbGVtZW50IGhhcyAnbGVuZ3RoJyBhbmQgJ2l0ZW0nIHByb3BlcnRpZXMgb24gSUU4XG4gICAgdHlwZW9mIG9iai5ub2RlVHlwZSAhPSAnbnVtYmVyJyAmJiAoXG4gICAgLy8gYSByZWFsIGFycmF5XG4gICAgQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgLy8gYXJndW1lbnRzXG4gICAgJ2NhbGxlZScgaW4gb2JqIHx8XG4gICAgLy8gSFRNTENvbGxlY3Rpb24vTm9kZUxpc3RcbiAgICAnaXRlbScgaW4gb2JqKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBieSB3cmFwcGluZyBpdCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3QuXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYXJndW1lbnQgaWYgaXQgaXMgYWxyZWFkeSBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgaWRpb21hdGljYWxseTpcbiAqXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG4gKlxuICogICBmdW5jdGlvbiB0YWtlc09uZU9yTW9yZVRoaW5ncyh0aGluZ3MpIHtcbiAqICAgICB0aGluZ3MgPSBjcmVhdGVBcnJheUZyb21NaXhlZCh0aGluZ3MpO1xuICogICAgIC4uLlxuICogICB9XG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyZWF0IGB0aGluZ3MnIGFzIGFuIGFycmF5LCBidXQgYWNjZXB0IHNjYWxhcnMgaW4gdGhlIEFQSS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XG4gKiB1c2UgdG9BcnJheSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWl4ZWQob2JqKSB7XG4gIGlmICghaGFzQXJyYXlOYXR1cmUob2JqKSkge1xuICAgIHJldHVybiBbb2JqXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXBcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBmYi13d3cvdW5zYWZlLWh0bWwqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnLi9jcmVhdGVBcnJheUZyb21NaXhlZCcpO1xudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKCcuL2dldE1hcmt1cFdyYXAnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIER1bW15IGNvbnRhaW5lciB1c2VkIHRvIHJlbmRlciBhbGwgbWFya3VwLlxuICovXG52YXIgZHVtbXlOb2RlID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiBudWxsO1xuXG4vKipcbiAqIFBhdHRlcm4gdXNlZCBieSBgZ2V0Tm9kZU5hbWVgLlxuICovXG52YXIgbm9kZU5hbWVQYXR0ZXJuID0gL15cXHMqPChcXHcrKS87XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGBub2RlTmFtZWAgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gYSBzdHJpbmcgb2YgbWFya3VwLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IE5vZGUgbmFtZSBvZiB0aGUgc3VwcGxpZWQgbWFya3VwLlxuICovXG5mdW5jdGlvbiBnZXROb2RlTmFtZShtYXJrdXApIHtcbiAgdmFyIG5vZGVOYW1lTWF0Y2ggPSBtYXJrdXAubWF0Y2gobm9kZU5hbWVQYXR0ZXJuKTtcbiAgcmV0dXJuIG5vZGVOYW1lTWF0Y2ggJiYgbm9kZU5hbWVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbm9kZXMgcmVuZGVyZWQgZnJvbSB0aGUgc3VwcGxpZWQgbWFya3VwLiBUaGVcbiAqIG9wdGlvbmFsbHkgc3VwcGxpZWQgYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIG9uY2UgZm9yIGVhY2hcbiAqIDxzY3JpcHQ+IGVsZW1lbnQgdGhhdCBpcyByZW5kZXJlZC4gSWYgbm8gYGhhbmRsZVNjcmlwdGAgZnVuY3Rpb24gaXMgc3VwcGxpZWQsXG4gKiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIGFueSA8c2NyaXB0PiBlbGVtZW50cyBhcmUgcmVuZGVyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBBIHN0cmluZyBvZiB2YWxpZCBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBoYW5kbGVTY3JpcHQgSW52b2tlZCBvbmNlIGZvciBlYWNoIHJlbmRlcmVkIDxzY3JpcHQ+LlxuICogQHJldHVybiB7YXJyYXk8RE9NRWxlbWVudHxET01UZXh0Tm9kZT59IEFuIGFycmF5IG9mIHJlbmRlcmVkIG5vZGVzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAobWFya3VwLCBoYW5kbGVTY3JpcHQpIHtcbiAgdmFyIG5vZGUgPSBkdW1teU5vZGU7XG4gICEhIWR1bW15Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgZHVtbXkgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB2YXIgbm9kZU5hbWUgPSBnZXROb2RlTmFtZShtYXJrdXApO1xuXG4gIHZhciB3cmFwID0gbm9kZU5hbWUgJiYgZ2V0TWFya3VwV3JhcChub2RlTmFtZSk7XG4gIGlmICh3cmFwKSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSB3cmFwWzFdICsgbWFya3VwICsgd3JhcFsyXTtcblxuICAgIHZhciB3cmFwRGVwdGggPSB3cmFwWzBdO1xuICAgIHdoaWxlICh3cmFwRGVwdGgtLSkge1xuICAgICAgbm9kZSA9IG5vZGUubGFzdENoaWxkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IG1hcmt1cDtcbiAgfVxuXG4gIHZhciBzY3JpcHRzID0gbm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0Jyk7XG4gIGlmIChzY3JpcHRzLmxlbmd0aCkge1xuICAgICFoYW5kbGVTY3JpcHQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlTm9kZXNGcm9tTWFya3VwKC4uLik6IFVuZXhwZWN0ZWQgPHNjcmlwdD4gZWxlbWVudCByZW5kZXJlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgY3JlYXRlQXJyYXlGcm9tTWl4ZWQoc2NyaXB0cykuZm9yRWFjaChoYW5kbGVTY3JpcHQpO1xuICB9XG5cbiAgdmFyIG5vZGVzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQobm9kZS5jaGlsZE5vZGVzKTtcbiAgd2hpbGUgKG5vZGUubGFzdENoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmxhc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZW1wdHlGdW5jdGlvblxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZW1wdHlPYmplY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZm9jdXNOb2RlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRBY3RpdmVFbGVtZW50XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KCkgLyo/RE9NRWxlbWVudCove1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0TWFya3VwV3JhcFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byBkZXRlY3Qgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeS5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBTb21lIGJyb3dzZXJzIGNhbm5vdCB1c2UgYGlubmVySFRNTGAgdG8gcmVuZGVyIGNlcnRhaW4gZWxlbWVudHMgc3RhbmRhbG9uZSxcbiAqIHNvIHdlIHdyYXAgdGhlbSwgcmVuZGVyIHRoZSB3cmFwcGVkIG5vZGVzLCB0aGVuIGV4dHJhY3QgdGhlIGRlc2lyZWQgbm9kZS5cbiAqXG4gKiBJbiBJRTgsIGNlcnRhaW4gZWxlbWVudHMgY2Fubm90IHJlbmRlciBhbG9uZSwgc28gd3JhcCBhbGwgZWxlbWVudHMgKCcqJykuXG4gKi9cblxudmFyIHNob3VsZFdyYXAgPSB7fTtcblxudmFyIHNlbGVjdFdyYXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJ0cnVlXCI+JywgJzwvc2VsZWN0PiddO1xudmFyIHRhYmxlV3JhcCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xudmFyIHRyV3JhcCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG52YXIgc3ZnV3JhcCA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JywgJzwvc3ZnPiddO1xuXG52YXIgbWFya3VwV3JhcCA9IHtcbiAgJyonOiBbMSwgJz88ZGl2PicsICc8L2Rpdj4nXSxcblxuICAnYXJlYSc6IFsxLCAnPG1hcD4nLCAnPC9tYXA+J10sXG4gICdjb2wnOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgJ2xlZ2VuZCc6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICAncGFyYW0nOiBbMSwgJzxvYmplY3Q+JywgJzwvb2JqZWN0PiddLFxuICAndHInOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcblxuICAnb3B0Z3JvdXAnOiBzZWxlY3RXcmFwLFxuICAnb3B0aW9uJzogc2VsZWN0V3JhcCxcblxuICAnY2FwdGlvbic6IHRhYmxlV3JhcCxcbiAgJ2NvbGdyb3VwJzogdGFibGVXcmFwLFxuICAndGJvZHknOiB0YWJsZVdyYXAsXG4gICd0Zm9vdCc6IHRhYmxlV3JhcCxcbiAgJ3RoZWFkJzogdGFibGVXcmFwLFxuXG4gICd0ZCc6IHRyV3JhcCxcbiAgJ3RoJzogdHJXcmFwXG59O1xuXG4vLyBJbml0aWFsaXplIHRoZSBTVkcgZWxlbWVudHMgc2luY2Ugd2Uga25vdyB0aGV5J2xsIGFsd2F5cyBuZWVkIHRvIGJlIHdyYXBwZWRcbi8vIGNvbnNpc3RlbnRseS4gSWYgdGhleSBhcmUgY3JlYXRlZCBpbnNpZGUgYSA8ZGl2PiB0aGV5IHdpbGwgYmUgaW5pdGlhbGl6ZWQgaW5cbi8vIHRoZSB3cm9uZyBuYW1lc3BhY2UgKGFuZCB3aWxsIG5vdCBkaXNwbGF5KS5cbnZhciBzdmdFbGVtZW50cyA9IFsnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2RlZnMnLCAnZWxsaXBzZScsICdnJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFzaycsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAndGV4dCcsICd0c3BhbiddO1xuc3ZnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobm9kZU5hbWUpIHtcbiAgbWFya3VwV3JhcFtub2RlTmFtZV0gPSBzdmdXcmFwO1xuICBzaG91bGRXcmFwW25vZGVOYW1lXSA9IHRydWU7XG59KTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uIGZvciB0aGUgc3VwcGxpZWQgYG5vZGVOYW1lYC5cbiAqXG4gKiBOT1RFOiBUaGlzIGxhemlseSBkZXRlY3RzIHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIExvd2VyY2FzZSBgbm9kZU5hbWVgLlxuICogQHJldHVybiB7P2FycmF5fSBNYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uLCBpZiBhcHBsaWNhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSB7XG4gICEhIWR1bW15Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNYXJrdXAgd3JhcHBpbmcgbm9kZSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmICghbWFya3VwV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBub2RlTmFtZSA9ICcqJztcbiAgfVxuICBpZiAoIXNob3VsZFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnKicpIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPGxpbmsgLz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzwnICsgbm9kZU5hbWUgKyAnPjwvJyArIG5vZGVOYW1lICsgJz4nO1xuICAgIH1cbiAgICBzaG91bGRXcmFwW25vZGVOYW1lXSA9ICFkdW1teU5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gc2hvdWxkV3JhcFtub2RlTmFtZV0gPyBtYXJrdXBXcmFwW25vZGVOYW1lXSA6IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3VwV3JhcDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb25cbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc3VwcGxpZWQgZWxlbWVudCBvciB3aW5kb3cuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZXMgYXJlIHVuYm91bmRlZCwgdW5saWtlIGBnZXRTY3JvbGxQb3NpdGlvbmAuIFRoaXMgbWVhbnMgdGhleVxuICogbWF5IGJlIG5lZ2F0aXZlIG9yIGV4Y2VlZCB0aGUgZWxlbWVudCBib3VuZGFyaWVzICh3aGljaCBpcyBwb3NzaWJsZSB1c2luZ1xuICogaW5lcnRpYWwgc2Nyb2xsaW5nKS5cbiAqXG4gKiBAcGFyYW0ge0RPTVdpbmRvd3xET01FbGVtZW50fSBzY3JvbGxhYmxlXG4gKiBAcmV0dXJuIHtvYmplY3R9IE1hcCB3aXRoIGB4YCBhbmQgYHlgIGtleXMuXG4gKi9cbmZ1bmN0aW9uIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGUpIHtcbiAgaWYgKHNjcm9sbGFibGUgPT09IHdpbmRvdykge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBzY3JvbGxhYmxlLnNjcm9sbExlZnQsXG4gICAgeTogc2Nyb2xsYWJsZS5zY3JvbGxUb3BcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaHlwaGVuYXRlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGh5cGhlbmF0ZVN0eWxlTmFtZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaW52YXJpYW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzTm9kZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNUZXh0Tm9kZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleU1pcnJvclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bWVyYXRpb24gd2l0aCBrZXlzIGVxdWFsIHRvIHRoZWlyIHZhbHVlLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgdmFyIENPTE9SUyA9IGtleU1pcnJvcih7Ymx1ZTogbnVsbCwgcmVkOiBudWxsfSk7XG4gKiAgIHZhciBteUNvbG9yID0gQ09MT1JTLmJsdWU7XG4gKiAgIHZhciBpc0NvbG9yVmFsaWQgPSAhIUNPTE9SU1tteUNvbG9yXTtcbiAqXG4gKiBUaGUgbGFzdCBsaW5lIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgaWYgdGhlIHZhbHVlcyBvZiB0aGUgZ2VuZXJhdGVkIGVudW0gd2VyZVxuICogbm90IGVxdWFsIHRvIHRoZWlyIGtleXMuXG4gKlxuICogICBJbnB1dDogIHtrZXkxOiB2YWwxLCBrZXkyOiB2YWwyfVxuICogICBPdXRwdXQ6IHtrZXkxOiBrZXkxLCBrZXkyOiBrZXkyfVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xudmFyIGtleU1pcnJvciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJldCA9IHt9O1xuICB2YXIga2V5O1xuICAhKG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdrZXlNaXJyb3IoLi4uKTogQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBrZXk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5TWlycm9yOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBrZXlPZlxuICovXG5cbi8qKlxuICogQWxsb3dzIGV4dHJhY3Rpb24gb2YgYSBtaW5pZmllZCBrZXkuIExldCdzIHRoZSBidWlsZCBzeXN0ZW0gbWluaWZ5IGtleXNcbiAqIHdpdGhvdXQgbG9zaW5nIHRoZSBhYmlsaXR5IHRvIGR5bmFtaWNhbGx5IHVzZSBrZXkgc3RyaW5ncyBhcyB2YWx1ZXNcbiAqIHRoZW1zZWx2ZXMuIFBhc3MgaW4gYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUga2V5L3ZhbCBwYWlyIGFuZCBpdCB3aWxsIHJldHVyblxuICogeW91IHRoZSBzdHJpbmcga2V5IG9mIHRoYXQgc2luZ2xlIHJlY29yZC4gU3VwcG9zZSB5b3Ugd2FudCB0byBncmFiIHRoZVxuICogdmFsdWUgZm9yIGEga2V5ICdjbGFzc05hbWUnIGluc2lkZSBvZiBhbiBvYmplY3QuIEtleS92YWwgbWluaWZpY2F0aW9uIG1heVxuICogaGF2ZSBhbGlhc2VkIHRoYXQga2V5IHRvIGJlICd4YTEyJy4ga2V5T2Yoe2NsYXNzTmFtZTogbnVsbH0pIHdpbGwgcmV0dXJuXG4gKiAneGExMicgaW4gdGhhdCBjYXNlLiBSZXNvbHZlIGtleXMgeW91IHdhbnQgdG8gdXNlIG9uY2UgYXQgc3RhcnR1cCB0aW1lLCB0aGVuXG4gKiByZXVzZSB0aG9zZSByZXNvbHV0aW9ucy5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBrZXlPZiA9IGZ1bmN0aW9uIChvbmVLZXlPYmopIHtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gb25lS2V5T2JqKSB7XG4gICAgaWYgKCFvbmVLZXlPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU9mOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtYXBPYmplY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHByb3ZpZGVkIGBjYWxsYmFja2Agb25jZSBmb3IgZWFjaCBlbnVtZXJhYmxlIG93biBwcm9wZXJ0eSBpbiB0aGVcbiAqIG9iamVjdCBhbmQgY29uc3RydWN0cyBhIG5ldyBvYmplY3QgZnJvbSB0aGUgcmVzdWx0cy4gVGhlIGBjYWxsYmFja2AgaXNcbiAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKlxuICogIC0gdGhlIHByb3BlcnR5IHZhbHVlXG4gKiAgLSB0aGUgcHJvcGVydHkgbmFtZVxuICogIC0gdGhlIG9iamVjdCBiZWluZyB0cmF2ZXJzZWRcbiAqXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYXJlIGFkZGVkIGFmdGVyIHRoZSBjYWxsIHRvIGBtYXBPYmplY3RgIHdpbGwgbm90IGJlIHZpc2l0ZWRcbiAqIGJ5IGBjYWxsYmFja2AuIElmIHRoZSB2YWx1ZXMgb2YgZXhpc3RpbmcgcHJvcGVydGllcyBhcmUgY2hhbmdlZCwgdGhlIHZhbHVlXG4gKiBwYXNzZWQgdG8gYGNhbGxiYWNrYCB3aWxsIGJlIHRoZSB2YWx1ZSBhdCB0aGUgdGltZSBgbWFwT2JqZWN0YCB2aXNpdHMgdGhlbS5cbiAqIFByb3BlcnRpZXMgdGhhdCBhcmUgZGVsZXRlZCBiZWZvcmUgYmVpbmcgdmlzaXRlZCBhcmUgbm90IHZpc2l0ZWQuXG4gKlxuICogQGdyZXAgZnVuY3Rpb24gb2JqZWN0TWFwKClcbiAqIEBncmVwIGZ1bmN0aW9uIG9iak1hcCgpXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1hcE9iamVjdChvYmplY3QsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbmFtZSkpIHtcbiAgICAgIHJlc3VsdFtuYW1lXSA9IGNhbGxiYWNrLmNhbGwoY29udGV4dCwgb2JqZWN0W25hbWVdLCBuYW1lLCBvYmplY3QpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcE9iamVjdDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbWVtb2l6ZVN0cmluZ09ubHlcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1lbW9pemVzIHRoZSByZXR1cm4gdmFsdWUgb2YgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgb25lIHN0cmluZyBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVTdHJpbmdPbmx5KGNhbGxiYWNrKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIGlmICghY2FjaGUuaGFzT3duUHJvcGVydHkoc3RyaW5nKSkge1xuICAgICAgY2FjaGVbc3RyaW5nXSA9IGNhbGxiYWNrLmNhbGwodGhpcywgc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW3N0cmluZ107XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZVN0cmluZ09ubHk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHBlcmZvcm1hbmNlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgcGVyZm9ybWFuY2U7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwgd2luZG93Lm1zUGVyZm9ybWFuY2UgfHwgd2luZG93LndlYmtpdFBlcmZvcm1hbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlIHx8IHt9OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBwZXJmb3JtYW5jZU5vd1xuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwZXJmb3JtYW5jZSA9IHJlcXVpcmUoJy4vcGVyZm9ybWFuY2UnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93O1xuXG4vKipcbiAqIERldGVjdCBpZiB3ZSBjYW4gdXNlIGB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClgIGFuZCBncmFjZWZ1bGx5IGZhbGxiYWNrIHRvXG4gKiBgRGF0ZS5ub3coKWAgaWYgaXQgZG9lc24ndCBleGlzdC4gV2UgbmVlZCB0byBzdXBwb3J0IEZpcmVmb3ggPCAxNSBmb3Igbm93XG4gKiBiZWNhdXNlIG9mIEZhY2Vib29rJ3MgdGVzdGluZyBpbmZyYXN0cnVjdHVyZS5cbiAqL1xuaWYgKHBlcmZvcm1hbmNlLm5vdykge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZU5vdzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2hhbGxvd0VxdWFsXG4gKiBAdHlwZWNoZWNrc1xuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChvYmpBID09PSBvYmpCKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgdmFyIGJIYXNPd25Qcm9wZXJ0eSA9IGhhc093blByb3BlcnR5LmJpbmQob2JqQik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWJIYXNPd25Qcm9wZXJ0eShrZXlzQVtpXSkgfHwgb2JqQVtrZXlzQVtpXV0gIT09IG9iakJba2V5c0FbaV1dKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB0b0FycmF5XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQ29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gYXJyYXlzLlxuICpcbiAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGNhbGxlciBrbm93cyB0aGUgY29udGVudHMgb2YgdGhlIGRhdGEgdHlwZS4gRm9yIGxlc3NcbiAqIHdlbGwgZGVmaW5lZCBpbnB1dHMgdXNlIGNyZWF0ZUFycmF5RnJvbU1peGVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufGZpbGVsaXN0fSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcblxuICAvLyBTb21lIGJyb3dzZSBidWlsdGluIG9iamVjdHMgY2FuIHJlcG9ydCB0eXBlb2YgJ2Z1bmN0aW9uJyAoZS5nLiBOb2RlTGlzdCBpblxuICAvLyBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpKS5cbiAgISghQXJyYXkuaXNBcnJheShvYmopICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogQXJyYXktbGlrZSBvYmplY3QgZXhwZWN0ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgISh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IG5lZWRzIGEgbGVuZ3RoIHByb3BlcnR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICEobGVuZ3RoID09PSAwIHx8IGxlbmd0aCAtIDEgaW4gb2JqKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3Qgc2hvdWxkIGhhdmUga2V5cyBmb3IgaW5kaWNlcycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAvLyBPbGQgSUUgZG9lc24ndCBnaXZlIGNvbGxlY3Rpb25zIGFjY2VzcyB0byBoYXNPd25Qcm9wZXJ0eS4gQXNzdW1lIGlucHV0c1xuICAvLyB3aXRob3V0IG1ldGhvZCB3aWxsIHRocm93IGR1cmluZyB0aGUgc2xpY2UgY2FsbCBhbmQgc2tpcCBzdHJhaWdodCB0byB0aGVcbiAgLy8gZmFsbGJhY2suXG4gIGlmIChvYmouaGFzT3duUHJvcGVydHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUUgPCA5IGRvZXMgbm90IHN1cHBvcnQgQXJyYXkjc2xpY2Ugb24gY29sbGVjdGlvbnMgb2JqZWN0c1xuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIGtleSBieSBrZXkuIFRoaXMgYXNzdW1lcyBhbGwga2V5cyBoYXZlIGEgdmFsdWUsXG4gIC8vIHNvIHdpbGwgbm90IHByZXNlcnZlIHNwYXJzZWx5IHBvcHVsYXRlZCBpbnB1dHMuXG4gIHZhciByZXQgPSBBcnJheShsZW5ndGgpO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuZ3RoOyBpaSsrKSB7XG4gICAgcmV0W2lpXSA9IG9ialtpaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB3YXJuaW5nXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nOyIsIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4xMi4wXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBob29rQ2FsbGJhY2s7XG5cbiAgICBmdW5jdGlvbiB1dGlsc19ob29rc19faG9va3MgKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5ICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93ICAgICAgICA6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoICAgIDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgICAgICBpc28gICAgICAgICAgICAgOiBmYWxzZVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5fcGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRfX2lzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgICAgICBtLl9pc1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IG0uX2lzVmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZF9fY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSB1dGlsc19ob29rc19faG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgaW4gbW9tZW50UHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBkaWZmcyA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XG4gICAgICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgICAgICBpZiAodXRpbHNfaG9va3NfX2hvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcsICcpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24gfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlX3NldF9fc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgICAgICAvLyBudW1iZXIgKyAocG9zc2libHkpIHN0dWZmIGNvbWluZyBmcm9tIF9vcmRpbmFsUGFyc2VMZW5pZW50LlxuICAgICAgICB0aGlzLl9vcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cCh0aGlzLl9vcmRpbmFsUGFyc2Uuc291cmNlICsgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICByZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBkZWZpbmVMb2NhbGUgY3VycmVudGx5IGFsc28gc2V0cyB0aGUgZ2xvYmFsIGxvY2FsZSwgd2VcbiAgICAgICAgICAgICAgICAvLyB3YW50IHRvIHVuZG8gdGhhdCBmb3IgbGF6eSBsb2FkZWQgbG9jYWxlc1xuICAgICAgICAgICAgICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlIChrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlIChuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZScpO1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhsb2NhbGVzW25hbWVdLl9jb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmVhdCBhcyBpZiB0aGVyZSBpcyBubyBiYXNlIGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoJ3BhcmVudExvY2FsZVVuZGVmaW5lZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3NwZWNpZmllZCBwYXJlbnRMb2NhbGUgaXMgbm90IGRlZmluZWQgeWV0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlO1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhsb2NhbGVzW25hbWVdLl9jb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbGUgPSBuZXcgTG9jYWxlKGNvbmZpZyk7XG4gICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZV9sb2NhbGVzX19saXN0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGxvY2FsZXMpO1xuICAgIH1cblxuICAgIHZhciBhbGlhc2VzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0ICh1bml0LCBrZWVwVGltZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdldF9zZXRfX3NldCh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRfc2V0X19nZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0X3NldF9fZ2V0IChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICAgICAgbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0X3NldF9fc2V0IChtb20sIHVuaXQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0ICh1bml0cywgdmFsdWUpIHtcbiAgICAgICAgdmFyIHVuaXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKHVuaXQgaW4gdW5pdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldCh1bml0LCB1bml0c1t1bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZztcblxuICAgIHZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG4gICAgdmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgdmFyIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbiAgICAvLyB0b2tlbjogICAgJ00nXG4gICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuICAgIC8vIG9yZGluYWw6ICAnTW8nXG4gICAgLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRlZCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRva2VuKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLCBpLCBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYXJyYXlbaV0gaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG4gICAgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuICAgIHZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG4gICAgdmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgdmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pO1xuXG5cbiAgICB2YXIgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbiAodG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgfSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMDtcbiAgICB2YXIgTU9OVEggPSAxO1xuICAgIHZhciBEQVRFID0gMjtcbiAgICB2YXIgSE9VUiA9IDM7XG4gICAgdmFyIE1JTlVURSA9IDQ7XG4gICAgdmFyIFNFQ09ORCA9IDU7XG4gICAgdmFyIE1JTExJU0VDT05EID0gNjtcbiAgICB2YXIgV0VFSyA9IDc7XG4gICAgdmFyIFdFRUtEQVkgPSA4O1xuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoICsgMSwgMCkpLmdldFVUQ0RhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMrKStNTU1NPy87XG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzW01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydCAobSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KSA/IHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV0gOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVfdXRjX19jcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRfc2V0X19nZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZU1vbnRoc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb207XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tb250aHNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJykkJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJCcsICdpJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyAobSkge1xuICAgICAgICB2YXIgb3ZlcmZsb3c7XG4gICAgICAgIHZhciBhID0gbS5fYTtcblxuICAgICAgICBpZiAoYSAmJiBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPT09IC0yKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICAgICAgYVtNT05USF0gICAgICAgPCAwIHx8IGFbTU9OVEhdICAgICAgID4gMTEgID8gTU9OVEggOlxuICAgICAgICAgICAgICAgIGFbREFURV0gICAgICAgIDwgMSB8fCBhW0RBVEVdICAgICAgICA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKSA/IERBVEUgOlxuICAgICAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICAgICAgYVtNSU5VVEVdICAgICAgPCAwIHx8IGFbTUlOVVRFXSAgICAgID4gNTkgID8gTUlOVVRFIDpcbiAgICAgICAgICAgICAgICBhW1NFQ09ORF0gICAgICA8IDAgfHwgYVtTRUNPTkRdICAgICAgPiA1OSAgPyBTRUNPTkQgOlxuICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgICAgICAtMTtcblxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dEYXlPZlllYXIgJiYgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/LztcbiAgICB2YXIgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/LztcblxuICAgIHZhciB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vO1xuXG4gICAgdmFyIGlzb0RhdGVzID0gW1xuICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxuICAgICAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXG4gICAgICAgIC8vIFlZWVlNTSBpcyBOT1QgYWxsb3dlZCBieSB0aGUgc3RhbmRhcmRcbiAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgWydHR0dHW1ddV1cnLCAvXFxkezR9V1xcZHsyfS8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZREREJywgL1xcZHs3fS9dXG4gICAgXTtcblxuICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICB2YXIgaXNvVGltZXMgPSBbXG4gICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICAgICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISCcsIC9cXGRcXGQvXVxuICAgIF07XG5cbiAgICB2YXIgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLCBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCB0ekZvcm1hdDtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlLiBUaGlzIGlzICcgK1xuICAgICAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB1cGNvbWluZyBtYWpvciAnICtcbiAgICAgICAgJ3JlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDA3IGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvL2Nhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxMzQ4L2luc3RhbnRpYXRpbmctYS1qYXZhc2NyaXB0LW9iamVjdC1ieS1jYWxsaW5nLXByb3RvdHlwZS1jb25zdHJ1Y3Rvci1hcHBseVxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgICAgICAvL3RoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAgICAgLy90aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICByZXR1cm4geSA8PSA5OTk5ID8gJycgKyB5IDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVknLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ1lZWVlZJywgJ1lZWVlZWSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCBmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG4gICAgZnVuY3Rpb24gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgICAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICAgICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG4gICAgfVxuXG4gICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbiAgICBmdW5jdGlvbiBkZWZhdWx0cyhhLCBiLCBjKSB7XG4gICAgICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKHV0aWxzX2hvb2tzX19ob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cbiAgICAvLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuICAgIC8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhcikge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xuICAgICAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAgICAgLy8gKiBpZiBkYXkgb2YgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgbW9udGggYW5kIHllYXJcbiAgICAgICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAzICYmIGNvbmZpZy5fYVtpXSA9PSBudWxsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBaZXJvIG91dCB3aGF0ZXZlciB3YXMgbm90IGRlZmF1bHRlZCwgaW5jbHVkaW5nIHRpbWVcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgICAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZy5fZCA9IChjb25maWcuX3VzZVVUQyA/IGNyZWF0ZVVUQ0RhdGUgOiBjcmVhdGVEYXRlKS5hcHBseShudWxsLCBpbnB1dCk7XG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICAgICAgaWYgKGNvbmZpZy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihsb2NhbF9fY3JlYXRlTG9jYWwoKSwgZG93LCBkb3kpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgMSk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIElTTyBzdGFuZGFyZFxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRfX2lzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoe251bGxJbnB1dDogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdmFsaWRfX2lzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh1dGlsc19ob29rc19faG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCtpbnB1dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmICh0eXBlb2YobG9jYWxlKSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsX19jcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OCcsXG4gICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgdmFyIG90aGVyID0gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIHJldHVybiB2YWxpZF9fY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgKTtcblxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDgnLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRfX2NyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuICAgIC8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbiAgICAvL1xuICAgIC8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2VcbiAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuICAgIGZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgICAgICB2YXIgcmVzLCBpO1xuICAgICAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMzZlNTsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcbiAgICAgICAgICAgIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgICAgICBxdWFydGVycyAqIDMgK1xuICAgICAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgICAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICAgICAgdGhpcy5fbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0ICh0b2tlbiwgc2VwYXJhdG9yKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgICAgIHZhciBzaWduID0gJysnO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9ICgoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKSB8fCBbXSk7XG4gICAgICAgIHZhciBjaHVuayAgID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdIHx8IFtdO1xuICAgICAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPSAoaXNNb21lbnQoaW5wdXQpIHx8IGlzRGF0ZShpbnB1dCkgPyAraW5wdXQgOiArbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KSkgLSAoK3Jlcyk7XG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgICAgICByZXMuX2Quc2V0VGltZSgrcmVzLl9kICsgZGlmZik7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgICAgIC8vIE9uIEZpcmVmb3guMjQgRGF0ZSNnZXRUaW1lem9uZU9mZnNldCByZXR1cm5zIGEgZmxvYXRpbmcgcG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgICAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgY3JlYXRlX19jcmVhdGVEdXJhdGlvbihpbnB1dCAtIG9mZnNldCwgJ20nKSwgMSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVfdXRjX19jcmVhdGVVVEMoYy5fYSkgOiBsb2NhbF9fY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKFxcLSk/KD86KFxcZCopWy4gXSk/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspXFwuPyhcXGR7M30pP1xcZCopPyQvO1xuXG4gICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgLy8gYW5kIGZ1cnRoZXIgbW9kaWZpZWQgdG8gYWxsb3cgZm9yIHN0cmluZ3MgY29udGFpbmluZyBib3RoIHdlZWsgYW5kIGRheVxuICAgIHZhciBpc29SZWdleCA9IC9eKC0pP1AoPzooWzAtOSwuXSopWSk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilXKT8oPzooWzAtOSwuXSopRCk/KD86VCg/OihbMC05LC5dKilIKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKVMpPyk/JC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBkaWZmUmVzO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQgIDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSBpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgICAgICBkICA6IHRvSW50KG1hdGNoW0RBVEVdKSAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBzICA6IHRvSW50KG1hdGNoW1NFQ09ORF0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zIDogdG9JbnQobWF0Y2hbTUlMTElTRUNPTkRdKSAqIHNpZ25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgbG9jYWxfX2NyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28gKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcblxuICAgICAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXG4gICAgICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNSb3VuZCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUobmFtZSwgJ21vbWVudCgpLicgKyBuYW1lICArICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArIG5hbWUgKyAnKG51bWJlciwgcGVyaW9kKS4nKTtcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUoK21vbS5fZCArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgZ2V0X3NldF9fc2V0KG1vbSwgJ0RhdGUnLCBnZXRfc2V0X19nZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldF9zZXRfX2dldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkX3N1YnRyYWN0X19hZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXIgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGxvY2FsX19jcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmKHNvZCwgJ2RheXMnLCB0cnVlKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XSgpIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgbG9jYWxfX2NyZWF0ZUxvY2FsKG5vdykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgPiArbG9jYWxJbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiArbG9jYWxJbnB1dCA8ICt0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyA8ICtsb2NhbElucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpIDwgK2xvY2FsSW5wdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0FmdGVyKGZyb20sIHVuaXRzKSAmJiB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCksXG4gICAgICAgICAgICBpbnB1dE1zO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzIHx8ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyA9PT0gK2xvY2FsSW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gK2xvY2FsSW5wdXQ7XG4gICAgICAgICAgICByZXR1cm4gKyh0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSArKHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCx1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsXG4gICAgICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgICAgICBkZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkZWx0YSAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnaG91cicgPyBkZWx0YSAvIDM2ZTUgOiAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpO1xuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzLmNsb25lKCkudXRjKCk7XG4gICAgICAgIGlmICgwIDwgbS55ZWFyKCkgJiYgbS55ZWFyKCkgPD0gOTk5OSkge1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdCAoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyB8fCB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBsb2NhbF9fY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGxvY2FsX19jcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBsb2NhbF9fY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cgKHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8obG9jYWxfX2NyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAgICAgLy8gdG8gdXRpbGl6ZSBmYWxsaW5nIHRocm91Z2ggdGhlIGNhc2VzLlxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgdGhpcy5ob3VycygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICB0aGlzLm1pbnV0ZXMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICB0aGlzLnNlY29uZHMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICB0aGlzLm1pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgICAgICBpZiAodW5pdHMgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBxdWFydGVycyBhcmUgYWxzbyBzcGVjaWFsXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9fdHlwZV9fdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiArdGhpcy5fZCAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigrdGhpcyAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQgPyBuZXcgRGF0ZSgrdGhpcykgOiB0aGlzLl9kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICAgICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF92YWxpZF9faXNWYWxpZCAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZF9faXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4gKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdHRycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHV0aWxzX2hvb2tzX19ob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgICAgICBpbnB1dCwgdGhpcy5pc29XZWVrKCksIHRoaXMuaXNvV2Vla2RheSgpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyB0aGlzLm1vbnRoKCkgJSAzKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCd3dycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyBsb2NhbGUuX29yZGluYWxQYXJzZSA6IGxvY2FsZS5fb3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0sIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIG1hdGNoV29yZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgIG1hdGNoV29yZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsIG1hdGNoV29yZCk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV0gOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20uZGF5KCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICAgICAgbW9tID0gbG9jYWxfX2NyZWF0ZUxvY2FsKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkJyAmJiB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB0aGlzLmRheSgpIHx8IDcgOiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IGlucHV0IDogaW5wdXQgLSA3KTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0gKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICAgICAgdmFyIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgLy8gdGhpcyBydWxlLlxuICAgIHZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgIH0pO1xuXG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbjtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIG1vbWVudFByb3RvdHlwZV9fcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZF9zdWJ0cmFjdF9fYWRkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgICAgICAgPSBtb21lbnRfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRpZmYgICAgICAgICAgICAgID0gZGlmZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmVuZE9mICAgICAgICAgICAgID0gZW5kT2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb20gICAgICAgICAgICAgID0gZnJvbTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb21Ob3cgICAgICAgICAgID0gZnJvbU5vdztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b05vdyAgICAgICAgICAgICA9IHRvTm93O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgICAgICAgPSBnZXRTZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQWZ0ZXIgICAgICAgICAgID0gaXNBZnRlcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzQmVmb3JlICAgICAgICAgID0gaXNCZWZvcmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzU2FtZSAgICAgICAgICAgID0gaXNTYW1lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lT3JBZnRlciAgICAgPSBpc1NhbWVPckFmdGVyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVmFsaWQgICAgICAgICAgID0gbW9tZW50X3ZhbGlkX19pc1ZhbGlkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubGFuZyAgICAgICAgICAgICAgPSBsYW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgICAgICA9IGxvY2FsZURhdGE7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5tYXggICAgICAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2luZ0ZsYWdzICAgICAgPSBwYXJzaW5nRmxhZ3M7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgICAgICA9IGdldFNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgICAgID0gYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0RhdGUgICAgICAgICAgICA9IHRvRGF0ZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICAgICAgID0gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICAgICA9IHRvSlNPTjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgICAgICA9IHRvX3R5cGVfX3ZhbHVlT2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcblxuICAgIC8vIFllYXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnllYXIgICAgICAgPSBnZXRTZXRZZWFyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG5cbiAgICAvLyBXZWVrIFllYXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuXG4gICAgLy8gUXVhcnRlclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlciA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuXG4gICAgLy8gTW9udGhcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuXG4gICAgLy8gV2Vla1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2VlayAgICAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuXG4gICAgLy8gRGF5XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheSAgICAgICAgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG5cbiAgICAvLyBIb3VyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5ob3VycyA9IGdldFNldEhvdXI7XG5cbiAgICAvLyBNaW51dGVcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbnV0ZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcblxuICAgIC8vIFNlY29uZFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuXG4gICAgLy8gTWlsbGlzZWNvbmRcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcblxuICAgIC8vIE9mZnNldFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNEU1RTaGlmdGVkICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbiAgICAvLyBUaW1lem9uZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1vbnRocyA9IGRlcHJlY2F0ZSgnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJywgZ2V0U2V0TW9udGgpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhcnMgID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJywgZ2V0U2V0WWVhcik7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTc3OScsIGdldFNldFpvbmUpO1xuXG4gICAgdmFyIG1vbWVudFByb3RvdHlwZSA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG87XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfX2NyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgICAgICBuZXh0RGF5IDogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICAgICAgbGFzdFdlZWsgOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlIDogJ0wnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV07XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICAgICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgICAgIEwgICAgOiAnTU0vREQvWVlZWScsXG4gICAgICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTCA6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc2xpY2UoMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQgKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmUgOiAnaW4gJXMnLFxuICAgICAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICAgICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIG0gIDogJ2EgbWludXRlJyxcbiAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgICAgIGggIDogJ2FuIGhvdXInLFxuICAgICAgICBoaCA6ICclZCBob3VycycsXG4gICAgICAgIGQgIDogJ2EgZGF5JyxcbiAgICAgICAgZGQgOiAnJWQgZGF5cycsXG4gICAgICAgIE0gIDogJ2EgbW9udGgnLFxuICAgICAgICBNTSA6ICclZCBtb250aHMnLFxuICAgICAgICB5ICA6ICdhIHllYXInLFxuICAgICAgICB5eSA6ICclZCB5ZWFycydcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVfX3JlbGF0aXZlVGltZSAobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlX19wcm90byA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90b3R5cGVfX3Byb3RvLl9jYWxlbmRhciAgICAgICA9IGRlZmF1bHRDYWxlbmRhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmNhbGVuZGFyICAgICAgICA9IGxvY2FsZV9jYWxlbmRhcl9fY2FsZW5kYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5fbG9uZ0RhdGVGb3JtYXQgPSBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5sb25nRGF0ZUZvcm1hdCAgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9pbnZhbGlkRGF0ZSAgICA9IGRlZmF1bHRJbnZhbGlkRGF0ZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmludmFsaWREYXRlICAgICA9IGludmFsaWREYXRlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX29yZGluYWwgICAgICAgID0gZGVmYXVsdE9yZGluYWw7XG4gICAgcHJvdG90eXBlX19wcm90by5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX29yZGluYWxQYXJzZSAgID0gZGVmYXVsdE9yZGluYWxQYXJzZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnByZXBhcnNlICAgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBvc3Rmb3JtYXQgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9yZWxhdGl2ZVRpbWUgICA9IGRlZmF1bHRSZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG90eXBlX19wcm90by5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZV9fcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICAgICA9IGxvY2FsZV9zZXRfX3NldDtcblxuICAgIC8vIE1vbnRoXG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG4gICAgcHJvdG90eXBlX19wcm90by5fbW9udGhzICAgICAgICAgICA9IGRlZmF1bHRMb2NhbGVNb250aHM7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHNTaG9ydCAgICAgID0gZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzUGFyc2UgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XG4gICAgcHJvdG90eXBlX19wcm90by5fbW9udGhzUmVnZXggICAgICA9IGRlZmF1bHRNb250aHNSZWdleDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG90eXBlX19wcm90by5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzU2hvcnRSZWdleCAgPSBtb250aHNTaG9ydFJlZ2V4O1xuXG4gICAgLy8gV2Vla1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgcHJvdG90eXBlX19wcm90by5fd2VlayA9IGRlZmF1bHRMb2NhbGVXZWVrO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICAvLyBEYXkgb2YgV2Vla1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXMgICAgICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXMgICAgICA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5cztcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzTWluICAgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX3dlZWtkYXlzU2hvcnQgPSBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICAvLyBIb3Vyc1xuICAgIHByb3RvdHlwZV9fcHJvdG8uaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG90eXBlX19wcm90by5fbWVyaWRpZW1QYXJzZSA9IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGxpc3RzX19nZXQgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUoKTtcbiAgICAgICAgdmFyIHV0YyA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3QgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBjb3VudCwgc2V0dGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0c19fZ2V0KGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGxpc3RzX19nZXQoZm9ybWF0LCBpLCBmaWVsZCwgc2V0dGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICdtb250aHMnLCAxMiwgJ21vbnRoJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnLCAxMiwgJ21vbnRoJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5cyAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnLCA3LCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0JywgNywgJ2RheScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RzX19saXN0V2Vla2RheXNNaW4gKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJywgNywgJ2RheScpO1xuICAgIH1cblxuICAgIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGUpO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsIGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGUpO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2Fic19fYWJzICgpIHtcbiAgICAgICAgdmFyIGRhdGEgICAgICAgICAgID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyAgICAgICA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICAgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICAgICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGQgKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1YmJsZSAoKSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gdGhpcy5fbW9udGhzO1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcbiAgICAgICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgICAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICAgICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKSkpIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzICAgICAgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICBob3VycyAgICAgICAgICAgICA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgICAgICAgID0gaG91cnMgJSAyNDtcblxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgZGF0YS5kYXlzICAgPSBkYXlzO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgZGF0YS55ZWFycyAgPSB5ZWFycztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMgKGRheXMpIHtcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICAgICAgcmV0dXJuIGRheXMgKiA0ODAwIC8gMTQ2MDk3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgICAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcyAodW5pdHMpIHtcbiAgICAgICAgdmFyIGRheXM7XG4gICAgICAgIHZhciBtb250aHM7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIGRheXMgICA9IHRoaXMuX2RheXMgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2FzX192YWx1ZU9mICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbiAgICB2YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbiAgICB2YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbiAgICB2YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbiAgICB2YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbiAgICB2YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbiAgICB2YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbiAgICB2YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2dldF9fZ2V0ICh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHMgKyAncyddKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG4gICAgdmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbiAgICB2YXIgbWludXRlcyAgICAgID0gbWFrZUdldHRlcignbWludXRlcycpO1xuICAgIHZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IG1ha2VHZXR0ZXIoJ21vbnRocycpO1xuICAgIHZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciB0aHJlc2hvbGRzID0ge1xuICAgICAgICBzOiA0NSwgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgIG06IDQ1LCAgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgIGg6IDIyLCAgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgIGQ6IDI2LCAgLy8gZGF5cyB0byBtb250aFxuICAgICAgICBNOiAxMSAgIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICAgICAgdmFyIHNlY29uZHMgID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSk7XG4gICAgICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgICAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICAgICAgdmFyIGRheXMgICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSk7XG4gICAgICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgICAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgICAgICB2YXIgYSA9IHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAmJiBbJ20nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPD0gMSAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAmJiBbJ2hoJywgaG91cnNdICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAmJiBbJ00nXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgICAgIHllYXJzICAgPD0gMSAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZHVyYXRpb25faHVtYW5pemVfX2dldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gZHVyYXRpb25faHVtYW5pemVfX3JlbGF0aXZlVGltZSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgaXNvX3N0cmluZ19fYWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBpc29fc3RyaW5nX190b0lTT1N0cmluZygpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIHZhciBzZWNvbmRzID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgICAgICB2YXIgZGF5cyAgICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB2YXIgbW9udGhzICAgICAgID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuX21vbnRocyk7XG4gICAgICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICB2YXIgWSA9IHllYXJzO1xuICAgICAgICB2YXIgTSA9IG1vbnRocztcbiAgICAgICAgdmFyIEQgPSBkYXlzO1xuICAgICAgICB2YXIgaCA9IGhvdXJzO1xuICAgICAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgICAgIHZhciBzID0gc2Vjb25kcztcbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHRvdGFsIDwgMCA/ICctJyA6ICcnKSArXG4gICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgKFkgPyBZICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChNID8gTSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoRCA/IEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGggPyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtID8gbSArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAocyA/IHMgKyAnUycgOiAnJyk7XG4gICAgfVxuXG4gICAgdmFyIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFicyAgICAgICAgICAgID0gZHVyYXRpb25fYWJzX19hYnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hZGQgICAgICAgICAgICA9IGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc3VidHJhY3QgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXMgICAgICAgICAgICAgPSBhcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udmFsdWVPZiAgICAgICAgPSBkdXJhdGlvbl9hc19fdmFsdWVPZjtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLl9idWJibGUgICAgICAgID0gYnViYmxlO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uZ2V0ICAgICAgICAgICAgPSBkdXJhdGlvbl9nZXRfX2dldDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nKTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnZlcnNpb24gPSAnMi4xMi4wJztcblxuICAgIHNldEhvb2tDYWxsYmFjayhsb2NhbF9fY3JlYXRlTG9jYWwpO1xuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm5vdyAgICAgICAgICAgICAgICAgICA9IG5vdztcbiAgICB1dGlsc19ob29rc19faG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBtb21lbnRfX2NyZWF0ZVVuaXg7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RzX19saXN0TW9udGhzO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IHZhbGlkX19jcmVhdGVJbnZhbGlkO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbiAgICB1dGlsc19ob29rc19faG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdHNfX2xpc3RXZWVrZGF5cztcbiAgICB1dGlsc19ob29rc19faG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gbW9tZW50X19jcmVhdGVJblpvbmU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGxvY2FsZV9sb2NhbGVzX19nZXRMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RzX19saXN0TW9udGhzU2hvcnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNNaW47XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbiAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlTG9jYWxlICAgICAgICAgID0gdXBkYXRlTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fbGlzdExvY2FsZXM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZTtcblxuICAgIHZhciBfbW9tZW50ID0gdXRpbHNfaG9va3NfX2hvb2tzO1xuXG4gICAgcmV0dXJuIF9tb21lbnQ7XG5cbn0pKTsiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RET00nKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBBdXRvRm9jdXNVdGlsc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoJy4vZmluZERPTU5vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcblxudmFyIE1peGluID0ge1xuICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnByb3BzLmF1dG9Gb2N1cykge1xuICAgICAgZm9jdXNOb2RlKGZpbmRET01Ob2RlKHRoaXMpKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBBdXRvRm9jdXNVdGlscyA9IHtcbiAgTWl4aW46IE1peGluLFxuXG4gIGZvY3VzRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZm9jdXNOb2RlKFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0b0ZvY3VzVXRpbHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1IEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSA9IHJlcXVpcmUoJy4vRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlJyk7XG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ29tcG9zaXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0lucHV0RXZlbnQnKTtcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkJlZm9yZUlucHV0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25CZWZvcmVJbnB1dENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wVGV4dElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25FbmQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblVwZGF0ZTogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25VcGRhdGUsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZTpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93biAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gZmFsbGJhY2sgb2JqZWN0LCBpZiBhbnkuXG52YXIgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZTtcbiAgdmFyIGZhbGxiYWNrRGF0YTtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbiAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmdldFBvb2xlZCh0b3BMZXZlbFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dDpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCB8fCBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucmVsZWFzZShjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpLCBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIE1vc3Qgc3R5bGUgcHJvcGVydGllcyBjYW4gYmUgdW5zZXQgYnkgZG9pbmcgLnN0eWxlW3Byb3BdID0gJycgYnV0IElFOFxuICogZG9lc24ndCBsaWtlIGRvaW5nIHRoYXQgd2l0aCBzaG9ydGhhbmQgcHJvcGVydGllcyBzbyBmb3IgdGhlIHByb3BlcnRpZXMgdGhhdFxuICogSUU4IGJyZWFrcyBvbiwgd2hpY2ggYXJlIGxpc3RlZCBoZXJlLCB3ZSBpbnN0ZWFkIHVuc2V0IGVhY2ggb2YgdGhlXG4gKiBpbmRpdmlkdWFsIHByb3BlcnRpZXMuIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM4NS5cbiAqIFRoZSA0LXZhbHVlICdjbG9jaycgcHJvcGVydGllcyBsaWtlIG1hcmdpbiwgcGFkZGluZywgYm9yZGVyLXdpZHRoIHNlZW0gdG9cbiAqIGJlaGF2ZSB3aXRob3V0IGFueSBwcm9ibGVtcy4gQ3VyaW91c2x5LCBsaXN0LXN0eWxlIHdvcmtzIHRvbyB3aXRob3V0IGFueVxuICogc3BlY2lhbCBwcm9kZGluZy5cbiAqL1xudmFyIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyA9IHtcbiAgYmFja2dyb3VuZDoge1xuICAgIGJhY2tncm91bmRBdHRhY2htZW50OiB0cnVlLFxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlLFxuICAgIGJhY2tncm91bmRSZXBlYXQ6IHRydWVcbiAgfSxcbiAgYmFja2dyb3VuZFBvc2l0aW9uOiB7XG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlXG4gIH0sXG4gIGJvcmRlcjoge1xuICAgIGJvcmRlcldpZHRoOiB0cnVlLFxuICAgIGJvcmRlclN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckJvdHRvbToge1xuICAgIGJvcmRlckJvdHRvbVdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbVN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckxlZnQ6IHtcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyTGVmdFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckxlZnRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJSaWdodDoge1xuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJSaWdodENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclRvcDoge1xuICAgIGJvcmRlclRvcFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclRvcFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclRvcENvbG9yOiB0cnVlXG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBmb250U3R5bGU6IHRydWUsXG4gICAgZm9udFZhcmlhbnQ6IHRydWUsXG4gICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICBmb250U2l6ZTogdHJ1ZSxcbiAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgIGZvbnRGYW1pbHk6IHRydWVcbiAgfSxcbiAgb3V0bGluZToge1xuICAgIG91dGxpbmVXaWR0aDogdHJ1ZSxcbiAgICBvdXRsaW5lU3R5bGU6IHRydWUsXG4gICAgb3V0bGluZUNvbG9yOiB0cnVlXG4gIH1cbn07XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHtcbiAgaXNVbml0bGVzc051bWJlcjogaXNVbml0bGVzc051bWJlcixcbiAgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zOiBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENTU1Byb3BlcnR5T3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcblxudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcbnZhciBkYW5nZXJvdXNTdHlsZVZhbHVlID0gcmVxdWlyZSgnLi9kYW5nZXJvdXNTdHlsZVZhbHVlJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgbWVtb2l6ZVN0cmluZ09ubHkgPSByZXF1aXJlKCdmYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gbWVtb2l6ZVN0cmluZ09ubHkoZnVuY3Rpb24gKHN0eWxlTmFtZSkge1xuICByZXR1cm4gaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG59KTtcblxudmFyIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gZmFsc2U7XG52YXIgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ2Nzc0Zsb2F0JztcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdmFyIHRlbXBTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuICB0cnkge1xuICAgIC8vIElFOCB0aHJvd3MgXCJJbnZhbGlkIGFyZ3VtZW50LlwiIGlmIHJlc2V0dGluZyBzaG9ydGhhbmQgc3R5bGUgcHJvcGVydGllcy5cbiAgICB0ZW1wU3R5bGUuZm9udCA9ICcnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgPSB0cnVlO1xuICB9XG4gIC8vIElFOCBvbmx5IHN1cHBvcnRzIGFjY2Vzc2luZyBjc3NGbG9hdCAoc3RhbmRhcmQpIGFzIHN0eWxlRmxvYXRcbiAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jc3NGbG9hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3R5bGVGbG9hdEFjY2Vzc29yID0gJ3N0eWxlRmxvYXQnO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vICdtc1RyYW5zZm9ybScgaXMgY29ycmVjdCwgYnV0IHRoZSBvdGhlciBwcmVmaXhlcyBzaG91bGQgYmUgY2FwaXRhbGl6ZWRcbiAgdmFyIGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiA9IC9eKD86d2Via2l0fG1venxvKVtBLVpdLztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBjYW1lbGl6ZVN0eWxlTmFtZShuYW1lKSkgOiB1bmRlZmluZWQ7XG4gIH07XG5cbiAgdmFyIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdTdHlsZSBwcm9wZXJ0eSB2YWx1ZXMgc2hvdWxkblxcJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gJyArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICB2YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggQ1NTIHByb3BlcnRpZXMuXG4gKi9cbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgYSBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgZm9yIHVzZSBhcyBpbmxpbmUgc3R5bGVzOlxuICAgKlxuICAgKiAgID4gY3JlYXRlTWFya3VwRm9yU3R5bGVzKHt3aWR0aDogJzIwMHB4JywgaGVpZ2h0OiAwfSlcbiAgICogICBcIndpZHRoOjIwMHB4O2hlaWdodDowO1wiXG4gICAqXG4gICAqIFVuZGVmaW5lZCB2YWx1ZXMgYXJlIGlnbm9yZWQgc28gdGhhdCBkZWNsYXJhdGl2ZSBwcm9ncmFtbWluZyBpcyBlYXNpZXIuXG4gICAqIFRoZSByZXN1bHQgc2hvdWxkIGJlIEhUTUwtZXNjYXBlZCBiZWZvcmUgaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yU3R5bGVzOiBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKSArICc7JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICAgKiAnJyAoZW1wdHkgc3RyaW5nKSwgdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGUgcHJvcGVydHkgd2lsbCBiZSB1bnNldC5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICovXG4gIHNldFZhbHVlRm9yU3R5bGVzOiBmdW5jdGlvbiAobm9kZSwgc3R5bGVzKSB7XG4gICAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSk7XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSk7XG4gICAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlRmxvYXRBY2Nlc3NvcjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZVZhbHVlKSB7XG4gICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSBzdHlsZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnICYmIENTU1Byb3BlcnR5LnNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9uc1tzdHlsZU5hbWVdO1xuICAgICAgICBpZiAoZXhwYW5zaW9uKSB7XG4gICAgICAgICAgLy8gU2hvcnRoYW5kIHByb3BlcnR5IHRoYXQgSUU4IHdvbid0IGxpa2UgdW5zZXR0aW5nLCBzbyB1bnNldCBlYWNoXG4gICAgICAgICAgLy8gY29tcG9uZW50IHRvIHBsYWNhdGUgaXRcbiAgICAgICAgICBmb3IgKHZhciBpbmRpdmlkdWFsU3R5bGVOYW1lIGluIGV4cGFuc2lvbikge1xuICAgICAgICAgICAgc3R5bGVbaW5kaXZpZHVhbFN0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhDU1NQcm9wZXJ0eU9wZXJhdGlvbnMsICdDU1NQcm9wZXJ0eU9wZXJhdGlvbnMnLCB7XG4gIHNldFZhbHVlRm9yU3R5bGVzOiAnc2V0VmFsdWVGb3JTdHlsZXMnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENhbGxiYWNrUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgcHNldWRvLWV2ZW50IG1vZHVsZSB0byBoZWxwIGtlZXAgdHJhY2sgb2YgY29tcG9uZW50cyB3YWl0aW5nIHRvXG4gKiBiZSBub3RpZmllZCB3aGVuIHRoZWlyIERPTSByZXByZXNlbnRhdGlvbnMgYXJlIGF2YWlsYWJsZSBmb3IgdXNlLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50cyBgUG9vbGVkQ2xhc3NgLCBzbyB5b3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEluc3RlYWQsIHVzZSBgQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKWAuXG4gKlxuICogQGNsYXNzIFJlYWN0TW91bnRSZWFkeVxuICogQGltcGxlbWVudHMgUG9vbGVkQ2xhc3NcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBDYWxsYmFja1F1ZXVlKCkge1xuICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG59XG5cbmFzc2lnbihDYWxsYmFja1F1ZXVlLnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IENvbnRleHQgdG8gY2FsbCBgY2FsbGJhY2tgIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZTogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IFtdO1xuICAgIHRoaXMuX2NvbnRleHRzID0gdGhpcy5fY29udGV4dHMgfHwgW107XG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludm9rZXMgYWxsIGVucXVldWVkIGNhbGxiYWNrcyBhbmQgY2xlYXJzIHRoZSBxdWV1ZS4gVGhpcyBpcyBpbnZva2VkIGFmdGVyXG4gICAqIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgYSBjb21wb25lbnQgaGFzIGJlZW4gY3JlYXRlZCBvciB1cGRhdGVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG5vdGlmeUFsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gICAgdmFyIGNvbnRleHRzID0gdGhpcy5fY29udGV4dHM7XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgIShjYWxsYmFja3MubGVuZ3RoID09PSBjb250ZXh0cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc21hdGNoZWQgbGlzdCBvZiBjb250ZXh0cyBpbiBjYWxsYmFjayBxdWV1ZScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0uY2FsbChjb250ZXh0c1tpXSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICAgIGNvbnRleHRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIGludGVybmFsIHF1ZXVlLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0cyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIHRoaXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oQ2FsbGJhY2tRdWV1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FsbGJhY2tRdWV1ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2hhbmdlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2hhbmdlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DaGFuZ2VDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ2hhbmdlLCB0b3BMZXZlbFR5cGVzLnRvcENsaWNrLCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG52YXIgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIFNlZSBgaGFuZGxlQ2hhbmdlYCBjb21tZW50IGJlbG93XG4gIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2NoYW5nZScpICYmICghKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA4KTtcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGFjdGl2ZUVsZW1lbnRJRCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldElEKSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IHRhcmdldElEO1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UpIHtcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHNcbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOSk7XG59XG5cbi8qKlxuICogKEZvciBvbGQgSUUuKSBSZXBsYWNlbWVudCBnZXR0ZXIvc2V0dGVyIGZvciB0aGUgYHZhbHVlYCBwcm9wZXJ0eSB0aGF0IGdldHNcbiAqIHNldCBvbiB0aGUgYWN0aXZlIGVsZW1lbnQuXG4gKi9cbnZhciBuZXdWYWx1ZVByb3AgPSB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLmdldC5jYWxsKHRoaXMpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyBDYXN0IHRvIGEgc3RyaW5nIHNvIHdlIGNhbiBkbyBlcXVhbGl0eSBjaGVja3MuXG4gICAgYWN0aXZlRWxlbWVudFZhbHVlID0gJycgKyB2YWw7XG4gICAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5zZXQuY2FsbCh0aGlzLCB2YWwpO1xuICB9XG59O1xuXG4vKipcbiAqIChGb3Igb2xkIElFLikgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SUQpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudElEID0gdGFyZ2V0SUQ7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ3ZhbHVlJyk7XG5cbiAgLy8gTm90IGd1YXJkZWQgaW4gYSBjYW5EZWZpbmVQcm9wZXJ0eSBjaGVjazogSUU4IHN1cHBvcnRzIGRlZmluZVByb3BlcnR5IG9ubHlcbiAgLy8gb24gRE9NIGVsZW1lbnRzXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhY3RpdmVFbGVtZW50LCAndmFsdWUnLCBuZXdWYWx1ZVByb3ApO1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcbn1cblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB2YWx1ZSA9IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQudmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHZhbHVlO1xuXG4gIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xufVxuXG4vKipcbiAqIElmIGEgYGNoYW5nZWAgZXZlbnQgc2hvdWxkIGJlIGZpcmVkLCByZXR1cm5zIHRoZSB0YXJnZXQncyBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCkge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0b3BMZXZlbFRhcmdldElEO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBJbiBJRTgsIHdlIGNhbiBjYXB0dXJlIGFsbW9zdCBhbGwgLnZhbHVlIGNoYW5nZXMgYnkgYWRkaW5nIGFcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBoYW5kbGVyIGFuZCBsb29raW5nIGZvciBldmVudHMgd2l0aCBwcm9wZXJ0eU5hbWVcbiAgICAvLyBlcXVhbCB0byAndmFsdWUnXG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2UgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSAhPT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRJRDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2xpY2spIHtcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG5cbiAgICB2YXIgZ2V0VGFyZ2V0SURGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgaWYgKGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSkge1xuICAgICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodG9wTGV2ZWxUYXJnZXQpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9ySW5wdXRFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9ySW5wdXRFdmVudElFO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJREZ1bmMpIHtcbiAgICAgIHZhciB0YXJnZXRJRCA9IGdldFRhcmdldElERnVuYyh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKTtcbiAgICAgIGlmICh0YXJnZXRJRCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIHRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gICAgICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhbmdlRXZlbnRQbHVnaW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIENsaWVudFJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG5leHRSZWFjdFJvb3RJbmRleCA9IDA7XG5cbnZhciBDbGllbnRSZWFjdFJvb3RJbmRleCA9IHtcbiAgY3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV4dFJlYWN0Um9vdEluZGV4Kys7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpZW50UmVhY3RSb290SW5kZXg7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTUNoaWxkcmVuT3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEYW5nZXIgPSByZXF1aXJlKCcuL0RhbmdlcicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcycpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEluc2VydHMgYGNoaWxkTm9kZWAgYXMgYSBjaGlsZCBvZiBgcGFyZW50Tm9kZWAgYXQgdGhlIGBpbmRleGAuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBwYXJlbnROb2RlIFBhcmVudCBub2RlIGluIHdoaWNoIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY2hpbGROb2RlIENoaWxkIG5vZGUgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIGluZGV4KSB7XG4gIC8vIEJ5IGV4cGxvaXRpbmcgYXJyYXlzIHJldHVybmluZyBgdW5kZWZpbmVkYCBmb3IgYW4gdW5kZWZpbmVkIGluZGV4LCB3ZSBjYW5cbiAgLy8gcmVseSBleGNsdXNpdmVseSBvbiBgaW5zZXJ0QmVmb3JlKG5vZGUsIG51bGwpYCBpbnN0ZWFkIG9mIGFsc28gdXNpbmdcbiAgLy8gYGFwcGVuZENoaWxkKG5vZGUpYC4gSG93ZXZlciwgdXNpbmcgYHVuZGVmaW5lZGAgaXMgbm90IGFsbG93ZWQgYnkgYWxsXG4gIC8vIGJyb3dzZXJzIHNvIHdlIG11c3QgcmVwbGFjZSBpdCB3aXRoIGBudWxsYC5cblxuICAvLyBmaXggcmVuZGVyIG9yZGVyIGVycm9yIGluIHNhZmFyaVxuICAvLyBJRTggd2lsbCB0aHJvdyBlcnJvciB3aGVuIGluZGV4IG91dCBvZiBsaXN0IHNpemUuXG4gIHZhciBiZWZvcmVDaGlsZCA9IGluZGV4ID49IHBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBudWxsIDogcGFyZW50Tm9kZS5jaGlsZE5vZGVzLml0ZW0oaW5kZXgpO1xuXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgYmVmb3JlQ2hpbGQpO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIHVwZGF0aW5nIHdpdGggRE9NIGNoaWxkcmVuLlxuICovXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0ge1xuXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAsXG5cbiAgdXBkYXRlVGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLiBUaGVcbiAgICogdXBkYXRlIGNvbmZpZ3VyYXRpb25zIGFyZSBlYWNoIGV4cGVjdGVkIHRvIGhhdmUgYSBgcGFyZW50Tm9kZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXBMaXN0IExpc3Qgb2YgbWFya3VwIHN0cmluZ3MuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc1VwZGF0ZXM6IGZ1bmN0aW9uICh1cGRhdGVzLCBtYXJrdXBMaXN0KSB7XG4gICAgdmFyIHVwZGF0ZTtcbiAgICAvLyBNYXBwaW5nIGZyb20gcGFyZW50IElEcyB0byBpbml0aWFsIGNoaWxkIG9yZGVyaW5ncy5cbiAgICB2YXIgaW5pdGlhbENoaWxkcmVuID0gbnVsbDtcbiAgICAvLyBMaXN0IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBiZSBtb3ZlZCBvciByZW1vdmVkLlxuICAgIHZhciB1cGRhdGVkQ2hpbGRyZW4gPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2ldO1xuICAgICAgaWYgKHVwZGF0ZS50eXBlID09PSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HIHx8IHVwZGF0ZS50eXBlID09PSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERSkge1xuICAgICAgICB2YXIgdXBkYXRlZEluZGV4ID0gdXBkYXRlLmZyb21JbmRleDtcbiAgICAgICAgdmFyIHVwZGF0ZWRDaGlsZCA9IHVwZGF0ZS5wYXJlbnROb2RlLmNoaWxkTm9kZXNbdXBkYXRlZEluZGV4XTtcbiAgICAgICAgdmFyIHBhcmVudElEID0gdXBkYXRlLnBhcmVudElEO1xuXG4gICAgICAgICF1cGRhdGVkQ2hpbGQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc1VwZGF0ZXMoKTogVW5hYmxlIHRvIGZpbmQgY2hpbGQgJXMgb2YgZWxlbWVudC4gVGhpcyAnICsgJ3Byb2JhYmx5IG1lYW5zIHRoZSBET00gd2FzIHVuZXhwZWN0ZWRseSBtdXRhdGVkIChlLmcuLCBieSB0aGUgJyArICdicm93c2VyKSwgdXN1YWxseSBkdWUgdG8gZm9yZ2V0dGluZyBhIDx0Ym9keT4gd2hlbiB1c2luZyB0YWJsZXMsICcgKyAnbmVzdGluZyB0YWdzIGxpa2UgPGZvcm0+LCA8cD4sIG9yIDxhPiwgb3IgdXNpbmcgbm9uLVNWRyBlbGVtZW50cyAnICsgJ2luIGFuIDxzdmc+IHBhcmVudC4gVHJ5IGluc3BlY3RpbmcgdGhlIGNoaWxkIG5vZGVzIG9mIHRoZSBlbGVtZW50ICcgKyAnd2l0aCBSZWFjdCBJRCBgJXNgLicsIHVwZGF0ZWRJbmRleCwgcGFyZW50SUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpbml0aWFsQ2hpbGRyZW4gPSBpbml0aWFsQ2hpbGRyZW4gfHwge307XG4gICAgICAgIGluaXRpYWxDaGlsZHJlbltwYXJlbnRJRF0gPSBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdIHx8IFtdO1xuICAgICAgICBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdW3VwZGF0ZWRJbmRleF0gPSB1cGRhdGVkQ2hpbGQ7XG5cbiAgICAgICAgdXBkYXRlZENoaWxkcmVuID0gdXBkYXRlZENoaWxkcmVuIHx8IFtdO1xuICAgICAgICB1cGRhdGVkQ2hpbGRyZW4ucHVzaCh1cGRhdGVkQ2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZW5kZXJlZE1hcmt1cDtcbiAgICAvLyBtYXJrdXBMaXN0IGlzIGVpdGhlciBhIGxpc3Qgb2YgbWFya3VwIG9yIGp1c3QgYSBsaXN0IG9mIGVsZW1lbnRzXG4gICAgaWYgKG1hcmt1cExpc3QubGVuZ3RoICYmIHR5cGVvZiBtYXJrdXBMaXN0WzBdID09PSAnc3RyaW5nJykge1xuICAgICAgcmVuZGVyZWRNYXJrdXAgPSBEYW5nZXIuZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAobWFya3VwTGlzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkTWFya3VwID0gbWFya3VwTGlzdDtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdXBkYXRlZCBjaGlsZHJlbiBmaXJzdCBzbyB0aGF0IGB0b0luZGV4YCBpcyBjb25zaXN0ZW50LlxuICAgIGlmICh1cGRhdGVkQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdXBkYXRlZENoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbltqXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHVwZGF0ZWRDaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCB1cGRhdGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2tdO1xuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVA6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdCh1cGRhdGUucGFyZW50Tm9kZSwgcmVuZGVyZWRNYXJrdXBbdXBkYXRlLm1hcmt1cEluZGV4XSwgdXBkYXRlLnRvSW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkc6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdCh1cGRhdGUucGFyZW50Tm9kZSwgaW5pdGlhbENoaWxkcmVuW3VwZGF0ZS5wYXJlbnRJRF1bdXBkYXRlLmZyb21JbmRleF0sIHVwZGF0ZS50b0luZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5TRVRfTUFSS1VQOlxuICAgICAgICAgIHNldElubmVySFRNTCh1cGRhdGUucGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVDpcbiAgICAgICAgICBzZXRUZXh0Q29udGVudCh1cGRhdGUucGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFOlxuICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZCBieSB0aGUgZm9yLWxvb3AgYWJvdmUuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhET01DaGlsZHJlbk9wZXJhdGlvbnMsICdET01DaGlsZHJlbk9wZXJhdGlvbnMnLCB7XG4gIHVwZGF0ZVRleHRDb250ZW50OiAndXBkYXRlVGV4dENvbnRlbnQnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG5mdW5jdGlvbiBjaGVja01hc2sodmFsdWUsIGJpdG1hc2spIHtcbiAgcmV0dXJuICh2YWx1ZSAmIGJpdG1hc2spID09PSBiaXRtYXNrO1xufVxuXG52YXIgRE9NUHJvcGVydHlJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCwgY2FtZWxjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBhIGNvbmZpZ3VyYXRpb24gdGhhdFxuICAgKiBzcGVjaWZpZXMgaG93IHRoZSBhc3NvY2lhdGVkIERPTSBwcm9wZXJ0eSBzaG91bGQgYmUgYWNjZXNzZWQgb3IgcmVuZGVyZWQuXG4gICAqL1xuICBNVVNUX1VTRV9BVFRSSUJVVEU6IDB4MSxcbiAgTVVTVF9VU0VfUFJPUEVSVFk6IDB4MixcbiAgSEFTX1NJREVfRUZGRUNUUzogMHg0LFxuICBIQVNfQk9PTEVBTl9WQUxVRTogMHg4LFxuICBIQVNfTlVNRVJJQ19WQUxVRTogMHgxMCxcbiAgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6IDB4MjAgfCAweDEwLFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDQwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnICsgJ1xcJyVzXFwnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5ICcgKyAnaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgJyArICdpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IGxvd2VyQ2FzZWQsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZTogbnVsbCxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgbXV0YXRpb25NZXRob2Q6IG51bGwsXG5cbiAgICAgICAgbXVzdFVzZUF0dHJpYnV0ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEUpLFxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNTaWRlRWZmZWN0czogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfU0lERV9FRkZFQ1RTKSxcbiAgICAgICAgaGFzQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuXG4gICAgICAhKCFwcm9wZXJ0eUluZm8ubXVzdFVzZUF0dHJpYnV0ZSB8fCAhcHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IENhbm5vdCByZXF1aXJlIHVzaW5nIGJvdGggYXR0cmlidXRlIGFuZCBwcm9wZXJ0eTogJXMnLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgIShwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5IHx8ICFwcm9wZXJ0eUluZm8uaGFzU2lkZUVmZmVjdHMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBQcm9wZXJ0aWVzIHRoYXQgaGF2ZSBzaWRlIGVmZmVjdHMgbXVzdCB1c2UgcHJvcGVydHk6ICVzJywgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICEocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSArIHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogVmFsdWUgY2FuIGJlIG9uZSBvZiBib29sZWFuLCBvdmVybG9hZGVkIGJvb2xlYW4sIG9yICcgKyAnbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlcycsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWRdID0gcHJvcE5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVthdHRyaWJ1dGVOYW1lXSA9IHByb3BOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01Qcm9wZXJ0eU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lID0gRE9NUHJvcGVydHlOYW1lc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01NdXRhdGlvbk1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZCA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcbnZhciBkZWZhdWx0VmFsdWVDYWNoZSA9IHt9O1xuXG4vKipcbiAqIERPTVByb3BlcnR5IGV4cG9ydHMgbG9va3VwIG9iamVjdHMgdGhhdCBjYW4gYmUgdXNlZCBsaWtlIGZ1bmN0aW9uczpcbiAqXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnaWQnXVxuICogICB0cnVlXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnZm9vYmFyJ11cbiAqICAgdW5kZWZpbmVkXG4gKlxuICogQWx0aG91Z2ggdGhpcyBtYXkgYmUgY29uZnVzaW5nLCBpdCBwZXJmb3JtcyBiZXR0ZXIgaW4gZ2VuZXJhbC5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1leGlzdHNcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LW1pc3NpbmdcbiAqL1xudmFyIERPTVByb3BlcnR5ID0ge1xuXG4gIElEX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdGlkJyxcblxuICAvKipcbiAgICogTWFwIGZyb20gcHJvcGVydHkgXCJzdGFuZGFyZCBuYW1lXCIgdG8gYW4gb2JqZWN0IHdpdGggaW5mbyBhYm91dCBob3cgdG8gc2V0XG4gICAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAgICpcbiAgICogYXR0cmlidXRlTmFtZTpcbiAgICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICAgKiBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgICogcHJvcGVydHlOYW1lOlxuICAgKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICAgKiAgIGV4dGVybmFsIGZhY3RvcnMuKVxuICAgKiBtdXRhdGlvbk1ldGhvZDpcbiAgICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gICAqICAgaW5pdGlhbCByZW5kZXIuXG4gICAqIG11c3RVc2VBdHRyaWJ1dGU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCB1c2luZyBgKkF0dHJpYnV0ZSgpYC5cbiAgICogICAoVGhpcyBpbmNsdWRlcyBhbnl0aGluZyB0aGF0IGZhaWxzIGA8cHJvcE5hbWU+IGluIDxlbGVtZW50PmAuKVxuICAgKiBtdXN0VXNlUHJvcGVydHk6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCBhcyBhbiBvYmplY3QgcHJvcGVydHkuXG4gICAqIGhhc1NpZGVFZmZlY3RzOlxuICAgKiAgIFdoZXRoZXIgb3Igbm90IHNldHRpbmcgYSB2YWx1ZSBjYXVzZXMgc2lkZSBlZmZlY3RzIHN1Y2ggYXMgdHJpZ2dlcmluZ1xuICAgKiAgIHJlc291cmNlcyB0byBiZSBsb2FkZWQgb3IgdGV4dCBzZWxlY3Rpb24gY2hhbmdlcy4gSWYgdHJ1ZSwgd2UgcmVhZCBmcm9tXG4gICAqICAgdGhlIERPTSBiZWZvcmUgdXBkYXRpbmcgdG8gZW5zdXJlIHRoYXQgdGhlIHZhbHVlIGlzIG9ubHkgc2V0IGlmIGl0IGhhc1xuICAgKiAgIGNoYW5nZWQuXG4gICAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICAgKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gICAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICAgKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxuICAgKiAgIHN0cmljdGx5IGVxdWFsIHRvIHRydWU7IHByZXNlbnQgd2l0aCBhIHZhbHVlIG90aGVyd2lzZS5cbiAgICovXG4gIHByb3BlcnRpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLCB1c2VkXG4gICAqIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBwcm9wZXJ0aWVzLiBBdmFpbGFibGUgb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UG9zc2libGVTdGFuZGFyZE5hbWU6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7fSA6IG51bGwsXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUgaXNDdXN0b21BdHRyaWJ1dGUoKSBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gaW5qZWN0ZWQuXG4gICAqL1xuICBfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gYXR0cmlidXRlLlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlzQ3VzdG9tQXR0cmlidXRlRm4gPSBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnNbaV07XG4gICAgICBpZiAoaXNDdXN0b21BdHRyaWJ1dGVGbihhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHByb3BlcnR5IHZhbHVlIGZvciBhIERPTSBwcm9wZXJ0eSAoaS5lLiwgbm90IGFuXG4gICAqIGF0dHJpYnV0ZSkuIE1vc3QgZGVmYXVsdCB2YWx1ZXMgYXJlICcnIG9yIGZhbHNlLCBidXQgbm90IGFsbC4gV29yc2UgeWV0LFxuICAgKiBzb21lIChpbiBwYXJ0aWN1bGFyLCBgdHlwZWApIHZhcnkgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGVsZW1lbnQuXG4gICAqXG4gICAqIFRPRE86IElzIGl0IGJldHRlciB0byBncmFiIGFsbCB0aGUgcG9zc2libGUgcHJvcGVydGllcyB3aGVuIGNyZWF0aW5nIGFuXG4gICAqIGVsZW1lbnQgdG8gYXZvaWQgaGF2aW5nIHRvIGNyZWF0ZSB0aGUgc2FtZSBlbGVtZW50IHR3aWNlP1xuICAgKi9cbiAgZ2V0RGVmYXVsdFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlTmFtZSwgcHJvcCkge1xuICAgIHZhciBub2RlRGVmYXVsdHMgPSBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV07XG4gICAgdmFyIHRlc3RFbGVtZW50O1xuICAgIGlmICghbm9kZURlZmF1bHRzKSB7XG4gICAgICBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV0gPSBub2RlRGVmYXVsdHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCEocHJvcCBpbiBub2RlRGVmYXVsdHMpKSB7XG4gICAgICB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgbm9kZURlZmF1bHRzW3Byb3BdID0gdGVzdEVsZW1lbnRbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiBub2RlRGVmYXVsdHNbcHJvcF07XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBET01Qcm9wZXJ0eUluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRE9NUHJvcGVydHlPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vLyBTaW1wbGlmaWVkIHN1YnNldFxudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gL15bYS16QS1aX11bXFx3XFwuXFwtXSokLztcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcmVhY3RQcm9wcyA9IHtcbiAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgICBrZXk6IHRydWUsXG4gICAgcmVmOiB0cnVlXG4gIH07XG4gIHZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG5cbiAgdmFyIHdhcm5Vbmtub3duUHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHwgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gZGF0YS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb25cbiAgICB2YXIgc3RhbmRhcmROYW1lID0gRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgLy8gRm9yIG5vdywgb25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIHN1Z2dlc3RlZCBjb3JyZWN0aW9uLiBUaGlzIHByZXZlbnRzXG4gICAgLy8gbG9nZ2luZyB0b28gbXVjaCB3aGVuIHVzaW5nIHRyYW5zZmVyUHJvcHNUby5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhzdGFuZGFyZE5hbWUgPT0gbnVsbCwgJ1Vua25vd24gRE9NIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgc3RhbmRhcmROYW1lKSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcihpZCk7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9ySUQ6IGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FLCBpZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgaWYgKHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBjdXN0b20gcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBlbXB0eSBzdHJpbmcgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICAgKi9cbiAgY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZSArICc9JyArIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgc2V0VmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QpIHtcbiAgICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xuICAgICAgICB0aGlzLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlQXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgICAvLyBNdXN0IGV4cGxpY2l0bHkgY2FzdCB2YWx1ZXMgZm9yIEhBU19TSURFX0VGRkVDVFMtcHJvcGVydGllcyB0byB0aGVcbiAgICAgICAgLy8gcHJvcGVydHkgdHlwZSBiZWZvcmUgY29tcGFyaW5nOyBvbmx5IGB2YWx1ZWAgZG9lcyBhbmQgaXMgc3RyaW5nLlxuICAgICAgICBpZiAoIXByb3BlcnR5SW5mby5oYXNTaWRlRWZmZWN0cyB8fCAnJyArIG5vZGVbcHJvcE5hbWVdICE9PSAnJyArIHZhbHVlKSB7XG4gICAgICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5Vbmtub3duUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICB9LFxuXG4gIHNldFZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyArIHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqL1xuICBkZWxldGVWYWx1ZUZvclByb3BlcnR5OiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlQXR0cmlidXRlKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBET01Qcm9wZXJ0eS5nZXREZWZhdWx0VmFsdWVGb3JQcm9wZXJ0eShub2RlLm5vZGVOYW1lLCBwcm9wTmFtZSk7XG4gICAgICAgIGlmICghcHJvcGVydHlJbmZvLmhhc1NpZGVFZmZlY3RzIHx8ICcnICsgbm9kZVtwcm9wTmFtZV0gIT09IGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgIG5vZGVbcHJvcE5hbWVdID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoRE9NUHJvcGVydHlPcGVyYXRpb25zLCAnRE9NUHJvcGVydHlPcGVyYXRpb25zJywge1xuICBzZXRWYWx1ZUZvclByb3BlcnR5OiAnc2V0VmFsdWVGb3JQcm9wZXJ0eScsXG4gIHNldFZhbHVlRm9yQXR0cmlidXRlOiAnc2V0VmFsdWVGb3JBdHRyaWJ1dGUnLFxuICBkZWxldGVWYWx1ZUZvclByb3BlcnR5OiAnZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSdcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTVByb3BlcnR5T3BlcmF0aW9uczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRGFuZ2VyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cCA9IHJlcXVpcmUoJ2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCcpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldE1hcmt1cFdyYXAnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIE9QRU5fVEFHX05BTUVfRVhQID0gL14oPFteIFxcLz5dKykvO1xudmFyIFJFU1VMVF9JTkRFWF9BVFRSID0gJ2RhdGEtZGFuZ2VyLWluZGV4JztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBmcm9tIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAqXG4gKiBOT1RFOiBFeHRyYWN0aW5nIHRoZSBgbm9kZU5hbWVgIGRvZXMgbm90IHJlcXVpcmUgYSByZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2hcbiAqIGJlY2F1c2Ugd2UgbWFrZSBhc3N1bXB0aW9ucyBhYm91dCBSZWFjdC1nZW5lcmF0ZWQgbWFya3VwIChpLmUuIHRoZXJlIGFyZSBub1xuICogc3BhY2VzIHN1cnJvdW5kaW5nIHRoZSBvcGVuaW5nIHRhZyBhbmQgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGF0dHJpYnV0ZSkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7c3RyaW5nfSBOb2RlIG5hbWUgb2YgdGhlIHN1cHBsaWVkIG1hcmt1cC5cbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vZXh0cmFjdC1ub2RlbmFtZVxuICovXG5mdW5jdGlvbiBnZXROb2RlTmFtZShtYXJrdXApIHtcbiAgcmV0dXJuIG1hcmt1cC5zdWJzdHJpbmcoMSwgbWFya3VwLmluZGV4T2YoJyAnKSk7XG59XG5cbnZhciBEYW5nZXIgPSB7XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgbWFya3VwIGludG8gYW4gYXJyYXkgb2Ygbm9kZXMuIFRoZSBtYXJrdXAgaXMgZXhwZWN0ZWQgdG8gcmVuZGVyXG4gICAqIGludG8gYSBsaXN0IG9mIHJvb3Qgbm9kZXMuIEFsc28sIHRoZSBsZW5ndGggb2YgYHJlc3VsdExpc3RgIGFuZFxuICAgKiBgbWFya3VwTGlzdGAgc2hvdWxkIGJlIHRoZSBzYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PHN0cmluZz59IG1hcmt1cExpc3QgTGlzdCBvZiBtYXJrdXAgc3RyaW5ncyB0byByZW5kZXIuXG4gICAqIEByZXR1cm4ge2FycmF5PERPTUVsZW1lbnQ+fSBMaXN0IG9mIHJlbmRlcmVkIG5vZGVzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVuZGVyTWFya3VwOiBmdW5jdGlvbiAobWFya3VwTGlzdCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSB3b3JrZXIgJyArICd0aHJlYWQuIE1ha2Ugc3VyZSBgd2luZG93YCBhbmQgYGRvY3VtZW50YCBhcmUgYXZhaWxhYmxlIGdsb2JhbGx5ICcgKyAnYmVmb3JlIHJlcXVpcmluZyBSZWFjdCB3aGVuIHVuaXQgdGVzdGluZyBvciB1c2UgJyArICdSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZyBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIG5vZGVOYW1lO1xuICAgIHZhciBtYXJrdXBCeU5vZGVOYW1lID0ge307XG4gICAgLy8gR3JvdXAgbWFya3VwIGJ5IGBub2RlTmFtZWAgaWYgYSB3cmFwIGlzIG5lY2Vzc2FyeSwgZWxzZSBieSAnKicuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrdXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAhbWFya3VwTGlzdFtpXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlbmRlck1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cExpc3RbaV0pO1xuICAgICAgbm9kZU5hbWUgPSBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSA/IG5vZGVOYW1lIDogJyonO1xuICAgICAgbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV0gPSBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXSB8fCBbXTtcbiAgICAgIG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdW2ldID0gbWFya3VwTGlzdFtpXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdExpc3QgPSBbXTtcbiAgICB2YXIgcmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCA9IDA7XG4gICAgZm9yIChub2RlTmFtZSBpbiBtYXJrdXBCeU5vZGVOYW1lKSB7XG4gICAgICBpZiAoIW1hcmt1cEJ5Tm9kZU5hbWUuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIG1hcmt1cExpc3RCeU5vZGVOYW1lID0gbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV07XG5cbiAgICAgIC8vIFRoaXMgZm9yLWluIGxvb3Agc2tpcHMgdGhlIGhvbGVzIG9mIHRoZSBzcGFyc2UgYXJyYXkuIFRoZSBvcmRlciBvZlxuICAgICAgLy8gaXRlcmF0aW9uIHNob3VsZCBmb2xsb3cgdGhlIG9yZGVyIG9mIGFzc2lnbm1lbnQsIHdoaWNoIGhhcHBlbnMgdG8gbWF0Y2hcbiAgICAgIC8vIG51bWVyaWNhbCBpbmRleCBvcmRlciwgYnV0IHdlIGRvbid0IHJlbHkgb24gdGhhdC5cbiAgICAgIHZhciByZXN1bHRJbmRleDtcbiAgICAgIGZvciAocmVzdWx0SW5kZXggaW4gbWFya3VwTGlzdEJ5Tm9kZU5hbWUpIHtcbiAgICAgICAgaWYgKG1hcmt1cExpc3RCeU5vZGVOYW1lLmhhc093blByb3BlcnR5KHJlc3VsdEluZGV4KSkge1xuICAgICAgICAgIHZhciBtYXJrdXAgPSBtYXJrdXBMaXN0QnlOb2RlTmFtZVtyZXN1bHRJbmRleF07XG5cbiAgICAgICAgICAvLyBQdXNoIHRoZSByZXF1ZXN0ZWQgbWFya3VwIHdpdGggYW4gYWRkaXRpb25hbCBSRVNVTFRfSU5ERVhfQVRUUlxuICAgICAgICAgIC8vIGF0dHJpYnV0ZS4gIElmIHRoZSBtYXJrdXAgZG9lcyBub3Qgc3RhcnQgd2l0aCBhIDwgY2hhcmFjdGVyLCBpdFxuICAgICAgICAgIC8vIHdpbGwgYmUgZGlzY2FyZGVkIGJlbG93ICh3aXRoIGFuIGFwcHJvcHJpYXRlIGNvbnNvbGUuZXJyb3IpLlxuICAgICAgICAgIG1hcmt1cExpc3RCeU5vZGVOYW1lW3Jlc3VsdEluZGV4XSA9IG1hcmt1cC5yZXBsYWNlKE9QRU5fVEFHX05BTUVfRVhQLFxuICAgICAgICAgIC8vIFRoaXMgaW5kZXggd2lsbCBiZSBwYXJzZWQgYmFjayBvdXQgYmVsb3cuXG4gICAgICAgICAgJyQxICcgKyBSRVNVTFRfSU5ERVhfQVRUUiArICc9XCInICsgcmVzdWx0SW5kZXggKyAnXCIgJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIGVhY2ggZ3JvdXAgb2YgbWFya3VwIHdpdGggc2ltaWxhciB3cmFwcGluZyBgbm9kZU5hbWVgLlxuICAgICAgdmFyIHJlbmRlck5vZGVzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cExpc3RCeU5vZGVOYW1lLmpvaW4oJycpLCBlbXB0eUZ1bmN0aW9uIC8vIERvIG5vdGhpbmcgc3BlY2lhbCB3aXRoIDxzY3JpcHQ+IHRhZ3MuXG4gICAgICApO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlbmRlck5vZGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciByZW5kZXJOb2RlID0gcmVuZGVyTm9kZXNbal07XG4gICAgICAgIGlmIChyZW5kZXJOb2RlLmhhc0F0dHJpYnV0ZSAmJiByZW5kZXJOb2RlLmhhc0F0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUikpIHtcblxuICAgICAgICAgIHJlc3VsdEluZGV4ID0gK3JlbmRlck5vZGUuZ2V0QXR0cmlidXRlKFJFU1VMVF9JTkRFWF9BVFRSKTtcbiAgICAgICAgICByZW5kZXJOb2RlLnJlbW92ZUF0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUik7XG5cbiAgICAgICAgICAhIXJlc3VsdExpc3QuaGFzT3duUHJvcGVydHkocmVzdWx0SW5kZXgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RhbmdlcjogQXNzaWduaW5nIHRvIGFuIGFscmVhZHktb2NjdXBpZWQgcmVzdWx0IGluZGV4LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHJlc3VsdExpc3RbcmVzdWx0SW5kZXhdID0gcmVuZGVyTm9kZTtcblxuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG1hdGNoIHJlc3VsdExpc3QubGVuZ3RoIGFuZCBtYXJrdXBMaXN0Lmxlbmd0aCB3aGVuXG4gICAgICAgICAgLy8gd2UncmUgZG9uZS5cbiAgICAgICAgICByZXN1bHRMaXN0QXNzaWdubWVudENvdW50ICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0RhbmdlcjogRGlzY2FyZGluZyB1bmV4cGVjdGVkIG5vZGU6JywgcmVuZGVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbHRob3VnaCByZXN1bHRMaXN0IHdhcyBwb3B1bGF0ZWQgb3V0IG9mIG9yZGVyLCBpdCBzaG91bGQgbm93IGJlIGEgZGVuc2VcbiAgICAvLyBhcnJheS5cbiAgICAhKHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgPT09IHJlc3VsdExpc3QubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEYW5nZXI6IERpZCBub3QgYXNzaWduIHRvIGV2ZXJ5IGluZGV4IG9mIHJlc3VsdExpc3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgIShyZXN1bHRMaXN0Lmxlbmd0aCA9PT0gbWFya3VwTGlzdC5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RhbmdlcjogRXhwZWN0ZWQgbWFya3VwIHRvIHJlbmRlciAlcyBub2RlcywgYnV0IHJlbmRlcmVkICVzLicsIG1hcmt1cExpc3QubGVuZ3RoLCByZXN1bHRMaXN0Lmxlbmd0aCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHJlc3VsdExpc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgbm9kZSB3aXRoIGEgc3RyaW5nIG9mIG1hcmt1cCBhdCBpdHMgY3VycmVudCBwb3NpdGlvbiB3aXRoaW4gaXRzXG4gICAqIHBhcmVudC4gVGhlIG1hcmt1cCBtdXN0IHJlbmRlciBpbnRvIGEgc2luZ2xlIHJvb3Qgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBvbGRDaGlsZCBDaGlsZCBub2RlIHRvIHJlcGxhY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHJlbmRlciBpbiBwbGFjZSBvZiB0aGUgY2hpbGQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZnVuY3Rpb24gKG9sZENoaWxkLCBtYXJrdXApIHtcbiAgICAhRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgJyArICd3b3JrZXIgdGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSAnICsgJ2dsb2JhbGx5IGJlZm9yZSByZXF1aXJpbmcgUmVhY3Qgd2hlbiB1bml0IHRlc3Rpbmcgb3IgdXNlICcgKyAnUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgIW1hcmt1cCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgIShvbGRDaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdodG1sJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlcGxhY2UgbWFya3VwIG9mIHRoZSAnICsgJzxodG1sPiBub2RlLiBUaGlzIGlzIGJlY2F1c2UgYnJvd3NlciBxdWlya3MgbWFrZSB0aGlzIHVucmVsaWFibGUgJyArICdhbmQvb3Igc2xvdy4gSWYgeW91IHdhbnQgdG8gcmVuZGVyIHRvIHRoZSByb290IHlvdSBtdXN0IHVzZSAnICsgJ3NlcnZlciByZW5kZXJpbmcuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBuZXdDaGlsZDtcbiAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5ld0NoaWxkID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwKG1hcmt1cCwgZW1wdHlGdW5jdGlvbilbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0NoaWxkID0gbWFya3VwO1xuICAgIH1cbiAgICBvbGRDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdDaGlsZCwgb2xkQ2hpbGQpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGFuZ2VyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gW2tleU9mKHsgUmVzcG9uZGVyRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgU2ltcGxlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgVGFwRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IENoYW5nZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNlbGVjdEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IG51bGwgfSldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRFdmVudFBsdWdpbk9yZGVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFbnRlckxlYXZlRXZlbnRQbHVnaW5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcbnZhciBnZXRGaXJzdFJlYWN0RE9NID0gUmVhY3RNb3VudC5nZXRGaXJzdFJlYWN0RE9NO1xuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IGtleU9mKHsgb25Nb3VzZUVudGVyOiBudWxsIH0pLFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wTW91c2VPdXQsIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2YoeyBvbk1vdXNlTGVhdmU6IG51bGwgfSksXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXJdXG4gIH1cbn07XG5cbnZhciBleHRyYWN0ZWRFdmVudHMgPSBbbnVsbCwgbnVsbF07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50c31cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3ZlciAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0ICYmIHRvcExldmVsVHlwZSAhPT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXIpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmICh0b3BMZXZlbFRhcmdldC53aW5kb3cgPT09IHRvcExldmVsVGFyZ2V0KSB7XG4gICAgICAvLyBgdG9wTGV2ZWxUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IHRvcExldmVsVGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gdG9wTGV2ZWxUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIHZhciBmcm9tSUQgPSAnJztcbiAgICB2YXIgdG9JRCA9ICcnO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQpIHtcbiAgICAgIGZyb20gPSB0b3BMZXZlbFRhcmdldDtcbiAgICAgIGZyb21JRCA9IHRvcExldmVsVGFyZ2V0SUQ7XG4gICAgICB0byA9IGdldEZpcnN0UmVhY3RET00obmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQpO1xuICAgICAgaWYgKHRvKSB7XG4gICAgICAgIHRvSUQgPSBSZWFjdE1vdW50LmdldElEKHRvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvID0gd2luO1xuICAgICAgfVxuICAgICAgdG8gPSB0byB8fCB3aW47XG4gICAgfSBlbHNlIHtcbiAgICAgIGZyb20gPSB3aW47XG4gICAgICB0byA9IHRvcExldmVsVGFyZ2V0O1xuICAgICAgdG9JRCA9IHRvcExldmVsVGFyZ2V0SUQ7XG4gICAgfVxuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlTGVhdmUsIGZyb21JRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb207XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvO1xuXG4gICAgdmFyIGVudGVyID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUVudGVyLCB0b0lELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSAnbW91c2VlbnRlcic7XG4gICAgZW50ZXIudGFyZ2V0ID0gdG87XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb207XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb21JRCwgdG9JRCk7XG5cbiAgICBleHRyYWN0ZWRFdmVudHNbMF0gPSBsZWF2ZTtcbiAgICBleHRyYWN0ZWRFdmVudHNbMV0gPSBlbnRlcjtcblxuICAgIHJldHVybiBleHRyYWN0ZWRFdmVudHM7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbnRlckxlYXZlRXZlbnRQbHVnaW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50Q29uc3RhbnRzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbnZhciBQcm9wYWdhdGlvblBoYXNlcyA9IGtleU1pcnJvcih7IGJ1YmJsZWQ6IG51bGwsIGNhcHR1cmVkOiBudWxsIH0pO1xuXG4vKipcbiAqIFR5cGVzIG9mIHJhdyBzaWduYWxzIGZyb20gdGhlIGJyb3dzZXIgY2F1Z2h0IGF0IHRoZSB0b3AgbGV2ZWwuXG4gKi9cbnZhciB0b3BMZXZlbFR5cGVzID0ga2V5TWlycm9yKHtcbiAgdG9wQWJvcnQ6IG51bGwsXG4gIHRvcEJsdXI6IG51bGwsXG4gIHRvcENhblBsYXk6IG51bGwsXG4gIHRvcENhblBsYXlUaHJvdWdoOiBudWxsLFxuICB0b3BDaGFuZ2U6IG51bGwsXG4gIHRvcENsaWNrOiBudWxsLFxuICB0b3BDb21wb3NpdGlvbkVuZDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6IG51bGwsXG4gIHRvcENvbnRleHRNZW51OiBudWxsLFxuICB0b3BDb3B5OiBudWxsLFxuICB0b3BDdXQ6IG51bGwsXG4gIHRvcERvdWJsZUNsaWNrOiBudWxsLFxuICB0b3BEcmFnOiBudWxsLFxuICB0b3BEcmFnRW5kOiBudWxsLFxuICB0b3BEcmFnRW50ZXI6IG51bGwsXG4gIHRvcERyYWdFeGl0OiBudWxsLFxuICB0b3BEcmFnTGVhdmU6IG51bGwsXG4gIHRvcERyYWdPdmVyOiBudWxsLFxuICB0b3BEcmFnU3RhcnQ6IG51bGwsXG4gIHRvcERyb3A6IG51bGwsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiBudWxsLFxuICB0b3BFbXB0aWVkOiBudWxsLFxuICB0b3BFbmNyeXB0ZWQ6IG51bGwsXG4gIHRvcEVuZGVkOiBudWxsLFxuICB0b3BFcnJvcjogbnVsbCxcbiAgdG9wRm9jdXM6IG51bGwsXG4gIHRvcElucHV0OiBudWxsLFxuICB0b3BLZXlEb3duOiBudWxsLFxuICB0b3BLZXlQcmVzczogbnVsbCxcbiAgdG9wS2V5VXA6IG51bGwsXG4gIHRvcExvYWQ6IG51bGwsXG4gIHRvcExvYWRlZERhdGE6IG51bGwsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiBudWxsLFxuICB0b3BMb2FkU3RhcnQ6IG51bGwsXG4gIHRvcE1vdXNlRG93bjogbnVsbCxcbiAgdG9wTW91c2VNb3ZlOiBudWxsLFxuICB0b3BNb3VzZU91dDogbnVsbCxcbiAgdG9wTW91c2VPdmVyOiBudWxsLFxuICB0b3BNb3VzZVVwOiBudWxsLFxuICB0b3BQYXN0ZTogbnVsbCxcbiAgdG9wUGF1c2U6IG51bGwsXG4gIHRvcFBsYXk6IG51bGwsXG4gIHRvcFBsYXlpbmc6IG51bGwsXG4gIHRvcFByb2dyZXNzOiBudWxsLFxuICB0b3BSYXRlQ2hhbmdlOiBudWxsLFxuICB0b3BSZXNldDogbnVsbCxcbiAgdG9wU2Nyb2xsOiBudWxsLFxuICB0b3BTZWVrZWQ6IG51bGwsXG4gIHRvcFNlZWtpbmc6IG51bGwsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogbnVsbCxcbiAgdG9wU3RhbGxlZDogbnVsbCxcbiAgdG9wU3VibWl0OiBudWxsLFxuICB0b3BTdXNwZW5kOiBudWxsLFxuICB0b3BUZXh0SW5wdXQ6IG51bGwsXG4gIHRvcFRpbWVVcGRhdGU6IG51bGwsXG4gIHRvcFRvdWNoQ2FuY2VsOiBudWxsLFxuICB0b3BUb3VjaEVuZDogbnVsbCxcbiAgdG9wVG91Y2hNb3ZlOiBudWxsLFxuICB0b3BUb3VjaFN0YXJ0OiBudWxsLFxuICB0b3BWb2x1bWVDaGFuZ2U6IG51bGwsXG4gIHRvcFdhaXRpbmc6IG51bGwsXG4gIHRvcFdoZWVsOiBudWxsXG59KTtcblxudmFyIEV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzLFxuICBQcm9wYWdhdGlvblBoYXNlczogUHJvcGFnYXRpb25QaGFzZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRDb25zdGFudHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luSHViXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEludGVybmFsIHN0b3JlIGZvciBldmVudCBsaXN0ZW5lcnNcbiAqL1xudmFyIGxpc3RlbmVyQmFuayA9IHt9O1xuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCwgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudCkge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIC0gYEluc3RhbmNlSGFuZGxlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBwZXJmb3JtcyBsb2dpY2FsIHRyYXZlcnNhbHMgb2YgRE9NXG4gKiAgIGhpZXJhcmNoeSBnaXZlbiBpZHMgb2YgdGhlIGxvZ2ljYWwgRE9NIGVsZW1lbnRzIGludm9sdmVkLlxuICovXG52YXIgSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCkge1xuICB2YXIgdmFsaWQgPSBJbnN0YW5jZUhhbmRsZSAmJiBJbnN0YW5jZUhhbmRsZS50cmF2ZXJzZVR3b1BoYXNlICYmIEluc3RhbmNlSGFuZGxlLnRyYXZlcnNlRW50ZXJMZWF2ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodmFsaWQsICdJbnN0YW5jZUhhbmRsZSBub3QgaW5qZWN0ZWQgYmVmb3JlIHVzZSEnKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgRXZlbnRQbHVnaW5IdWIgPSB7XG5cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZE1vdW50XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdE1vdW50OiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZEluc3RhbmNlSGFuZGxlXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEluc3RhbmNlSGFuZGxlOiBmdW5jdGlvbiAoSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgSW5zdGFuY2VIYW5kbGUgPSBJbmplY3RlZEluc3RhbmNlSGFuZGxlO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRJbnN0YW5jZUhhbmRsZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEluc3RhbmNlSGFuZGxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxuXG4gIH0sXG5cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblxuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczogRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblxuICAvKipcbiAgICogU3RvcmVzIGBsaXN0ZW5lcmAgYXQgYGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gc3RvcmUuXG4gICAqL1xuICBwdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgICEodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCAlcyBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCB0eXBlICVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gfHwgKGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSA9IHt9KTtcbiAgICBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF0gPSBsaXN0ZW5lcjtcblxuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICAgKi9cbiAgZ2V0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbGlzdGVuZXIgZnJvbSB0aGUgcmVnaXN0cmF0aW9uIGJhbmsuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICovXG4gIGRlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBuZXZlciBiZSBudWxsIC0tIHdoZW4gaXMgaXQ/XG4gICAgaWYgKGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICBkZWxldGUgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgRE9NIGVsZW1lbnQgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqL1xuICBkZWxldGVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIChpZCkge1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gbGlzdGVuZXJCYW5rKSB7XG4gICAgICBpZiAoIWxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2lkXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICB2YXIgcGx1Z2lucyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE5vdCBldmVyeSBwbHVnaW4gaW4gdGhlIG9yZGVyaW5nIG1heSBiZSBsb2FkZWQgYXQgcnVudGltZS5cbiAgICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgICAgdmFyIGV4dHJhY3RlZEV2ZW50cyA9IHBvc3NpYmxlUGx1Z2luLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzRXZlbnRRdWV1ZTogZnVuY3Rpb24gKHNpbXVsYXRlZCkge1xuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcbiAgICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICAgIH1cbiAgICAhIWV2ZW50UXVldWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nICcgKyAnYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudFBsdWdpblJlZ2lzdHJ5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIUV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBFdmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBFdmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gJyArICd0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFQbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCAnICsgJ21ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2luc1twbHVnaW5JbmRleF0gPSBQbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IFBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBGYWlsZWQgdG8gcHVibGlzaCBldmVudCBgJXNgIGZvciBwbHVnaW4gYCVzYC4nLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgKyAnZXZlbnQgbmFtZSwgYCVzYC4nLCBldmVudE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMgYW5kXG4gKiBjYW4gYmUgdXNlZCB3aXRoIGBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcmAgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSAnICsgJ3JlZ2lzdHJhdGlvbiBuYW1lLCBgJXNgLicsIHJlZ2lzdHJhdGlvbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0ge1xuXG4gIC8qKlxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAgICovXG4gIHBsdWdpbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAgICovXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcblxuICAvKipcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAgICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBmdW5jdGlvbiAoSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgISFFdmVudFBsdWdpbk9yZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiAnICsgJ29uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbiAoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gUGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgJyArICd1c2luZyB0aGUgc2FtZSBuYW1lLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBQbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCB0aGUgcGx1Z2luIGZvciB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cbiAgICogQHJldHVybiB7P29iamVjdH0gVGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFBsdWdpbk1vZHVsZUZvckV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZV0gfHwgbnVsbDtcbiAgICB9XG4gICAgZm9yICh2YXIgcGhhc2UgaW4gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmICghZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2UpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VdXTtcbiAgICAgIGlmIChQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFBsdWdpbk1vZHVsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZXNldEV2ZW50UGx1Z2luczogZnVuY3Rpb24gKCkge1xuICAgIEV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmIChuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBkZWxldGUgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MpIHtcbiAgICAgIGlmIChldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICBkZWxldGUgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcztcbiAgICBmb3IgKHZhciByZWdpc3RyYXRpb25OYW1lIGluIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocmVnaXN0cmF0aW9uTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luUmVnaXN0cnk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XG4gKi9cblxuLyoqXG4gKiAtIGBNb3VudGA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgY2FuIGNvbnZlcnQgYmV0d2VlbiBSZWFjdCBkb20gSURzIGFuZFxuICogICBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICovXG52YXIgaW5qZWN0aW9uID0ge1xuICBNb3VudDogbnVsbCxcbiAgaW5qZWN0TW91bnQ6IGZ1bmN0aW9uIChJbmplY3RlZE1vdW50KSB7XG4gICAgaW5qZWN0aW9uLk1vdW50ID0gSW5qZWN0ZWRNb3VudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWRNb3VudCAmJiBJbmplY3RlZE1vdW50LmdldE5vZGUgJiYgSW5qZWN0ZWRNb3VudC5nZXRJRCwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdE1vdW50KC4uLik6IEluamVjdGVkIE1vdW50ICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZSBvciBnZXRJRC4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDtcbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGlkc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaElEcyk7XG4gICAgdmFyIElEc0xlbiA9IGlkc0lzQXJyID8gZGlzcGF0Y2hJRHMubGVuZ3RoIDogZGlzcGF0Y2hJRHMgPyAxIDogMDtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaWRzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIElEc0xlbiA9PT0gbGlzdGVuZXJzTGVuLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21JRCBET00gaWQgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgZG9tSUQpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGluamVjdGlvbi5Nb3VudC5nZXROb2RlKGRvbUlEKTtcbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2godHlwZSwgbGlzdGVuZXIsIGV2ZW50LCBkb21JRCk7XG4gIH0gZWxzZSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayh0eXBlLCBsaXN0ZW5lciwgZXZlbnQsIGRvbUlEKTtcbiAgfVxuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJRHMgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJRHMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSURzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSURzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLCBidXQgc3RvcHNcbiAqIGF0IHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gcmV0dXJuaW5nIHRydWUsIGFuZCByZXR1cm5zIHRoYXQgaWQuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gaWQgb2YgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiB3aG8ncyBsaXN0ZW5lciByZXR1cm5zXG4gKiB0cnVlLCBvciBudWxsIGlmIG5vIGxpc3RlbmVyIHJldHVybmVkIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSURzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzW2ldKGV2ZW50LCBkaXNwYXRjaElEc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoSURzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGlmIChkaXNwYXRjaExpc3RlbmVycyhldmVudCwgZGlzcGF0Y2hJRHMpKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hJRHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShldmVudCkge1xuICB2YXIgcmV0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lciA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSUQgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gICEhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdleGVjdXRlRGlyZWN0RGlzcGF0Y2goLi4uKTogSW52YWxpZCBgZXZlbnRgLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHJlcyA9IGRpc3BhdGNoTGlzdGVuZXIgPyBkaXNwYXRjaExpc3RlbmVyKGV2ZW50LCBkaXNwYXRjaElEKSA6IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaElEcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXROb2RlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uLk1vdW50LmdldE5vZGUoaWQpO1xuICB9LFxuICBnZXRJRDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uLk1vdW50LmdldElEKG5vZGUpO1xuICB9LFxuXG4gIGluamVjdGlvbjogaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luVXRpbHM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UHJvcGFnYXRvcnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBhY2N1bXVsYXRlSW50byA9IHJlcXVpcmUoJy4vYWNjdW11bGF0ZUludG8nKTtcbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSByZXF1aXJlKCcuL2ZvckVhY2hBY2N1bXVsYXRlZCcpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBFdmVudENvbnN0YW50cy5Qcm9wYWdhdGlvblBoYXNlcztcbnZhciBnZXRMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyO1xuXG4vKipcbiAqIFNvbWUgZXZlbnQgdHlwZXMgaGF2ZSBhIG5vdGlvbiBvZiBkaWZmZXJlbnQgcmVnaXN0cmF0aW9uIG5hbWVzIGZvciBkaWZmZXJlbnRcbiAqIFwicGhhc2VzXCIgb2YgcHJvcGFnYXRpb24uIFRoaXMgZmluZHMgbGlzdGVuZXJzIGJ5IGEgZ2l2ZW4gcGhhc2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyQXRQaGFzZShpZCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoZG9tSUQsIHVwd2FyZHMsIGV2ZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZG9tSUQsICdEaXNwYXRjaGluZyBpZCBtdXN0IG5vdCBiZSBudWxsJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdmFyIHBoYXNlID0gdXB3YXJkcyA/IFByb3BhZ2F0aW9uUGhhc2VzLmJ1YmJsZWQgOiBQcm9wYWdhdGlvblBoYXNlcy5jYXB0dXJlZDtcbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGRvbUlELCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJRHMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJRHMsIGRvbUlEKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZVR3b1BoYXNlKGV2ZW50LmRpc3BhdGNoTWFya2VyLCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZVR3b1BoYXNlU2tpcFRhcmdldChldmVudC5kaXNwYXRjaE1hcmtlciwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaWQsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lO1xuICAgIHZhciBsaXN0ZW5lciA9IGdldExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSURzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSURzLCBpZCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5kaXNwYXRjaE1hcmtlciwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tSUQsIHRvSUQpIHtcbiAgRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmdldEluc3RhbmNlSGFuZGxlKCkudHJhdmVyc2VFbnRlckxlYXZlKGZyb21JRCwgdG9JRCwgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbi8qKlxuICogQSBzbWFsbCBzZXQgb2YgcHJvcGFnYXRpb24gcGF0dGVybnMsIGVhY2ggb2Ygd2hpY2ggd2lsbCBhY2NlcHQgYSBzbWFsbCBhbW91bnRcbiAqIG9mIGluZm9ybWF0aW9uLCBhbmQgZ2VuZXJhdGUgYSBzZXQgb2YgXCJkaXNwYXRjaCByZWFkeSBldmVudCBvYmplY3RzXCIgLSB3aGljaFxuICogYXJlIHNldHMgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gYW5ub3RhdGVkIHdpdGggYSBzZXQgb2YgZGlzcGF0Y2hlZFxuICogbGlzdGVuZXIgZnVuY3Rpb25zL2lkcy4gVGhlIEFQSSBpcyBkZXNpZ25lZCB0aGlzIHdheSB0byBkaXNjb3VyYWdlIHRoZXNlXG4gKiBwcm9wYWdhdGlvbiBzdHJhdGVnaWVzIGZyb20gYWN0dWFsbHkgZXhlY3V0aW5nIHRoZSBkaXNwYXRjaGVzLCBzaW5jZSB3ZVxuICogYWx3YXlzIHdhbnQgdG8gY29sbGVjdCB0aGUgZW50aXJlIHNldCBvZiBkaXNwYXRjaGVzIGJlZm9yZSBleGVjdXRpbmcgZXZlbnQgYVxuICogc2luZ2xlIG9uZS5cbiAqXG4gKiBAY29uc3RydWN0b3IgRXZlbnRQcm9wYWdhdG9yc1xuICovXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0LFxuICBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMsXG4gIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UHJvcGFnYXRvcnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcblxuLyoqXG4gKiBUaGlzIGhlbHBlciBjbGFzcyBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSByb290XG4gKi9cbmZ1bmN0aW9uIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZShyb290KSB7XG4gIHRoaXMuX3Jvb3QgPSByb290O1xuICB0aGlzLl9zdGFydFRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuYXNzaWduKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGlmICgndmFsdWUnIGluIHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGRpZmZlcmluZyBzdWJzdHJpbmcgYmV0d2VlbiB0aGUgaW5pdGlhbGx5IHN0b3JlZFxuICAgKiB0ZXh0IGNvbnRlbnQgYW5kIHRoZSBjdXJyZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmFsbGJhY2tUZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICAgIH1cblxuICAgIHZhciBzdGFydDtcbiAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuX3N0YXJ0VGV4dDtcbiAgICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gICAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBIVE1MRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBNVVNUX1VTRV9BVFRSSUJVVEUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfQVRUUklCVVRFO1xudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19TSURFX0VGRkVDVFMgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1NJREVfRUZGRUNUUztcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG5cbnZhciBoYXNTVkc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciBpbXBsZW1lbnRhdGlvbiA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uO1xuICBoYXNTVkcgPSBpbXBsZW1lbnRhdGlvbiAmJiBpbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmIGltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmUnLCAnMS4xJyk7XG59XG5cbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXihkYXRhfGFyaWEpLVthLXpfXVthLXpcXGRfLlxcLV0qJC8pLFxuICBQcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFjY2VwdDogbnVsbCxcbiAgICBhY2NlcHRDaGFyc2V0OiBudWxsLFxuICAgIGFjY2Vzc0tleTogbnVsbCxcbiAgICBhY3Rpb246IG51bGwsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGFsdDogbnVsbCxcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b0NvbXBsZXRlOiBudWxsLFxuICAgIC8vIGF1dG9Gb2N1cyBpcyBwb2x5ZmlsbGVkL25vcm1hbGl6ZWQgYnkgQXV0b0ZvY3VzVXRpbHNcbiAgICAvLyBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjZWxsUGFkZGluZzogbnVsbCxcbiAgICBjZWxsU3BhY2luZzogbnVsbCxcbiAgICBjaGFyU2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY2hhbGxlbmdlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjbGFzc0lEOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gVG8gc2V0IGNsYXNzTmFtZSBvbiBTVkcgZWxlbWVudHMsIGl0J3MgbmVjZXNzYXJ5IHRvIHVzZSAuc2V0QXR0cmlidXRlO1xuICAgIC8vIHRoaXMgd29ya3Mgb24gSFRNTCBlbGVtZW50cyB0b28gaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCBJRTguIENvbnZlbmllbnRseSxcbiAgICAvLyBJRTggZG9lc24ndCBzdXBwb3J0IFNWRyBhbmQgc28gd2UgY2FuIHNpbXBseSB1c2UgdGhlIGF0dHJpYnV0ZSBpblxuICAgIC8vIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBTVkcgYW5kIHRoZSBwcm9wZXJ0eSBpbiBicm93c2VycyB0aGF0IGRvbid0LFxuICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgZWxlbWVudCBpcyBIVE1MIG9yIFNWRy5cbiAgICBjbGFzc05hbWU6IGhhc1NWRyA/IE1VU1RfVVNFX0FUVFJJQlVURSA6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIGNvbHM6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbFNwYW46IG51bGwsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBjb250ZW50RWRpdGFibGU6IG51bGwsXG4gICAgY29udGV4dE1lbnU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjb250cm9sczogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb29yZHM6IG51bGwsXG4gICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgZGF0YTogbnVsbCwgLy8gRm9yIGA8b2JqZWN0IC8+YCBhY3RzIGFzIGBzcmNgLlxuICAgIGRhdGVUaW1lOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlyOiBudWxsLFxuICAgIGRpc2FibGVkOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IG51bGwsXG4gICAgZW5jVHlwZTogbnVsbCxcbiAgICBmb3JtOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9ybUFjdGlvbjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1FbmNUeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9ybU1ldGhvZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtVGFyZ2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZnJhbWVCb3JkZXI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBoZWFkZXJzOiBudWxsLFxuICAgIGhlaWdodDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGhpZGRlbjogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlnaDogbnVsbCxcbiAgICBocmVmOiBudWxsLFxuICAgIGhyZWZMYW5nOiBudWxsLFxuICAgIGh0bWxGb3I6IG51bGwsXG4gICAgaHR0cEVxdWl2OiBudWxsLFxuICAgIGljb246IG51bGwsXG4gICAgaWQ6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIGlucHV0TW9kZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGludGVncml0eTogbnVsbCxcbiAgICBpczogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGtleVBhcmFtczogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGtleVR5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBraW5kOiBudWxsLFxuICAgIGxhYmVsOiBudWxsLFxuICAgIGxhbmc6IG51bGwsXG4gICAgbGlzdDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGxvb3A6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG93OiBudWxsLFxuICAgIG1hbmlmZXN0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFyZ2luSGVpZ2h0OiBudWxsLFxuICAgIG1hcmdpbldpZHRoOiBudWxsLFxuICAgIG1heDogbnVsbCxcbiAgICBtYXhMZW5ndGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtZWRpYTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1lZGlhR3JvdXA6IG51bGwsXG4gICAgbWV0aG9kOiBudWxsLFxuICAgIG1pbjogbnVsbCxcbiAgICBtaW5MZW5ndGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBuYW1lOiBudWxsLFxuICAgIG5vbmNlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3B0aW11bTogbnVsbCxcbiAgICBwYXR0ZXJuOiBudWxsLFxuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHBvc3RlcjogbnVsbCxcbiAgICBwcmVsb2FkOiBudWxsLFxuICAgIHJhZGlvR3JvdXA6IG51bGwsXG4gICAgcmVhZE9ubHk6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVsOiBudWxsLFxuICAgIHJlcXVpcmVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXZlcnNlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm9sZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJvd3M6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IG51bGwsXG4gICAgc2FuZGJveDogbnVsbCxcbiAgICBzY29wZTogbnVsbCxcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNjcm9sbGluZzogbnVsbCxcbiAgICBzZWFtbGVzczogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2hhcGU6IG51bGwsXG4gICAgc2l6ZTogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc2l6ZXM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzcGFuOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzcGVsbENoZWNrOiBudWxsLFxuICAgIHNyYzogbnVsbCxcbiAgICBzcmNEb2M6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIHNyY0xhbmc6IG51bGwsXG4gICAgc3JjU2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHN0ZXA6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgc3VtbWFyeTogbnVsbCxcbiAgICB0YWJJbmRleDogbnVsbCxcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgdHlwZTogbnVsbCxcbiAgICB1c2VNYXA6IG51bGwsXG4gICAgdmFsdWU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX1NJREVfRUZGRUNUUyxcbiAgICB3aWR0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHdtb2RlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgd3JhcDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFJERmEgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFib3V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZGF0YXR5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpbmxpc3Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwcmVmaXg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIHN1cHBvcnRlZCBmb3IgT3BlbkdyYXBoIGluIG1ldGEgdGFncy5cbiAgICBwcm9wZXJ0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJlc291cmNlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgJ3R5cGVvZic6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2b2NhYjogTVVTVF9VU0VfQVRUUklCVVRFLFxuXG4gICAgLyoqXG4gICAgICogTm9uLXN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICAvLyBhdXRvQ2FwaXRhbGl6ZSBhbmQgYXV0b0NvcnJlY3QgYXJlIHN1cHBvcnRlZCBpbiBNb2JpbGUgU2FmYXJpIGZvclxuICAgIC8vIGtleWJvYXJkIGhpbnRzLlxuICAgIGF1dG9DYXBpdGFsaXplOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgYXV0b0NvcnJlY3Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBhdXRvU2F2ZSBhbGxvd3MgV2ViS2l0L0JsaW5rIHRvIHBlcnNpc3QgdmFsdWVzIG9mIGlucHV0IGZpZWxkcyBvbiBwYWdlIHJlbG9hZHNcbiAgICBhdXRvU2F2ZTogbnVsbCxcbiAgICAvLyBjb2xvciBpcyBmb3IgU2FmYXJpIG1hc2staWNvbiBsaW5rXG4gICAgY29sb3I6IG51bGwsXG4gICAgLy8gaXRlbVByb3AsIGl0ZW1TY29wZSwgaXRlbVR5cGUgYXJlIGZvclxuICAgIC8vIE1pY3JvZGF0YSBzdXBwb3J0LiBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVByb3A6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpdGVtU2NvcGU6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGl0ZW1UeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gaXRlbUlEIGFuZCBpdGVtUmVmIGFyZSBmb3IgTWljcm9kYXRhIHN1cHBvcnQgYXMgd2VsbCBidXRcbiAgICAvLyBvbmx5IHNwZWNpZmllZCBpbiB0aGUgdGhlIFdIQVRXRyBzcGVjIGRvY3VtZW50LiBTZWVcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9taWNyb2RhdGEuaHRtbCNtaWNyb2RhdGEtZG9tLWFwaVxuICAgIGl0ZW1JRDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGl0ZW1SZWY6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyByZXN1bHRzIHNob3cgbG9va2luZyBnbGFzcyBpY29uIGFuZCByZWNlbnQgc2VhcmNoZXMgb24gaW5wdXRcbiAgICAvLyBzZWFyY2ggZmllbGRzIGluIFdlYktpdC9CbGlua1xuICAgIHJlc3VsdHM6IG51bGwsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgc2VjdXJpdHkgcmVzdHJpY3Rpb25zIG9uIGFuIGlmcmFtZVxuICAgIC8vIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBzYW5kYm94IGF0dHJpYnV0ZSBvbiBJRTwxMFxuICAgIHNlY3VyaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBjb250cm9scyBmb2N1cyBiZWhhdmlvclxuICAgIHVuc2VsZWN0YWJsZTogTVVTVF9VU0VfQVRUUklCVVRFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NUHJvcGVydHlOYW1lczoge1xuICAgIGF1dG9Db21wbGV0ZTogJ2F1dG9jb21wbGV0ZScsXG4gICAgYXV0b0ZvY3VzOiAnYXV0b2ZvY3VzJyxcbiAgICBhdXRvUGxheTogJ2F1dG9wbGF5JyxcbiAgICBhdXRvU2F2ZTogJ2F1dG9zYXZlJyxcbiAgICAvLyBgZW5jb2RpbmdgIGlzIGVxdWl2YWxlbnQgdG8gYGVuY3R5cGVgLCBJRTggbGFja3MgYW4gYGVuY3R5cGVgIHNldHRlci5cbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI2RvbS1mcy1lbmNvZGluZ1xuICAgIGVuY1R5cGU6ICdlbmNvZGluZycsXG4gICAgaHJlZkxhbmc6ICdocmVmbGFuZycsXG4gICAgcmFkaW9Hcm91cDogJ3JhZGlvZ3JvdXAnLFxuICAgIHNwZWxsQ2hlY2s6ICdzcGVsbGNoZWNrJyxcbiAgICBzcmNEb2M6ICdzcmNkb2MnLFxuICAgIHNyY1NldDogJ3NyY3NldCdcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIVE1MRE9NUHJvcGVydHlDb25maWc7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIExpbmtlZFZhbHVlVXRpbHNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVzJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICdidXR0b24nOiB0cnVlLFxuICAnY2hlY2tib3gnOiB0cnVlLFxuICAnaW1hZ2UnOiB0cnVlLFxuICAnaGlkZGVuJzogdHJ1ZSxcbiAgJ3JhZGlvJzogdHJ1ZSxcbiAgJ3Jlc2V0JzogdHJ1ZSxcbiAgJ3N1Ym1pdCc6IHRydWVcbn07XG5cbmZ1bmN0aW9uIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpIHtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXRQcm9wcy52YWx1ZUxpbmsgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSB2YWx1ZUxpbmsuIElmIHlvdSB3YW50IHRvIHVzZSAnICsgJ2NoZWNrZWRMaW5rLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvIHVzZSB2YWx1ZUxpbmsgYW5kIHZpY2UgdmVyc2EuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMudmFsdWUgPT0gbnVsbCAmJiBpbnB1dFByb3BzLm9uQ2hhbmdlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgdmFsdWVMaW5rIGFuZCBhIHZhbHVlIG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCAnICsgJ3RvIHVzZSB2YWx1ZSBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIGNoZWNrZWRMaW5rIGFuZCBhIGNoZWNrZWQgcHJvcGVydHkgb3Igb25DaGFuZ2UgZXZlbnQuICcgKyAnSWYgeW91IHdhbnQgdG8gdXNlIGNoZWNrZWQgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gJyArICd1c2UgY2hlY2tlZExpbmsnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBwcm9wVHlwZXMgPSB7XG4gIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gIH0sXG4gIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBvbkNoYW5nZTogUmVhY3RQcm9wVHlwZXMuZnVuY1xufTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICovXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgb3duZXIpIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICAgIGlmIChwcm9wVHlwZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCB0YWdOYW1lLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgZm9ybSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSB2YWx1ZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRWYWx1ZTogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCBjaGVja2VkIHN0YXR1cyBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gY2hlY2tlZCBwcm9wXG4gICAqICAgICAgICAgICAgIG9yIGxpbmsuXG4gICAqL1xuICBnZXRDaGVja2VkOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAgICovXG4gIGV4ZWN1dGVPbkNoYW5nZTogZnVuY3Rpb24gKGlucHV0UHJvcHMsIGV2ZW50KSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5vbkNoYW5nZSkge1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMub25DaGFuZ2UuY2FsbCh1bmRlZmluZWQsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlsczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgT2JqZWN0LmFzc2lnblxuICovXG5cbi8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1vYmplY3QuYXNzaWduXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlcykge1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIHRhcmdldCBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgfVxuXG4gIHZhciB0byA9IE9iamVjdCh0YXJnZXQpO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIG5leHRJbmRleCA9IDE7IG5leHRJbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IG5leHRJbmRleCsrKSB7XG4gICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbbmV4dEluZGV4XTtcbiAgICBpZiAobmV4dFNvdXJjZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgZnJvbSA9IE9iamVjdChuZXh0U291cmNlKTtcblxuICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IGFjY2Vzc29ycyBub3IgcHJveGllcy4gVGhlcmVmb3JlIHRoaXNcbiAgICAvLyBjb3B5IGNhbm5vdCB0aHJvdy4gSWYgd2UgZXZlciBzdXBwb3J0ZWQgdGhpcyB0aGVuIHdlIG11c3QgaGFuZGxlXG4gICAgLy8gZXhjZXB0aW9ucyBhbmQgc2lkZS1lZmZlY3RzLiBXZSBkb24ndCBzdXBwb3J0IHN5bWJvbHMgc28gdGhleSB3b24ndFxuICAgIC8vIGJlIHRyYW5zZmVycmVkLlxuXG4gICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdG87XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBQb29sZWRDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgZml2ZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGluc3RhbmNlLmRlc3RydWN0b3IoKTtcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGggPCBLbGFzcy5wb29sU2l6ZSkge1xuICAgIEtsYXNzLmluc3RhbmNlUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufTtcblxudmFyIERFRkFVTFRfUE9PTF9TSVpFID0gMTA7XG52YXIgREVGQVVMVF9QT09MRVIgPSBvbmVBcmd1bWVudFBvb2xlcjtcblxuLyoqXG4gKiBBdWdtZW50cyBgQ29weUNvbnN0cnVjdG9yYCB0byBiZSBhIHBvb2xhYmxlIGNsYXNzLCBhdWdtZW50aW5nIG9ubHkgdGhlIGNsYXNzXG4gKiBpdHNlbGYgKHN0YXRpY2FsbHkpIG5vdCBhZGRpbmcgYW55IHByb3RvdHlwaWNhbCBmaWVsZHMuIEFueSBDb3B5Q29uc3RydWN0b3JcbiAqIHlvdSBnaXZlIHRoaXMgbWF5IGhhdmUgYSBgcG9vbFNpemVgIHByb3BlcnR5LCBhbmQgd2lsbCBsb29rIGZvciBhXG4gKiBwcm90b3R5cGljYWwgYGRlc3RydWN0b3JgIG9uIGluc3RhbmNlcyAob3B0aW9uYWwpLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvcHlDb25zdHJ1Y3RvciBDb25zdHJ1Y3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcG9vbGVyIEN1c3RvbWl6YWJsZSBwb29sZXIuXG4gKi9cbnZhciBhZGRQb29saW5nVG8gPSBmdW5jdGlvbiAoQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xuICBOZXdLbGFzcy5pbnN0YW5jZVBvb2wgPSBbXTtcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XG4gICAgTmV3S2xhc3MucG9vbFNpemUgPSBERUZBVUxUX1BPT0xfU0laRTtcbiAgfVxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcbiAgcmV0dXJuIE5ld0tsYXNzO1xufTtcblxudmFyIFBvb2xlZENsYXNzID0ge1xuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxuICB0d29Bcmd1bWVudFBvb2xlcjogdHdvQXJndW1lbnRQb29sZXIsXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXG4gIGZvdXJBcmd1bWVudFBvb2xlcjogZm91ckFyZ3VtZW50UG9vbGVyLFxuICBmaXZlQXJndW1lbnRQb29sZXI6IGZpdmVBcmd1bWVudFBvb2xlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJy4vUmVhY3RET00nKTtcbnZhciBSZWFjdERPTVNlcnZlciA9IHJlcXVpcmUoJy4vUmVhY3RET01TZXJ2ZXInKTtcbnZhciBSZWFjdElzb21vcnBoaWMgPSByZXF1aXJlKCcuL1JlYWN0SXNvbW9ycGhpYycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZGVwcmVjYXRlZCA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlZCcpO1xuXG4vLyBgdmVyc2lvbmAgd2lsbCBiZSBhZGRlZCBoZXJlIGJ5IFJlYWN0SXNvbW9ycGhpYy5cbnZhciBSZWFjdCA9IHt9O1xuXG5hc3NpZ24oUmVhY3QsIFJlYWN0SXNvbW9ycGhpYyk7XG5cbmFzc2lnbihSZWFjdCwge1xuICAvLyBSZWFjdERPTVxuICBmaW5kRE9NTm9kZTogZGVwcmVjYXRlZCgnZmluZERPTU5vZGUnLCAnUmVhY3RET00nLCAncmVhY3QtZG9tJywgUmVhY3RET00sIFJlYWN0RE9NLmZpbmRET01Ob2RlKSxcbiAgcmVuZGVyOiBkZXByZWNhdGVkKCdyZW5kZXInLCAnUmVhY3RET00nLCAncmVhY3QtZG9tJywgUmVhY3RET00sIFJlYWN0RE9NLnJlbmRlciksXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGRlcHJlY2F0ZWQoJ3VubW91bnRDb21wb25lbnRBdE5vZGUnLCAnUmVhY3RET00nLCAncmVhY3QtZG9tJywgUmVhY3RET00sIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUpLFxuXG4gIC8vIFJlYWN0RE9NU2VydmVyXG4gIHJlbmRlclRvU3RyaW5nOiBkZXByZWNhdGVkKCdyZW5kZXJUb1N0cmluZycsICdSZWFjdERPTVNlcnZlcicsICdyZWFjdC1kb20vc2VydmVyJywgUmVhY3RET01TZXJ2ZXIsIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKSxcbiAgcmVuZGVyVG9TdGF0aWNNYXJrdXA6IGRlcHJlY2F0ZWQoJ3JlbmRlclRvU3RhdGljTWFya3VwJywgJ1JlYWN0RE9NU2VydmVyJywgJ3JlYWN0LWRvbS9zZXJ2ZXInLCBSZWFjdERPTVNlcnZlciwgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdGF0aWNNYXJrdXApXG59KTtcblxuUmVhY3QuX19TRUNSRVRfRE9NX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdERPTTtcblJlYWN0Ll9fU0VDUkVUX0RPTV9TRVJWRVJfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0RE9NU2VydmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuS2V5ID0gJ19nZXRET01Ob2RlRGlkV2Fybic7XG5cbnZhciBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbiA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIERPTSBub2RlIHJlbmRlcmVkIGJ5IHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSBUaGUgcm9vdCBub2RlIG9mIHRoaXMgY29tcG9uZW50LlxuICAgKiBAZmluYWxcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0RE9NTm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHRoaXMuY29uc3RydWN0b3JbZGlkV2FybktleV0sICclcy5nZXRET01Ob2RlKC4uLikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAnICsgJ1JlYWN0RE9NLmZpbmRET01Ob2RlKGluc3RhbmNlKSBpbnN0ZWFkLicsIFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHRoaXMpLmdldE5hbWUoKSB8fCB0aGlzLnRhZ05hbWUgfHwgJ1Vua25vd24nKSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbnN0cnVjdG9yW2RpZFdhcm5LZXldID0gdHJ1ZTtcbiAgICByZXR1cm4gZmluZERPTU5vZGUodGhpcyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudEVtaXR0ZXJNaXhpbicpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcblxuLyoqXG4gKiBTdW1tYXJ5IG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGV2ZW50IGhhbmRsaW5nOlxuICpcbiAqICAtIFRvcC1sZXZlbCBkZWxlZ2F0aW9uIGlzIHVzZWQgdG8gdHJhcCBtb3N0IG5hdGl2ZSBicm93c2VyIGV2ZW50cy4gVGhpc1xuICogICAgbWF5IG9ubHkgb2NjdXIgaW4gdGhlIG1haW4gdGhyZWFkIGFuZCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2ZcbiAqICAgIFJlYWN0RXZlbnRMaXN0ZW5lciwgd2hpY2ggaXMgaW5qZWN0ZWQgYW5kIGNhbiB0aGVyZWZvcmUgc3VwcG9ydCBwbHVnZ2FibGVcbiAqICAgIGV2ZW50IHNvdXJjZXMuIFRoaXMgaXMgdGhlIG9ubHkgd29yayB0aGF0IG9jY3VycyBpbiB0aGUgbWFpbiB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IGZhbHNlO1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8vIEZvciBldmVudHMgbGlrZSAnc3VibWl0JyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHkgYnViYmxlICh3aGljaCB3ZSB0cmFwIGF0IGFcbi8vIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkIGNhdXNlIGR1cGxpY2F0ZVxuLy8gZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlXG52YXIgdG9wRXZlbnRNYXBwaW5nID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6ICdjb21wb3NpdGlvbmVuZCcsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6ICdjb21wb3NpdGlvbnN0YXJ0JyxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6ICdjb21wb3NpdGlvbnVwZGF0ZScsXG4gIHRvcENvbnRleHRNZW51OiAnY29udGV4dG1lbnUnLFxuICB0b3BDb3B5OiAnY29weScsXG4gIHRvcEN1dDogJ2N1dCcsXG4gIHRvcERvdWJsZUNsaWNrOiAnZGJsY2xpY2snLFxuICB0b3BEcmFnOiAnZHJhZycsXG4gIHRvcERyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgdG9wRHJhZ0VudGVyOiAnZHJhZ2VudGVyJyxcbiAgdG9wRHJhZ0V4aXQ6ICdkcmFnZXhpdCcsXG4gIHRvcERyYWdMZWF2ZTogJ2RyYWdsZWF2ZScsXG4gIHRvcERyYWdPdmVyOiAnZHJhZ292ZXInLFxuICB0b3BEcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICB0b3BEcm9wOiAnZHJvcCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wRm9jdXM6ICdmb2N1cycsXG4gIHRvcElucHV0OiAnaW5wdXQnLFxuICB0b3BLZXlEb3duOiAna2V5ZG93bicsXG4gIHRvcEtleVByZXNzOiAna2V5cHJlc3MnLFxuICB0b3BLZXlVcDogJ2tleXVwJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgdG9wTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIHRvcE1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnLFxuICB0b3BXaGVlbDogJ3doZWVsJ1xufTtcblxuLyoqXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxuICovXG52YXIgdG9wTGlzdGVuZXJzSURLZXkgPSAnX3JlYWN0TGlzdGVuZXJzSUQnICsgU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBpcyB1c2VkIHRvIGF0dGFjaCB0b3AtbGV2ZWwgZXZlbnQgbGlzdGVuZXJzLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIucHV0TGlzdGVuZXIoJ215SUQnLCAnb25DbGljaycsIG15RnVuY3Rpb24pO1xuICpcbiAqIFRoaXMgd291bGQgYWxsb2NhdGUgYSBcInJlZ2lzdHJhdGlvblwiIG9mIGAoJ29uQ2xpY2snLCBteUZ1bmN0aW9uKWAgb24gJ215SUQnLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gYXNzaWduKHt9LCBSZWFjdEV2ZW50RW1pdHRlck1peGluLCB7XG5cbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChSZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBpZiBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIShSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyICYmIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICB2YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICAgIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsKSB7XG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3doZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnd2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ21vdXNld2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICdtb3VzZXdoZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggbmVlZHMgdG8gY2FwdHVyZSBhIGRpZmZlcmVudCBtb3VzZSBzY3JvbGwgZXZlbnQuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy90ZXN0cy9zY3JvbGwuaHRtbFxuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wV2hlZWwsICdET01Nb3VzZVNjcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCkge1xuXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3Njcm9sbCcsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wU2Nyb2xsLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCwgJ3Njcm9sbCcsIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuV0lORE9XX0hBTkRMRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMgfHwgZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BCbHVyKSB7XG5cbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXMnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCAnZm9jdXMnLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BCbHVyLCAnYmx1cicsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnZm9jdXNpbicpKSB7XG4gICAgICAgICAgICAvLyBJRSBoYXMgYGZvY3VzaW5gIGFuZCBgZm9jdXNvdXRgIGV2ZW50cyB3aGljaCBidWJibGUuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDA4LzA0L2RlbGVnYXRpbmdfdGhlLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCAnZm9jdXNpbicsIG1vdW50QXQpO1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wQmx1ciwgJ2ZvY3Vzb3V0JywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BCbHVyXSA9IHRydWU7XG4gICAgICAgICAgaXNMaXN0ZW5pbmdbdG9wTGV2ZWxUeXBlcy50b3BGb2N1c10gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcEV2ZW50TWFwcGluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudChkZXBlbmRlbmN5LCB0b3BFdmVudE1hcHBpbmdbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0cmFwQnViYmxlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSk7XG4gIH0sXG5cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgcmV0dXJuIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbnMgdG8gd2luZG93IHNjcm9sbCBhbmQgcmVzaXplIGV2ZW50cy4gV2UgY2FjaGUgc2Nyb2xsIHZhbHVlcyBzbyB0aGF0XG4gICAqIGFwcGxpY2F0aW9uIGNvZGUgY2FuIGFjY2VzcyB0aGVtIHdpdGhvdXQgdHJpZ2dlcmluZyByZWZsb3dzLlxuICAgKlxuICAgKiBOT1RFOiBTY3JvbGwgZXZlbnRzIGRvIG5vdCBidWJibGUuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Njcm9sbC5odG1sXG4gICAqL1xuICBlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3Jpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlKSB7XG4gICAgICB2YXIgcmVmcmVzaCA9IFZpZXdwb3J0TWV0cmljcy5yZWZyZXNoU2Nyb2xsVmFsdWVzO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5tb25pdG9yU2Nyb2xsVmFsdWUocmVmcmVzaCk7XG4gICAgICBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogRXZlbnRQbHVnaW5IdWIuZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiBFdmVudFBsdWdpbkh1Yi5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblxuICBwdXRMaXN0ZW5lcjogRXZlbnRQbHVnaW5IdWIucHV0TGlzdGVuZXIsXG5cbiAgZ2V0TGlzdGVuZXI6IEV2ZW50UGx1Z2luSHViLmdldExpc3RlbmVyLFxuXG4gIGRlbGV0ZUxpc3RlbmVyOiBFdmVudFBsdWdpbkh1Yi5kZWxldGVMaXN0ZW5lcixcblxuICBkZWxldGVBbGxMaXN0ZW5lcnM6IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUFsbExpc3RlbmVyc1xuXG59KTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciwgJ1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicsIHtcbiAgcHV0TGlzdGVuZXI6ICdwdXRMaXN0ZW5lcicsXG4gIGRlbGV0ZUxpc3RlbmVyOiAnZGVsZXRlTGlzdGVuZXInXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRSZWNvbmNpbGVyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG5cbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGluc3RhbnRpYXRlQ2hpbGQoY2hpbGRJbnN0YW5jZXMsIGNoaWxkLCBuYW1lKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICB2YXIga2V5VW5pcXVlID0gY2hpbGRJbnN0YW5jZXNbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhrZXlVbmlxdWUsICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4nLCBuYW1lKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoY2hpbGQgIT0gbnVsbCAmJiBrZXlVbmlxdWUpIHtcbiAgICBjaGlsZEluc3RhbmNlc1tuYW1lXSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoY2hpbGQsIG51bGwpO1xuICB9XG59XG5cbi8qKlxuICogUmVhY3RDaGlsZFJlY29uY2lsZXIgcHJvdmlkZXMgaGVscGVycyBmb3IgaW5pdGlhbGl6aW5nIG9yIHVwZGF0aW5nIGEgc2V0IG9mXG4gKiBjaGlsZHJlbi4gSXRzIG91dHB1dCBpcyBzdWl0YWJsZSBmb3IgcGFzc2luZyBpdCBvbnRvIFJlYWN0TXVsdGlDaGlsZCB3aGljaFxuICogZG9lcyBkaWZmZWQgcmVvcmRlcmluZyBhbmQgaW5zZXJ0aW9uLlxuICovXG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZE5vZGVzIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgaWYgKG5lc3RlZENoaWxkTm9kZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZEluc3RhbmNlcyA9IHt9O1xuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgaW5zdGFudGlhdGVDaGlsZCwgY2hpbGRJbnN0YW5jZXMpO1xuICAgIHJldHVybiBjaGlsZEluc3RhbmNlcztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gYW5kIHJldHVybnMgYSBuZXcgc2V0IG9mIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q2hpbGRyZW4gRmxhdCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH0gQSBuZXcgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBkb24ndCBoYXZlIGEgd2F5IHRvIHRyYWNrIG1vdmVzIGhlcmUgYnV0IGlmIHdlIHVzZSBpdGVyYXRvcnNcbiAgICAvLyBpbnN0ZWFkIG9mIGZvci4uaW4gd2UgY2FuIHppcCB0aGUgaXRlcmF0b3JzIGFuZCBjaGVjayBpZiBhbiBpdGVtIGhhc1xuICAgIC8vIG1vdmVkLlxuICAgIC8vIFRPRE86IElmIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHJldHVybiB0aGUgcHJldkNoaWxkcmVuIG9iamVjdCBzbyB0aGF0IHdlXG4gICAgLy8gY2FuIHF1aWNrbHkgYmFpbG91dCBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLlxuICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbmFtZTtcbiAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldkNoaWxkICYmIHByZXZDaGlsZC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICBpZiAocHJldkNoaWxkICE9IG51bGwgJiYgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q2hpbGQsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IHByZXZDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICB2YXIgbmV4dENoaWxkSW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBudWxsKTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gbmV4dENoaWxkSW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVubW91bnQgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZHJlbltuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSByZW5kZXJlZENoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChyZW5kZXJlZENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHZhciByZW5kZXJlZENoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocmVuZGVyZWRDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZFJlY29uY2lsZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyO1xudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IFBvb2xlZENsYXNzLmZvdXJBcmd1bWVudFBvb2xlcjtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLyg/IVxcLykvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnLy8nKTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIHRyYXZlcnNhbC4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBGb3JFYWNoQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBmb3JFYWNoRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSB0cmF2ZXJzYWwgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBjb250ZXh0IHdpdGguXG4gKi9cbmZ1bmN0aW9uIEZvckVhY2hCb29rS2VlcGluZyhmb3JFYWNoRnVuY3Rpb24sIGZvckVhY2hDb250ZXh0KSB7XG4gIHRoaXMuZnVuYyA9IGZvckVhY2hGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gZm9yRWFjaENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuRm9yRWFjaEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oRm9yRWFjaEJvb2tLZWVwaW5nLCB0d29Bcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBGb3JFYWNoQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgRm9yRWFjaEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBQb29sZWRDbGFzcyByZXByZXNlbnRpbmcgdGhlIGJvb2trZWVwaW5nIGFzc29jaWF0ZWQgd2l0aCBwZXJmb3JtaW5nIGEgY2hpbGRcbiAqIG1hcHBpbmcuIEFsbG93cyBhdm9pZGluZyBiaW5kaW5nIGNhbGxiYWNrcy5cbiAqXG4gKiBAY29uc3RydWN0b3IgTWFwQm9va0tlZXBpbmdcbiAqIEBwYXJhbSB7ISp9IG1hcFJlc3VsdCBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBtYXBGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqIEBwYXJhbSB7Pyp9IG1hcENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIG1hcHBpbmcgd2l0aC5cbiAqL1xuZnVuY3Rpb24gTWFwQm9va0tlZXBpbmcobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIHRoaXMucmVzdWx0ID0gbWFwUmVzdWx0O1xuICB0aGlzLmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgdGhpcy5mdW5jID0gbWFwRnVuY3Rpb247XG4gIHRoaXMuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gIHRoaXMuY291bnQgPSAwO1xufVxuTWFwQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVzdWx0ID0gbnVsbDtcbiAgdGhpcy5rZXlQcmVmaXggPSBudWxsO1xuICB0aGlzLmZ1bmMgPSBudWxsO1xuICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICB0aGlzLmNvdW50ID0gMDtcbn07XG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oTWFwQm9va0tlZXBpbmcsIGZvdXJBcmd1bWVudFBvb2xlcik7XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0O1xuICB2YXIga2V5UHJlZml4ID0gYm9va0tlZXBpbmcua2V5UHJlZml4O1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmM7XG4gIHZhciBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxuICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkICE9PSBjaGlsZCA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkgfHwgJycpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xuICB2YXIgZXNjYXBlZFByZWZpeCA9ICcnO1xuICBpZiAocHJlZml4ICE9IG51bGwpIHtcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IE1hcEJvb2tLZWVwaW5nLmdldFBvb2xlZChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIE1hcEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBUaGUgcHJvdmlkZWQgbWFwRnVuY3Rpb24oY2hpbGQsIGtleSwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZnVuYywgY29udGV4dCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZER1bW15KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzXG4gKiBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSwgbnVsbCk7XG59XG5cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWFjdENoaWxkcmVuID0ge1xuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWw6IG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwsXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRyZW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2xhc3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIE1JWElOU19LRVkgPSBrZXlPZih7IG1peGluczogbnVsbCB9KTtcblxuLyoqXG4gKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuICovXG52YXIgU3BlY1BvbGljeSA9IGtleU1pcnJvcih7XG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBkZWZpbmVkIG9ubHkgb25jZSBieSB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBvciBtaXhpbi5cbiAgICovXG4gIERFRklORV9PTkNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBieSBib3RoIHRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIGFuZCBtaXhpbnMuXG4gICAqIFN1YnNlcXVlbnQgZGVmaW5pdGlvbnMgd2lsbCBiZSBjaGFpbmVkLiBUaGVzZSBtZXRob2RzIG11c3QgcmV0dXJuIHZvaWQuXG4gICAqL1xuICBERUZJTkVfTUFOWTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIG92ZXJyaWRpbmcgdGhlIGJhc2UgY2xhc3MuXG4gICAqL1xuICBPVkVSUklERV9CQVNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBhcmUgc2ltaWxhciB0byBERUZJTkVfTUFOWSwgZXhjZXB0IHdlIGFzc3VtZSB0aGV5IHJldHVyblxuICAgKiBvYmplY3RzLiBXZSB0cnkgdG8gbWVyZ2UgdGhlIGtleXMgb2YgdGhlIHJldHVybiB2YWx1ZXMgb2YgYWxsIHRoZSBtaXhlZCBpblxuICAgKiBmdW5jdGlvbnMuIElmIHRoZXJlIGlzIGEga2V5IGNvbmZsaWN0IHdlIHRocm93LlxuICAgKi9cbiAgREVGSU5FX01BTllfTUVSR0VEOiBudWxsXG59KTtcblxudmFyIGluamVjdGVkTWl4aW5zID0gW107XG5cbnZhciB3YXJuZWRTZXRQcm9wcyA9IGZhbHNlO1xuZnVuY3Rpb24gd2FyblNldFByb3BzKCkge1xuICBpZiAoIXdhcm5lZFNldFByb3BzKSB7XG4gICAgd2FybmVkU2V0UHJvcHMgPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnc2V0UHJvcHMoLi4uKSBhbmQgcmVwbGFjZVByb3BzKC4uLikgYXJlIGRlcHJlY2F0ZWQuICcgKyAnSW5zdGVhZCwgY2FsbCByZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIENvbXBvc2l0ZSBjb21wb25lbnRzIGFyZSBoaWdoZXItbGV2ZWwgY29tcG9uZW50cyB0aGF0IGNvbXBvc2Ugb3RoZXIgY29tcG9zaXRlXG4gKiBvciBuYXRpdmUgY29tcG9uZW50cy5cbiAqXG4gKiBUbyBjcmVhdGUgYSBuZXcgdHlwZSBvZiBgUmVhY3RDbGFzc2AsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXG4gKiB5b3VyIG5ldyBjbGFzcyB0byBgUmVhY3QuY3JlYXRlQ2xhc3NgLiBUaGUgb25seSByZXF1aXJlbWVudCBvZiB5b3VyIGNsYXNzXG4gKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBzdXBwb3J0cyBhIHNwZWNpZmljIHByb3RvY29sIG9mIG1ldGhvZHMgdGhhdCBoYXZlXG4gKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxuICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gKiBjbGFzcyBzcGVjaWZpY2F0aW9uIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZSBwcm90b3R5cGUuXG4gKlxuICogQGludGVyZmFjZSBSZWFjdENsYXNzSW50ZXJmYWNlXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0Q2xhc3NJbnRlcmZhY2UgPSB7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIE1peGluIG9iamVjdHMgdG8gaW5jbHVkZSB3aGVuIGRlZmluaW5nIHlvdXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7YXJyYXl9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgbWl4aW5zOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cbiAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHN0YXRpY3M6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgcHJvcCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgcHJvcFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjaGlsZENvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvLyA9PT09IERlZmluaXRpb24gbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgKlxuICAgKiAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAqICAgICByZXR1cm4ge1xuICAgKiAgICAgICBpc09uOiBmYWxzZSxcbiAgICogICAgICAgZm9vQmF6OiBuZXcgQmF6Rm9vKClcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRJbml0aWFsU3RhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0Q2hpbGRDb250ZXh0OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxuICAgKiBzdHJ1Y3R1cmUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xuICAgKiBpdCBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICpcbiAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgKiBAbm9zaWRlZWZmZWN0c1xuICAgKiBAcmVxdWlyZWRcbiAgICovXG4gIHJlbmRlcjogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICogYnkgdGhpcyBtZXRob2QgbXVzdCBiZSBjbGVhbmVkIHVwIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGAuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIGFuZCBoYXMgYSBET00gcmVwcmVzZW50YXRpb24uXG4gICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgKlxuICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgKiAgICAgICBsaWtlc0luY3JlYXNpbmc6IG5leHRQcm9wcy5saWtlQ291bnQgPiB0aGlzLnByb3BzLmxpa2VDb3VudFxuICAgKiAgICAgfSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAqIG5lZWQgaXQsIHlvdSBhcmUgcHJvYmFibHkgbG9va2luZyBmb3IgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICogdXBkYXRlLlxuICAgKlxuICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICByZXR1cm4gIWVxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAqIGFuZCBgbmV4dENvbnRleHRgLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgKlxuICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNvbnRleHRcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCBoYXZlXG4gICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBkZWFsbG9jYXRlIGFueSBleHRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgKiBkZXN0cm95ZWQgYnkgdGhhdCBwb2ludC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvLyA9PT09IEFkdmFuY2VkIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IFNwZWNQb2xpY3kuT1ZFUlJJREVfQkFTRVxuXG59O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBjbGFzcyBzcGVjaWZpY2F0aW9uIGtleXMgdG8gc3BlY2lhbCBwcm9jZXNzaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbHRob3VnaCB0aGVzZSBhcmUgZGVjbGFyZWQgbGlrZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGluIHRoZSBzcGVjaWZpY2F0aW9uXG4gKiB3aGVuIGRlZmluaW5nIGNsYXNzZXMgdXNpbmcgYFJlYWN0LmNyZWF0ZUNsYXNzYCwgdGhleSBhcmUgYWN0dWFsbHkgc3RhdGljXG4gKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICogYmVpbmcgc3RhdGljLCB0aGV5IG11c3QgYmUgZGVmaW5lZCBvdXRzaWRlIG9mIHRoZSBcInN0YXRpY3NcIiBrZXkgdW5kZXJcbiAqIHdoaWNoIGFsbCBvdGhlciBzdGF0aWMgbWV0aG9kcyBhcmUgZGVmaW5lZC5cbiAqL1xudmFyIFJFU0VSVkVEX1NQRUNfS0VZUyA9IHtcbiAgZGlzcGxheU5hbWU6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICB9LFxuICBtaXhpbnM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgbWl4aW5zKSB7XG4gICAgaWYgKG1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIG1peGluc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjaGlsZENvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID0gYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0VHlwZXMpO1xuICB9LFxuICBjb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHQpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBhc3NpZ24oe30sIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcywgY29udGV4dFR5cGVzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsIGdldERlZmF1bHRQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcbiAgICB9XG4gIH0sXG4gIHByb3BUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IGFzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICB9LFxuICBzdGF0aWNzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XG4gIH0sXG4gIGF1dG9iaW5kOiBmdW5jdGlvbiAoKSB7fSB9O1xuXG4vLyBub29wXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHR5cGVEZWYsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICBpZiAodHlwZURlZi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIC8vIHVzZSBhIHdhcm5pbmcgaW5zdGVhZCBvZiBhbiBpbnZhcmlhbnQgc28gY29tcG9uZW50c1xuICAgICAgLy8gZG9uJ3Qgc2hvdyB1cCBpbiBwcm9kIGJ1dCBub3QgaW4gX19ERVZfX1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIHR5cGVEZWZbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKHByb3RvLCBuYW1lKSB7XG4gIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV0gOiBudWxsO1xuXG4gIC8vIERpc2FsbG93IG92ZXJyaWRpbmcgb2YgYmFzZSBjbGFzcyBtZXRob2RzIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChSZWFjdENsYXNzTWl4aW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuT1ZFUlJJREVfQkFTRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIG92ZXJyaWRlICcgKyAnYCVzYCBmcm9tIHlvdXIgY2xhc3Mgc3BlY2lmaWNhdGlvbi4gRW5zdXJlIHRoYXQgeW91ciBtZXRob2QgbmFtZXMgJyArICdkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gRGlzYWxsb3cgZGVmaW5pbmcgbWV0aG9kcyBtb3JlIHRoYW4gb25jZSB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgJyArICd0byBhIG1peGluLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuICogc3BlY2lmaWNhdGlvbiBrZXlzIHdoZW4gYnVpbGRpbmcgUmVhY3QgY2xhc3NzZXMuXG4gKi9cbmZ1bmN0aW9uIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKSB7XG4gIGlmICghc3BlYykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gICEodHlwZW9mIHNwZWMgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gJyArICd1c2UgYSBjb21wb25lbnQgY2xhc3MgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICEhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHNwZWMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gJyArICd1c2UgYSBjb21wb25lbnQgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gIC8vIEJ5IGhhbmRsaW5nIG1peGlucyBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMsIHdlIGVuc3VyZSB0aGUgc2FtZVxuICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgLy8gbWl4aW5zIGFyZSBsaXN0ZWQgYmVmb3JlIG9yIGFmdGVyIHRoZXNlIG1ldGhvZHMgaW4gdGhlIHNwZWMuXG4gIGlmIChzcGVjLmhhc093blByb3BlcnR5KE1JWElOU19LRVkpKSB7XG4gICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzcGVjKSB7XG4gICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgbWl4aW5zIGluIGEgc3BlY2lhbCBjYXNlIGFib3ZlLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BlcnR5ID0gc3BlY1tuYW1lXTtcbiAgICB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKHByb3RvLCBuYW1lKTtcblxuICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIFJFU0VSVkVEX1NQRUNfS0VZU1tuYW1lXShDb25zdHJ1Y3RvciwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbWVtYmVyIG1ldGhvZHMgc2hvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kOlxuICAgICAgLy8gMS4gRXhwZWN0ZWQgUmVhY3RDbGFzcyBtZXRob2RzIChpbiB0aGUgXCJpbnRlcmZhY2VcIikuXG4gICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICB2YXIgaXNSZWFjdENsYXNzTWV0aG9kID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhciBpc0FscmVhZHlEZWZpbmVkID0gcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIHZhciBzaG91bGRBdXRvQmluZCA9IGlzRnVuY3Rpb24gJiYgIWlzUmVhY3RDbGFzc01ldGhvZCAmJiAhaXNBbHJlYWR5RGVmaW5lZCAmJiBzcGVjLmF1dG9iaW5kICE9PSBmYWxzZTtcblxuICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgIGlmICghcHJvdG8uX19yZWFjdEF1dG9CaW5kTWFwKSB7XG4gICAgICAgICAgcHJvdG8uX19yZWFjdEF1dG9CaW5kTWFwID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcHJvdG8uX19yZWFjdEF1dG9CaW5kTWFwW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXTtcblxuICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICEoaXNSZWFjdENsYXNzTWV0aG9kICYmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCB8fCBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzICcgKyAnd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsIHNwZWNQb2xpY3ksIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgIC8vIG1ldGhvZHMgYmVmb3JlIGNhbGxpbmcgdGhlIG5ldyBwcm9wZXJ0eSwgbWVyZ2luZyBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICBpZiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEFkZCB2ZXJib3NlIGRpc3BsYXlOYW1lIHRvIHRoZSBmdW5jdGlvbiwgd2hpY2ggaGVscHMgd2hlbiBsb29raW5nXG4gICAgICAgICAgICAvLyBhdCBwcm9maWxpbmcgdG9vbHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgcHJvdG9bbmFtZV0uZGlzcGxheU5hbWUgPSBzcGVjLmRpc3BsYXlOYW1lICsgJ18nICsgbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgaWYgKCFzdGF0aWNzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIG5hbWUgaW4gc3RhdGljcykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XG4gICAgaWYgKCFzdGF0aWNzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IChuYW1lIGluIFJFU0VSVkVEX1NQRUNfS0VZUyk7XG4gICAgISFpc1Jlc2VydmVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCAnICsgJ3Byb3BlcnR5LCBgJXNgLCB0aGF0IHNob3VsZG5cXCd0IGJlIG9uIHRoZSBcInN0YXRpY3NcIiBrZXkuIERlZmluZSBpdCAnICsgJ2FzIGFuIGluc3RhbmNlIHByb3BlcnR5IGluc3RlYWQ7IGl0IHdpbGwgc3RpbGwgYmUgYWNjZXNzaWJsZSBvbiB0aGUgJyArICdjb25zdHJ1Y3Rvci4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgaXNJbmhlcml0ZWQgPSAobmFtZSBpbiBDb25zdHJ1Y3Rvcik7XG4gICAgISFpc0luaGVyaXRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgKyAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgJyArICdkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcbiAgIShvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgIShvbmVba2V5XSA9PT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6ICcgKyAnVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgJyArICdtYXkgYmUgZHVlIHRvIGEgbWl4aW47IGluIHBhcnRpY3VsYXIsIHRoaXMgbWF5IGJlIGNhdXNlZCBieSB0d28gJyArICdnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzICcgKyAnd2l0aCBjbGFzaGluZyBrZXlzLicsIGtleSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9uZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciBjID0ge307XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIEJpbmRzIGEgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1ldGhvZCB0byBiZSBib3VuZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpIHtcbiAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lO1xuICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgLyogZXNsaW50LWRpc2FibGUgYmxvY2stc2NvcGVkLXZhciwgbm8tdW5kZWYgKi9cbiAgICBib3VuZE1ldGhvZC5iaW5kID0gZnVuY3Rpb24gKG5ld1RoaXMpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlciBpcyB0cnlpbmcgdG8gYmluZCgpIGFuIGF1dG9ib3VuZCBtZXRob2Q7IHdlIGVmZmVjdGl2ZWx5IHdpbGxcbiAgICAgIC8vIGlnbm9yZSB0aGUgdmFsdWUgb2YgXCJ0aGlzXCIgdGhhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG8gdXNlLCBzb1xuICAgICAgLy8gbGV0J3Mgd2Fybi5cbiAgICAgIGlmIChuZXdUaGlzICE9PSBjb21wb25lbnQgJiYgbmV3VGhpcyAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgKyAnY29tcG9uZW50IGluc3RhbmNlLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBZb3UgYXJlIGJpbmRpbmcgYSBjb21wb25lbnQgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuICcgKyAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArICd3YXksIHNvIHlvdSBjYW4gc2FmZWx5IHJlbW92ZSB0aGlzIGNhbGwuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgICB9XG4gICAgICB2YXIgcmVib3VuZE1ldGhvZCA9IF9iaW5kLmFwcGx5KGJvdW5kTWV0aG9kLCBhcmd1bWVudHMpO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICByZXR1cm4gcmVib3VuZE1ldGhvZDtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICB9O1xuICB9XG4gIHJldHVybiBib3VuZE1ldGhvZDtcbn1cblxuLyoqXG4gKiBCaW5kcyBhbGwgYXV0by1ib3VuZCBtZXRob2RzIGluIGEgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kcyhjb21wb25lbnQpIHtcbiAgZm9yICh2YXIgYXV0b0JpbmRLZXkgaW4gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgIGlmIChjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kTWFwLmhhc093blByb3BlcnR5KGF1dG9CaW5kS2V5KSkge1xuICAgICAgdmFyIG1ldGhvZCA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXBbYXV0b0JpbmRLZXldO1xuICAgICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxuICovXG52YXIgUmVhY3RDbGFzc01peGluID0ge1xuXG4gIC8qKlxuICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcbiAgICogdHlwZSBzaWduYXR1cmUgYW5kIHRoZSBvbmx5IHVzZSBjYXNlIGZvciB0aGlzLCBpcyB0byBhdm9pZCB0aGF0LlxuICAgKi9cbiAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAobmV3U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlci5pc01vdW50ZWQodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFByb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBwcm9wcyBhcmUgdXBkYXRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBwdWJsaWNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHNldFByb3BzOiBmdW5jdGlvbiAocGFydGlhbFByb3BzLCBjYWxsYmFjaykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuU2V0UHJvcHMoKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRQcm9wcyh0aGlzLCBwYXJ0aWFsUHJvcHMpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIGFsbCB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wcyBTdWJzZXQgb2YgdGhlIG5leHQgcHJvcHMuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHVibGljXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICByZXBsYWNlUHJvcHM6IGZ1bmN0aW9uIChuZXdQcm9wcywgY2FsbGJhY2spIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FyblNldFByb3BzKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVByb3BzKHRoaXMsIG5ld1Byb3BzKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFJlYWN0Q2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7fTtcbmFzc2lnbihSZWFjdENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENsYXNzTWl4aW4pO1xuXG4vKipcbiAqIE1vZHVsZSBmb3IgY3JlYXRpbmcgY29tcG9zaXRlIGNvbXBvbmVudHMuXG4gKlxuICogQGNsYXNzIFJlYWN0Q2xhc3NcbiAqL1xudmFyIFJlYWN0Q2xhc3MgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjcmVhdGVDbGFzczogZnVuY3Rpb24gKHNwZWMpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIC8vIFRoaXMgY29uc3RydWN0b3IgaXMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAgIC8vIGJ5IG1vY2tzIHRvIGFzc2VydCBvbiB3aGF0IGdldHMgbW91bnRlZC5cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLCAnU29tZXRoaW5nIGlzIGNhbGxpbmcgYSBSZWFjdCBjb21wb25lbnQgZGlyZWN0bHkuIFVzZSBhIGZhY3Rvcnkgb3IgJyArICdKU1ggaW5zdGVhZC4gU2VlOiBodHRwczovL2ZiLm1lL3JlYWN0LWxlZ2FjeWZhY3RvcnknKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gV2lyZSB1cCBhdXRvLWJpbmRpbmdcbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgICAgLy8gUmVhY3RDbGFzc2VzIGRvZXNuJ3QgaGF2ZSBjb25zdHJ1Y3RvcnMuIEluc3RlYWQsIHRoZXkgdXNlIHRoZVxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJyAmJiB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgfTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDbGFzc0NvbXBvbmVudCgpO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuXG4gICAgaW5qZWN0ZWRNaXhpbnMuZm9yRWFjaChtaXhTcGVjSW50b0NvbXBvbmVudC5iaW5kKG51bGwsIENvbnN0cnVjdG9yKSk7XG5cbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0TWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgaW5qZWN0ZWRNaXhpbnMucHVzaChtaXhpbik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDbGFzczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBSZWFjdENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSAnICsgJ2Z1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocGFydGlhbFN0YXRlICE9IG51bGwsICdzZXRTdGF0ZSguLi4pOiBZb3UgcGFzc2VkIGFuIHVuZGVmaW5lZCBvciBudWxsIHN0YXRlIG9iamVjdDsgJyArICdpbnN0ZWFkLCB1c2UgZm9yY2VVcGRhdGUoKS4nKSA6IHVuZGVmaW5lZDtcbiAgfVxuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGdldERPTU5vZGU6IFsnZ2V0RE9NTm9kZScsICdVc2UgUmVhY3RET00uZmluZERPTU5vZGUoY29tcG9uZW50KSBpbnN0ZWFkLiddLFxuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlUHJvcHM6IFsncmVwbGFjZVByb3BzJywgJ0luc3RlYWQsIGNhbGwgcmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ10sXG4gICAgc2V0UHJvcHM6IFsnc2V0UHJvcHMnLCAnSW5zdGVhZCwgY2FsbCByZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdERPTUlET3BlcmF0aW9ucycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxuLyoqXG4gKiBBYnN0cmFjdHMgYXdheSBhbGwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgcmVjb25jaWxlciB0aGF0IHJlcXVpcmVzIGtub3dsZWRnZSBvZlxuICogdGhlIGJyb3dzZXIgY29udGV4dC4gVE9ETzogVGhlc2UgY2FsbGVycyBzaG91bGQgYmUgcmVmYWN0b3JlZCB0byBhdm9pZCB0aGVcbiAqIG5lZWQgZm9yIHRoaXMgaW5qZWN0aW9uLlxuICovXG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSB7XG5cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogUmVhY3RET01JRE9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzLFxuXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCxcblxuICAvKipcbiAgICogSWYgYSBwYXJ0aWN1bGFyIGVudmlyb25tZW50IHJlcXVpcmVzIHRoYXQgc29tZSByZXNvdXJjZXMgYmUgY2xlYW5lZCB1cCxcbiAgICogc3BlY2lmeSB0aGlzIGluIHRoZSBpbmplY3RlZCBNaXhpbi4gSW4gdGhlIERPTSwgd2Ugd291bGQgbGlrZWx5IHdhbnQgdG9cbiAgICogcHVyZ2UgYW55IGNhY2hlZCBub2RlIElEIGxvb2t1cHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bm1vdW50SURGcm9tRW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChyb290Tm9kZUlEKSB7XG4gICAgUmVhY3RNb3VudC5wdXJnZUlEKHJvb3ROb2RlSUQpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGluamVjdGVkID0gZmFsc2U7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0ge1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgZW52aXJvbm1lbnQgZGVwZW5kZW50IGNsZWFudXAgaG9vay4gKHNlcnZlciB2cy5cbiAgICogYnJvd3NlciBldGMpLiBFeGFtcGxlOiBBIGJyb3dzZXIgc3lzdGVtIGNhY2hlcyBET00gbm9kZXMgYmFzZWQgb24gY29tcG9uZW50XG4gICAqIElEIGFuZCBtdXN0IHJlbW92ZSB0aGF0IGNhY2hlIGVudHJ5IHdoZW4gdGhpcyBpbnN0YW5jZSBpcyB1bm1vdW50ZWQuXG4gICAqL1xuICB1bm1vdW50SURGcm9tRW52aXJvbm1lbnQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBob29rIGZvciBzd2FwcGluZyBvdXQgbW91bnQgaW1hZ2VzIGluIHRoZSBtaWRkbGUgb2ZcbiAgICogdGhlIHRyZWUuXG4gICAqL1xuICByZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiBudWxsLFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlIG9mIGNoaWxkIHVwZGF0ZXMuIFdpbGxcbiAgICogbGF0ZXIgbW92ZSBpbnRvIE11bHRpQ2hpbGRDb21wb25lbnRzLlxuICAgKi9cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RFbnZpcm9ubWVudDogZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XG4gICAgICAhIWluamVjdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50OiBpbmplY3RFbnZpcm9ubWVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQudW5tb3VudElERnJvbUVudmlyb25tZW50ID0gZW52aXJvbm1lbnQudW5tb3VudElERnJvbUVudmlyb25tZW50O1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEID0gZW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyA9IGVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXM7XG4gICAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDb21wb3NpdGVDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkge1xuICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciB8fCBudWxsO1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBTdGF0ZWxlc3NDb21wb25lbnQoQ29tcG9uZW50KSB7fVxuU3RhdGVsZXNzQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBDb21wb25lbnQgPSBSZWFjdEluc3RhbmNlTWFwLmdldCh0aGlzKS5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgcmV0dXJuIENvbXBvbmVudCh0aGlzLnByb3BzLCB0aGlzLmNvbnRleHQsIHRoaXMudXBkYXRlcik7XG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLSBUaGUgTGlmZS1DeWNsZSBvZiBhIENvbXBvc2l0ZSBDb21wb25lbnQgLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogLSBjb25zdHJ1Y3RvcjogSW5pdGlhbGl6YXRpb24gb2Ygc3RhdGUuIFRoZSBpbnN0YW5jZSBpcyBub3cgcmV0YWluZWQuXG4gKiAgIC0gY29tcG9uZW50V2lsbE1vdW50XG4gKiAgIC0gcmVuZGVyXG4gKiAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXJdXG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnREaWRNb3VudF1cbiAqICAgICAtIGNvbXBvbmVudERpZE1vdW50XG4gKlxuICogICAgICAgVXBkYXRlIFBoYXNlczpcbiAqICAgICAgIC0gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAob25seSBjYWxsZWQgaWYgcGFyZW50IHVwZGF0ZWQpXG4gKiAgICAgICAtIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICogICAgICAgICAtIGNvbXBvbmVudFdpbGxVcGRhdGVcbiAqICAgICAgICAgICAtIHJlbmRlclxuICogICAgICAgICAgIC0gW2NoaWxkcmVuJ3MgY29uc3RydWN0b3JzIG9yIHJlY2VpdmUgcHJvcHMgcGhhc2VzXVxuICogICAgICAgICAtIGNvbXBvbmVudERpZFVwZGF0ZVxuICpcbiAqICAgICAtIGNvbXBvbmVudFdpbGxVbm1vdW50XG4gKiAgICAgLSBbY2hpbGRyZW4ncyBjb21wb25lbnRXaWxsVW5tb3VudF1cbiAqICAgLSBbY2hpbGRyZW4gZGVzdHJveWVkXVxuICogLSAoZGVzdHJveWVkKTogVGhlIGluc3RhbmNlIGlzIG5vdyBibGFuaywgcmVsZWFzZWQgYnkgUmVhY3QgYW5kIHJlYWR5IGZvciBHQy5cbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogQW4gaW5jcmVtZW50aW5nIElEIGFzc2lnbmVkIHRvIGVhY2ggY29tcG9uZW50IHdoZW4gaXQgaXMgbW91bnRlZC4gVGhpcyBpc1xuICogdXNlZCB0byBlbmZvcmNlIHRoZSBvcmRlciBpbiB3aGljaCBgUmVhY3RVcGRhdGVzYCB1cGRhdGVzIGRpcnR5IGNvbXBvbmVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIG5leHRNb3VudElEID0gMTtcblxuLyoqXG4gKiBAbGVuZHMge1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LnByb3RvdHlwZX1cbiAqL1xudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4gPSB7XG5cbiAgLyoqXG4gICAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBjb21wb3NpdGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG5cbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gMDtcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlcyBhbmQgUmVhY3RVcGRhdGVRdWV1ZS5cbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IG5leHRNb3VudElEKys7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IHJvb3RJRDtcblxuICAgIHZhciBwdWJsaWNQcm9wcyA9IHRoaXMuX3Byb2Nlc3NQcm9wcyh0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcyk7XG4gICAgdmFyIHB1YmxpY0NvbnRleHQgPSB0aGlzLl9wcm9jZXNzQ29udGV4dChjb250ZXh0KTtcblxuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgcHVibGljIGNsYXNzXG4gICAgdmFyIGluc3Q7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcblxuICAgIC8vIFRoaXMgaXMgYSB3YXkgdG8gZGV0ZWN0IGlmIENvbXBvbmVudCBpcyBhIHN0YXRlbGVzcyBhcnJvdyBmdW5jdGlvblxuICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggaXMgbm90IG5ld2FibGUuIEl0IG1pZ2h0IG5vdCBiZSAxMDAlIHJlbGlhYmxlIGJ1dCBpc1xuICAgIC8vIHNvbWV0aGluZyB3ZSBjYW4gZG8gdW50aWwgd2Ugc3RhcnQgZGV0ZWN0aW5nIHRoYXQgQ29tcG9uZW50IGV4dGVuZHNcbiAgICAvLyBSZWFjdC5Db21wb25lbnQuIFdlIGFscmVhZHkgYXNzdW1lIHRoYXQgdHlwZW9mIENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJy5cbiAgICB2YXIgY2FuSW5zdGFudGlhdGUgPSAoJ3Byb3RvdHlwZScgaW4gQ29tcG9uZW50KTtcblxuICAgIGlmIChjYW5JbnN0YW50aWF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5zdCA9IG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIFJlYWN0VXBkYXRlUXVldWUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0ID0gbmV3IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgUmVhY3RVcGRhdGVRdWV1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjYW5JbnN0YW50aWF0ZSB8fCBpbnN0ID09PSBudWxsIHx8IGluc3QgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChpbnN0KSkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gaW5zdDtcbiAgICAgIGluc3QgPSBuZXcgU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBsYXRlciBpbiBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50LCBidXQgYWRkIGFuIGVhcmx5XG4gICAgICAvLyB3YXJuaW5nIG5vdyB0byBoZWxwIGRlYnVnZ2luZ1xuICAgICAgaWYgKGluc3QucmVuZGVyID09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYCwgcmV0dXJuZWQgJyArICdudWxsL2ZhbHNlIGZyb20gYSBzdGF0ZWxlc3MgY29tcG9uZW50LCBvciB0cmllZCB0byByZW5kZXIgYW4gJyArICdlbGVtZW50IHdob3NlIHR5cGUgaXMgYSBmdW5jdGlvbiB0aGF0IGlzblxcJ3QgYSBSZWFjdCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIHN1cHBvcnQgRVM2IGluaGVyaXRpbmcgZnJvbSBSZWFjdC5Db21wb25lbnQsIHRoZSBtb2R1bGUgcGF0dGVybixcbiAgICAgICAgLy8gYW5kIHN0YXRlbGVzcyBjb21wb25lbnRzLCBidXQgbm90IEVTNiBjbGFzc2VzIHRoYXQgZG9uJ3QgZXh0ZW5kXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50IHx8ICFjYW5JbnN0YW50aWF0ZSB8fCAhKGluc3QgaW5zdGFuY2VvZiBDb21wb25lbnQpLCAnJXMoLi4uKTogUmVhY3QgY29tcG9uZW50IGNsYXNzZXMgbXVzdCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2Ugc2hvdWxkIGJlIHNldCB1cCBpbiB0aGUgY29uc3RydWN0b3IsIGJ1dCBhcyBhIGNvbnZlbmllbmNlIGZvclxuICAgIC8vIHNpbXBsZXIgY2xhc3MgYWJzdHJhY3Rpb25zLCB3ZSBzZXQgdGhlbSB1cCBhZnRlciB0aGUgZmFjdC5cbiAgICBpbnN0LnByb3BzID0gcHVibGljUHJvcHM7XG4gICAgaW5zdC5jb250ZXh0ID0gcHVibGljQ29udGV4dDtcbiAgICBpbnN0LnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICBpbnN0LnVwZGF0ZXIgPSBSZWFjdFVwZGF0ZVF1ZXVlO1xuXG4gICAgdGhpcy5faW5zdGFuY2UgPSBpbnN0O1xuXG4gICAgLy8gU3RvcmUgYSByZWZlcmVuY2UgZnJvbSB0aGUgaW5zdGFuY2UgYmFjayB0byB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICBSZWFjdEluc3RhbmNlTWFwLnNldChpbnN0LCB0aGlzKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBTaW5jZSBwbGFpbiBKUyBjbGFzc2VzIGFyZSBkZWZpbmVkIHdpdGhvdXQgYW55IHNwZWNpYWwgaW5pdGlhbGl6YXRpb25cbiAgICAgIC8vIGxvZ2ljLCB3ZSBjYW4gbm90IGNhdGNoIGNvbW1vbiBlcnJvcnMgZWFybHkuIFRoZXJlZm9yZSwgd2UgaGF2ZSB0b1xuICAgICAgLy8gY2F0Y2ggdGhlbSBoZXJlLCBhdCBpbml0aWFsaXphdGlvbiB0aW1lLCBpbnN0ZWFkLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3QuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3QuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5wcm9wVHlwZXMsICdwcm9wVHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBwcm9wVHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmNvbnRleHRUeXBlcywgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgJyArICdzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbicsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdC5zdGF0ZSA9IGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgICEodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoaW5pdGlhbFN0YXRlKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxNb3VudCkge1xuICAgICAgaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIC8vIFdoZW4gbW91bnRpbmcsIGNhbGxzIHRvIGBzZXRTdGF0ZWAgYnkgYGNvbXBvbmVudFdpbGxNb3VudGAgd2lsbCBzZXRcbiAgICAgIC8vIGB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZWAgd2l0aG91dCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyLlxuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIGluc3Quc3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKGluc3QucHJvcHMsIGluc3QuY29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90IGEgc3RhdGVsZXNzIGNvbXBvbmVudCwgd2Ugbm93IHJlbmRlclxuICAgIGlmIChyZW5kZXJlZEVsZW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KHJlbmRlcmVkRWxlbWVudCk7XG5cbiAgICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LCByb290SUQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICBpZiAoaW5zdC5jb21wb25lbnREaWRNb3VudCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZE1vdW50LCBpbnN0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbnkgcmVzb3VyY2VzIGFsbG9jYXRlZCBieSBgbW91bnRDb21wb25lbnRgLlxuICAgKlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XG4gICAgICBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgfVxuXG4gICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAvLyBSZXNldCBwZW5kaW5nIGZpZWxkc1xuICAgIC8vIEV2ZW4gaWYgdGhpcyBjb21wb25lbnQgaXMgc2NoZWR1bGVkIGZvciBhbm90aGVyIHVwZGF0ZSBpbiBSZWFjdFVwZGF0ZXMsXG4gICAgLy8gaXQgd291bGQgc3RpbGwgYmUgaWdub3JlZCBiZWNhdXNlIHRoZXNlIGZpZWxkcyBhcmUgcmVzZXQuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICAvLyBUaGVzZSBmaWVsZHMgZG8gbm90IHJlYWxseSBuZWVkIHRvIGJlIHJlc2V0IHNpbmNlIHRoaXMgb2JqZWN0IGlzIG5vXG4gICAgLy8gbG9uZ2VyIGFjY2Vzc2libGUuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIERlbGV0ZSB0aGUgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIHRvIHRoaXMgaW50ZXJuYWwgcmVwcmVzZW50YXRpb25cbiAgICAvLyB3aGljaCBhbGxvdyB0aGUgaW50ZXJuYWxzIHRvIGJlIHByb3Blcmx5IGNsZWFuZWQgdXAgZXZlbiBpZiB0aGUgdXNlclxuICAgIC8vIGxlYWtzIGEgcmVmZXJlbmNlIHRvIHRoZSBwdWJsaWMgaW5zdGFuY2UuXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5yZW1vdmUoaW5zdCk7XG5cbiAgICAvLyBTb21lIGV4aXN0aW5nIGNvbXBvbmVudHMgcmVseSBvbiBpbnN0LnByb3BzIGV2ZW4gYWZ0ZXIgdGhleSd2ZSBiZWVuXG4gICAgLy8gZGVzdHJveWVkIChpbiBldmVudCBoYW5kbGVycykuXG4gICAgLy8gVE9ETzogaW5zdC5wcm9wcyA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5zdGF0ZSA9IG51bGw7XG4gICAgLy8gVE9ETzogaW5zdC5jb250ZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWFza0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSBudWxsO1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBDb21wb25lbnQuY29udGV4dFR5cGVzO1xuICAgIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgfVxuICAgIG1hc2tlZENvbnRleHQgPSB7fTtcbiAgICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICAgIG1hc2tlZENvbnRleHRbY29udGV4dE5hbWVdID0gY29udGV4dFtjb250ZXh0TmFtZV07XG4gICAgfVxuICAgIHJldHVybiBtYXNrZWRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRoZSBjb250ZXh0IG9iamVjdCB0byBvbmx5IGNvbnRhaW4ga2V5cyBzcGVjaWZpZWQgaW5cbiAgICogYGNvbnRleHRUeXBlc2AsIGFuZCBhc3NlcnRzIHRoYXQgdGhleSBhcmUgdmFsaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4gez9vYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG1hc2tlZENvbnRleHQgPSB0aGlzLl9tYXNrQ29udGV4dChjb250ZXh0KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICBpZiAoQ29tcG9uZW50LmNvbnRleHRUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhDb21wb25lbnQuY29udGV4dFR5cGVzLCBtYXNrZWRDb250ZXh0LCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRDb250ZXh0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoY3VycmVudENvbnRleHQpIHtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCAmJiBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xuICAgIGlmIChjaGlsZENvbnRleHQpIHtcbiAgICAgICEodHlwZW9mIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcyA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY2hpbGRDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAgICEobmFtZSBpbiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhc3NpZ24oe30sIGN1cnJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBwcm9wcyBieSBzZXR0aW5nIGRlZmF1bHQgdmFsdWVzIGZvciB1bnNwZWNpZmllZCBwcm9wcyBhbmRcbiAgICogYXNzZXJ0aW5nIHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZC4gRG9lcyBub3QgbXV0YXRlIGl0cyBhcmd1bWVudDsgcmV0dXJuc1xuICAgKiBhIG5ldyBwcm9wcyBvYmplY3Qgd2l0aCBkZWZhdWx0cyBtZXJnZWQgaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wc1xuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc1Byb3BzOiBmdW5jdGlvbiAobmV3UHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICBpZiAoQ29tcG9uZW50LnByb3BUeXBlcykge1xuICAgICAgICB0aGlzLl9jaGVja1Byb3BUeXBlcyhDb21wb25lbnQucHJvcFR5cGVzLCBuZXdQcm9wcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1Byb3BzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCB0aGUgcHJvcHMgYXJlIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wVHlwZXMgTWFwIG9mIHByb3AgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHByb3BUeXBlcywgcHJvcHMsIGxvY2F0aW9uKSB7XG4gICAgLy8gVE9ETzogU3RvcCB2YWxpZGF0aW5nIHByb3AgdHlwZXMgaGVyZSBhbmQgb25seSB1c2UgdGhlIGVsZW1lbnRcbiAgICAvLyB2YWxpZGF0aW9uLlxuICAgIHZhciBjb21wb25lbnROYW1lID0gdGhpcy5nZXROYW1lKCk7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XG4gICAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgICEodHlwZW9mIHByb3BUeXBlc1twcm9wTmFtZV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5ICcgKyAnZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24pO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAvLyBXZSBtYXkgd2FudCB0byBleHRlbmQgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBlcnJvcnMgaW5cbiAgICAgICAgICAvLyB0b3AtbGV2ZWwgcmVuZGVyIGNhbGxzLCBzbyBJJ20gYWJzdHJhY3RpbmcgaXQgYXdheSBpbnRvXG4gICAgICAgICAgLy8gYSBmdW5jdGlvbiB0byBtaW5pbWl6ZSByZWZhY3RvcmluZyBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKHRoaXMpO1xuXG4gICAgICAgICAgaWYgKGxvY2F0aW9uID09PSBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApIHtcbiAgICAgICAgICAgIC8vIFByZWZhY2UgZ2l2ZXMgdXMgc29tZXRoaW5nIHRvIGJsYWNrbGlzdCBpbiB3YXJuaW5nIG1vZHVsZVxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBDb250ZXh0IFR5cGVzOiAlcyVzJywgZXJyb3IubWVzc2FnZSwgYWRkZW5kdW0pIDogdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBuZXh0Q29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBwcmV2Q29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBwcmV2Q29udGV4dCwgbmV4dENvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhbnkgb2YgYF9wZW5kaW5nRWxlbWVudGAsIGBfcGVuZGluZ1N0YXRlUXVldWVgLCBvciBgX3BlbmRpbmdGb3JjZVVwZGF0ZWBcbiAgICogaXMgc2V0LCB1cGRhdGUgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHRoaXMsIHRoaXMuX3BlbmRpbmdFbGVtZW50IHx8IHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fY29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlICE9PSBudWxsIHx8IHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSkge1xuICAgICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHRoaXMuX2N1cnJlbnRFbGVtZW50LCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY29udGV4dCwgdGhpcy5fY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIHVwZGF0ZSB0byBhIG1vdW50ZWQgY29tcG9uZW50LiBUaGUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBhbmRcbiAgICogc2hvdWxkQ29tcG9uZW50VXBkYXRlIG1ldGhvZHMgYXJlIGNhbGxlZCwgdGhlbiAoYXNzdW1pbmcgdGhlIHVwZGF0ZSBpc24ndFxuICAgKiBza2lwcGVkKSB0aGUgcmVtYWluaW5nIHVwZGF0ZSBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgY2FsbGVkIGFuZCB0aGUgRE9NXG4gICAqIHJlcHJlc2VudGF0aW9uIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldlBhcmVudEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRQYXJlbnRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2UGFyZW50RWxlbWVudCwgbmV4dFBhcmVudEVsZW1lbnQsIHByZXZVbm1hc2tlZENvbnRleHQsIG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIG5leHRDb250ZXh0ID0gdGhpcy5fY29udGV4dCA9PT0gbmV4dFVubWFza2VkQ29udGV4dCA/IGluc3QuY29udGV4dCA6IHRoaXMuX3Byb2Nlc3NDb250ZXh0KG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIHZhciBuZXh0UHJvcHM7XG5cbiAgICAvLyBEaXN0aW5ndWlzaCBiZXR3ZWVuIGEgcHJvcHMgdXBkYXRlIHZlcnN1cyBhIHNpbXBsZSBzdGF0ZSB1cGRhdGVcbiAgICBpZiAocHJldlBhcmVudEVsZW1lbnQgPT09IG5leHRQYXJlbnRFbGVtZW50KSB7XG4gICAgICAvLyBTa2lwIGNoZWNraW5nIHByb3AgdHlwZXMgYWdhaW4gLS0gd2UgZG9uJ3QgcmVhZCBpbnN0LnByb3BzIHRvIGF2b2lkXG4gICAgICAvLyB3YXJuaW5nIGZvciBET00gY29tcG9uZW50IHByb3BzIGluIHRoaXMgdXBncmFkZVxuICAgICAgbmV4dFByb3BzID0gbmV4dFBhcmVudEVsZW1lbnQucHJvcHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRQcm9wcyA9IHRoaXMuX3Byb2Nlc3NQcm9wcyhuZXh0UGFyZW50RWxlbWVudC5wcm9wcyk7XG4gICAgICAvLyBBbiB1cGRhdGUgaGVyZSB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSBidXQgaW1tZWRpYXRlbHkgc2V0XG4gICAgICAvLyBfcGVuZGluZ1N0YXRlUXVldWUgd2hpY2ggd2lsbCBlbnN1cmUgdGhhdCBhbnkgc3RhdGUgdXBkYXRlcyBnZXRzXG4gICAgICAvLyBpbW1lZGlhdGVseSByZWNvbmNpbGVkIGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgdGhlIG5leHQgYmF0Y2guXG5cbiAgICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpIHtcbiAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXh0U3RhdGUgPSB0aGlzLl9wcm9jZXNzUGVuZGluZ1N0YXRlKG5leHRQcm9wcywgbmV4dENvbnRleHQpO1xuXG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSB8fCAhaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUgfHwgaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2Ygc2hvdWxkVXBkYXRlICE9PSAndW5kZWZpbmVkJywgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgLy8gV2lsbCBzZXQgYHRoaXMucHJvcHNgLCBgdGhpcy5zdGF0ZWAgYW5kIGB0aGlzLmNvbnRleHRgLlxuICAgICAgdGhpcy5fcGVyZm9ybUNvbXBvbmVudFVwZGF0ZShuZXh0UGFyZW50RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgbmV4dFVubWFza2VkQ29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGl0J3MgZGV0ZXJtaW5lZCB0aGF0IGEgY29tcG9uZW50IHNob3VsZCBub3QgdXBkYXRlLCB3ZSBzdGlsbCB3YW50XG4gICAgICAvLyB0byBzZXQgcHJvcHMgYW5kIHN0YXRlIGJ1dCB3ZSBzaG9ydGN1dCB0aGUgcmVzdCBvZiB0aGUgdXBkYXRlLlxuICAgICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0UGFyZW50RWxlbWVudDtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBuZXh0VW5tYXNrZWRDb250ZXh0O1xuICAgICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgICB9XG4gIH0sXG5cbiAgX3Byb2Nlc3NQZW5kaW5nU3RhdGU6IGZ1bmN0aW9uIChwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcGVuZGluZ1N0YXRlUXVldWU7XG4gICAgdmFyIHJlcGxhY2UgPSB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICBpZiAoIXF1ZXVlKSB7XG4gICAgICByZXR1cm4gaW5zdC5zdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZSAmJiBxdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBxdWV1ZVswXTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gYXNzaWduKHt9LCByZXBsYWNlID8gcXVldWVbMF0gOiBpbnN0LnN0YXRlKTtcbiAgICBmb3IgKHZhciBpID0gcmVwbGFjZSA/IDEgOiAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gcXVldWVbaV07XG4gICAgICBhc3NpZ24obmV4dFN0YXRlLCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBjb250ZXh0KSA6IHBhcnRpYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlcyBuZXcgcHJvcHMgYW5kIHN0YXRlLCBub3RpZmllcyBkZWxlZ2F0ZSBtZXRob2RzIG9mIHVwZGF0ZSBhbmRcbiAgICogcGVyZm9ybXMgdXBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgTmV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHMgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZSBOZXh0IG9iamVjdCB0byBzZXQgYXMgc3RhdGUuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHQgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdW5tYXNrZWRDb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgdmFyIGhhc0NvbXBvbmVudERpZFVwZGF0ZSA9IEJvb2xlYW4oaW5zdC5jb21wb25lbnREaWRVcGRhdGUpO1xuICAgIHZhciBwcmV2UHJvcHM7XG4gICAgdmFyIHByZXZTdGF0ZTtcbiAgICB2YXIgcHJldkNvbnRleHQ7XG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgcHJldlByb3BzID0gaW5zdC5wcm9wcztcbiAgICAgIHByZXZTdGF0ZSA9IGluc3Quc3RhdGU7XG4gICAgICBwcmV2Q29udGV4dCA9IGluc3QuY29udGV4dDtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG4gICAgICBpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMuX2NvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyZWRDb21wb25lbnQodHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGluc3QuY29tcG9uZW50RGlkVXBkYXRlLmJpbmQoaW5zdCwgcHJldlByb3BzLCBwcmV2U3RhdGUsIHByZXZDb250ZXh0KSwgaW5zdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBjb21wb25lbnQncyBgcmVuZGVyYCBtZXRob2QgYW5kIHVwZGF0ZSB0aGUgRE9NIGFjY29yZGluZ2x5LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgdmFyIHByZXZSZW5kZXJlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBuZXh0UmVuZGVyZWRFbGVtZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KCk7XG4gICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZSZW5kZXJlZEVsZW1lbnQsIG5leHRSZW5kZXJlZEVsZW1lbnQpKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIG5leHRSZW5kZXJlZEVsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlc2UgdHdvIElEcyBhcmUgYWN0dWFsbHkgdGhlIHNhbWUhIEJ1dCBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoYXQuXG4gICAgICB2YXIgdGhpc0lEID0gdGhpcy5fcm9vdE5vZGVJRDtcbiAgICAgIHZhciBwcmV2Q29tcG9uZW50SUQgPSBwcmV2Q29tcG9uZW50SW5zdGFuY2UuX3Jvb3ROb2RlSUQ7XG4gICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dFJlbmRlcmVkRWxlbWVudCk7XG4gICAgICB2YXIgbmV4dE1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgdGhpc0lELCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgICB0aGlzLl9yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEKHByZXZDb21wb25lbnRJRCwgbmV4dE1hcmt1cCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogZnVuY3Rpb24gKHByZXZDb21wb25lbnRJRCwgbmV4dE1hcmt1cCkge1xuICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQgPSBpbnN0LnJlbmRlcigpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgIGlmICh0eXBlb2YgcmVuZGVyZWRDb21wb25lbnQgPT09ICd1bmRlZmluZWQnICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICByZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZW5kZXJlZENvbXBvbmVudDtcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgICEoXG4gICAgLy8gVE9ETzogQW4gYGlzVmFsaWROb2RlYCBmdW5jdGlvbiB3b3VsZCBwcm9iYWJseSBiZSBtb3JlIGFwcHJvcHJpYXRlXG4gICAgcmVuZGVyZWRDb21wb25lbnQgPT09IG51bGwgfHwgcmVuZGVyZWRDb21wb25lbnQgPT09IGZhbHNlIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChyZW5kZXJlZENvbXBvbmVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnJlbmRlcigpOiBBIHZhbGlkIFJlYWN0Q29tcG9uZW50IG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSAnICsgJ3JldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlbmRlcmVkQ29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMYXppbHkgYWxsb2NhdGVzIHRoZSByZWZzIG9iamVjdCBhbmQgc3RvcmVzIGBjb21wb25lbnRgIGFzIGByZWZgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIFJlZmVyZW5jZSBuYW1lLlxuICAgKiBAcGFyYW0ge2NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBzdG9yZSBhcyBgcmVmYC5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hSZWY6IGZ1bmN0aW9uIChyZWYsIGNvbXBvbmVudCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgcHVibGljQ29tcG9uZW50SW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQgJiYgY29tcG9uZW50LmdldE5hbWUgPyBjb21wb25lbnQuZ2V0TmFtZSgpIDogJ2EgY29tcG9uZW50JztcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHB1YmxpY0NvbXBvbmVudEluc3RhbmNlICE9IG51bGwsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcyAnICsgJyhTZWUgcmVmIFwiJXNcIiBpbiAlcyBjcmVhdGVkIGJ5ICVzKS4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLicsIHJlZiwgY29tcG9uZW50TmFtZSwgdGhpcy5nZXROYW1lKCkpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICByZWZzW3JlZl0gPSBwdWJsaWNDb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0YWNoZXMgYSByZWZlcmVuY2UgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGFjaFJlZjogZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciByZWZzID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnM7XG4gICAgZGVsZXRlIHJlZnNbcmVmXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgaXRcbiAgICogaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb3IgbnVsbC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5uYW1lIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudCAtIGkuZS4gd2hhdFxuICAgKiBpcyBleHBvc2VkIGJ5IHJlZnMgYW5kIHJldHVybmVkIGJ5IHJlbmRlci4gQ2FuIGJlIG51bGwgZm9yIHN0YXRlbGVzc1xuICAgKiBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gdGhlIHB1YmxpYyBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmIChpbnN0IGluc3RhbmNlb2YgU3RhdGVsZXNzQ29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLy8gU3R1YlxuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogbnVsbFxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpbiwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jywge1xuICBtb3VudENvbXBvbmVudDogJ21vdW50Q29tcG9uZW50JyxcbiAgdXBkYXRlQ29tcG9uZW50OiAndXBkYXRlQ29tcG9uZW50JyxcbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudDogJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnXG59KTtcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0ge1xuXG4gIE1peGluOiBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb3NpdGVDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q3VycmVudE93bmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVxuICovXG5cbi8qIGdsb2JhbHMgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RET01UZXh0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTVRleHRDb21wb25lbnQnKTtcbnZhciBSZWFjdERlZmF1bHRJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEluamVjdGlvbicpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIgPSByZXF1aXJlKCcuL3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgcmVuZGVyID0gUmVhY3RQZXJmLm1lYXN1cmUoJ1JlYWN0JywgJ3JlbmRlcicsIFJlYWN0TW91bnQucmVuZGVyKTtcblxudmFyIFJlYWN0ID0ge1xuICBmaW5kRE9NTm9kZTogZmluZERPTU5vZGUsXG4gIHJlbmRlcjogcmVuZGVyLFxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGUsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyXG59O1xuXG4vLyBJbmplY3QgdGhlIHJ1bnRpbWUgaW50byBhIGRldnRvb2xzIGdsb2JhbCBob29rIHJlZ2FyZGxlc3Mgb2YgYnJvd3Nlci5cbi8vIEFsbG93cyBmb3IgZGVidWdnaW5nIHdoZW4gdGhlIGhvb2sgaXMgaW5qZWN0ZWQgb24gdGhlIHBhZ2UuXG4vKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3Qoe1xuICAgIEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gICAgSW5zdGFuY2VIYW5kbGVzOiBSZWFjdEluc3RhbmNlSGFuZGxlcyxcbiAgICBNb3VudDogUmVhY3RNb3VudCxcbiAgICBSZWNvbmNpbGVyOiBSZWFjdFJlY29uY2lsZXIsXG4gICAgVGV4dENvbXBvbmVudDogUmVhY3RET01UZXh0Q29tcG9uZW50XG4gIH0pO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuICBpZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG5cbiAgICAvLyBGaXJzdCBjaGVjayBpZiBkZXZ0b29scyBpcyBub3QgaW5zdGFsbGVkXG4gICAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBpbiBJRTgsIGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgaW4gY29tcGF0aWJpbGl0eSBtb2RlIGFuZCBwcm92aWRlXG4gICAgLy8gaW5mb3JtYXRpb24gb24gcHJldmVudGluZyBjb21wYXRpYmlsaXR5IG1vZGVcbiAgICB2YXIgaWVDb21wYXRpYmlsaXR5TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA4O1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWllQ29tcGF0aWJpbGl0eU1vZGUsICdJbnRlcm5ldCBFeHBsb3JlciBpcyBydW5uaW5nIGluIGNvbXBhdGliaWxpdHkgbW9kZTsgcGxlYXNlIGFkZCB0aGUgJyArICdmb2xsb3dpbmcgdGFnIHRvIHlvdXIgSFRNTCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmc6ICcgKyAnPG1ldGEgaHR0cC1lcXVpdj1cIlgtVUEtQ29tcGF0aWJsZVwiIGNvbnRlbnQ9XCJJRT1lZGdlXCIgLz4nKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBleHBlY3RlZEZlYXR1cmVzID0gW1xuICAgIC8vIHNoaW1zXG4gICAgQXJyYXkuaXNBcnJheSwgQXJyYXkucHJvdG90eXBlLmV2ZXJ5LCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YsIEFycmF5LnByb3RvdHlwZS5tYXAsIERhdGUubm93LCBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgT2JqZWN0LmtleXMsIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsIFN0cmluZy5wcm90b3R5cGUudHJpbSxcblxuICAgIC8vIHNoYW1zXG4gICAgT2JqZWN0LmNyZWF0ZSwgT2JqZWN0LmZyZWV6ZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZXhwZWN0ZWRGZWF0dXJlc1tpXSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdPbmUgb3IgbW9yZSBFUzUgc2hpbS9zaGFtcyBleHBlY3RlZCBieSBSZWFjdCBhcmUgbm90IGF2YWlsYWJsZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctcG9seWZpbGxzJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUJ1dHRvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIG1vdXNlTGlzdGVuZXJOYW1lcyA9IHtcbiAgb25DbGljazogdHJ1ZSxcbiAgb25Eb3VibGVDbGljazogdHJ1ZSxcbiAgb25Nb3VzZURvd246IHRydWUsXG4gIG9uTW91c2VNb3ZlOiB0cnVlLFxuICBvbk1vdXNlVXA6IHRydWUsXG5cbiAgb25DbGlja0NhcHR1cmU6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VNb3ZlQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZVVwQ2FwdHVyZTogdHJ1ZVxufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPGJ1dHRvbj4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGRvZXMgbm90IHJlY2VpdmUgbW91c2UgZXZlbnRzXG4gKiB3aGVuIGBkaXNhYmxlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01CdXR0b24gPSB7XG4gIGdldE5hdGl2ZVByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICBpZiAoIXByb3BzLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuXG4gICAgLy8gQ29weSB0aGUgcHJvcHMsIGV4Y2VwdCB0aGUgbW91c2UgbGlzdGVuZXJzXG4gICAgdmFyIG5hdGl2ZVByb3BzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhbW91c2VMaXN0ZW5lck5hbWVzW2tleV0pIHtcbiAgICAgICAgbmF0aXZlUHJvcHNba2V5XSA9IHByb3BzW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQnV0dG9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUNvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4vKiBnbG9iYWwgaGFzT3duUHJvcGVydHk6dHJ1ZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBdXRvRm9jdXNVdGlscyA9IHJlcXVpcmUoJy4vQXV0b0ZvY3VzVXRpbHMnKTtcbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdERPTUJ1dHRvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01CdXR0b24nKTtcbnZhciBSZWFjdERPTUlucHV0ID0gcmVxdWlyZSgnLi9SZWFjdERPTUlucHV0Jyk7XG52YXIgUmVhY3RET01PcHRpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NT3B0aW9uJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0YXJlYScpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdE11bHRpQ2hpbGQgPSByZXF1aXJlKCcuL1JlYWN0TXVsdGlDaGlsZCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2V0VGV4dENvbnRlbnQgPSByZXF1aXJlKCcuL3NldFRleHRDb250ZW50Jyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGVsZXRlTGlzdGVuZXIgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZGVsZXRlTGlzdGVuZXI7XG52YXIgbGlzdGVuVG8gPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIubGlzdGVuVG87XG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG5cbi8vIEZvciBxdWlja2x5IG1hdGNoaW5nIGNoaWxkcmVuIHR5cGUsIHRvIHRlc3QgaWYgY2FuIGJlIHRyZWF0ZWQgYXMgY29udGVudC5cbnZhciBDT05URU5UX1RZUEVTID0geyAnc3RyaW5nJzogdHJ1ZSwgJ251bWJlcic6IHRydWUgfTtcblxudmFyIENISUxEUkVOID0ga2V5T2YoeyBjaGlsZHJlbjogbnVsbCB9KTtcbnZhciBTVFlMRSA9IGtleU9mKHsgc3R5bGU6IG51bGwgfSk7XG52YXIgSFRNTCA9IGtleU9mKHsgX19odG1sOiBudWxsIH0pO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oaW50ZXJuYWxJbnN0YW5jZSkge1xuICBpZiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIHZhciBvd25lciA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lciB8fCBudWxsO1xuICAgIGlmIChvd25lcikge1xuICAgICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJyBUaGlzIERPTSBub2RlIHdhcyByZW5kZXJlZCBieSBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsZWdhY3lQcm9wc0Rlc2NyaXB0b3I7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBsZWdhY3lQcm9wc0Rlc2NyaXB0b3IgPSB7XG4gICAgcHJvcHM6IHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RE9NQ29tcG9uZW50OiBEbyBub3QgYWNjZXNzIC5wcm9wcyBvZiBhIERPTSBub2RlOyBpbnN0ZWFkLCAnICsgJ3JlY3JlYXRlIHRoZSBwcm9wcyBhcyBgcmVuZGVyYCBkaWQgb3JpZ2luYWxseSBvciByZWFkIHRoZSBET00gJyArICdwcm9wZXJ0aWVzL2F0dHJpYnV0ZXMgZGlyZWN0bHkgZnJvbSB0aGlzIG5vZGUgKGUuZy4sICcgKyAndGhpcy5yZWZzLmJveC5jbGFzc05hbWUpLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeUdldERPTU5vZGUoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQ7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAuZ2V0RE9NTm9kZSgpIG9mIGEgRE9NIG5vZGU7ICcgKyAnaW5zdGVhZCwgdXNlIHRoZSBub2RlIGRpcmVjdGx5LiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBsZWdhY3lJc01vdW50ZWQoKSB7XG4gIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLmlzTW91bnRlZCgpIG9mIGEgRE9NIG5vZGUuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuICEhY29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBsZWdhY3lTZXRTdGF0ZUV0YygpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RE9NQ29tcG9uZW50OiBEbyBub3QgYWNjZXNzIC5zZXRTdGF0ZSgpLCAucmVwbGFjZVN0YXRlKCksIG9yICcgKyAnLmZvcmNlVXBkYXRlKCkgb2YgYSBET00gbm9kZS4gVGhpcyBpcyBhIG5vLW9wLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeVNldFByb3BzKHBhcnRpYWxQcm9wcywgY2FsbGJhY2spIHtcbiAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAuc2V0UHJvcHMoKSBvZiBhIERPTSBub2RlLiAnICsgJ0luc3RlYWQsIGNhbGwgUmVhY3RET00ucmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKCFjb21wb25lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlU2V0UHJvcHNJbnRlcm5hbChjb21wb25lbnQsIHBhcnRpYWxQcm9wcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwoY29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVnYWN5UmVwbGFjZVByb3BzKHBhcnRpYWxQcm9wcywgY2FsbGJhY2spIHtcbiAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAucmVwbGFjZVByb3BzKCkgb2YgYSBET00gbm9kZS4gJyArICdJbnN0ZWFkLCBjYWxsIFJlYWN0RE9NLnJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmICghY29tcG9uZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVJlcGxhY2VQcm9wc0ludGVybmFsKGNvbXBvbmVudCwgcGFydGlhbFByb3BzKTtcbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbChjb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmcmllbmRseVN0cmluZ2lmeShvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgcmV0dXJuICdbJyArIG9iai5tYXAoZnJpZW5kbHlTdHJpbmdpZnkpLmpvaW4oJywgJykgKyAnXSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYWlycyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgIHZhciBrZXlFc2NhcGVkID0gL15bYS16JF9dW1xcdyRfXSokL2kudGVzdChrZXkpID8ga2V5IDogSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgICAgICBwYWlycy5wdXNoKGtleUVzY2FwZWQgKyAnOiAnICsgZnJpZW5kbHlTdHJpbmdpZnkob2JqW2tleV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICd7JyArIHBhaXJzLmpvaW4oJywgJykgKyAnfSc7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAnW2Z1bmN0aW9uIG9iamVjdF0nO1xuICB9XG4gIC8vIERpZmZlcnMgZnJvbSBKU09OLnN0cmluZ2lmeSBpbiB0aGF0IHVuZGVmaW5lZCBiZWNhdXNlcyB1bmRlZmluZWQgYW5kIHRoYXRcbiAgLy8gaW5mIGFuZCBuYW4gZG9uJ3QgYmVjb21lIG51bGxcbiAgcmV0dXJuIFN0cmluZyhvYmopO1xufVxuXG52YXIgc3R5bGVNdXRhdGlvbldhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHN0eWxlMSwgc3R5bGUyLCBjb21wb25lbnQpIHtcbiAgaWYgKHN0eWxlMSA9PSBudWxsIHx8IHN0eWxlMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaGFsbG93RXF1YWwoc3R5bGUxLCBzdHlsZTIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuX3RhZztcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcikge1xuICAgIG93bmVyTmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgfVxuXG4gIHZhciBoYXNoID0gb3duZXJOYW1lICsgJ3wnICsgY29tcG9uZW50TmFtZTtcblxuICBpZiAoc3R5bGVNdXRhdGlvbldhcm5pbmcuaGFzT3duUHJvcGVydHkoaGFzaCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHlsZU11dGF0aW9uV2FybmluZ1toYXNoXSA9IHRydWU7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgJXNgIHdhcyBwYXNzZWQgYSBzdHlsZSBvYmplY3QgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIG11dGF0ZWQuICcgKyAnTXV0YXRpbmcgYHN0eWxlYCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciBjbG9uaW5nIGl0IGJlZm9yZWhhbmQuIENoZWNrICcgKyAndGhlIGByZW5kZXJgICVzLiBQcmV2aW91cyBzdHlsZTogJXMuIE11dGF0ZWQgc3R5bGU6ICVzLicsIGNvbXBvbmVudE5hbWUsIG93bmVyID8gJ29mIGAnICsgb3duZXJOYW1lICsgJ2AnIDogJ3VzaW5nIDwnICsgY29tcG9uZW50TmFtZSArICc+JywgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUxKSwgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUyKSkgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wc1xuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh2b2lkRWxlbWVudFRhZ3NbY29tcG9uZW50Ll90YWddKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3Qgbm90IGhhdmUgYGNoaWxkcmVuYCBvciAnICsgJ3VzZSBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiAnICsgJ1BsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCAnICsgJ2ZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLmlubmVySFRNTCA9PSBudWxsLCAnRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdW5kZWZpbmVkO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxuICAhKHByb3BzLnN0eWxlID09IG51bGwgfHwgdHlwZW9mIHByb3BzLnN0eWxlID09PSAnb2JqZWN0JykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCAnICsgJ25vdCBhIHN0cmluZy4gRm9yIGV4YW1wbGUsIHN0eWxlPXt7bWFyZ2luUmlnaHQ6IHNwYWNpbmcgKyBcXCdlbVxcJ319IHdoZW4gJyArICd1c2luZyBKU1guJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlUHV0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyLCB0cmFuc2FjdGlvbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIElFOCBoYXMgbm8gQVBJIGZvciBldmVudCBjYXB0dXJpbmcgYW5kIHRoZSBgb25TY3JvbGxgIGV2ZW50IGRvZXNuJ3RcbiAgICAvLyBidWJibGUuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocmVnaXN0cmF0aW9uTmFtZSAhPT0gJ29uU2Nyb2xsJyB8fCBpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSwgJ1RoaXMgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCB0aGUgYG9uU2Nyb2xsYCBldmVudCcpIDogdW5kZWZpbmVkO1xuICB9XG4gIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIHZhciBkb2MgPSBjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFID8gY29udGFpbmVyLm93bmVyRG9jdW1lbnQgOiBjb250YWluZXI7XG4gICAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbiAgfVxuICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHB1dExpc3RlbmVyLCB7XG4gICAgaWQ6IGlkLFxuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwdXRMaXN0ZW5lcigpIHtcbiAgdmFyIGxpc3RlbmVyVG9QdXQgPSB0aGlzO1xuICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIucHV0TGlzdGVuZXIobGlzdGVuZXJUb1B1dC5pZCwgbGlzdGVuZXJUb1B1dC5yZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lclRvUHV0Lmxpc3RlbmVyKTtcbn1cblxuLy8gVGhlcmUgYXJlIHNvIG1hbnkgbWVkaWEgZXZlbnRzLCBpdCBtYWtlcyBzZW5zZSB0byBqdXN0XG4vLyBtYWludGFpbiBhIGxpc3QgcmF0aGVyIHRoYW4gY3JlYXRlIGEgYHRyYXBCdWJibGVkRXZlbnRgIGZvciBlYWNoXG52YXIgbWVkaWFFdmVudHMgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZydcbn07XG5cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnRzTG9jYWwoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgLy8gSWYgYSBjb21wb25lbnQgcmVuZGVycyB0byBudWxsIG9yIGlmIGFub3RoZXIgY29tcG9uZW50IGZhdGFscyBhbmQgY2F1c2VzXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgdHJlZSB0byBiZSBjb3JydXB0ZWQsIGBub2RlYCBoZXJlIGNhbiBiZSBudWxsLlxuICAhaW5zdC5fcm9vdE5vZGVJRCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IGJlIG1vdW50ZWQgdG8gdHJhcCBldmVudHMnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGluc3QuX3Jvb3ROb2RlSUQpO1xuICAhbm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmFwQnViYmxlZEV2ZW50KC4uLik6IFJlcXVpcmVzIG5vZGUgdG8gYmUgcmVuZGVyZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHN3aXRjaCAoaW5zdC5fdGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BMb2FkLCAnbG9hZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG5cbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIC8vIGNyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgZXZlbnQgaW4gbWVkaWFFdmVudHMpIHtcbiAgICAgICAgaWYgKG1lZGlhRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMucHVzaChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzW2V2ZW50XSwgbWVkaWFFdmVudHNbZXZlbnRdLCBub2RlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BFcnJvciwgJ2Vycm9yJywgbm9kZSksIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wTG9hZCwgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcy50b3BSZXNldCwgJ3Jlc2V0Jywgbm9kZSksIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wU3VibWl0LCAnc3VibWl0Jywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRSZWFkeUlucHV0V3JhcHBlcigpIHtcbiAgUmVhY3RET01JbnB1dC5tb3VudFJlYWR5V3JhcHBlcih0aGlzKTtcbn1cblxuZnVuY3Rpb24gcG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIoKSB7XG4gIFJlYWN0RE9NU2VsZWN0LnBvc3RVcGRhdGVXcmFwcGVyKHRoaXMpO1xufVxuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIHNob3VsZCBvbWl0IHRoZWlyIGNsb3NlIHRhZy4gV2Uga2VlcCBhIHdoaXRlbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwgY2FzZWQgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gICdhcmVhJzogdHJ1ZSxcbiAgJ2Jhc2UnOiB0cnVlLFxuICAnYnInOiB0cnVlLFxuICAnY29sJzogdHJ1ZSxcbiAgJ2VtYmVkJzogdHJ1ZSxcbiAgJ2hyJzogdHJ1ZSxcbiAgJ2ltZyc6IHRydWUsXG4gICdpbnB1dCc6IHRydWUsXG4gICdrZXlnZW4nOiB0cnVlLFxuICAnbGluayc6IHRydWUsXG4gICdtZXRhJzogdHJ1ZSxcbiAgJ3BhcmFtJzogdHJ1ZSxcbiAgJ3NvdXJjZSc6IHRydWUsXG4gICd0cmFjayc6IHRydWUsXG4gICd3YnInOiB0cnVlXG59O1xuXG4vLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxudmFyIG5ld2xpbmVFYXRpbmdUYWdzID0ge1xuICAnbGlzdGluZyc6IHRydWUsXG4gICdwcmUnOiB0cnVlLFxuICAndGV4dGFyZWEnOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBhc3NpZ24oe1xuICAnbWVudWl0ZW0nOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxuLy8gV2UgYWNjZXB0IGFueSB0YWcgdG8gYmUgcmVuZGVyZWQgYnV0IHNpbmNlIHRoaXMgZ2V0cyBpbmplY3RlZCBpbnRvIGFyYml0cmFyeVxuLy8gSFRNTCwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBpdCdzIGEgc2FmZSB0YWcuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMteG1sLyNOVC1OYW1lXG5cbnZhciBWQUxJRF9UQUdfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWjpfXFwuXFwtXFxkXSokLzsgLy8gU2ltcGxpZmllZCBzdWJzZXRcbnZhciB2YWxpZGF0ZWRUYWdDYWNoZSA9IHt9O1xudmFyIGhhc093blByb3BlcnR5ID0gKHt9KS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh2YWxpZGF0ZWRUYWdDYWNoZSwgdGFnKSkge1xuICAgICFWQUxJRF9UQUdfUkVHRVgudGVzdCh0YWcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdGFnOiAlcycsIHRhZykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhbGlkYXRlZFRhZ0NhY2hlW3RhZ10gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHREZXYoY29udGV4dCwgaW5zdCkge1xuICAvLyBQYXNzIGRvd24gb3VyIHRhZyBuYW1lIHRvIGNoaWxkIGNvbXBvbmVudHMgZm9yIHZhbGlkYXRpb24gcHVycG9zZXNcbiAgY29udGV4dCA9IGFzc2lnbih7fSwgY29udGV4dCk7XG4gIHZhciBpbmZvID0gY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV07XG4gIGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldID0gdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8oaW5mbywgaW5zdC5fdGFnLCBpbnN0KTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIHJldHVybiB0YWdOYW1lLmluZGV4T2YoJy0nKSA+PSAwIHx8IHByb3BzLmlzICE9IG51bGw7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSZWFjdCBjbGFzcyB0aGF0IGlzIGlkZW1wb3RlbnQgYW5kIGNhcGFibGUgb2YgY29udGFpbmluZyBvdGhlclxuICogUmVhY3QgY29tcG9uZW50cy4gSXQgYWNjZXB0cyBldmVudCBsaXN0ZW5lcnMgYW5kIERPTSBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gKiB2YWxpZCBhY2NvcmRpbmcgdG8gYERPTVByb3BlcnR5YC5cbiAqXG4gKiAgLSBFdmVudCBsaXN0ZW5lcnM6IGBvbkNsaWNrYCwgYG9uTW91c2VEb3duYCwgZXRjLlxuICogIC0gRE9NIHByb3BlcnRpZXM6IGBjbGFzc05hbWVgLCBgbmFtZWAsIGB0aXRsZWAsIGV0Yy5cbiAqXG4gKiBUaGUgYHN0eWxlYCBwcm9wZXJ0eSBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZnJvbSB0aGUgRE9NIEFQSS4gSXQgYWNjZXB0cyBhblxuICogb2JqZWN0IG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yIFJlYWN0RE9NQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuZnVuY3Rpb24gUmVhY3RET01Db21wb25lbnQodGFnKSB7XG4gIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZyk7XG4gIHRoaXMuX3RhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IG51bGw7XG4gIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG4gIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcyA9IG51bGw7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdGhpcy5fdW5wcm9jZXNzZWRDb250ZXh0RGV2ID0gbnVsbDtcbiAgICB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2ID0gbnVsbDtcbiAgfVxufVxuXG5SZWFjdERPTUNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdSZWFjdERPTUNvbXBvbmVudCc7XG5cblJlYWN0RE9NQ29tcG9uZW50Lk1peGluID0ge1xuXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyByb290IHRhZyBtYXJrdXAgdGhlbiByZWN1cnNlcy4gVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBhbmRcbiAgICogaXMgbm90IGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIFRoZSByb290IERPTSBJRCBmb3IgdGhpcyBub2RlLlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29tcHV0ZWQgbWFya3VwLlxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IHJvb3RJRDtcblxuICAgIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgICAgICBsaXN0ZW5lcnM6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFwQnViYmxlZEV2ZW50c0xvY2FsLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NQnV0dG9uLmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUlucHV0LmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBSZWFjdERPTU9wdGlvbi5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBSZWFjdERPTVNlbGVjdC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgY29udGV4dCA9IFJlYWN0RE9NU2VsZWN0LnByb2Nlc3NDaGlsZENvbnRleHQodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0TmF0aXZlUHJvcHModGhpcywgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKSB7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyh0aGlzLl90YWcsIHRoaXMsIGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdGhpcy5fdW5wcm9jZXNzZWRDb250ZXh0RGV2ID0gY29udGV4dDtcbiAgICAgIHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXYgPSBwcm9jZXNzQ2hpbGRDb250ZXh0RGV2KGNvbnRleHQsIHRoaXMpO1xuICAgICAgY29udGV4dCA9IHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXY7XG4gICAgfVxuXG4gICAgdmFyIG1vdW50SW1hZ2U7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gY29udGV4dFtSZWFjdE1vdW50Lm93bmVyRG9jdW1lbnRDb250ZXh0S2V5XTtcbiAgICAgIHZhciBlbCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRBdHRyaWJ1dGVGb3JJRChlbCwgdGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAvLyBQb3B1bGF0ZSBub2RlIGNhY2hlXG4gICAgICBSZWFjdE1vdW50LmdldElEKGVsKTtcbiAgICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMoe30sIHByb3BzLCB0cmFuc2FjdGlvbiwgZWwpO1xuICAgICAgdGhpcy5fY3JlYXRlSW5pdGlhbENoaWxkcmVuKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgZWwpO1xuICAgICAgbW91bnRJbWFnZSA9IGVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGFnT3BlbiA9IHRoaXMuX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnModHJhbnNhY3Rpb24sIHByb3BzKTtcbiAgICAgIHZhciB0YWdDb250ZW50ID0gdGhpcy5fY3JlYXRlQ29udGVudE1hcmt1cCh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQpO1xuICAgICAgaWYgKCF0YWdDb250ZW50ICYmIG9taXR0ZWRDbG9zZVRhZ3NbdGhpcy5fdGFnXSkge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICcvPic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb3VudEltYWdlID0gdGFnT3BlbiArICc+JyArIHRhZ0NvbnRlbnQgKyAnPC8nICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSArICc+JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKG1vdW50UmVhZHlJbnB1dFdyYXBwZXIsIHRoaXMpO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIGlmIChwcm9wcy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKEF1dG9Gb2N1c1V0aWxzLmZvY3VzRE9NQ29tcG9uZW50LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gbW91bnRJbWFnZTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBvcGVuIHRhZyBhbmQgYWxsIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYmVjYXVzZSBldmVudHMgZ2V0IHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEl0ZXJhdGluZyBvdmVyIG9iamVjdCBwcm9wZXJ0aWVzIGlzIGZhc3RlciB0aGFuIGl0ZXJhdGluZyBvdmVyIGFycmF5cy5cbiAgICogQHNlZSBodHRwOi8vanNwZXJmLmNvbS9vYmotdnMtYXJyLWl0ZXJhdGlvblxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIG9mIG9wZW5pbmcgdGFnLlxuICAgKi9cbiAgX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnM6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMpIHtcbiAgICB2YXIgcmV0ID0gJzwnICsgdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5LCBwcm9wVmFsdWUsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgICAgaWYgKHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gU2VlIGBfdXBkYXRlRE9NUHJvcGVydGllc2AuIHN0eWxlIGJsb2NrXG4gICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wVmFsdWUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IGFzc2lnbih7fSwgcHJvcHMuc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9wVmFsdWUgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmt1cCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90YWcgIT0gbnVsbCAmJiBpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIHByb3BzKSkge1xuICAgICAgICAgIGlmIChwcm9wS2V5ICE9PSBDSElMRFJFTikge1xuICAgICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZShwcm9wS2V5LCBwcm9wVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrdXAgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yUHJvcGVydHkocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya3VwKSB7XG4gICAgICAgICAgcmV0ICs9ICcgJyArIG1hcmt1cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBzdGF0aWMgcGFnZXMsIG5vIG5lZWQgdG8gcHV0IFJlYWN0IElEIGFuZCBjaGVja3N1bS4gU2F2ZXMgbG90cyBvZlxuICAgIC8vIGJ5dGVzLlxuICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICB2YXIgbWFya3VwRm9ySUQgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9ySUQodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgcmV0dXJuIHJldCArICcgJyArIG1hcmt1cEZvcklEO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgdGFncy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvbnRlbnQgbWFya3VwLlxuICAgKi9cbiAgX2NyZWF0ZUNvbnRlbnRNYXJrdXA6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgcmV0ID0gJyc7XG5cbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHJldCA9IGlubmVySFRNTC5fX2h0bWw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICAgIHJldCA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcihjb250ZW50VG9Vc2UpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgcmV0ID0gbW91bnRJbWFnZXMuam9pbignJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXdsaW5lRWF0aW5nVGFnc1t0aGlzLl90YWddICYmIHJldC5jaGFyQXQoMCkgPT09ICdcXG4nKSB7XG4gICAgICAvLyB0ZXh0L2h0bWwgaWdub3JlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZXNlIHRhZ3MgaWYgaXQncyBhIG5ld2xpbmVcbiAgICAgIC8vIFByZWZlciB0byBicmVhayBhcHBsaWNhdGlvbi94bWwgb3ZlciB0ZXh0L2h0bWwgKGZvciBub3cpIGJ5IGFkZGluZ1xuICAgICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgICAgLy8gdGV4dGFyZWFzLCByZXBsYWNpbmcgXCJeXFxuXCIgd2l0aCBcIlxcclxcblwiIGRvZXNuJ3QgZ2V0IGVhdGVuLCBhbmQgdGhlIGZpcnN0XG4gICAgICAvLyBcXHIgaXMgbm9ybWFsaXplZCBvdXQgYnkgSFRNTFRleHRBcmVhRWxlbWVudCN2YWx1ZS4pXG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjZWxlbWVudC1yZXN0cmljdGlvbnM+XG4gICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNuZXdsaW5lcz5cbiAgICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAgIC8vICBmcm9tIDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5PlxuICAgICAgcmV0dXJuICdcXG4nICsgcmV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSxcblxuICBfY3JlYXRlSW5pdGlhbENoaWxkcmVuOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBlbCkge1xuICAgIC8vIEludGVudGlvbmFsIHVzZSBvZiAhPSB0byBhdm9pZCBjYXRjaGluZyB6ZXJvL2ZhbHNlLlxuICAgIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcbiAgICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAgIGlmIChpbm5lckhUTUwuX19odG1sICE9IG51bGwpIHtcbiAgICAgICAgc2V0SW5uZXJIVE1MKGVsLCBpbm5lckhUTUwuX19odG1sKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRlbnRUb1VzZSA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIHByb3BzLmNoaWxkcmVuXSA/IHByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICAgIHZhciBjaGlsZHJlblRvVXNlID0gY29udGVudFRvVXNlICE9IG51bGwgPyBudWxsIDogcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY29udGVudFRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgICAgc2V0VGV4dENvbnRlbnQoZWwsIGNvbnRlbnRUb1VzZSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vdW50SW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZWwuYXBwZW5kQ2hpbGQobW91bnRJbWFnZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNlaXZlcyBhIG5leHQgZWxlbWVudCBhbmQgdXBkYXRlcyB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBuYXRpdmUgRE9NIGNvbXBvbmVudCBhZnRlciBpdCBoYXMgYWxyZWFkeSBiZWVuIGFsbG9jYXRlZCBhbmRcbiAgICogYXR0YWNoZWQgdG8gdGhlIERPTS4gUmVjb25jaWxlcyB0aGUgcm9vdCBET00gbm9kZSwgdGhlbiByZWN1cnNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldkVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdFByb3BzID0gcHJldkVsZW1lbnQucHJvcHM7XG4gICAgdmFyIG5leHRQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NQnV0dG9uLmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NQnV0dG9uLmdldE5hdGl2ZVByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0TmF0aXZlUHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01JbnB1dC5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldE5hdGl2ZVByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0TmF0aXZlUHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0TmF0aXZlUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgICAgICAgbGFzdFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldE5hdGl2ZVByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBJZiB0aGUgY29udGV4dCBpcyByZWZlcmVuY2UtZXF1YWwgdG8gdGhlIG9sZCBvbmUsIHBhc3MgZG93biB0aGUgc2FtZVxuICAgICAgLy8gcHJvY2Vzc2VkIG9iamVjdCBzbyB0aGUgdXBkYXRlIGJhaWxvdXQgaW4gUmVhY3RSZWNvbmNpbGVyIGJlaGF2ZXNcbiAgICAgIC8vIGNvcnJlY3RseSAoYW5kIGlkZW50aWNhbGx5IGluIGRldiBhbmQgcHJvZCkuIFNlZSAjNTAwNS5cbiAgICAgIGlmICh0aGlzLl91bnByb2Nlc3NlZENvbnRleHREZXYgIT09IGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fdW5wcm9jZXNzZWRDb250ZXh0RGV2ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc2VkQ29udGV4dERldiA9IHByb2Nlc3NDaGlsZENvbnRleHREZXYoY29udGV4dCwgdGhpcyk7XG4gICAgICB9XG4gICAgICBjb250ZXh0ID0gdGhpcy5fcHJvY2Vzc2VkQ29udGV4dERldjtcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIG51bGwpO1xuICAgIHRoaXMuX3VwZGF0ZURPTUNoaWxkcmVuKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBpZiAoIWNhbkRlZmluZVByb3BlcnR5ICYmIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcykge1xuICAgICAgdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzLnByb3BzID0gbmV4dFByb3BzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyLCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIHByb3BlcnRpZXMgYnkgZGV0ZWN0aW5nIGRpZmZlcmVuY2VzIGluIHByb3BlcnR5IHZhbHVlcyBhbmRcbiAgICogdXBkYXRpbmcgdGhlIERPTSBhcyBuZWNlc3NhcnkuIFRoaXMgZnVuY3Rpb24gaXMgcHJvYmFibHkgdGhlIHNpbmdsZSBtb3N0XG4gICAqIGNyaXRpY2FsIHBhdGggZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICpcbiAgICogVE9ETzogQmVuY2htYXJrIHdoZXRoZXIgY2hlY2tpbmcgZm9yIGNoYW5nZWQgdmFsdWVzIGluIG1lbW9yeSBhY3R1YWxseVxuICAgKiAgICAgICBpbXByb3ZlcyBwZXJmb3JtYW5jZSAoZXNwZWNpYWxseSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudHMpLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgdGhlIGVmZmVjdHMgb2YgcHV0dGluZyB0aGlzIGF0IHRoZSB0b3Agc2luY2UgOTklIG9mIHByb3BzXG4gICAqICAgICAgIGRvIG5vdCBjaGFuZ2UgZm9yIGEgZ2l2ZW4gcmVjb25jaWxpYXRpb24uXG4gICAqIFRPRE86IEJlbmNobWFyayBhcmVhcyB0aGF0IGNhbiBiZSBpbXByb3ZlZCB3aXRoIGNhY2hpbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIF91cGRhdGVET01Qcm9wZXJ0aWVzOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBub2RlKSB7XG4gICAgdmFyIHByb3BLZXk7XG4gICAgdmFyIHN0eWxlTmFtZTtcbiAgICB2YXIgc3R5bGVVcGRhdGVzO1xuICAgIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICAgIGlmIChuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgIWxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICB2YXIgbGFzdFN0eWxlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHk7XG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICAgIGlmIChsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAobGFzdFByb3BzW3Byb3BLZXldKSB7XG4gICAgICAgICAgLy8gT25seSBjYWxsIGRlbGV0ZUxpc3RlbmVyIGlmIHRoZXJlIHdhcyBhIGxpc3RlbmVyIHByZXZpb3VzbHkgb3JcbiAgICAgICAgICAvLyBlbHNlIHdpbGxEZWxldGVMaXN0ZW5lciBnZXRzIGNhbGxlZCB3aGVuIHRoZXJlIHdhc24ndCBhY3R1YWxseSBhXG4gICAgICAgICAgLy8gbGlzdGVuZXIgKGUuZy4sIG9uQ2xpY2s9e251bGx9KVxuICAgICAgICAgIGRlbGV0ZUxpc3RlbmVyKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgfVxuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgICAgdmFyIGxhc3RQcm9wID0gcHJvcEtleSA9PT0gU1RZTEUgPyB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA6IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5LCB0aGlzLl9wcmV2aW91c1N0eWxlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBuZXh0UHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFByb3AgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IGFzc2lnbih7fSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFByb3ApIHtcbiAgICAgICAgICAgIGlmIChsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBuZXh0UHJvcCkge1xuICAgICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgbGFzdFByb3Bbc3R5bGVOYW1lXSAhPT0gbmV4dFByb3Bbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICAgICAgc3R5bGVVcGRhdGVzID0gbmV4dFByb3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMuX3Jvb3ROb2RlSUQsIHByb3BLZXksIG5leHRQcm9wLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIG5leHRQcm9wcykpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgICAgICBuZXh0UHJvcCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0YW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZVVwZGF0ZXMpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgfVxuICAgICAgQ1NTUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlVXBkYXRlcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGhlXG4gICAqIGNoaWxkcmVuIGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXN0UHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqL1xuICBfdXBkYXRlRE9NQ2hpbGRyZW46IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbGFzdENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBsYXN0UHJvcHMuY2hpbGRyZW5dID8gbGFzdFByb3BzLmNoaWxkcmVuIDogbnVsbDtcbiAgICB2YXIgbmV4dENvbnRlbnQgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBuZXh0UHJvcHMuY2hpbGRyZW5dID8gbmV4dFByb3BzLmNoaWxkcmVuIDogbnVsbDtcblxuICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJiBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sO1xuXG4gICAgLy8gTm90ZSB0aGUgdXNlIG9mIGAhPWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICB2YXIgbGFzdENoaWxkcmVuID0gbGFzdENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBsYXN0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRDb250ZW50ICE9IG51bGwgPyBudWxsIDogbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gY2hpbGRyZW4gdG8gY29udGVudC9odG1sIG9yIHZpY2UgdmVyc2EsIHJlbW92ZVxuICAgIC8vIHRoZSBvbGQgY29udGVudFxuICAgIHZhciBsYXN0SGFzQ29udGVudE9ySHRtbCA9IGxhc3RDb250ZW50ICE9IG51bGwgfHwgbGFzdEh0bWwgIT0gbnVsbDtcbiAgICB2YXIgbmV4dEhhc0NvbnRlbnRPckh0bWwgPSBuZXh0Q29udGVudCAhPSBudWxsIHx8IG5leHRIdG1sICE9IG51bGw7XG4gICAgaWYgKGxhc3RDaGlsZHJlbiAhPSBudWxsICYmIG5leHRDaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKG51bGwsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKGxhc3RIYXNDb250ZW50T3JIdG1sICYmICFuZXh0SGFzQ29udGVudE9ySHRtbCkge1xuICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0Q29udGVudCAhPT0gbmV4dENvbnRlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0Q29udGVudCgnJyArIG5leHRDb250ZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRIdG1sICE9IG51bGwpIHtcbiAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgdGhpcy51cGRhdGVNYXJrdXAoJycgKyBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFsbCBldmVudCByZWdpc3RyYXRpb25zIGZvciB0aGlzIGluc3RhbmNlLiBEb2VzIG5vdCByZW1vdmUgZnJvbVxuICAgKiB0aGUgRE9NLiBUaGF0IG11c3QgYmUgZG9uZSBieSB0aGUgcGFyZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaWZyYW1lJzpcbiAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnM7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgUmVhY3RET01JbnB1dC51bm1vdW50V3JhcHBlcih0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wb25lbnRzIGxpa2UgPGh0bWw+IDxoZWFkPiBhbmQgPGJvZHk+IGNhbid0IGJlIHJlbW92ZWQgb3IgYWRkZWRcbiAgICAgICAgICogZWFzaWx5IGluIGEgY3Jvc3MtYnJvd3NlciB3YXksIGhvd2V2ZXIgaXQncyB2YWx1YWJsZSB0byBiZSBhYmxlIHRvXG4gICAgICAgICAqIHRha2UgYWR2YW50YWdlIG9mIFJlYWN0J3MgcmVjb25jaWxpYXRpb24gZm9yIHN0eWxpbmcgYW5kIDx0aXRsZT5cbiAgICAgICAgICogbWFuYWdlbWVudC4gU28gd2UganVzdCBkb2N1bWVudCBpdCBhbmQgdGhyb3cgaW4gZGFuZ2Vyb3VzIGNhc2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzwlcz4gdHJpZWQgdG8gdW5tb3VudC4gQmVjYXVzZSBvZiBjcm9zcy1icm93c2VyIHF1aXJrcyBpdCBpcyAnICsgJ2ltcG9zc2libGUgdG8gdW5tb3VudCBzb21lIHRvcC1sZXZlbCBjb21wb25lbnRzIChlZyA8aHRtbD4sICcgKyAnPGhlYWQ+LCBhbmQgPGJvZHk+KSByZWxpYWJseSBhbmQgZWZmaWNpZW50bHkuIFRvIGZpeCB0aGlzLCBoYXZlIGEgJyArICdzaW5nbGUgdG9wLWxldmVsIGNvbXBvbmVudCB0aGF0IG5ldmVyIHVubW91bnRzIHJlbmRlciB0aGVzZSAnICsgJ2VsZW1lbnRzLicsIHRoaXMuX3RhZykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLnVubW91bnRDaGlsZHJlbigpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5kZWxldGVBbGxMaXN0ZW5lcnModGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQudW5tb3VudElERnJvbUVudmlyb25tZW50KHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZSA9IG51bGw7XG4gICAgaWYgKHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcykge1xuICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXM7XG4gICAgICBub2RlLl9yZWFjdEludGVybmFsQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcyA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuXG4gICAgICBub2RlLl9yZWFjdEludGVybmFsQ29tcG9uZW50ID0gdGhpcztcbiAgICAgIG5vZGUuZ2V0RE9NTm9kZSA9IGxlZ2FjeUdldERPTU5vZGU7XG4gICAgICBub2RlLmlzTW91bnRlZCA9IGxlZ2FjeUlzTW91bnRlZDtcbiAgICAgIG5vZGUuc2V0U3RhdGUgPSBsZWdhY3lTZXRTdGF0ZUV0YztcbiAgICAgIG5vZGUucmVwbGFjZVN0YXRlID0gbGVnYWN5U2V0U3RhdGVFdGM7XG4gICAgICBub2RlLmZvcmNlVXBkYXRlID0gbGVnYWN5U2V0U3RhdGVFdGM7XG4gICAgICBub2RlLnNldFByb3BzID0gbGVnYWN5U2V0UHJvcHM7XG4gICAgICBub2RlLnJlcGxhY2VQcm9wcyA9IGxlZ2FjeVJlcGxhY2VQcm9wcztcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobm9kZSwgbGVnYWN5UHJvcHNEZXNjcmlwdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1cGRhdGVDb21wb25lbnQgd2lsbCB1cGRhdGUgdGhpcyBwcm9wZXJ0eSBvbiBzdWJzZXF1ZW50IHJlbmRlcnNcbiAgICAgICAgICBub2RlLnByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZUNvbXBvbmVudCB3aWxsIHVwZGF0ZSB0aGlzIHByb3BlcnR5IG9uIHN1YnNlcXVlbnQgcmVuZGVyc1xuICAgICAgICBub2RlLnByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcyA9IG5vZGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXM7XG4gIH1cblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0RE9NQ29tcG9uZW50LCAnUmVhY3RET01Db21wb25lbnQnLCB7XG4gIG1vdW50Q29tcG9uZW50OiAnbW91bnRDb21wb25lbnQnLFxuICB1cGRhdGVDb21wb25lbnQ6ICd1cGRhdGVDb21wb25lbnQnXG59KTtcblxuYXNzaWduKFJlYWN0RE9NQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RET01Db21wb25lbnQuTWl4aW4sIFJlYWN0TXVsdGlDaGlsZC5NaXhpbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NRmFjdG9yaWVzXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcblxudmFyIG1hcE9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL21hcE9iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhY3RvcnkgdGhhdCBjcmVhdGVzIEhUTUwgdGFnIGVsZW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGFnIG5hbWUgKGUuZy4gYGRpdmApLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRE9NRmFjdG9yeSh0YWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICByZXR1cm4gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3RvcnkodGFnKTtcbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkodGFnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwcGluZyBmcm9tIHN1cHBvcnRlZCBIVE1MIHRhZ3MgdG8gYFJlYWN0RE9NQ29tcG9uZW50YCBjbGFzc2VzLlxuICogVGhpcyBpcyBhbHNvIGFjY2Vzc2libGUgdmlhIGBSZWFjdC5ET01gLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0gbWFwT2JqZWN0KHtcbiAgYTogJ2EnLFxuICBhYmJyOiAnYWJicicsXG4gIGFkZHJlc3M6ICdhZGRyZXNzJyxcbiAgYXJlYTogJ2FyZWEnLFxuICBhcnRpY2xlOiAnYXJ0aWNsZScsXG4gIGFzaWRlOiAnYXNpZGUnLFxuICBhdWRpbzogJ2F1ZGlvJyxcbiAgYjogJ2InLFxuICBiYXNlOiAnYmFzZScsXG4gIGJkaTogJ2JkaScsXG4gIGJkbzogJ2JkbycsXG4gIGJpZzogJ2JpZycsXG4gIGJsb2NrcXVvdGU6ICdibG9ja3F1b3RlJyxcbiAgYm9keTogJ2JvZHknLFxuICBicjogJ2JyJyxcbiAgYnV0dG9uOiAnYnV0dG9uJyxcbiAgY2FudmFzOiAnY2FudmFzJyxcbiAgY2FwdGlvbjogJ2NhcHRpb24nLFxuICBjaXRlOiAnY2l0ZScsXG4gIGNvZGU6ICdjb2RlJyxcbiAgY29sOiAnY29sJyxcbiAgY29sZ3JvdXA6ICdjb2xncm91cCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0YWxpc3Q6ICdkYXRhbGlzdCcsXG4gIGRkOiAnZGQnLFxuICBkZWw6ICdkZWwnLFxuICBkZXRhaWxzOiAnZGV0YWlscycsXG4gIGRmbjogJ2RmbicsXG4gIGRpYWxvZzogJ2RpYWxvZycsXG4gIGRpdjogJ2RpdicsXG4gIGRsOiAnZGwnLFxuICBkdDogJ2R0JyxcbiAgZW06ICdlbScsXG4gIGVtYmVkOiAnZW1iZWQnLFxuICBmaWVsZHNldDogJ2ZpZWxkc2V0JyxcbiAgZmlnY2FwdGlvbjogJ2ZpZ2NhcHRpb24nLFxuICBmaWd1cmU6ICdmaWd1cmUnLFxuICBmb290ZXI6ICdmb290ZXInLFxuICBmb3JtOiAnZm9ybScsXG4gIGgxOiAnaDEnLFxuICBoMjogJ2gyJyxcbiAgaDM6ICdoMycsXG4gIGg0OiAnaDQnLFxuICBoNTogJ2g1JyxcbiAgaDY6ICdoNicsXG4gIGhlYWQ6ICdoZWFkJyxcbiAgaGVhZGVyOiAnaGVhZGVyJyxcbiAgaGdyb3VwOiAnaGdyb3VwJyxcbiAgaHI6ICdocicsXG4gIGh0bWw6ICdodG1sJyxcbiAgaTogJ2knLFxuICBpZnJhbWU6ICdpZnJhbWUnLFxuICBpbWc6ICdpbWcnLFxuICBpbnB1dDogJ2lucHV0JyxcbiAgaW5zOiAnaW5zJyxcbiAga2JkOiAna2JkJyxcbiAga2V5Z2VuOiAna2V5Z2VuJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxlZ2VuZDogJ2xlZ2VuZCcsXG4gIGxpOiAnbGknLFxuICBsaW5rOiAnbGluaycsXG4gIG1haW46ICdtYWluJyxcbiAgbWFwOiAnbWFwJyxcbiAgbWFyazogJ21hcmsnLFxuICBtZW51OiAnbWVudScsXG4gIG1lbnVpdGVtOiAnbWVudWl0ZW0nLFxuICBtZXRhOiAnbWV0YScsXG4gIG1ldGVyOiAnbWV0ZXInLFxuICBuYXY6ICduYXYnLFxuICBub3NjcmlwdDogJ25vc2NyaXB0JyxcbiAgb2JqZWN0OiAnb2JqZWN0JyxcbiAgb2w6ICdvbCcsXG4gIG9wdGdyb3VwOiAnb3B0Z3JvdXAnLFxuICBvcHRpb246ICdvcHRpb24nLFxuICBvdXRwdXQ6ICdvdXRwdXQnLFxuICBwOiAncCcsXG4gIHBhcmFtOiAncGFyYW0nLFxuICBwaWN0dXJlOiAncGljdHVyZScsXG4gIHByZTogJ3ByZScsXG4gIHByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICBxOiAncScsXG4gIHJwOiAncnAnLFxuICBydDogJ3J0JyxcbiAgcnVieTogJ3J1YnknLFxuICBzOiAncycsXG4gIHNhbXA6ICdzYW1wJyxcbiAgc2NyaXB0OiAnc2NyaXB0JyxcbiAgc2VjdGlvbjogJ3NlY3Rpb24nLFxuICBzZWxlY3Q6ICdzZWxlY3QnLFxuICBzbWFsbDogJ3NtYWxsJyxcbiAgc291cmNlOiAnc291cmNlJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzdHJvbmc6ICdzdHJvbmcnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3ViOiAnc3ViJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICBzdXA6ICdzdXAnLFxuICB0YWJsZTogJ3RhYmxlJyxcbiAgdGJvZHk6ICd0Ym9keScsXG4gIHRkOiAndGQnLFxuICB0ZXh0YXJlYTogJ3RleHRhcmVhJyxcbiAgdGZvb3Q6ICd0Zm9vdCcsXG4gIHRoOiAndGgnLFxuICB0aGVhZDogJ3RoZWFkJyxcbiAgdGltZTogJ3RpbWUnLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgdHI6ICd0cicsXG4gIHRyYWNrOiAndHJhY2snLFxuICB1OiAndScsXG4gIHVsOiAndWwnLFxuICAndmFyJzogJ3ZhcicsXG4gIHZpZGVvOiAndmlkZW8nLFxuICB3YnI6ICd3YnInLFxuXG4gIC8vIFNWR1xuICBjaXJjbGU6ICdjaXJjbGUnLFxuICBjbGlwUGF0aDogJ2NsaXBQYXRoJyxcbiAgZGVmczogJ2RlZnMnLFxuICBlbGxpcHNlOiAnZWxsaXBzZScsXG4gIGc6ICdnJyxcbiAgaW1hZ2U6ICdpbWFnZScsXG4gIGxpbmU6ICdsaW5lJyxcbiAgbGluZWFyR3JhZGllbnQ6ICdsaW5lYXJHcmFkaWVudCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgcGF0aDogJ3BhdGgnLFxuICBwYXR0ZXJuOiAncGF0dGVybicsXG4gIHBvbHlnb246ICdwb2x5Z29uJyxcbiAgcG9seWxpbmU6ICdwb2x5bGluZScsXG4gIHJhZGlhbEdyYWRpZW50OiAncmFkaWFsR3JhZGllbnQnLFxuICByZWN0OiAncmVjdCcsXG4gIHN0b3A6ICdzdG9wJyxcbiAgc3ZnOiAnc3ZnJyxcbiAgdGV4dDogJ3RleHQnLFxuICB0c3BhbjogJ3RzcGFuJ1xuXG59LCBjcmVhdGVET01GYWN0b3J5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZhY3RvcmllczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01GZWF0dXJlRmxhZ3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHtcbiAgdXNlQ3JlYXRlRWxlbWVudDogZmFsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GZWF0dXJlRmxhZ3M7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSURPcGVyYXRpb25zXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUNoaWxkcmVuT3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NQ2hpbGRyZW5PcGVyYXRpb25zJyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEVycm9ycyBmb3IgcHJvcGVydGllcyB0aGF0IHNob3VsZCBub3QgYmUgdXBkYXRlZCB3aXRoIGB1cGRhdGVQcm9wZXJ0eUJ5SUQoKWAuXG4gKlxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBJTlZBTElEX1BST1BFUlRZX0VSUk9SUyA9IHtcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6ICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgc2V0IHVzaW5nIGB1cGRhdGVJbm5lckhUTUxCeUlEKClgLicsXG4gIHN0eWxlOiAnYHN0eWxlYCBtdXN0IGJlIHNldCB1c2luZyBgdXBkYXRlU3R5bGVzQnlJRCgpYC4nXG59O1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgdXNlZCB0byBwcm9jZXNzIHVwZGF0ZXMgdG8gRE9NIG5vZGVzLlxuICovXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSB7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gbm9kZSB3aXRoIG5ldyBwcm9wZXJ0eSB2YWx1ZXMuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB0b1xuICAgKiB1cGRhdGUgRE9NIHByb3BlcnRpZXMgaW4gYERPTVByb3BlcnR5YC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIHRoZSBub2RlIHRvIHVwZGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSB2YWxpZCBwcm9wZXJ0eSBuYW1lLCBzZWUgYERPTVByb3BlcnR5YC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgdmFsdWUgb2YgdGhlIHByb3BlcnR5LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVwZGF0ZVByb3BlcnR5QnlJRDogZnVuY3Rpb24gKGlkLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAhIUlOVkFMSURfUFJPUEVSVFlfRVJST1JTLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVByb3BlcnR5QnlJRCguLi4pOiAlcycsIElOVkFMSURfUFJPUEVSVFlfRVJST1JTW25hbWVdKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0YW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGEgRE9NIG5vZGUgdGhhdCBleGlzdHMgaW4gdGhlIGRvY3VtZW50IHdpdGggbWFya3VwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgY2hpbGQgdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgRGFuZ2Vyb3VzIG1hcmt1cCB0byBpbmplY3QgaW4gcGxhY2Ugb2YgY2hpbGQuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXB9XG4gICAqL1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IGZ1bmN0aW9uIChpZCwgbWFya3VwKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cChub2RlLCBtYXJrdXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBwYXJhbSB7YXJyYXk8c3RyaW5nPn0gbWFya3VwIExpc3Qgb2YgbWFya3VwIHN0cmluZ3MuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBmdW5jdGlvbiAodXBkYXRlcywgbWFya3VwKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1cGRhdGVzW2ldLnBhcmVudE5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodXBkYXRlc1tpXS5wYXJlbnRJRCk7XG4gICAgfVxuICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5wcm9jZXNzVXBkYXRlcyh1cGRhdGVzLCBtYXJrdXApO1xuICB9XG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RET01JRE9wZXJhdGlvbnMsICdSZWFjdERPTUlET3BlcmF0aW9ucycsIHtcbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEJyxcbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiAnZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JRE9wZXJhdGlvbnM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NSW5wdXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGluc3RhbmNlc0J5UmVhY3RJRCA9IHt9O1xuXG5mdW5jdGlvbiBmb3JjZVVwZGF0ZUlmTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQpIHtcbiAgICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICAgIFJlYWN0RE9NSW5wdXQudXBkYXRlV3JhcHBlcih0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPGlucHV0PiBuYXRpdmUgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcbiAqIHByb3BzOiBgY2hlY2tlZGAsIGB2YWx1ZWAsIGBkZWZhdWx0Q2hlY2tlZGAsIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xuICogdGhhdCBhZmZlY3QgdGhlIGNoZWNrZWQgc3RhdGUgb3IgdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxuICogdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgcHJvcHMgbXVzdCBjaGFuZ2UgaW4gb3JkZXIgZm9yXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYXMgdW5jaGVja2VkIChvciBgZGVmYXVsdENoZWNrZWRgKVxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cbnZhciBSZWFjdERPTUlucHV0ID0ge1xuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgdmFyIGNoZWNrZWQgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldENoZWNrZWQocHJvcHMpO1xuXG4gICAgdmFyIG5hdGl2ZVByb3BzID0gYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgdmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkLFxuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9LFxuXG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIExpbmtlZFZhbHVlVXRpbHMuY2hlY2tQcm9wVHlwZXMoJ2lucHV0JywgcHJvcHMsIGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICBpbml0aWFsQ2hlY2tlZDogcHJvcHMuZGVmYXVsdENoZWNrZWQgfHwgZmFsc2UsXG4gICAgICBpbml0aWFsVmFsdWU6IGRlZmF1bHRWYWx1ZSAhPSBudWxsID8gZGVmYXVsdFZhbHVlIDogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuICB9LFxuXG4gIG1vdW50UmVhZHlXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIENhbid0IGJlIGluIG1vdW50V3JhcHBlciBvciBlbHNlIHNlcnZlciByZW5kZXJpbmcgbGVha3MuXG4gICAgaW5zdGFuY2VzQnlSZWFjdElEW2luc3QuX3Jvb3ROb2RlSURdID0gaW5zdDtcbiAgfSxcblxuICB1bm1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdElEW2luc3QuX3Jvb3ROb2RlSURdO1xuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBUT0RPOiBTaG91bGRuJ3QgdGhpcyBiZSBnZXRDaGVja2VkKHByb3BzKT9cbiAgICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gICAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgUmVhY3RET01JRE9wZXJhdGlvbnMudXBkYXRlUHJvcGVydHlCeUlEKGluc3QuX3Jvb3ROb2RlSUQsICdjaGVja2VkJywgY2hlY2tlZCB8fCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICBSZWFjdERPTUlET3BlcmF0aW9ucy51cGRhdGVQcm9wZXJ0eUJ5SUQoaW5zdC5fcm9vdE5vZGVJRCwgJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG5cbiAgLy8gSGVyZSB3ZSB1c2UgYXNhcCB0byB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2hcbiAgLy8gaXMgaW1wb3J0YW50IHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG5cbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLCBsZXQncyBqdXN0IHVzZSB0aGUgZ2xvYmFsXG4gICAgLy8gYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndCBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3Qgd2l0aCBub24tUmVhY3QuXG4gICAgICB2YXIgb3RoZXJJRCA9IFJlYWN0TW91bnQuZ2V0SUQob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlcklEID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSAnICsgJ3NhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG90aGVySW5zdGFuY2UgPSBpbnN0YW5jZXNCeVJlYWN0SURbb3RoZXJJRF07XG4gICAgICAhb3RoZXJJbnN0YW5jZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBVbmtub3duIHJhZGlvIGJ1dHRvbiBJRCAlcy4nLCBvdGhlcklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbiAgICAgIC8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXG4gICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCBvdGhlckluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnB1dDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01PcHRpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsdWVDb250ZXh0S2V5ID0gUmVhY3RET01TZWxlY3QudmFsdWVDb250ZXh0S2V5O1xuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTU9wdGlvbiA9IHtcbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgd2hldGhlciB0aGlzIG9wdGlvbiBpcyAnc2VsZWN0ZWQnIHZpYSBjb250ZXh0XG4gICAgdmFyIHNlbGVjdFZhbHVlID0gY29udGV4dFt2YWx1ZUNvbnRleHRLZXldO1xuXG4gICAgLy8gSWYgY29udGV4dCBrZXkgaXMgbnVsbCAoZS5nLiwgbm8gc3BlY2lmaWVkIHZhbHVlIG9yIGFmdGVyIGluaXRpYWwgbW91bnQpXG4gICAgLy8gb3IgbWlzc2luZyAoZS5nLiwgZm9yIDxkYXRhbGlzdD4pLCB3ZSBkb24ndCBjaGFuZ2UgcHJvcHMuc2VsZWN0ZWRcbiAgICB2YXIgc2VsZWN0ZWQgPSBudWxsO1xuICAgIGlmIChzZWxlY3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0VmFsdWUpKSB7XG4gICAgICAgIC8vIG11bHRpcGxlXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0VmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoJycgKyBzZWxlY3RWYWx1ZVtpXSA9PT0gJycgKyBwcm9wcy52YWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09ICcnICsgcHJvcHMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0geyBzZWxlY3RlZDogc2VsZWN0ZWQgfTtcbiAgfSxcblxuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIG5hdGl2ZVByb3BzID0gYXNzaWduKHsgc2VsZWN0ZWQ6IHVuZGVmaW5lZCwgY2hpbGRyZW46IHVuZGVmaW5lZCB9LCBwcm9wcyk7XG5cbiAgICAvLyBSZWFkIHN0YXRlIG9ubHkgZnJvbSBpbml0aWFsIG1vdW50IGJlY2F1c2UgPHNlbGVjdD4gdXBkYXRlcyB2YWx1ZVxuICAgIC8vIG1hbnVhbGx5OyB3ZSBuZWVkIHRoZSBpbml0aWFsIHN0YXRlIG9ubHkgZm9yIHNlcnZlciByZW5kZXJpbmdcbiAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgIG5hdGl2ZVByb3BzLnNlbGVjdGVkID0gaW5zdC5fd3JhcHBlclN0YXRlLnNlbGVjdGVkO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50ID0gJyc7XG5cbiAgICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgICAvLyBpbnZhbGlkIHR5cGVzIGFyZSBpZ25vcmVkLlxuICAgIFJlYWN0Q2hpbGRyZW4uZm9yRWFjaChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIG5hdGl2ZVByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmF0aXZlUHJvcHM7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU9wdGlvbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01TZWxlY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsdWVDb250ZXh0S2V5ID0gJ19fUmVhY3RET01TZWxlY3RfdmFsdWUkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCgpIHtcbiAgaWYgKHRoaXMuX3Jvb3ROb2RlSUQgJiYgdGhpcy5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUpIHtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG5cbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyh0aGlzLCBCb29sZWFuKHByb3BzLm11bHRpcGxlKSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcblxuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKGluc3QsIHByb3BzKSB7XG4gIHZhciBvd25lciA9IGluc3QuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIG93bmVyKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLm11bHRpcGxlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSksICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSksICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGluc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbGVcbiAqIEBwYXJhbSB7Kn0gcHJvcFZhbHVlIEEgc3RyaW5nYWJsZSAod2l0aCBgbXVsdGlwbGVgLCBhIGxpc3Qgb2Ygc3RyaW5nYWJsZXMpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhpbnN0LCBtdWx0aXBsZSwgcHJvcFZhbHVlKSB7XG4gIHZhciBzZWxlY3RlZFZhbHVlLCBpO1xuICB2YXIgb3B0aW9ucyA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpbnN0Ll9yb290Tm9kZUlEKS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxlY3RlZFZhbHVlWycnICsgcHJvcFZhbHVlW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KG9wdGlvbnNbaV0udmFsdWUpO1xuICAgICAgaWYgKG9wdGlvbnNbaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHNlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9wdGlvbnNbaV0udmFsdWUgPT09IHNlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICBvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xudmFyIFJlYWN0RE9NU2VsZWN0ID0ge1xuICB2YWx1ZUNvbnRleHRLZXk6IHZhbHVlQ29udGV4dEtleSxcblxuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2UsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIHBlbmRpbmdVcGRhdGU6IGZhbHNlLFxuICAgICAgaW5pdGlhbFZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpLFxuICAgICAgd2FzTXVsdGlwbGU6IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpXG4gICAgfTtcbiAgfSxcblxuICBwcm9jZXNzQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICAvLyBQYXNzIGRvd24gaW5pdGlhbCB2YWx1ZSBzbyBpbml0aWFsIGdlbmVyYXRlZCBtYXJrdXAgaGFzIGNvcnJlY3RcbiAgICAvLyBgc2VsZWN0ZWRgIGF0dHJpYnV0ZXNcbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gYXNzaWduKHt9LCBjb250ZXh0KTtcbiAgICBjaGlsZENvbnRleHRbdmFsdWVDb250ZXh0S2V5XSA9IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU7XG4gICAgcmV0dXJuIGNoaWxkQ29udGV4dDtcbiAgfSxcblxuICBwb3N0VXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIC8vIEFmdGVyIHRoZSBpbml0aWFsIG1vdW50LCB3ZSBjb250cm9sIHNlbGVjdGVkLW5lc3MgbWFudWFsbHkgc28gZG9uJ3QgcGFzc1xuICAgIC8vIHRoZSBjb250ZXh0IHZhbHVlIGRvd25cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIHdhc011bHRpcGxlID0gaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpO1xuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG4gICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSkpIHtcbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSA9IHRydWU7XG4gIFJlYWN0VXBkYXRlcy5hc2FwKHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkLCB0aGlzKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKCcuL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQnKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogV2hpbGUgYGlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgb24gdGhlIFNlbGVjdGlvbiBvYmplY3QgYW5kIGBjb2xsYXBzZWRgXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIFJhbmdlIG9iamVjdCwgSUUxMSBzb21ldGltZXMgZ2V0cyB0aGVtIHdyb25nLlxuICogSWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhbmQgb2Zmc2V0cyBhcmUgdGhlIHNhbWUsIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGFwc2VkKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICByZXR1cm4gYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvck9mZnNldCA9PT0gZm9jdXNPZmZzZXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhcHByb3ByaWF0ZSBhbmNob3IgYW5kIGZvY3VzIG5vZGUvb2Zmc2V0IHBhaXJzIGZvciBJRS5cbiAqXG4gKiBUaGUgY2F0Y2ggaGVyZSBpcyB0aGF0IElFJ3Mgc2VsZWN0aW9uIEFQSSBkb2Vzbid0IHByb3ZpZGUgaW5mb3JtYXRpb25cbiAqIGFib3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBmb3J3YXJkIG9yIGJhY2t3YXJkLCBzbyB3ZSBoYXZlIHRvXG4gKiBiZWhhdmUgYXMgdGhvdWdoIGl0J3MgYWx3YXlzIGZvcndhcmQuXG4gKlxuICogSUUgdGV4dCBkaWZmZXJzIGZyb20gbW9kZXJuIHNlbGVjdGlvbiBpbiB0aGF0IGl0IGJlaGF2ZXMgYXMgdGhvdWdoXG4gKiBibG9jayBlbGVtZW50cyBlbmQgd2l0aCBhIG5ldyBsaW5lLiBUaGlzIG1lYW5zIGNoYXJhY3RlciBvZmZzZXRzIHdpbGxcbiAqIGRpZmZlciBiZXR3ZWVuIHRoZSB0d28gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0SUVPZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LnNlbGVjdGlvbjtcbiAgdmFyIHNlbGVjdGVkUmFuZ2UgPSBzZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgdmFyIHNlbGVjdGVkTGVuZ3RoID0gc2VsZWN0ZWRSYW5nZS50ZXh0Lmxlbmd0aDtcblxuICAvLyBEdXBsaWNhdGUgc2VsZWN0aW9uIHNvIHdlIGNhbiBtb3ZlIHJhbmdlIHdpdGhvdXQgYnJlYWtpbmcgdXNlciBzZWxlY3Rpb24uXG4gIHZhciBmcm9tU3RhcnQgPSBzZWxlY3RlZFJhbmdlLmR1cGxpY2F0ZSgpO1xuICBmcm9tU3RhcnQubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIGZyb21TdGFydC5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHNlbGVjdGVkUmFuZ2UpO1xuXG4gIHZhciBzdGFydE9mZnNldCA9IGZyb21TdGFydC50ZXh0Lmxlbmd0aDtcbiAgdmFyIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgc2VsZWN0ZWRMZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnRPZmZzZXQsXG4gICAgZW5kOiBlbmRPZmZzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICB2YXIgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIHZhciBjdXJyZW50UmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblxuICAvLyBJbiBGaXJlZm94LCByYW5nZS5zdGFydENvbnRhaW5lciBhbmQgcmFuZ2UuZW5kQ29udGFpbmVyIGNhbiBiZSBcImFub255bW91c1xuICAvLyBkaXZzXCIsIGUuZy4gdGhlIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzXG4gIC8vIGRpdnMgZG8gbm90IHNlZW0gdG8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkXG4gIC8vIGVycm9yXCIgaWYgYW55IG9mIGl0cyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlXG4gIC8vIHdheSB0byBhdm9pZCBlcnJvcmluZyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3JcbiAgLy8gbm9uLWFub255bW91cyBkaXZzIGFuZCBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlO1xuICAgIGN1cnJlbnRSYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsIHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG5cbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICB0ZW1wUmFuZ2Uuc2V0RW5kKGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lciwgY3VycmVudFJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZCh0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsIHRlbXBSYW5nZS5zdGFydE9mZnNldCwgdGVtcFJhbmdlLmVuZENvbnRhaW5lciwgdGVtcFJhbmdlLmVuZE9mZnNldCk7XG5cbiAgdmFyIHN0YXJ0ID0gaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPyAwIDogdGVtcFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZUxlbmd0aDtcblxuICAvLyBEZXRlY3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkLlxuICB2YXIgZGV0ZWN0aW9uUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRTdGFydChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRFbmQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG4gIHZhciBpc0JhY2t3YXJkID0gZGV0ZWN0aW9uUmFuZ2UuY29sbGFwc2VkO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcbiAgICBlbmQ6IGlzQmFja3dhcmQgPyBzdGFydCA6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0SUVPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZHVwbGljYXRlKCk7XG4gIHZhciBzdGFydCwgZW5kO1xuXG4gIGlmICh0eXBlb2Ygb2Zmc2V0cy5lbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKG9mZnNldHMuc3RhcnQgPiBvZmZzZXRzLmVuZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5lbmQ7XG4gICAgZW5kID0gb2Zmc2V0cy5zdGFydDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gIH1cblxuICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0JywgcmFuZ2UpO1xuICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gIHJhbmdlLnNlbGVjdCgpO1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRNb2Rlcm5PZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSB0eXBlb2Ygb2Zmc2V0cy5lbmQgPT09ICd1bmRlZmluZWQnID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHVzZUlFT2Zmc2V0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnc2VsZWN0aW9uJyBpbiBkb2N1bWVudCAmJiAhKCdnZXRTZWxlY3Rpb24nIGluIHdpbmRvdyk7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgZ2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gZ2V0SUVPZmZzZXRzIDogZ2V0TW9kZXJuT2Zmc2V0cyxcblxuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gICAqL1xuICBzZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBzZXRJRU9mZnNldHMgOiBzZXRNb2Rlcm5PZmZzZXRzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NU2VsZWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlcnZlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmcgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyUmVuZGVyaW5nJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgUmVhY3RET01TZXJ2ZXIgPSB7XG4gIHJlbmRlclRvU3RyaW5nOiBSZWFjdFNlcnZlclJlbmRlcmluZy5yZW5kZXJUb1N0cmluZyxcbiAgcmVuZGVyVG9TdGF0aWNNYXJrdXA6IFJlYWN0U2VydmVyUmVuZGVyaW5nLnJlbmRlclRvU3RhdGljTWFya3VwLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZXJ2ZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGluIGVsZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gdW5kZXJnb1xuICogdGhlIHNhbWUgcmVjb25jaWxpYXRpb24gdGhhdCBpcyBhcHBsaWVkIHRvIGVsZW1lbnRzLlxuICpcbiAqIFRPRE86IEludmVzdGlnYXRlIHJlcHJlc2VudGluZyBSZWFjdCBjb21wb25lbnRzIGluIHRoZSBET00gd2l0aCB0ZXh0IG5vZGVzLlxuICpcbiAqIEBjbGFzcyBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0Q29tcG9uZW50XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAvLyBUaGlzIGNvbnN0cnVjdG9yIGFuZCBpdHMgYXJndW1lbnQgaXMgY3VycmVudGx5IHVzZWQgYnkgbW9ja3MuXG59O1xuXG5hc3NpZ24oUmVhY3RET01UZXh0Q29tcG9uZW50LnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSB0ZXh0O1xuICAgIHRoaXMuX3N0cmluZ1RleHQgPSAnJyArIHRleHQ7XG5cbiAgICAvLyBQcm9wZXJ0aWVzXG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRJbmRleCA9IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuIFRoaXMgbm9kZSBpcyBub3QgaW50ZW5kZWQgdG8gaGF2ZVxuICAgKiBhbnkgZmVhdHVyZXMgYmVzaWRlcyBjb250YWluaW5nIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKSB7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZygnc3BhbicsIG51bGwsIGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGNvbnRleHRbUmVhY3RNb3VudC5vd25lckRvY3VtZW50Q29udGV4dEtleV07XG4gICAgICB2YXIgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRBdHRyaWJ1dGVGb3JJRChlbCwgcm9vdElEKTtcbiAgICAgIC8vIFBvcHVsYXRlIG5vZGUgY2FjaGVcbiAgICAgIFJlYWN0TW91bnQuZ2V0SUQoZWwpO1xuICAgICAgc2V0VGV4dENvbnRlbnQoZWwsIHRoaXMuX3N0cmluZ1RleHQpO1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXNjYXBlZFRleHQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGhpcy5fc3RyaW5nVGV4dCk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIHdyYXAgdGhpcyBpbiBhIGBzcGFuYCBmb3IgdGhlIHJlYXNvbnMgc3RhdGVkIGFib3ZlLCBidXRcbiAgICAgICAgLy8gc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvbiB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXIgKHN0YXRpYyBwYWdlcyksXG4gICAgICAgIC8vIHdlIGNhbiBzaW1wbHkgcmV0dXJuIHRoZSB0ZXh0IGFzIGl0IGlzLlxuICAgICAgICByZXR1cm4gZXNjYXBlZFRleHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPHNwYW4gJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRChyb290SUQpICsgJz4nICsgZXNjYXBlZFRleHQgKyAnPC9zcGFuPic7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgY29tcG9uZW50IGJ5IHVwZGF0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RUZXh0fSBuZXh0VGV4dCBUaGUgbmV4dCB0ZXh0IGNvbnRlbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0VGV4dCwgdHJhbnNhY3Rpb24pIHtcbiAgICBpZiAobmV4dFRleHQgIT09IHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRUZXh0O1xuICAgICAgdmFyIG5leHRTdHJpbmdUZXh0ID0gJycgKyBuZXh0VGV4dDtcbiAgICAgIGlmIChuZXh0U3RyaW5nVGV4dCAhPT0gdGhpcy5fc3RyaW5nVGV4dCkge1xuICAgICAgICAvLyBUT0RPOiBTYXZlIHRoaXMgYXMgcGVuZGluZyBwcm9wcyBhbmQgdXNlIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeVxuICAgICAgICAvLyBhbmQvb3IgdXBkYXRlQ29tcG9uZW50IHRvIGRvIHRoZSBhY3R1YWwgdXBkYXRlIGZvciBjb25zaXN0ZW5jeSB3aXRoXG4gICAgICAgIC8vIG90aGVyIGNvbXBvbmVudCB0eXBlcz9cbiAgICAgICAgdGhpcy5fc3RyaW5nVGV4dCA9IG5leHRTdHJpbmdUZXh0O1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnVwZGF0ZVRleHRDb250ZW50KG5vZGUsIG5leHRTdHJpbmdUZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVGV4dGFyZWFcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0gcmVxdWlyZSgnLi9MaW5rZWRWYWx1ZVV0aWxzJyk7XG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cbnZhciBSZWFjdERPTVRleHRhcmVhID0ge1xuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAgIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuXG4gICAgdmFyIG5hdGl2ZVByb3BzID0gYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgY2hpbGRyZW46IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgICBvbkNoYW5nZTogaW5zdC5fd3JhcHBlclN0YXRlLm9uQ2hhbmdlXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmF0aXZlUHJvcHM7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuXG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgLy8gV2Ugc2F2ZSB0aGUgaW5pdGlhbCB2YWx1ZSBzbyB0aGF0IGBSZWFjdERPTUNvbXBvbmVudGAgZG9lc24ndCB1cGRhdGVcbiAgICAgIC8vIGB0ZXh0Q29udGVudGAgKHVubmVjZXNzYXJ5IHNpbmNlIHdlIHVwZGF0ZSB2YWx1ZSkuXG4gICAgICAvLyBUaGUgaW5pdGlhbCB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3NcbiAgICAgIC8vIGZvcmNlZCB0byBiZSBhIHN0cmluZy5cbiAgICAgIGluaXRpYWxWYWx1ZTogJycgKyAodmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogZGVmYXVsdFZhbHVlKSxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdClcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICBSZWFjdERPTUlET3BlcmF0aW9ucy51cGRhdGVQcm9wZXJ0eUJ5SUQoaW5zdC5fcm9vdE5vZGVJRCwgJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRhcmVhOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG5cbnZhciBSRVNFVF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB9XG59O1xuXG52YXIgRkxVU0hfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogUmVhY3RVcGRhdGVzLmZsdXNoQmF0Y2hlZFVwZGF0ZXMuYmluZChSZWFjdFVwZGF0ZXMpXG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbRkxVU0hfQkFUQ0hFRF9VUERBVEVTLCBSRVNFVF9CQVRDSEVEX1VQREFURVNdO1xuXG5mdW5jdGlvbiBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbn1cblxuYXNzaWduKFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH1cbn0pO1xuXG52YXIgdHJhbnNhY3Rpb24gPSBuZXcgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCk7XG5cbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0ge1xuICBpc0JhdGNoaW5nVXBkYXRlczogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGluIGEgY29udGV4dCB3aXRoaW4gd2hpY2ggY2FsbHMgdG8gYHNldFN0YXRlYFxuICAgKiBhbmQgZnJpZW5kcyBhcmUgYmF0Y2hlZCBzdWNoIHRoYXQgY29tcG9uZW50cyBhcmVuJ3QgdXBkYXRlZCB1bm5lY2Vzc2FyaWx5LlxuICAgKi9cbiAgYmF0Y2hlZFVwZGF0ZXM6IGZ1bmN0aW9uIChjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xuICAgIHZhciBhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzID0gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcztcblxuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuXG4gICAgLy8gVGhlIGNvZGUgaXMgd3JpdHRlbiB0aGlzIHdheSB0byBhdm9pZCBleHRyYSBhbGxvY2F0aW9uc1xuICAgIGlmIChhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICBjYWxsYmFjayhhLCBiLCBjLCBkLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShjYWxsYmFjaywgbnVsbCwgYSwgYiwgYywgZCwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3k7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdEluamVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nKTtcbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQ2hhbmdlRXZlbnRQbHVnaW4nKTtcbnZhciBDbGllbnRSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vQ2xpZW50UmVhY3RSb290SW5kZXgnKTtcbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IHJlcXVpcmUoJy4vRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXInKTtcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0VudGVyTGVhdmVFdmVudFBsdWdpbicpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0hUTUxET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbicpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnQnKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dENvbXBvbmVudCcpO1xudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudExpc3RlbmVyJyk7XG52YXIgUmVhY3RJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24nKTtcbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2VsZWN0RXZlbnRQbHVnaW4nKTtcbnZhciBTZXJ2ZXJSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vU2VydmVyUmVhY3RSb290SW5kZXgnKTtcbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2ltcGxlRXZlbnRQbHVnaW4nKTtcbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vU1ZHRE9NUHJvcGVydHlDb25maWcnKTtcblxudmFyIGFscmVhZHlJbmplY3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIGlmIChhbHJlYWR5SW5qZWN0ZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGJlY2F1c2UgdGhlc2UgaW5qZWN0aW9ucyBhcmUgc2hhcmVkIGJldHdlZW5cbiAgICAvLyB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyIHBhY2thZ2UuIFRoZXkgc2hvdWxkIGJlIGJ1aWx0IGluZGVwZW5kZW50bHlcbiAgICAvLyBhbmQgbm90IHNoYXJlIGFueSBpbmplY3Rpb24gc3RhdGUuIFRoZW4gdGhpcyBwcm9ibGVtIHdpbGwgYmUgc29sdmVkLlxuICAgIHJldHVybjtcbiAgfVxuICBhbHJlYWR5SW5qZWN0ZWQgPSB0cnVlO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50RW1pdHRlci5pbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIoUmVhY3RFdmVudExpc3RlbmVyKTtcblxuICAvKipcbiAgICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERlZmF1bHRFdmVudFBsdWdpbk9yZGVyKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0SW5zdGFuY2VIYW5kbGUoUmVhY3RJbnN0YW5jZUhhbmRsZXMpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RNb3VudChSZWFjdE1vdW50KTtcblxuICAvKipcbiAgICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gICAqIHRoZW0pLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gICAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gICAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICAgIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MoUmVhY3RET01Db21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MoUmVhY3RET01UZXh0Q29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5DbGFzcy5pbmplY3RNaXhpbihSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbik7XG5cbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkVtcHR5Q29tcG9uZW50LmluamVjdEVtcHR5Q29tcG9uZW50KCdub3NjcmlwdCcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICBSZWFjdEluamVjdGlvbi5Sb290SW5kZXguaW5qZWN0Q3JlYXRlUmVhY3RSb290SW5kZXgoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gQ2xpZW50UmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXggOiBTZXJ2ZXJSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uQ29tcG9uZW50LmluamVjdEVudmlyb25tZW50KFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50KTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB1cmwgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJyc7XG4gICAgaWYgKC9bPyZdcmVhY3RfcGVyZlxcYi8udGVzdCh1cmwpKSB7XG4gICAgICB2YXIgUmVhY3REZWZhdWx0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0UGVyZicpO1xuICAgICAgUmVhY3REZWZhdWx0UGVyZi5zdGFydCgpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5qZWN0OiBpbmplY3Rcbn07IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdFBlcmZcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcblxudmFyIHBlcmZvcm1hbmNlTm93ID0gcmVxdWlyZSgnZmJqcy9saWIvcGVyZm9ybWFuY2VOb3cnKTtcblxuZnVuY3Rpb24gcm91bmRGbG9hdCh2YWwpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IodmFsICogMTAwKSAvIDEwMDtcbn1cblxuZnVuY3Rpb24gYWRkVmFsdWUob2JqLCBrZXksIHZhbCkge1xuICBvYmpba2V5XSA9IChvYmpba2V5XSB8fCAwKSArIHZhbDtcbn1cblxudmFyIFJlYWN0RGVmYXVsdFBlcmYgPSB7XG4gIF9hbGxNZWFzdXJlbWVudHM6IFtdLCAvLyBsYXN0IGl0ZW0gaW4gdGhlIGxpc3QgaXMgdGhlIGN1cnJlbnQgb25lXG4gIF9tb3VudFN0YWNrOiBbMF0sXG4gIF9pbmplY3RlZDogZmFsc2UsXG5cbiAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIVJlYWN0RGVmYXVsdFBlcmYuX2luamVjdGVkKSB7XG4gICAgICBSZWFjdFBlcmYuaW5qZWN0aW9uLmluamVjdE1lYXN1cmUoUmVhY3REZWZhdWx0UGVyZi5tZWFzdXJlKTtcbiAgICB9XG5cbiAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoID0gMDtcbiAgICBSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSA9IHRydWU7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0UGVyZi5lbmFibGVNZWFzdXJlID0gZmFsc2U7XG4gIH0sXG5cbiAgZ2V0TGFzdE1lYXN1cmVtZW50czogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gIH0sXG5cbiAgcHJpbnRFeGNsdXNpdmU6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEV4Y2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnQ29tcG9uZW50IGNsYXNzIG5hbWUnOiBpdGVtLmNvbXBvbmVudE5hbWUsXG4gICAgICAgICdUb3RhbCBpbmNsdXNpdmUgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLmluY2x1c2l2ZSksXG4gICAgICAgICdFeGNsdXNpdmUgbW91bnQgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLmV4Y2x1c2l2ZSksXG4gICAgICAgICdFeGNsdXNpdmUgcmVuZGVyIHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5yZW5kZXIpLFxuICAgICAgICAnTW91bnQgdGltZSBwZXIgaW5zdGFuY2UgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5leGNsdXNpdmUgLyBpdGVtLmNvdW50KSxcbiAgICAgICAgJ1JlbmRlciB0aW1lIHBlciBpbnN0YW5jZSAobXMpJzogcm91bmRGbG9hdChpdGVtLnJlbmRlciAvIGl0ZW0uY291bnQpLFxuICAgICAgICAnSW5zdGFuY2VzJzogaXRlbS5jb3VudFxuICAgICAgfTtcbiAgICB9KSk7XG4gICAgLy8gVE9ETzogUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldFRvdGFsVGltZSgpIGRvZXMgbm90IHJldHVybiB0aGUgY29ycmVjdFxuICAgIC8vIG51bWJlci5cbiAgfSxcblxuICBwcmludEluY2x1c2l2ZTogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0SW5jbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMpO1xuICAgIGNvbnNvbGUudGFibGUoc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdPd25lciA+IGNvbXBvbmVudCc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ0luY2x1c2l2ZSB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0udGltZSksXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBnZXRNZWFzdXJlbWVudHNTdW1tYXJ5TWFwOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0SW5jbHVzaXZlU3VtbWFyeShtZWFzdXJlbWVudHMsIHRydWUpO1xuICAgIHJldHVybiBzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ093bmVyID4gY29tcG9uZW50JzogaXRlbS5jb21wb25lbnROYW1lLFxuICAgICAgICAnV2FzdGVkIHRpbWUgKG1zKSc6IGl0ZW0udGltZSxcbiAgICAgICAgJ0luc3RhbmNlcyc6IGl0ZW0uY291bnRcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sXG5cbiAgcHJpbnRXYXN0ZWQ6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIGNvbnNvbGUudGFibGUoUmVhY3REZWZhdWx0UGVyZi5nZXRNZWFzdXJlbWVudHNTdW1tYXJ5TWFwKG1lYXN1cmVtZW50cykpO1xuICAgIGNvbnNvbGUubG9nKCdUb3RhbCB0aW1lOicsIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKS50b0ZpeGVkKDIpICsgJyBtcycpO1xuICB9LFxuXG4gIHByaW50RE9NOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRET01TdW1tYXJ5KG1lYXN1cmVtZW50cyk7XG4gICAgY29uc29sZS50YWJsZShzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgcmVzdWx0W0RPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FXSA9IGl0ZW0uaWQ7XG4gICAgICByZXN1bHQudHlwZSA9IGl0ZW0udHlwZTtcbiAgICAgIHJlc3VsdC5hcmdzID0gSlNPTi5zdHJpbmdpZnkoaXRlbS5hcmdzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSkpO1xuICAgIGNvbnNvbGUubG9nKCdUb3RhbCB0aW1lOicsIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKS50b0ZpeGVkKDIpICsgJyBtcycpO1xuICB9LFxuXG4gIF9yZWNvcmRXcml0ZTogZnVuY3Rpb24gKGlkLCBmbk5hbWUsIHRvdGFsVGltZSwgYXJncykge1xuICAgIC8vIFRPRE86IHRvdGFsVGltZSBpc24ndCB0aGF0IHVzZWZ1bCBzaW5jZSBpdCBkb2Vzbid0IGNvdW50IHBhaW50cy9yZWZsb3dzXG4gICAgdmFyIHdyaXRlcyA9IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV0ud3JpdGVzO1xuICAgIHdyaXRlc1tpZF0gPSB3cml0ZXNbaWRdIHx8IFtdO1xuICAgIHdyaXRlc1tpZF0ucHVzaCh7XG4gICAgICB0eXBlOiBmbk5hbWUsXG4gICAgICB0aW1lOiB0b3RhbFRpbWUsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG4gIH0sXG5cbiAgbWVhc3VyZTogZnVuY3Rpb24gKG1vZHVsZU5hbWUsIGZuTmFtZSwgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG90YWxUaW1lO1xuICAgICAgdmFyIHJ2O1xuICAgICAgdmFyIHN0YXJ0O1xuXG4gICAgICBpZiAoZm5OYW1lID09PSAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQnIHx8IGZuTmFtZSA9PT0gJ2ZsdXNoQmF0Y2hlZFVwZGF0ZXMnKSB7XG4gICAgICAgIC8vIEEgXCJtZWFzdXJlbWVudFwiIGlzIGEgc2V0IG9mIG1ldHJpY3MgcmVjb3JkZWQgZm9yIGVhY2ggZmx1c2guIFdlIHdhbnRcbiAgICAgICAgLy8gdG8gZ3JvdXAgdGhlIG1ldHJpY3MgZm9yIGEgZ2l2ZW4gZmx1c2ggdG9nZXRoZXIgc28gd2UgY2FuIGxvb2sgYXQgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudHMgdGhhdCByZW5kZXJlZCBhbmQgdGhlIERPTSBvcGVyYXRpb25zIHRoYXQgYWN0dWFsbHlcbiAgICAgICAgLy8gaGFwcGVuZWQgdG8gZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2YgXCJ3YXN0ZWQgd29ya1wiIHBlcmZvcm1lZC5cbiAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLnB1c2goe1xuICAgICAgICAgIGV4Y2x1c2l2ZToge30sXG4gICAgICAgICAgaW5jbHVzaXZlOiB7fSxcbiAgICAgICAgICByZW5kZXI6IHt9LFxuICAgICAgICAgIGNvdW50czoge30sXG4gICAgICAgICAgd3JpdGVzOiB7fSxcbiAgICAgICAgICBkaXNwbGF5TmFtZXM6IHt9LFxuICAgICAgICAgIHRvdGFsVGltZTogMCxcbiAgICAgICAgICBjcmVhdGVkOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV0udG90YWxUaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0O1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9IGVsc2UgaWYgKGZuTmFtZSA9PT0gJ19tb3VudEltYWdlSW50b05vZGUnIHx8IG1vZHVsZU5hbWUgPT09ICdSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInIHx8IG1vZHVsZU5hbWUgPT09ICdSZWFjdERPTUlET3BlcmF0aW9ucycgfHwgbW9kdWxlTmFtZSA9PT0gJ0NTU1Byb3BlcnR5T3BlcmF0aW9ucycgfHwgbW9kdWxlTmFtZSA9PT0gJ0RPTUNoaWxkcmVuT3BlcmF0aW9ucycgfHwgbW9kdWxlTmFtZSA9PT0gJ0RPTVByb3BlcnR5T3BlcmF0aW9ucycpIHtcbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcblxuICAgICAgICBpZiAoZm5OYW1lID09PSAnX21vdW50SW1hZ2VJbnRvTm9kZScpIHtcbiAgICAgICAgICB2YXIgbW91bnRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoYXJnc1sxXSk7XG4gICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUobW91bnRJRCwgZm5OYW1lLCB0b3RhbFRpbWUsIGFyZ3NbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGZuTmFtZSA9PT0gJ2Rhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcycpIHtcbiAgICAgICAgICAvLyBzcGVjaWFsIGZvcm1hdFxuICAgICAgICAgIGFyZ3NbMF0uZm9yRWFjaChmdW5jdGlvbiAodXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVBcmdzID0ge307XG4gICAgICAgICAgICBpZiAodXBkYXRlLmZyb21JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MuZnJvbUluZGV4ID0gdXBkYXRlLmZyb21JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUudG9JbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MudG9JbmRleCA9IHVwZGF0ZS50b0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS50ZXh0Q29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MudGV4dENvbnRlbnQgPSB1cGRhdGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLm1hcmt1cEluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdyaXRlQXJncy5tYXJrdXAgPSBhcmdzWzFdW3VwZGF0ZS5tYXJrdXBJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9yZWNvcmRXcml0ZSh1cGRhdGUucGFyZW50SUQsIHVwZGF0ZS50eXBlLCB0b3RhbFRpbWUsIHdyaXRlQXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYmFzaWMgZm9ybWF0XG4gICAgICAgICAgdmFyIGlkID0gYXJnc1swXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGlkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWQgPSBSZWFjdE1vdW50LmdldElEKGFyZ3NbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9yZWNvcmRXcml0ZShpZCwgZm5OYW1lLCB0b3RhbFRpbWUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9IGVsc2UgaWYgKG1vZHVsZU5hbWUgPT09ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcgJiYgKGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JyB8fCBmbk5hbWUgPT09ICd1cGRhdGVDb21wb25lbnQnIHx8IC8vIFRPRE86IHJlY2VpdmVDb21wb25lbnQoKT9cbiAgICAgIGZuTmFtZSA9PT0gJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnKSkge1xuXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlID09PSBSZWFjdE1vdW50LlRvcExldmVsV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvb3ROb2RlSUQgPSBmbk5hbWUgPT09ICdtb3VudENvbXBvbmVudCcgPyBhcmdzWzBdIDogdGhpcy5fcm9vdE5vZGVJRDtcbiAgICAgICAgdmFyIGlzUmVuZGVyID0gZm5OYW1lID09PSAnX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCc7XG4gICAgICAgIHZhciBpc01vdW50ID0gZm5OYW1lID09PSAnbW91bnRDb21wb25lbnQnO1xuXG4gICAgICAgIHZhciBtb3VudFN0YWNrID0gUmVhY3REZWZhdWx0UGVyZi5fbW91bnRTdGFjaztcbiAgICAgICAgdmFyIGVudHJ5ID0gUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzW1JlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoaXNSZW5kZXIpIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5jb3VudHMsIHJvb3ROb2RlSUQsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTW91bnQpIHtcbiAgICAgICAgICBlbnRyeS5jcmVhdGVkW3Jvb3ROb2RlSURdID0gdHJ1ZTtcbiAgICAgICAgICBtb3VudFN0YWNrLnB1c2goMCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgIHJ2ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgdG90YWxUaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIHN0YXJ0O1xuXG4gICAgICAgIGlmIChpc1JlbmRlcikge1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LnJlbmRlciwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdW50KSB7XG4gICAgICAgICAgdmFyIHN1Yk1vdW50VGltZSA9IG1vdW50U3RhY2sucG9wKCk7XG4gICAgICAgICAgbW91bnRTdGFja1ttb3VudFN0YWNrLmxlbmd0aCAtIDFdICs9IHRvdGFsVGltZTtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5leGNsdXNpdmUsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSAtIHN1Yk1vdW50VGltZSk7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuaW5jbHVzaXZlLCByb290Tm9kZUlELCB0b3RhbFRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmluY2x1c2l2ZSwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVudHJ5LmRpc3BsYXlOYW1lc1tyb290Tm9kZUlEXSA9IHtcbiAgICAgICAgICBjdXJyZW50OiB0aGlzLmdldE5hbWUoKSxcbiAgICAgICAgICBvd25lcjogdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyID8gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSA6ICc8cm9vdD4nXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRQZXJmOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcblxuLy8gRG9uJ3QgdHJ5IHRvIHNhdmUgdXNlcnMgbGVzcyB0aGFuIDEuMm1zIChhIG51bWJlciBJIG1hZGUgdXApXG52YXIgRE9OVF9DQVJFX1RIUkVTSE9MRCA9IDEuMjtcbnZhciBET01fT1BFUkFUSU9OX1RZUEVTID0ge1xuICAnX21vdW50SW1hZ2VJbnRvTm9kZSc6ICdzZXQgaW5uZXJIVE1MJyxcbiAgSU5TRVJUX01BUktVUDogJ3NldCBpbm5lckhUTUwnLFxuICBNT1ZFX0VYSVNUSU5HOiAnbW92ZScsXG4gIFJFTU9WRV9OT0RFOiAncmVtb3ZlJyxcbiAgU0VUX01BUktVUDogJ3NldCBpbm5lckhUTUwnLFxuICBURVhUX0NPTlRFTlQ6ICdzZXQgdGV4dENvbnRlbnQnLFxuICAnc2V0VmFsdWVGb3JQcm9wZXJ0eSc6ICd1cGRhdGUgYXR0cmlidXRlJyxcbiAgJ3NldFZhbHVlRm9yQXR0cmlidXRlJzogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxuICAnZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSc6ICdyZW1vdmUgYXR0cmlidXRlJyxcbiAgJ3NldFZhbHVlRm9yU3R5bGVzJzogJ3VwZGF0ZSBzdHlsZXMnLFxuICAncmVwbGFjZU5vZGVXaXRoTWFya3VwJzogJ3JlcGxhY2UnLFxuICAndXBkYXRlVGV4dENvbnRlbnQnOiAnc2V0IHRleHRDb250ZW50J1xufTtcblxuZnVuY3Rpb24gZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykge1xuICAvLyBUT0RPOiByZXR1cm4gbnVtYmVyIG9mIERPTSBvcHM/IGNvdWxkIGJlIG1pc2xlYWRpbmcuXG4gIC8vIFRPRE86IG1lYXN1cmUgZHJvcHBlZCBmcmFtZXMgYWZ0ZXIgcmVjb25jaWxlP1xuICAvLyBUT0RPOiBsb2cgdG90YWwgdGltZSBvZiBlYWNoIHJlY29uY2lsZSBhbmQgdGhlIHRvcC1sZXZlbCBjb21wb25lbnRcbiAgLy8gY2xhc3MgdGhhdCB0cmlnZ2VyZWQgaXQuXG4gIHZhciB0b3RhbFRpbWUgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB0b3RhbFRpbWUgKz0gbWVhc3VyZW1lbnQudG90YWxUaW1lO1xuICB9XG4gIHJldHVybiB0b3RhbFRpbWU7XG59XG5cbmZ1bmN0aW9uIGdldERPTVN1bW1hcnkobWVhc3VyZW1lbnRzKSB7XG4gIHZhciBpdGVtcyA9IFtdO1xuICBtZWFzdXJlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobWVhc3VyZW1lbnQpIHtcbiAgICBPYmplY3Qua2V5cyhtZWFzdXJlbWVudC53cml0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICBtZWFzdXJlbWVudC53cml0ZXNbaWRdLmZvckVhY2goZnVuY3Rpb24gKHdyaXRlKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICB0eXBlOiBET01fT1BFUkFUSU9OX1RZUEVTW3dyaXRlLnR5cGVdIHx8IHdyaXRlLnR5cGUsXG4gICAgICAgICAgYXJnczogd3JpdGUuYXJnc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG5mdW5jdGlvbiBnZXRFeGNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cykge1xuICB2YXIgY2FuZGlkYXRlcyA9IHt9O1xuICB2YXIgZGlzcGxheU5hbWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdmFyIGFsbElEcyA9IGFzc2lnbih7fSwgbWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuXG4gICAgZm9yICh2YXIgaWQgaW4gYWxsSURzKSB7XG4gICAgICBkaXNwbGF5TmFtZSA9IG1lYXN1cmVtZW50LmRpc3BsYXlOYW1lc1tpZF0uY3VycmVudDtcblxuICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0gPSBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXSB8fCB7XG4gICAgICAgIGNvbXBvbmVudE5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBpbmNsdXNpdmU6IDAsXG4gICAgICAgIGV4Y2x1c2l2ZTogMCxcbiAgICAgICAgcmVuZGVyOiAwLFxuICAgICAgICBjb3VudDogMFxuICAgICAgfTtcbiAgICAgIGlmIChtZWFzdXJlbWVudC5yZW5kZXJbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLnJlbmRlciArPSBtZWFzdXJlbWVudC5yZW5kZXJbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmV4Y2x1c2l2ZVtpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uZXhjbHVzaXZlICs9IG1lYXN1cmVtZW50LmV4Y2x1c2l2ZVtpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5pbmNsdXNpdmUgKz0gbWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5jb3VudHNbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmNvdW50ICs9IG1lYXN1cmVtZW50LmNvdW50c1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTm93IG1ha2UgYSBzb3J0ZWQgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cy5cbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKGRpc3BsYXlOYW1lIGluIGNhbmRpZGF0ZXMpIHtcbiAgICBpZiAoY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uZXhjbHVzaXZlID49IERPTlRfQ0FSRV9USFJFU0hPTEQpIHtcbiAgICAgIGFyci5wdXNoKGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdKTtcbiAgICB9XG4gIH1cblxuICBhcnIuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmV4Y2x1c2l2ZSAtIGEuZXhjbHVzaXZlO1xuICB9KTtcblxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBnZXRJbmNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cywgb25seUNsZWFuKSB7XG4gIHZhciBjYW5kaWRhdGVzID0ge307XG4gIHZhciBpbmNsdXNpdmVLZXk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBtZWFzdXJlbWVudHNbaV07XG4gICAgdmFyIGFsbElEcyA9IGFzc2lnbih7fSwgbWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuICAgIHZhciBjbGVhbkNvbXBvbmVudHM7XG5cbiAgICBpZiAob25seUNsZWFuKSB7XG4gICAgICBjbGVhbkNvbXBvbmVudHMgPSBnZXRVbmNoYW5nZWRDb21wb25lbnRzKG1lYXN1cmVtZW50KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICAgIGlmIChvbmx5Q2xlYW4gJiYgIWNsZWFuQ29tcG9uZW50c1tpZF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IG1lYXN1cmVtZW50LmRpc3BsYXlOYW1lc1tpZF07XG5cbiAgICAgIC8vIEluY2x1c2l2ZSB0aW1lIGlzIG5vdCB1c2VmdWwgZm9yIG1hbnkgY29tcG9uZW50cyB3aXRob3V0IGtub3dpbmcgd2hlcmVcbiAgICAgIC8vIHRoZXkgYXJlIGluc3RhbnRpYXRlZC4gU28gd2UgYWdncmVnYXRlIGluY2x1c2l2ZSB0aW1lIHdpdGggYm90aCB0aGVcbiAgICAgIC8vIG93bmVyIGFuZCBjdXJyZW50IGRpc3BsYXlOYW1lIGFzIHRoZSBrZXkuXG4gICAgICBpbmNsdXNpdmVLZXkgPSBkaXNwbGF5TmFtZS5vd25lciArICcgPiAnICsgZGlzcGxheU5hbWUuY3VycmVudDtcblxuICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldID0gY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldIHx8IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogaW5jbHVzaXZlS2V5LFxuICAgICAgICB0aW1lOiAwLFxuICAgICAgICBjb3VudDogMFxuICAgICAgfTtcblxuICAgICAgaWYgKG1lYXN1cmVtZW50LmluY2x1c2l2ZVtpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldLnRpbWUgKz0gbWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5jb3VudHNbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XS5jb3VudCArPSBtZWFzdXJlbWVudC5jb3VudHNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5vdyBtYWtlIGEgc29ydGVkIGFycmF5IHdpdGggdGhlIHJlc3VsdHMuXG4gIHZhciBhcnIgPSBbXTtcbiAgZm9yIChpbmNsdXNpdmVLZXkgaW4gY2FuZGlkYXRlcykge1xuICAgIGlmIChjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0udGltZSA+PSBET05UX0NBUkVfVEhSRVNIT0xEKSB7XG4gICAgICBhcnIucHVzaChjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0pO1xuICAgIH1cbiAgfVxuXG4gIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIudGltZSAtIGEudGltZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gZ2V0VW5jaGFuZ2VkQ29tcG9uZW50cyhtZWFzdXJlbWVudCkge1xuICAvLyBGb3IgYSBnaXZlbiByZWNvbmNpbGUsIGxvb2sgYXQgd2hpY2ggY29tcG9uZW50cyBkaWQgbm90IGFjdHVhbGx5XG4gIC8vIHJlbmRlciBhbnl0aGluZyB0byB0aGUgRE9NIGFuZCByZXR1cm4gYSBtYXBwaW5nIG9mIHRoZWlyIElEIHRvXG4gIC8vIHRoZSBhbW91bnQgb2YgdGltZSBpdCB0b29rIHRvIHJlbmRlciB0aGUgZW50aXJlIHN1YnRyZWUuXG4gIHZhciBjbGVhbkNvbXBvbmVudHMgPSB7fTtcbiAgdmFyIGRpcnR5TGVhZklEcyA9IE9iamVjdC5rZXlzKG1lYXN1cmVtZW50LndyaXRlcyk7XG4gIHZhciBhbGxJRHMgPSBhc3NpZ24oe30sIG1lYXN1cmVtZW50LmV4Y2x1c2l2ZSwgbWVhc3VyZW1lbnQuaW5jbHVzaXZlKTtcblxuICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICB2YXIgaXNEaXJ0eSA9IGZhbHNlO1xuICAgIC8vIEZvciBlYWNoIGNvbXBvbmVudCB0aGF0IHJlbmRlcmVkLCBzZWUgaWYgYSBjb21wb25lbnQgdGhhdCB0cmlnZ2VyZWRcbiAgICAvLyBhIERPTSBvcCBpcyBpbiBpdHMgc3VidHJlZS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnR5TGVhZklEcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGRpcnR5TGVhZklEc1tpXS5pbmRleE9mKGlkKSA9PT0gMCkge1xuICAgICAgICBpc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIGNvbXBvbmVudCBuZXdseSBjcmVhdGVkXG4gICAgaWYgKG1lYXN1cmVtZW50LmNyZWF0ZWRbaWRdKSB7XG4gICAgICBpc0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFpc0RpcnR5ICYmIG1lYXN1cmVtZW50LmNvdW50c1tpZF0gPiAwKSB7XG4gICAgICBjbGVhbkNvbXBvbmVudHNbaWRdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsZWFuQ29tcG9uZW50cztcbn1cblxudmFyIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcyA9IHtcbiAgZ2V0RXhjbHVzaXZlU3VtbWFyeTogZ2V0RXhjbHVzaXZlU3VtbWFyeSxcbiAgZ2V0SW5jbHVzaXZlU3VtbWFyeTogZ2V0SW5jbHVzaXZlU3VtbWFyeSxcbiAgZ2V0RE9NU3VtbWFyeTogZ2V0RE9NU3VtbWFyeSxcbiAgZ2V0VG90YWxUaW1lOiBnZXRUb3RhbFRpbWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVsZW1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG4vKipcbiAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBSZWFjdCBlbGVtZW50cy4gVGhpcyBpcyBvbmx5IHVzZWQgdG8gbWFrZSB0aGlzXG4gKiB3b3JrIHdpdGggYSBkeW5hbWljIGluc3RhbmNlb2YgY2hlY2suIE5vdGhpbmcgc2hvdWxkIGxpdmUgb24gdGhpcyBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc2VsZlxuICAgICAgfSk7XG4gICAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIGVsZW1lbnQuX3NlbGYgPSBzZWxmO1xuICAgICAgZWxlbWVudC5fc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cblJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIHJlZiA9IGNvbmZpZy5yZWYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcucmVmO1xuICAgIGtleSA9IGNvbmZpZy5rZXkgPT09IHVuZGVmaW5lZCA/IG51bGwgOiAnJyArIGNvbmZpZy5rZXk7XG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHNbcHJvcE5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufTtcblxuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cblJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdQcm9wcykge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG9sZEVsZW1lbnQua2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgbmV3UHJvcHMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gSWYgdGhlIGtleSBvbiB0aGUgb3JpZ2luYWwgaXMgdmFsaWQsIHRoZW4gdGhlIGNsb25lIGlzIHZhbGlkXG4gICAgbmV3RWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gb2xkRWxlbWVudC5fc3RvcmUudmFsaWRhdGVkO1xuICB9XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RWxlbWVudFZhbGlkYXRvclxuICovXG5cbi8qKlxuICogUmVhY3RFbGVtZW50VmFsaWRhdG9yIHByb3ZpZGVzIGEgd3JhcHBlciBhcm91bmQgYSBlbGVtZW50IGZhY3RvcnlcbiAqIHdoaWNoIHZhbGlkYXRlcyB0aGUgcHJvcHMgcGFzc2VkIHRvIHRoZSBlbGVtZW50LiBUaGlzIGlzIGludGVuZGVkIHRvIGJlXG4gKiB1c2VkIG9ubHkgaW4gREVWIGFuZCBjb3VsZCBiZSByZXBsYWNlZCBieSBhIHN0YXRpYyB0eXBlIGNoZWNrZXIgZm9yIGxhbmd1YWdlc1xuICogdGhhdCBzdXBwb3J0IGl0LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIGFkZGVuZGEgPSBnZXRBZGRlbmRhRm9yS2V5VXNlKCd1bmlxdWVLZXknLCBlbGVtZW50LCBwYXJlbnRUeXBlKTtcbiAgaWYgKGFkZGVuZGEgPT09IG51bGwpIHtcbiAgICAvLyB3ZSBhbHJlYWR5IHNob3dlZCB0aGUgd2FybmluZ1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyVzJywgYWRkZW5kYS5wYXJlbnRPck93bmVyIHx8ICcnLCBhZGRlbmRhLmNoaWxkT3duZXIgfHwgJycsIGFkZGVuZGEudXJsIHx8ICcnKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBTaGFyZWQgd2FybmluZyBhbmQgbW9uaXRvcmluZyBjb2RlIGZvciB0aGUga2V5IHdhcm5pbmdzLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VUeXBlIEEga2V5IHVzZWQgZm9yIGRlLWR1cGluZyB3YXJuaW5ncy5cbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IENvbXBvbmVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICogQHJldHVybnMgez9vYmplY3R9IEEgc2V0IG9mIGFkZGVuZGEgdG8gdXNlIGluIHRoZSB3YXJuaW5nIG1lc3NhZ2UsIG9yIG51bGxcbiAqIGlmIHRoZSB3YXJuaW5nIGhhcyBhbHJlYWR5IGJlZW4gc2hvd24gYmVmb3JlIChhbmQgc2hvdWxkbid0IGJlIHNob3duIGFnYWluKS5cbiAqL1xuZnVuY3Rpb24gZ2V0QWRkZW5kYUZvcktleVVzZShtZXNzYWdlVHlwZSwgZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgaWYgKCFhZGRlbmR1bSkge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBhZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtZW1vaXplciA9IG93bmVySGFzS2V5VXNlV2FybmluZ1ttZXNzYWdlVHlwZV0gfHwgKG93bmVySGFzS2V5VXNlV2FybmluZ1ttZXNzYWdlVHlwZV0gPSB7fSk7XG4gIGlmIChtZW1vaXplclthZGRlbmR1bV0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBtZW1vaXplclthZGRlbmR1bV0gPSB0cnVlO1xuXG4gIHZhciBhZGRlbmRhID0ge1xuICAgIHBhcmVudE9yT3duZXI6IGFkZGVuZHVtLFxuICAgIHVybDogJyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICBjaGlsZE93bmVyOiBudWxsXG4gIH07XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgYWRkZW5kYS5jaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nO1xuICB9XG5cbiAgcmV0dXJuIGFkZGVuZGE7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgLy8gRW50cnkgaXRlcmF0b3JzIHByb3ZpZGUgaW1wbGljaXQga2V5cy5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgcHJvcHMgYXJlIHZhbGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wVHlwZXMgTWFwIG9mIHByb3AgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXMoY29tcG9uZW50TmFtZSwgcHJvcFR5cGVzLCBwcm9wcywgbG9jYXRpb24pIHtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XG4gICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiBwcm9wVHlwZXNbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBlcnJvciA9IHByb3BUeXBlc1twcm9wTmFtZV0ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUsIHR5cGVvZiBlcnJvcikgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgYWRkZW5kdW0gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gZWxlbWVudC50eXBlO1xuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcbiAgaWYgKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcykge1xuICAgIGNoZWNrUHJvcFR5cGVzKG5hbWUsIGNvbXBvbmVudENsYXNzLnByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0ge1xuXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nO1xuICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh2YWxpZFR5cGUsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIHNob3VsZCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBib29sZWFuLCBvciAnICsgJ251bWJlci4gSXQgc2hvdWxkIGJlIGEgc3RyaW5nIChmb3IgRE9NIGVsZW1lbnRzKSBvciBhIFJlYWN0Q2xhc3MgJyArICcoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBlbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgY3JlYXRlRmFjdG9yeTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gICAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gICAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG4gIH0sXG5cbiAgY2xvbmVFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gICAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3I7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RW1wdHlDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeSA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xuXG52YXIgcGxhY2Vob2xkZXJFbGVtZW50O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RW1wdHlDb21wb25lbnQ6IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICBwbGFjZWhvbGRlckVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudChjb21wb25lbnQpO1xuICB9XG59O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGluc3RhbnRpYXRlKHBsYWNlaG9sZGVyRWxlbWVudCk7XG59O1xuYXNzaWduKFJlYWN0RW1wdHlDb21wb25lbnQucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHt9LFxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkucmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQocm9vdElEKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuICAgIHJldHVybiBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICB9LFxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7fSxcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gICAgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LmRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICB9XG59KTtcblxuUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24gPSBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB0aGUgUmVhY3QgSURzIG9mIHRoZSBjb21wb25lbnRzIHRoYXQgcmVuZGVyZWQgdG9cbi8vIGBudWxsYCAoaW4gcmVhbGl0eSBhIHBsYWNlaG9sZGVyIHN1Y2ggYXMgYG5vc2NyaXB0YClcbnZhciBudWxsQ29tcG9uZW50SURzUmVnaXN0cnkgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZCB0byBudWxsLlxuICovXG5mdW5jdGlvbiBpc051bGxDb21wb25lbnRJRChpZCkge1xuICByZXR1cm4gISFudWxsQ29tcG9uZW50SURzUmVnaXN0cnlbaWRdO1xufVxuXG4vKipcbiAqIE1hcmsgdGhlIGNvbXBvbmVudCBhcyBoYXZpbmcgcmVuZGVyZWQgdG8gbnVsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQncyBgX3Jvb3ROb2RlSURgLlxuICovXG5mdW5jdGlvbiByZWdpc3Rlck51bGxDb21wb25lbnRJRChpZCkge1xuICBudWxsQ29tcG9uZW50SURzUmVnaXN0cnlbaWRdID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVbm1hcmsgdGhlIGNvbXBvbmVudCBhcyBoYXZpbmcgcmVuZGVyZWQgdG8gbnVsbDogaXQgcmVuZGVycyB0byBzb21ldGhpbmcgbm93LlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIENvbXBvbmVudCdzIGBfcm9vdE5vZGVJRGAuXG4gKi9cbmZ1bmN0aW9uIGRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQoaWQpIHtcbiAgZGVsZXRlIG51bGxDb21wb25lbnRJRHNSZWdpc3RyeVtpZF07XG59XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkgPSB7XG4gIGlzTnVsbENvbXBvbmVudElEOiBpc051bGxDb21wb25lbnRJRCxcbiAgcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQ6IHJlZ2lzdGVyTnVsbENvbXBvbmVudElELFxuICBkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEOiBkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFcnJvclV0aWxzXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqXG4gKiBAcGFyYW0gez9TdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBhIEZpcnN0IGFyZ3VtZW50XG4gKiBAcGFyYW0geyp9IGIgU2Vjb25kIGFyZ3VtZW50XG4gKi9cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBhLCBiKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZ1bmMoYSwgYik7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IgPT09IG51bGwpIHtcbiAgICAgIGNhdWdodEVycm9yID0geDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogSW52b2tlZCBieSBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZSBzbyB0aGF0IGFueSBlcnJvcnMgdGhyb3duIGJ5IHRoZSBldmVudFxuICAgKiBoYW5kbGVyIGFyZSBzdXJlIHRvIGJlIHJldGhyb3duIGJ5IHJldGhyb3dDYXVnaHRFcnJvci5cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaDogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAgICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICAgKi9cbiAgcmV0aHJvd0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcbiAgICAgIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLyoqXG4gICAqIFRvIGhlbHAgZGV2ZWxvcG1lbnQgd2UgY2FuIGdldCBiZXR0ZXIgZGV2dG9vbHMgaW50ZWdyYXRpb24gYnkgc2ltdWxhdGluZyBhXG4gICAqIHJlYWwgYnJvd3NlciBldmVudC5cbiAgICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgYSwgYikge1xuICAgICAgdmFyIGJvdW5kRnVuYyA9IGZ1bmMuYmluZChudWxsLCBhLCBiKTtcbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyBuYW1lO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXJyb3JVdGlsczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFdmVudEVtaXR0ZXJNaXhpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xuXG5mdW5jdGlvbiBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpIHtcbiAgRXZlbnRQbHVnaW5IdWIuZW5xdWV1ZUV2ZW50cyhldmVudHMpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbnZhciBSZWFjdEV2ZW50RW1pdHRlck1peGluID0ge1xuXG4gIC8qKlxuICAgKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICAgKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgZW52aXJvbm1lbnQgZXZlbnQuXG4gICAqL1xuICBoYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHMgPSBFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50RW1pdHRlck1peGluOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uJyk7XG5cbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgcGFyZW50IFJlYWN0IGNvbXBvbmVudCBvZiBgbm9kZWAuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRXZlbnRUYXJnZXR9IFBhcmVudCBjb250YWluZXIsIG9yIGBudWxsYCBpZiB0aGUgc3BlY2lmaWVkIG5vZGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgbm90IG5lc3RlZC5cbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudChub2RlKSB7XG4gIC8vIFRPRE86IEl0IG1heSBiZSBhIGdvb2QgaWRlYSB0byBjYWNoZSB0aGlzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgRE9NXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXG4gIHZhciBub2RlSUQgPSBSZWFjdE1vdW50LmdldElEKG5vZGUpO1xuICB2YXIgcm9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKG5vZGVJRCk7XG4gIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKHJvb3RJRCk7XG4gIHZhciBwYXJlbnQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oY29udGFpbmVyKTtcbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xufVxuYXNzaWduKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICB9XG59KTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIC8vIFRPRE86IFJlLWVuYWJsZSBldmVudC5wYXRoIGhhbmRsaW5nXG4gIC8vXG4gIC8vIGlmIChib29rS2VlcGluZy5uYXRpdmVFdmVudC5wYXRoICYmIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LnBhdGgubGVuZ3RoID4gMSkge1xuICAvLyAgIC8vIE5ldyBicm93c2VycyBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuICAvLyAgIGhhbmRsZVRvcExldmVsV2l0aFBhdGgoYm9va0tlZXBpbmcpO1xuICAvLyB9IGVsc2Uge1xuICAvLyAgIC8vIExlZ2FjeSBicm93c2VycyBkb24ndCBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuICAvLyAgIGhhbmRsZVRvcExldmVsV2l0aG91dFBhdGgoYm9va0tlZXBpbmcpO1xuICAvLyB9XG5cbiAgdm9pZCBoYW5kbGVUb3BMZXZlbFdpdGhQYXRoOyAvLyB0ZW1wb3JhcmlseSB1bnVzZWRcbiAgaGFuZGxlVG9wTGV2ZWxXaXRob3V0UGF0aChib29rS2VlcGluZyk7XG59XG5cbi8vIExlZ2FjeSBicm93c2VycyBkb24ndCBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxXaXRob3V0UGF0aChib29rS2VlcGluZykge1xuICB2YXIgdG9wTGV2ZWxUYXJnZXQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKSB8fCB3aW5kb3c7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRvcExldmVsVGFyZ2V0O1xuICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBmaW5kUGFyZW50KGFuY2VzdG9yKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9wTGV2ZWxUYXJnZXQgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgdmFyIHRvcExldmVsVGFyZ2V0SUQgPSBSZWFjdE1vdW50LmdldElEKHRvcExldmVsVGFyZ2V0KSB8fCAnJztcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbi8vIE5ldyBicm93c2VycyBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxXaXRoUGF0aChib29rS2VlcGluZykge1xuICB2YXIgcGF0aCA9IGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LnBhdGg7XG4gIHZhciBjdXJyZW50TmF0aXZlVGFyZ2V0ID0gcGF0aFswXTtcbiAgdmFyIGV2ZW50c0ZpcmVkID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRQYXRoRWxlbWVudCA9IHBhdGhbaV07XG4gICAgaWYgKGN1cnJlbnRQYXRoRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSB7XG4gICAgICBjdXJyZW50TmF0aXZlVGFyZ2V0ID0gcGF0aFtpICsgMV07XG4gICAgfVxuICAgIC8vIFRPRE86IHNsb3dcbiAgICB2YXIgcmVhY3RQYXJlbnQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oY3VycmVudFBhdGhFbGVtZW50KTtcbiAgICBpZiAocmVhY3RQYXJlbnQgPT09IGN1cnJlbnRQYXRoRWxlbWVudCkge1xuICAgICAgdmFyIGN1cnJlbnRQYXRoRWxlbWVudElEID0gUmVhY3RNb3VudC5nZXRJRChjdXJyZW50UGF0aEVsZW1lbnQpO1xuICAgICAgdmFyIG5ld1Jvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChjdXJyZW50UGF0aEVsZW1lbnRJRCk7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChjdXJyZW50UGF0aEVsZW1lbnQpO1xuXG4gICAgICB2YXIgdG9wTGV2ZWxUYXJnZXRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY3VycmVudFBhdGhFbGVtZW50KSB8fCAnJztcbiAgICAgIGV2ZW50c0ZpcmVkKys7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgY3VycmVudFBhdGhFbGVtZW50LCB0b3BMZXZlbFRhcmdldElELCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgY3VycmVudE5hdGl2ZVRhcmdldCk7XG5cbiAgICAgIC8vIEp1bXAgdG8gdGhlIHJvb3Qgb2YgdGhpcyBSZWFjdCByZW5kZXIgdHJlZVxuICAgICAgd2hpbGUgKGN1cnJlbnRQYXRoRWxlbWVudElEICE9PSBuZXdSb290SUQpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBjdXJyZW50UGF0aEVsZW1lbnQgPSBwYXRoW2ldO1xuICAgICAgICBjdXJyZW50UGF0aEVsZW1lbnRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY3VycmVudFBhdGhFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGV2ZW50c0ZpcmVkID09PSAwKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHdpbmRvdywgJycsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKGhhbmRsZVRvcExldmVsKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xuICB9LFxuXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkID0gISFlbmFibGVkO1xuICB9LFxuXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGhhbmRsZTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgbW9uaXRvclNjcm9sbFZhbHVlOiBmdW5jdGlvbiAocmVmcmVzaCkge1xuICAgIHZhciBjYWxsYmFjayA9IHNjcm9sbFZhbHVlTW9uaXRvci5iaW5kKG51bGwsIHJlZnJlc2gpO1xuICAgIEV2ZW50TGlzdGVuZXIubGlzdGVuKHdpbmRvdywgJ3Njcm9sbCcsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAgIGlmICghUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJvb2tLZWVwaW5nID0gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLmdldFBvb2xlZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgICB0cnkge1xuICAgICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnJlbGVhc2UoYm9va0tlZXBpbmcpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50TGlzdGVuZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5qZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3ROYXRpdmVDb21wb25lbnQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZSgnLi9SZWFjdFJvb3RJbmRleCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBSZWFjdEluamVjdGlvbiA9IHtcbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LmluamVjdGlvbixcbiAgQ2xhc3M6IFJlYWN0Q2xhc3MuaW5qZWN0aW9uLFxuICBET01Qcm9wZXJ0eTogRE9NUHJvcGVydHkuaW5qZWN0aW9uLFxuICBFbXB0eUNvbXBvbmVudDogUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24sXG4gIEV2ZW50RW1pdHRlcjogUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmluamVjdGlvbixcbiAgTmF0aXZlQ29tcG9uZW50OiBSZWFjdE5hdGl2ZUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIFBlcmY6IFJlYWN0UGVyZi5pbmplY3Rpb24sXG4gIFJvb3RJbmRleDogUmVhY3RSb290SW5kZXguaW5qZWN0aW9uLFxuICBVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5qZWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdElucHV0U2VsZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0aW9uJyk7XG5cbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudCcpO1xuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHtcblxuICBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgICBzZWxlY3Rpb25SYW5nZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICAgKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAgICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gICAqL1xuICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbiAocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIGlmIChSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiAoaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JykpIHtcbiAgICAgIC8vIElFOCBpbnB1dC5cbiAgICAgIHZhciByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgLy8gVGhlcmUgY2FuIG9ubHkgYmUgb25lIHNlbGVjdGlvbiBwZXIgZG9jdW1lbnQgaW4gSUUsIHNvIGl0IG11c3RcbiAgICAgIC8vIGJlIGluIG91ciBlbGVtZW50LlxuICAgICAgaWYgKHJhbmdlLnBhcmVudEVsZW1lbnQoKSA9PT0gaW5wdXQpIHtcbiAgICAgICAgc2VsZWN0aW9uID0ge1xuICAgICAgICAgIHN0YXJ0OiAtcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKSxcbiAgICAgICAgICBlbmQ6IC1yYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCAtaW5wdXQudmFsdWUubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb250ZW50IGVkaXRhYmxlIG9yIG9sZCBJRSB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IFJlYWN0RE9NU2VsZWN0aW9uLmdldE9mZnNldHMoaW5wdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3Rpb24gfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICAgKiB0aGUgaW5wdXQuXG4gICAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAgICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICAgKi9cbiAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQsIG9mZnNldHMpIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgICBpZiAodHlwZW9mIGVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgaW5wdXQuc2VsZWN0aW9uRW5kID0gTWF0aC5taW4oZW5kLCBpbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uICYmIChpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSkge1xuICAgICAgdmFyIHJhbmdlID0gaW5wdXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kIC0gc3RhcnQpO1xuICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RE9NU2VsZWN0aW9uLnNldE9mZnNldHMoaW5wdXQsIG9mZnNldHMpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdElucHV0U2VsZWN0aW9uOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEluc3RhbmNlSGFuZGxlc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vUmVhY3RSb290SW5kZXgnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNFUEFSQVRPUl9MRU5HVEggPSBTRVBBUkFUT1IubGVuZ3RoO1xuXG4vKipcbiAqIE1heGltdW0gZGVwdGggb2YgdHJhdmVyc2FscyBiZWZvcmUgd2UgY29uc2lkZXIgdGhlIHBvc3NpYmlsaXR5IG9mIGEgYmFkIElELlxuICovXG52YXIgTUFYX1RSRUVfREVQVEggPSAxMDAwMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgRE9NIElEIHByZWZpeCB0byB1c2Ugd2hlbiBtb3VudGluZyBSZWFjdCBjb21wb25lbnRzLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBBIHVuaXF1ZSBpbnRlZ2VyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlYWN0IHJvb3QgSUQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290SURTdHJpbmcoaW5kZXgpIHtcbiAgcmV0dXJuIFNFUEFSQVRPUiArIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBjaGFyYWN0ZXIgaW4gdGhlIHN1cHBsaWVkIElEIGlzIGEgc2VwYXJhdG9yIG9yIHRoZSBlbmQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QgRE9NIElELlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBjaGFyYWN0ZXIgaXMgYSBzZXBhcmF0b3Igb3IgZW5kIG9mIHRoZSBJRC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzQm91bmRhcnkoaWQsIGluZGV4KSB7XG4gIHJldHVybiBpZC5jaGFyQXQoaW5kZXgpID09PSBTRVBBUkFUT1IgfHwgaW5kZXggPT09IGlkLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHN1cHBsaWVkIHN0cmluZyBpcyBhIHZhbGlkIFJlYWN0IERPTSBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQSBSZWFjdCBET00gSUQsIG1heWJlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgUmVhY3QgRE9NIElELlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZElEKGlkKSB7XG4gIHJldHVybiBpZCA9PT0gJycgfHwgaWQuY2hhckF0KDApID09PSBTRVBBUkFUT1IgJiYgaWQuY2hhckF0KGlkLmxlbmd0aCAtIDEpICE9PSBTRVBBUkFUT1I7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBmaXJzdCBJRCBpcyBhbiBhbmNlc3RvciBvZiBvciBlcXVhbCB0byB0aGUgc2Vjb25kIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbmNlc3RvcklEXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzY2VuZGFudElEXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBhbmNlc3RvcklEYCBpcyBhbiBhbmNlc3RvciBvZiBgZGVzY2VuZGFudElEYC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc0FuY2VzdG9ySURPZihhbmNlc3RvcklELCBkZXNjZW5kYW50SUQpIHtcbiAgcmV0dXJuIGRlc2NlbmRhbnRJRC5pbmRleE9mKGFuY2VzdG9ySUQpID09PSAwICYmIGlzQm91bmRhcnkoZGVzY2VuZGFudElELCBhbmNlc3RvcklELmxlbmd0aCk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcGFyZW50IElEIG9mIHRoZSBzdXBwbGllZCBSZWFjdCBET00gSUQsIGBpZGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIGEgY29tcG9uZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBJRCBvZiB0aGUgcGFyZW50LCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJRChpZCkge1xuICByZXR1cm4gaWQgPyBpZC5zdWJzdHIoMCwgaWQubGFzdEluZGV4T2YoU0VQQVJBVE9SKSkgOiAnJztcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuZXh0IERPTSBJRCBvbiB0aGUgdHJlZSBwYXRoIGZyb20gdGhlIHN1cHBsaWVkIGBhbmNlc3RvcklEYCB0byB0aGVcbiAqIHN1cHBsaWVkIGBkZXN0aW5hdGlvbklEYC4gSWYgdGhleSBhcmUgZXF1YWwsIHRoZSBJRCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW5jZXN0b3JJRCBJRCBvZiBhbiBhbmNlc3RvciBub2RlIG9mIGBkZXN0aW5hdGlvbklEYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0aW5hdGlvbklEIElEIG9mIHRoZSBkZXN0aW5hdGlvbiBub2RlLlxuICogQHJldHVybiB7c3RyaW5nfSBOZXh0IElEIG9uIHRoZSBwYXRoIGZyb20gYGFuY2VzdG9ySURgIHRvIGBkZXN0aW5hdGlvbklEYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldE5leHREZXNjZW5kYW50SUQoYW5jZXN0b3JJRCwgZGVzdGluYXRpb25JRCkge1xuICAhKGlzVmFsaWRJRChhbmNlc3RvcklEKSAmJiBpc1ZhbGlkSUQoZGVzdGluYXRpb25JRCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5leHREZXNjZW5kYW50SUQoJXMsICVzKTogUmVjZWl2ZWQgYW4gaW52YWxpZCBSZWFjdCBET00gSUQuJywgYW5jZXN0b3JJRCwgZGVzdGluYXRpb25JRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAhaXNBbmNlc3RvcklET2YoYW5jZXN0b3JJRCwgZGVzdGluYXRpb25JRCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0TmV4dERlc2NlbmRhbnRJRCguLi4pOiBSZWFjdCBoYXMgbWFkZSBhbiBpbnZhbGlkIGFzc3VtcHRpb24gYWJvdXQgJyArICd0aGUgRE9NIGhpZXJhcmNoeS4gRXhwZWN0ZWQgYCVzYCB0byBiZSBhbiBhbmNlc3RvciBvZiBgJXNgLicsIGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgaWYgKGFuY2VzdG9ySUQgPT09IGRlc3RpbmF0aW9uSUQpIHtcbiAgICByZXR1cm4gYW5jZXN0b3JJRDtcbiAgfVxuICAvLyBTa2lwIG92ZXIgdGhlIGFuY2VzdG9yIGFuZCB0aGUgaW1tZWRpYXRlIHNlcGFyYXRvci4gVHJhdmVyc2UgdW50aWwgd2UgaGl0XG4gIC8vIGFub3RoZXIgc2VwYXJhdG9yIG9yIHdlIHJlYWNoIHRoZSBlbmQgb2YgYGRlc3RpbmF0aW9uSURgLlxuICB2YXIgc3RhcnQgPSBhbmNlc3RvcklELmxlbmd0aCArIFNFUEFSQVRPUl9MRU5HVEg7XG4gIHZhciBpO1xuICBmb3IgKGkgPSBzdGFydDsgaSA8IGRlc3RpbmF0aW9uSUQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNCb3VuZGFyeShkZXN0aW5hdGlvbklELCBpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXN0aW5hdGlvbklELnN1YnN0cigwLCBpKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBJRCBvZiB0d28gSURzLlxuICpcbiAqIFVzaW5nIHRoaXMgSUQgc2NoZW1lLCB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgSUQgaXMgdGhlIGxvbmdlc3QgY29tbW9uXG4gKiBwcmVmaXggb2YgdGhlIHR3byBJRHMgdGhhdCBpbW1lZGlhdGVseSBwcmVjZWRlZCBhIFwibWFya2VyXCIgaW4gYm90aCBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBvbmVJRFxuICogQHBhcmFtIHtzdHJpbmd9IHR3b0lEXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIElELCBvciB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vbmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQob25lSUQsIHR3b0lEKSB7XG4gIHZhciBtaW5MZW5ndGggPSBNYXRoLm1pbihvbmVJRC5sZW5ndGgsIHR3b0lELmxlbmd0aCk7XG4gIGlmIChtaW5MZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgdmFyIGxhc3RDb21tb25NYXJrZXJJbmRleCA9IDA7XG4gIC8vIFVzZSBgPD1gIHRvIHRyYXZlcnNlIHVudGlsIHRoZSBcIkVPTFwiIG9mIHRoZSBzaG9ydGVyIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbWluTGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaXNCb3VuZGFyeShvbmVJRCwgaSkgJiYgaXNCb3VuZGFyeSh0d29JRCwgaSkpIHtcbiAgICAgIGxhc3RDb21tb25NYXJrZXJJbmRleCA9IGk7XG4gICAgfSBlbHNlIGlmIChvbmVJRC5jaGFyQXQoaSkgIT09IHR3b0lELmNoYXJBdChpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBsb25nZXN0Q29tbW9uSUQgPSBvbmVJRC5zdWJzdHIoMCwgbGFzdENvbW1vbk1hcmtlckluZGV4KTtcbiAgIWlzVmFsaWRJRChsb25nZXN0Q29tbW9uSUQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldEZpcnN0Q29tbW9uQW5jZXN0b3JJRCglcywgJXMpOiBFeHBlY3RlZCBhIHZhbGlkIFJlYWN0IERPTSBJRDogJXMnLCBvbmVJRCwgdHdvSUQsIGxvbmdlc3RDb21tb25JRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gbG9uZ2VzdENvbW1vbklEO1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgcGFyZW50IHBhdGggYmV0d2VlbiB0d28gSURzIChlaXRoZXIgdXAgb3IgZG93bikuIFRoZSBJRHMgbXVzdFxuICogbm90IGJlIHRoZSBzYW1lLCBhbmQgdGhlcmUgbXVzdCBleGlzdCBhIHBhcmVudCBwYXRoIGJldHdlZW4gdGhlbS4gSWYgdGhlXG4gKiBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAsIHRyYXZlcnNhbCBpcyBzdG9wcGVkLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gc3RhcnQgSUQgYXQgd2hpY2ggdG8gc3RhcnQgdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/c3RyaW5nfSBzdG9wIElEIGF0IHdoaWNoIHRvIGVuZCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2UgZWFjaCBJRCB3aXRoLlxuICogQHBhcmFtIHsqfSBhcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcEZpcnN0IFdoZXRoZXIgb3Igbm90IHRvIHNraXAgdGhlIGZpcnN0IG5vZGUuXG4gKiBAcGFyYW0gez9ib29sZWFufSBza2lwTGFzdCBXaGV0aGVyIG9yIG5vdCB0byBza2lwIHRoZSBsYXN0IG5vZGUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVBhcmVudFBhdGgoc3RhcnQsIHN0b3AsIGNiLCBhcmcsIHNraXBGaXJzdCwgc2tpcExhc3QpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAnJztcbiAgc3RvcCA9IHN0b3AgfHwgJyc7XG4gICEoc3RhcnQgIT09IHN0b3ApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RyYXZlcnNlUGFyZW50UGF0aCguLi4pOiBDYW5ub3QgdHJhdmVyc2UgZnJvbSBhbmQgdG8gdGhlIHNhbWUgSUQsIGAlc2AuJywgc3RhcnQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHRyYXZlcnNlVXAgPSBpc0FuY2VzdG9ySURPZihzdG9wLCBzdGFydCk7XG4gICEodHJhdmVyc2VVcCB8fCBpc0FuY2VzdG9ySURPZihzdGFydCwgc3RvcCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RyYXZlcnNlUGFyZW50UGF0aCglcywgJXMsIC4uLik6IENhbm5vdCB0cmF2ZXJzZSBmcm9tIHR3byBJRHMgdGhhdCBkbyAnICsgJ25vdCBoYXZlIGEgcGFyZW50IHBhdGguJywgc3RhcnQsIHN0b3ApIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgLy8gVHJhdmVyc2UgZnJvbSBgc3RhcnRgIHRvIGBzdG9wYCBvbmUgZGVwdGggYXQgYSB0aW1lLlxuICB2YXIgZGVwdGggPSAwO1xuICB2YXIgdHJhdmVyc2UgPSB0cmF2ZXJzZVVwID8gZ2V0UGFyZW50SUQgOiBnZXROZXh0RGVzY2VuZGFudElEO1xuICBmb3IgKHZhciBpZCA9IHN0YXJ0OzsgLyogdW50aWwgYnJlYWsgKi9pZCA9IHRyYXZlcnNlKGlkLCBzdG9wKSkge1xuICAgIHZhciByZXQ7XG4gICAgaWYgKCghc2tpcEZpcnN0IHx8IGlkICE9PSBzdGFydCkgJiYgKCFza2lwTGFzdCB8fCBpZCAhPT0gc3RvcCkpIHtcbiAgICAgIHJldCA9IGNiKGlkLCB0cmF2ZXJzZVVwLCBhcmcpO1xuICAgIH1cbiAgICBpZiAocmV0ID09PSBmYWxzZSB8fCBpZCA9PT0gc3RvcCkge1xuICAgICAgLy8gT25seSBicmVhayAvL2FmdGVyLy8gdmlzaXRpbmcgYHN0b3BgLlxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICEoZGVwdGgrKyA8IE1BWF9UUkVFX0RFUFRIKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZVBhcmVudFBhdGgoJXMsICVzLCAuLi4pOiBEZXRlY3RlZCBhbiBpbmZpbml0ZSBsb29wIHdoaWxlICcgKyAndHJhdmVyc2luZyB0aGUgUmVhY3QgRE9NIElEIHRyZWUuIFRoaXMgbWF5IGJlIGR1ZSB0byBtYWxmb3JtZWQgSURzOiAlcycsIHN0YXJ0LCBzdG9wLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogTWFuYWdlcyB0aGUgSURzIGFzc2lnbmVkIHRvIERPTSByZXByZXNlbnRhdGlvbnMgb2YgUmVhY3QgY29tcG9uZW50cy4gVGhpc1xuICogdXNlcyBhIHNwZWNpZmljIHNjaGVtZSBpbiBvcmRlciB0byB0cmF2ZXJzZSB0aGUgRE9NIGVmZmljaWVudGx5IChlLmcuIGluXG4gKiBvcmRlciB0byBzaW11bGF0ZSBldmVudHMpLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBSZWFjdCByb290IElEXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWFjdCByb290IElELlxuICAgKi9cbiAgY3JlYXRlUmVhY3RSb290SUQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0UmVhY3RSb290SURTdHJpbmcoUmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXgoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBSZWFjdCBJRCBieSBqb2luaW5nIGEgcm9vdCBJRCB3aXRoIGEgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBSb290IElEIG9mIGEgcGFyZW50IGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSBjb21wb25lbnQncyBuYW1lIChhcyBmbGF0dGVuZWQgY2hpbGRyZW4pLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgUmVhY3QgSUQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY3JlYXRlUmVhY3RJRDogZnVuY3Rpb24gKHJvb3RJRCwgbmFtZSkge1xuICAgIHJldHVybiByb290SUQgKyBuYW1lO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBET00gSUQgb2YgdGhlIFJlYWN0IGNvbXBvbmVudCB0aGF0IGlzIHRoZSByb290IG9mIHRoZSB0cmVlIHRoYXRcbiAgICogY29udGFpbnMgdGhlIFJlYWN0IGNvbXBvbmVudCB3aXRoIHRoZSBzdXBwbGllZCBET00gSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBET00gSUQgb2YgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IERPTSBJRCBvZiB0aGUgUmVhY3QgY29tcG9uZW50IHRoYXQgaXMgdGhlIHJvb3QuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZiAoaWQgJiYgaWQuY2hhckF0KDApID09PSBTRVBBUkFUT1IgJiYgaWQubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGluZGV4ID0gaWQuaW5kZXhPZihTRVBBUkFUT1IsIDEpO1xuICAgICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpZC5zdWJzdHIoMCwgaW5kZXgpIDogaWQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdGhlIElEIGhpZXJhcmNoeSBhbmQgaW52b2tlcyB0aGUgc3VwcGxpZWQgYGNiYCBvbiBhbnkgSURzIHRoYXRcbiAgICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICAgKlxuICAgKiBOT1RFOiBEb2VzIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlXG4gICAqIG5vdGhpbmcgXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGVhdmVJRCBJRCBiZWluZyBsZWZ0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW50ZXJJRCBJRCBiZWluZyBlbnRlcmVkLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2Ugb24gZWFjaCBlbnRlcmVkL2xlZnQgSUQuXG4gICAqIEBwYXJhbSB7Kn0gdXBBcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIG9uIGxlZnQgSURzLlxuICAgKiBAcGFyYW0geyp9IGRvd25BcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIG9uIGVudGVyZWQgSURzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXZlcnNlRW50ZXJMZWF2ZTogZnVuY3Rpb24gKGxlYXZlSUQsIGVudGVySUQsIGNiLCB1cEFyZywgZG93bkFyZykge1xuICAgIHZhciBhbmNlc3RvcklEID0gZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEKGxlYXZlSUQsIGVudGVySUQpO1xuICAgIGlmIChhbmNlc3RvcklEICE9PSBsZWF2ZUlEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgobGVhdmVJRCwgYW5jZXN0b3JJRCwgY2IsIHVwQXJnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChhbmNlc3RvcklEICE9PSBlbnRlcklEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgoYW5jZXN0b3JJRCwgZW50ZXJJRCwgY2IsIGRvd25BcmcsIHRydWUsIGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAgICpcbiAgICogTk9URTogVGhpcyB0cmF2ZXJzYWwgaGFwcGVucyBvbiBJRHMgd2l0aG91dCB0b3VjaGluZyB0aGUgRE9NLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0SUQgSUQgb2YgdGhlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gYXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmF2ZXJzZVR3b1BoYXNlOiBmdW5jdGlvbiAodGFyZ2V0SUQsIGNiLCBhcmcpIHtcbiAgICBpZiAodGFyZ2V0SUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCgnJywgdGFyZ2V0SUQsIGNiLCBhcmcsIHRydWUsIGZhbHNlKTtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCh0YXJnZXRJRCwgJycsIGNiLCBhcmcsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgYHRyYXZlcnNlVHdvUGhhc2VgIGJ1dCBza2lwcyB0aGUgYHRhcmdldElEYC5cbiAgICovXG4gIHRyYXZlcnNlVHdvUGhhc2VTa2lwVGFyZ2V0OiBmdW5jdGlvbiAodGFyZ2V0SUQsIGNiLCBhcmcpIHtcbiAgICBpZiAodGFyZ2V0SUQpIHtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCgnJywgdGFyZ2V0SUQsIGNiLCBhcmcsIHRydWUsIHRydWUpO1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKHRhcmdldElELCAnJywgY2IsIGFyZywgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZSBhIG5vZGUgSUQsIGNhbGxpbmcgdGhlIHN1cHBsaWVkIGBjYmAgZm9yIGVhY2ggYW5jZXN0b3IgSUQuIEZvclxuICAgKiBleGFtcGxlLCBwYXNzaW5nIGAuMC4kcm93LTAuMWAgd291bGQgcmVzdWx0IGluIGBjYmAgZ2V0dGluZyBjYWxsZWRcbiAgICogd2l0aCBgLjBgLCBgLjAuJHJvdy0wYCwgYW5kIGAuMC4kcm93LTAuMWAuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgdHJhdmVyc2FsIGhhcHBlbnMgb24gSURzIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IGFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VBbmNlc3RvcnM6IGZ1bmN0aW9uICh0YXJnZXRJRCwgY2IsIGFyZykge1xuICAgIHRyYXZlcnNlUGFyZW50UGF0aCgnJywgdGFyZ2V0SUQsIGNiLCBhcmcsIHRydWUsIGZhbHNlKTtcbiAgfSxcblxuICBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQ6IGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRCxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldE5leHREZXNjZW5kYW50SUQ6IGdldE5leHREZXNjZW5kYW50SUQsXG5cbiAgaXNBbmNlc3RvcklET2Y6IGlzQW5jZXN0b3JJRE9mLFxuXG4gIFNFUEFSQVRPUjogU0VQQVJBVE9SXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnN0YW5jZUhhbmRsZXM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5zdGFuY2VNYXBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKi9cblxuLy8gVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggRVM2OiB2YXIgUmVhY3RJbnN0YW5jZU1hcCA9IG5ldyBNYXAoKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SXNvbW9ycGhpY1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9SZWFjdENsYXNzJyk7XG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmFjdG9yaWVzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBvbmx5Q2hpbGQgPSByZXF1aXJlKCcuL29ubHlDaGlsZCcpO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50O1xudmFyIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbnZhciBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQ7XG4gIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRmFjdG9yeTtcbiAgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNsb25lRWxlbWVudDtcbn1cblxudmFyIFJlYWN0ID0ge1xuXG4gIC8vIE1vZGVyblxuXG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBSZWFjdENoaWxkcmVuLm1hcCxcbiAgICBmb3JFYWNoOiBSZWFjdENoaWxkcmVuLmZvckVhY2gsXG4gICAgY291bnQ6IFJlYWN0Q2hpbGRyZW4uY291bnQsXG4gICAgdG9BcnJheTogUmVhY3RDaGlsZHJlbi50b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnQsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQsXG5cbiAgLy8gQ2xhc3NpY1xuXG4gIFByb3BUeXBlczogUmVhY3RQcm9wVHlwZXMsXG4gIGNyZWF0ZUNsYXNzOiBSZWFjdENsYXNzLmNyZWF0ZUNsYXNzLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxuICBjcmVhdGVNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgLy8gQ3VycmVudGx5IGEgbm9vcC4gV2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIGFuZCB0cmFjZSBtaXhpbnMuXG4gICAgcmV0dXJuIG1peGluO1xuICB9LFxuXG4gIC8vIFRoaXMgbG9va3MgRE9NIHNwZWNpZmljIGJ1dCB0aGVzZSBhcmUgYWN0dWFsbHkgaXNvbW9ycGhpYyBoZWxwZXJzXG4gIC8vIHNpbmNlIHRoZXkgYXJlIGp1c3QgZ2VuZXJhdGluZyBET00gc3RyaW5ncy5cbiAgRE9NOiBSZWFjdERPTUZhY3RvcmllcyxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgLy8gSG9vayBmb3IgSlNYIHNwcmVhZCwgZG9uJ3QgdXNlIHRoaXMgZm9yIGFueXRoaW5nIGVsc2UuXG4gIF9fc3ByZWFkOiBhc3NpZ25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TWFya3VwQ2hlY2tzdW1cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG5cbnZhciBUQUdfRU5EID0gL1xcLz8+LztcblxudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSB7XG4gIENIRUNLU1VNX0FUVFJfTkFNRTogJ2RhdGEtcmVhY3QtY2hlY2tzdW0nLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCBzdHJpbmdcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nIHdpdGggY2hlY2tzdW0gYXR0cmlidXRlIGF0dGFjaGVkXG4gICAqL1xuICBhZGRDaGVja3N1bVRvTWFya3VwOiBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIGNoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuXG4gICAgLy8gQWRkIGNoZWNrc3VtIChoYW5kbGUgYm90aCBwYXJlbnQgdGFncyBhbmQgc2VsZi1jbG9zaW5nIHRhZ3MpXG4gICAgcmV0dXJuIG1hcmt1cC5yZXBsYWNlKFRBR19FTkQsICcgJyArIFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FICsgJz1cIicgKyBjaGVja3N1bSArICdcIiQmJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgdG8gdXNlXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCByb290IFJlYWN0IGVsZW1lbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBtYXJrdXAgaXMgdGhlIHNhbWVcbiAgICovXG4gIGNhblJldXNlTWFya3VwOiBmdW5jdGlvbiAobWFya3VwLCBlbGVtZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nQ2hlY2tzdW0gPSBlbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgZXhpc3RpbmdDaGVja3N1bSA9IGV4aXN0aW5nQ2hlY2tzdW0gJiYgcGFyc2VJbnQoZXhpc3RpbmdDaGVja3N1bSwgMTApO1xuICAgIHZhciBtYXJrdXBDaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcbiAgICByZXR1cm4gbWFya3VwQ2hlY2tzdW0gPT09IGV4aXN0aW5nQ2hlY2tzdW07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNYXJrdXBDaGVja3N1bTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RNb3VudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeScpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0gcmVxdWlyZSgnLi9SZWFjdE1hcmt1cENoZWNrc3VtJyk7XG52YXIgUmVhY3RQZXJmID0gcmVxdWlyZSgnLi9SZWFjdFBlcmYnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIG5vZGVDYWNoZSA9IHt9O1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ19OT0RFX1RZUEUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xuXG52YXIgb3duZXJEb2N1bWVudENvbnRleHRLZXkgPSAnX19SZWFjdE1vdW50X293bmVyRG9jdW1lbnQkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4vKiogTWFwcGluZyBmcm9tIHJlYWN0Um9vdElEIHRvIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS4gKi9cbnZhciBpbnN0YW5jZXNCeVJlYWN0Um9vdElEID0ge307XG5cbi8qKiBNYXBwaW5nIGZyb20gcmVhY3RSb290SUQgdG8gYGNvbnRhaW5lcmAgbm9kZXMuICovXG52YXIgY29udGFpbmVyc0J5UmVhY3RSb290SUQgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLyoqIF9fREVWX18tb25seSBtYXBwaW5nIGZyb20gcmVhY3RSb290SUQgdG8gcm9vdCBlbGVtZW50cy4gKi9cbiAgdmFyIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SUQgPSB7fTtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBicmVhZHRoLWZpcnN0IHNlYXJjaCBzdGF0ZSBpbiBmaW5kQ29tcG9uZW50Um9vdC5cbnZhciBmaW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXkgPSBbXTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNoYXJhY3RlclxuICogdGhhdCdzIG5vdCBjb21tb24gYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3MuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGNoYXJhY3RlciB3aGVyZSB0aGUgc3RyaW5ncyBkaXZlcmdlXG4gKi9cbmZ1bmN0aW9uIGZpcnN0RGlmZmVyZW5jZUluZGV4KHN0cmluZzEsIHN0cmluZzIpIHtcbiAgdmFyIG1pbkxlbiA9IE1hdGgubWluKHN0cmluZzEubGVuZ3RoLCBzdHJpbmcyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWluTGVuOyBpKyspIHtcbiAgICBpZiAoc3RyaW5nMS5jaGFyQXQoaSkgIT09IHN0cmluZzIuY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cmluZzEubGVuZ3RoID09PSBzdHJpbmcyLmxlbmd0aCA/IC0xIDogbWluTGVuO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01Eb2N1bWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRoYXQgbWF5IGNvbnRhaW5cbiAqIGEgUmVhY3QgY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/Kn0gRE9NIGVsZW1lbnQgdGhhdCBtYXkgaGF2ZSB0aGUgcmVhY3RSb290IElELCBvciBudWxsLlxuICovXG5mdW5jdGlvbiBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5maXJzdENoaWxkO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBtYXkgY29udGFpbiBhIFJlYWN0IGNvbXBvbmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IEEgXCJyZWFjdFJvb3RcIiBJRCwgaWYgYSBSZWFjdCBjb21wb25lbnQgaXMgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdElEKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuIHJvb3RFbGVtZW50ICYmIFJlYWN0TW91bnQuZ2V0SUQocm9vdEVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEFjY2Vzc2luZyBub2RlW0FUVFJfTkFNRV0gb3IgY2FsbGluZyBnZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSBvbiBhIGZvcm1cbiAqIGVsZW1lbnQgY2FuIHJldHVybiBpdHMgY29udHJvbCB3aG9zZSBuYW1lIG9yIElEIGVxdWFscyBBVFRSX05BTUUuIEFsbFxuICogRE9NIG5vZGVzIHN1cHBvcnQgYGdldEF0dHJpYnV0ZU5vZGVgIGJ1dCB0aGlzIGNhbiBhbHNvIGdldCBjYWxsZWQgb25cbiAqIG90aGVyIG9iamVjdHMgc28ganVzdCByZXR1cm4gJycgaWYgd2UncmUgZ2l2ZW4gc29tZXRoaW5nIG90aGVyIHRoYW4gYVxuICogRE9NIG5vZGUgKHN1Y2ggYXMgd2luZG93KS5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fERPTVdpbmRvd3xET01Eb2N1bWVudHxET01UZXh0Tm9kZX0gbm9kZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gSUQgb2YgdGhlIHN1cHBsaWVkIGBkb21Ob2RlYC5cbiAqL1xuZnVuY3Rpb24gZ2V0SUQobm9kZSkge1xuICB2YXIgaWQgPSBpbnRlcm5hbEdldElEKG5vZGUpO1xuICBpZiAoaWQpIHtcbiAgICBpZiAobm9kZUNhY2hlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgdmFyIGNhY2hlZCA9IG5vZGVDYWNoZVtpZF07XG4gICAgICBpZiAoY2FjaGVkICE9PSBub2RlKSB7XG4gICAgICAgICEhaXNWYWxpZChjYWNoZWQsIGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdE1vdW50OiBUd28gdmFsaWQgYnV0IHVuZXF1YWwgbm9kZXMgd2l0aCB0aGUgc2FtZSBgJXNgOiAlcycsIEFUVFJfTkFNRSwgaWQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBub2RlQ2FjaGVbaWRdID0gbm9kZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZUNhY2hlW2lkXSA9IG5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbEdldElEKG5vZGUpIHtcbiAgLy8gSWYgbm9kZSBpcyBzb21ldGhpbmcgbGlrZSBhIHdpbmRvdywgZG9jdW1lbnQsIG9yIHRleHQgbm9kZSwgbm9uZSBvZlxuICAvLyB3aGljaCBzdXBwb3J0IGF0dHJpYnV0ZXMgb3IgYSAuZ2V0QXR0cmlidXRlIG1ldGhvZCwgZ3JhY2VmdWxseSByZXR1cm5cbiAgLy8gdGhlIGVtcHR5IHN0cmluZywgYXMgaWYgdGhlIGF0dHJpYnV0ZSB3ZXJlIG1pc3NpbmcuXG4gIHJldHVybiBub2RlICYmIG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgfHwgJyc7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgUmVhY3Qtc3BlY2lmaWMgSUQgb2YgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIFRoZSBET00gbm9kZSB3aG9zZSBJRCB3aWxsIGJlIHNldC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgdmFsdWUgb2YgdGhlIElEIGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gc2V0SUQobm9kZSwgaWQpIHtcbiAgdmFyIG9sZElEID0gaW50ZXJuYWxHZXRJRChub2RlKTtcbiAgaWYgKG9sZElEICE9PSBpZCkge1xuICAgIGRlbGV0ZSBub2RlQ2FjaGVbb2xkSURdO1xuICB9XG4gIG5vZGUuc2V0QXR0cmlidXRlKEFUVFJfTkFNRSwgaWQpO1xuICBub2RlQ2FjaGVbaWRdID0gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBSZWFjdC1nZW5lcmF0ZWQgRE9NIElELlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBIFJlYWN0LWdlbmVyYXRlZCBET00gSUQuXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSBET00gbm9kZSB3aXRoIHRoZSBzdXBwbGVkIGBpZGAuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZShpZCkge1xuICBpZiAoIW5vZGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkgfHwgIWlzVmFsaWQobm9kZUNhY2hlW2lkXSwgaWQpKSB7XG4gICAgbm9kZUNhY2hlW2lkXSA9IFJlYWN0TW91bnQuZmluZFJlYWN0Tm9kZUJ5SUQoaWQpO1xuICB9XG4gIHJldHVybiBub2RlQ2FjaGVbaWRdO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIHB1YmxpYyBSZWFjdCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0geyp9IGluc3RhbmNlIEEgcHVibGljIFJlYWN0IGluc3RhbmNlLlxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9IERPTSBub2RlIHdpdGggdGhlIHN1cHBsZWQgYGlkYC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHZhciBpZCA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KGluc3RhbmNlKS5fcm9vdE5vZGVJRDtcbiAgaWYgKFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeS5pc051bGxDb21wb25lbnRJRChpZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIW5vZGVDYWNoZS5oYXNPd25Qcm9wZXJ0eShpZCkgfHwgIWlzVmFsaWQobm9kZUNhY2hlW2lkXSwgaWQpKSB7XG4gICAgbm9kZUNhY2hlW2lkXSA9IFJlYWN0TW91bnQuZmluZFJlYWN0Tm9kZUJ5SUQoaWQpO1xuICB9XG4gIHJldHVybiBub2RlQ2FjaGVbaWRdO1xufVxuXG4vKipcbiAqIEEgbm9kZSBpcyBcInZhbGlkXCIgaWYgaXQgaXMgY29udGFpbmVkIGJ5IGEgY3VycmVudGx5IG1vdW50ZWQgY29udGFpbmVyLlxuICpcbiAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgbm9kZSBkb2VzIG5vdCBoYXZlIHRvIGJlIGNvbnRhaW5lZCBieSBhIGRvY3VtZW50IGluXG4gKiBvcmRlciB0byBiZSBjb25zaWRlcmVkIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgZXhwZWN0ZWQgSUQgb2YgdGhlIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBub2RlIGlzIGNvbnRhaW5lZCBieSBhIG1vdW50ZWQgY29udGFpbmVyLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkKG5vZGUsIGlkKSB7XG4gIGlmIChub2RlKSB7XG4gICAgIShpbnRlcm5hbEdldElEKG5vZGUpID09PSBpZCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RNb3VudDogVW5leHBlY3RlZCBtb2RpZmljYXRpb24gb2YgYCVzYCcsIEFUVFJfTkFNRSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQoaWQpO1xuICAgIGlmIChjb250YWluZXIgJiYgY29udGFpbnNOb2RlKGNvbnRhaW5lciwgbm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDYXVzZXMgdGhlIGNhY2hlIHRvIGZvcmdldCBhYm91dCBvbmUgUmVhY3Qtc3BlY2lmaWMgSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCB0byBmb3JnZXQuXG4gKi9cbmZ1bmN0aW9uIHB1cmdlSUQoaWQpIHtcbiAgZGVsZXRlIG5vZGVDYWNoZVtpZF07XG59XG5cbnZhciBkZWVwZXN0Tm9kZVNvRmFyID0gbnVsbDtcbmZ1bmN0aW9uIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3JJbXBsKGFuY2VzdG9ySUQpIHtcbiAgdmFyIGFuY2VzdG9yID0gbm9kZUNhY2hlW2FuY2VzdG9ySURdO1xuICBpZiAoYW5jZXN0b3IgJiYgaXNWYWxpZChhbmNlc3RvciwgYW5jZXN0b3JJRCkpIHtcbiAgICBkZWVwZXN0Tm9kZVNvRmFyID0gYW5jZXN0b3I7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBub2RlIGlzbid0IHBvcHVsYXRlZCBpbiB0aGUgY2FjaGUsIHNvIHByZXN1bWFibHkgbm9uZSBvZiBpdHNcbiAgICAvLyBkZXNjZW5kYW50cyBhcmUuIEJyZWFrIG91dCBvZiB0aGUgbG9vcC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRlZXBlc3QgY2FjaGVkIG5vZGUgd2hvc2UgSUQgaXMgYSBwcmVmaXggb2YgYHRhcmdldElEYC5cbiAqL1xuZnVuY3Rpb24gZmluZERlZXBlc3RDYWNoZWRBbmNlc3Rvcih0YXJnZXRJRCkge1xuICBkZWVwZXN0Tm9kZVNvRmFyID0gbnVsbDtcbiAgUmVhY3RJbnN0YW5jZUhhbmRsZXMudHJhdmVyc2VBbmNlc3RvcnModGFyZ2V0SUQsIGZpbmREZWVwZXN0Q2FjaGVkQW5jZXN0b3JJbXBsKTtcblxuICB2YXIgZm91bmROb2RlID0gZGVlcGVzdE5vZGVTb0ZhcjtcbiAgZGVlcGVzdE5vZGVTb0ZhciA9IG51bGw7XG4gIHJldHVybiBmb3VuZE5vZGU7XG59XG5cbi8qKlxuICogTW91bnRzIHRoaXMgY29tcG9uZW50IGFuZCBpbnNlcnRzIGl0IGludG8gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gbW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgcm9vdElELCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICBpZiAoUmVhY3RET01GZWF0dXJlRmxhZ3MudXNlQ3JlYXRlRWxlbWVudCkge1xuICAgIGNvbnRleHQgPSBhc3NpZ24oe30sIGNvbnRleHQpO1xuICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICAgIGNvbnRleHRbb3duZXJEb2N1bWVudENvbnRleHRLZXldID0gY29udGFpbmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0W293bmVyRG9jdW1lbnRDb250ZXh0S2V5XSA9IGNvbnRhaW5lci5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChjb250ZXh0ID09PSBlbXB0eU9iamVjdCkge1xuICAgICAgY29udGV4dCA9IHt9O1xuICAgIH1cbiAgICB2YXIgdGFnID0gY29udGFpbmVyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgY29udGV4dFt2YWxpZGF0ZURPTU5lc3RpbmcuYW5jZXN0b3JJbmZvQ29udGV4dEtleV0gPSB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCB0YWcsIG51bGwpO1xuICB9XG4gIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICBjb21wb25lbnRJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQuX3RvcExldmVsV3JhcHBlciA9IGNvbXBvbmVudEluc3RhbmNlO1xuICBSZWFjdE1vdW50Ll9tb3VudEltYWdlSW50b05vZGUobWFya3VwLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogQmF0Y2hlZCBtb3VudC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gbW91bnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vdElEIERPTSBJRCBvZiB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUoY29tcG9uZW50SW5zdGFuY2UsIHJvb3RJRCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCkge1xuICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoXG4gIC8qIGZvcmNlSFRNTCAqL3Nob3VsZFJldXNlTWFya3VwKTtcbiAgdHJhbnNhY3Rpb24ucGVyZm9ybShtb3VudENvbXBvbmVudEludG9Ob2RlLCBudWxsLCBjb21wb25lbnRJbnN0YW5jZSwgcm9vdElELCBjb250YWluZXIsIHRyYW5zYWN0aW9uLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG4gIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIFVubW91bnRzIGEgY29tcG9uZW50IGFuZCByZW1vdmVzIGl0IGZyb20gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnN0YW5jZSBSZWFjdCBjb21wb25lbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byB1bm1vdW50IGZyb20uXG4gKiBAZmluYWxcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7UmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlfVxuICovXG5mdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUoaW5zdGFuY2UsIGNvbnRhaW5lcikge1xuICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChpbnN0YW5jZSk7XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9lbXB0eWluZy1hLW5vZGVcbiAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBoYXMgYSBkaXJlY3QgUmVhY3QtcmVuZGVyZWQgY2hpbGQgdGhhdCBpc1xuICogbm90IGEgUmVhY3Qgcm9vdCBlbGVtZW50LiBVc2VmdWwgZm9yIHdhcm5pbmcgaW4gYHJlbmRlcmAsXG4gKiBgdW5tb3VudENvbXBvbmVudEF0Tm9kZWAsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gZWxlbWVudCBjb250YWlucyBhIGRpcmVjdCBjaGlsZCB0aGF0IHdhc1xuICogcmVuZGVyZWQgYnkgUmVhY3QgYnV0IGlzIG5vdCBhIHJvb3QgZWxlbWVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBoYXNOb25Sb290UmVhY3RDaGlsZChub2RlKSB7XG4gIHZhciByZWFjdFJvb3RJRCA9IGdldFJlYWN0Um9vdElEKG5vZGUpO1xuICByZXR1cm4gcmVhY3RSb290SUQgPyByZWFjdFJvb3RJRCAhPT0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKHJlYWN0Um9vdElEKSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IChkZWVwZXN0KSBhbmNlc3RvciBvZiBhIG5vZGUgd2hpY2ggaXMgcmVuZGVyZWQgYnkgdGhpcyBjb3B5XG4gKiBvZiBSZWFjdC5cbiAqL1xuZnVuY3Rpb24gZmluZEZpcnN0UmVhY3RET01JbXBsKG5vZGUpIHtcbiAgLy8gVGhpcyBub2RlIG1pZ2h0IGJlIGZyb20gYW5vdGhlciBSZWFjdCBpbnN0YW5jZSwgc28gd2UgbWFrZSBzdXJlIG5vdCB0b1xuICAvLyBleGFtaW5lIHRoZSBub2RlIGNhY2hlIGhlcmVcbiAgZm9yICg7IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlICE9PSBub2RlOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgIC8vIE5vdCBhIERPTUVsZW1lbnQsIHRoZXJlZm9yZSBub3QgYSBSZWFjdCBjb21wb25lbnRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbm9kZUlEID0gaW50ZXJuYWxHZXRJRChub2RlKTtcbiAgICBpZiAoIW5vZGVJRCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChub2RlSUQpO1xuXG4gICAgLy8gSWYgY29udGFpbmVyc0J5UmVhY3RSb290SUQgY29udGFpbnMgdGhlIGNvbnRhaW5lciB3ZSBmaW5kIGJ5IGNyYXdsaW5nIHVwXG4gICAgLy8gdGhlIHRyZWUsIHdlIGtub3cgdGhhdCB0aGlzIGluc3RhbmNlIG9mIFJlYWN0IHJlbmRlcmVkIHRoZSBub2RlLlxuICAgIC8vIG5iLiBpc1ZhbGlkJ3Mgc3RyYXRlZ3kgKHdpdGggY29udGFpbnNOb2RlKSBkb2VzIG5vdCB3b3JrIGJlY2F1c2UgcmVuZGVyXG4gICAgLy8gdHJlZXMgbWF5IGJlIG5lc3RlZCBhbmQgd2UgZG9uJ3Qgd2FudCBhIGZhbHNlIHBvc2l0aXZlIGluIHRoYXQgY2FzZS5cbiAgICB2YXIgY3VycmVudCA9IG5vZGU7XG4gICAgdmFyIGxhc3RJRDtcbiAgICBkbyB7XG4gICAgICBsYXN0SUQgPSBpbnRlcm5hbEdldElEKGN1cnJlbnQpO1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlIHBhc3NlZC1pbiBub2RlIGhhcyBiZWVuIGRldGFjaGVkIGZyb20gdGhlIGNvbnRhaW5lciBpdCB3YXNcbiAgICAgICAgLy8gb3JpZ2luYWxseSByZW5kZXJlZCBpbnRvLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChsYXN0SUQgIT09IHJlYWN0Um9vdElEKTtcblxuICAgIGlmIChjdXJyZW50ID09PSBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0pIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUZW1wb3JhcnkgKD8pIGhhY2sgc28gdGhhdCB3ZSBjYW4gc3RvcmUgYWxsIHRvcC1sZXZlbCBwZW5kaW5nIHVwZGF0ZXMgb25cbiAqIGNvbXBvc2l0ZXMgaW5zdGVhZCBvZiBoYXZpbmcgdG8gd29ycnkgYWJvdXQgZGlmZmVyZW50IHR5cGVzIG9mIGNvbXBvbmVudHNcbiAqIGhlcmUuXG4gKi9cbnZhciBUb3BMZXZlbFdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7fTtcblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgVG9wTGV2ZWxXcmFwcGVyLmRpc3BsYXlOYW1lID0gJ1RvcExldmVsV3JhcHBlcic7XG59XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhpcy5wcm9wcyBpcyBhY3R1YWxseSBhIFJlYWN0RWxlbWVudFxuICByZXR1cm4gdGhpcy5wcm9wcztcbn07XG5cbi8qKlxuICogTW91bnRpbmcgaXMgdGhlIHByb2Nlc3Mgb2YgaW5pdGlhbGl6aW5nIGEgUmVhY3QgY29tcG9uZW50IGJ5IGNyZWF0aW5nIGl0c1xuICogcmVwcmVzZW50YXRpdmUgRE9NIGVsZW1lbnRzIGFuZCBpbnNlcnRpbmcgdGhlbSBpbnRvIGEgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiBBbnkgcHJpb3IgY29udGVudCBpbnNpZGUgYGNvbnRhaW5lcmAgaXMgZGVzdHJveWVkIGluIHRoZSBwcm9jZXNzLlxuICpcbiAqICAgUmVhY3RNb3VudC5yZW5kZXIoXG4gKiAgICAgY29tcG9uZW50LFxuICogICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXInKVxuICogICApO1xuICpcbiAqICAgPGRpdiBpZD1cImNvbnRhaW5lclwiPiAgICAgICAgICAgICAgICAgICA8LS0gU3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gKiAgICAgPGRpdiBkYXRhLXJlYWN0aWQ9XCIuM1wiPiAgICAgICAgICAgICAgPC0tIFJlbmRlcmVkIHJlYWN0Um9vdCBvZiBSZWFjdFxuICogICAgICAgLy8gLi4uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LlxuICogICAgIDwvZGl2PlxuICogICA8L2Rpdj5cbiAqXG4gKiBJbnNpZGUgb2YgYGNvbnRhaW5lcmAsIHRoZSBmaXJzdCBlbGVtZW50IHJlbmRlcmVkIGlzIHRoZSBcInJlYWN0Um9vdFwiLlxuICovXG52YXIgUmVhY3RNb3VudCA9IHtcblxuICBUb3BMZXZlbFdyYXBwZXI6IFRvcExldmVsV3JhcHBlcixcblxuICAvKiogRXhwb3NlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzICoqL1xuICBfaW5zdGFuY2VzQnlSZWFjdFJvb3RJRDogaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCxcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhvb2sgcHJvdmlkZWQgdG8gc3VwcG9ydCByZW5kZXJpbmcgUmVhY3QgY29tcG9uZW50cyB3aGlsZVxuICAgKiBlbnN1cmluZyB0aGF0IHRoZSBhcHBhcmVudCBzY3JvbGwgcG9zaXRpb24gb2YgaXRzIGBjb250YWluZXJgIGRvZXMgbm90XG4gICAqIGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgVGhlIGBjb250YWluZXJgIGJlaW5nIHJlbmRlcmVkIGludG8uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlbmRlckNhbGxiYWNrIFRoaXMgbXVzdCBiZSBjYWxsZWQgb25jZSB0byBkbyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgc2Nyb2xsTW9uaXRvcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgcmVuZGVyQ2FsbGJhY2spIHtcbiAgICByZW5kZXJDYWxsYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUYWtlIGEgY29tcG9uZW50IHRoYXQncyBhbHJlYWR5IG1vdW50ZWQgaW50byB0aGUgRE9NIGFuZCByZXBsYWNlIGl0cyBwcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwcmV2Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSBhbHJlYWR5IGluIHRoZSBET01cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKi9cbiAgX3VwZGF0ZVJvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIFJlYWN0TW91bnQuc2Nyb2xsTW9uaXRvcihjb250YWluZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbChwcmV2Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gUmVjb3JkIHRoZSByb290IGVsZW1lbnQgaW4gY2FzZSBpdCBsYXRlciBnZXRzIHRyYW5zcGxhbnRlZC5cbiAgICAgIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKV0gPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJldkNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBjb21wb25lbnQgaW50byB0aGUgaW5zdGFuY2UgbWFwIGFuZCBzdGFydHMgc2Nyb2xsIHZhbHVlXG4gICAqIG1vbml0b3JpbmdcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gbmV4dENvbXBvbmVudCBjb21wb25lbnQgaW5zdGFuY2UgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHJlYWN0Um9vdCBJRCBwcmVmaXhcbiAgICovXG4gIF9yZWdpc3RlckNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRDb21wb25lbnQsIGNvbnRhaW5lcikge1xuICAgICEoY29udGFpbmVyICYmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ19yZWdpc3RlckNvbXBvbmVudCguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5lbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmcoKTtcblxuICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0TW91bnQucmVnaXN0ZXJDb250YWluZXIoY29udGFpbmVyKTtcbiAgICBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IG5leHRDb21wb25lbnQ7XG4gICAgcmV0dXJuIHJlYWN0Um9vdElEO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBuZXcgY29tcG9uZW50IGludG8gdGhlIERPTS5cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGVsZW1lbnQgdG8gcmVuZGVyXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIGNvbnRhaW5lciB0byByZW5kZXIgaW50b1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFJldXNlTWFya3VwIGlmIHdlIHNob3VsZCBza2lwIHRoZSBtYXJrdXAgaW5zZXJ0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50XG4gICAqL1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ19yZW5kZXJOZXdSb290Q29tcG9uZW50KCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gJyArICdyZW5kZXIgaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQsIG51bGwpO1xuICAgIHZhciByZWFjdFJvb3RJRCA9IFJlYWN0TW91bnQuX3JlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCBjb250YWluZXIpO1xuXG4gICAgLy8gVGhlIGluaXRpYWwgcmVuZGVyIGlzIHN5bmNocm9ub3VzIGJ1dCBhbnkgdXBkYXRlcyB0aGF0IGhhcHBlbiBkdXJpbmdcbiAgICAvLyByZW5kZXJpbmcsIGluIGNvbXBvbmVudFdpbGxNb3VudCBvciBjb21wb25lbnREaWRNb3VudCwgd2lsbCBiZSBiYXRjaGVkXG4gICAgLy8gYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGJhdGNoaW5nIHN0cmF0ZWd5LlxuXG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKGJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlLCBjb21wb25lbnRJbnN0YW5jZSwgcmVhY3RSb290SUQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFJlY29yZCB0aGUgcm9vdCBlbGVtZW50IGluIGNhc2UgaXQgbGF0ZXIgZ2V0cyB0cmFuc3BsYW50ZWQuXG4gICAgICByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxuICAgKiBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBpdCBhbmQgb25seSBtdXRhdGUgdGhlIERPTSBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGVcbiAgICogbGF0ZXN0IFJlYWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gcGFyZW50Q29tcG9uZW50IFRoZSBjb25jZXB0dWFsIHBhcmVudCBvZiB0aGlzIHJlbmRlciB0cmVlLlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIHBhcmVudENvbXBvbmVudC5fcmVhY3RJbnRlcm5hbEluc3RhbmNlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChuZXh0RWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00ucmVuZGVyKCk6IEludmFsaWQgY29tcG9uZW50IGVsZW1lbnQuJXMnLCB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdzdHJpbmcnID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYW4gZWxlbWVudCBzdHJpbmcsIG1ha2Ugc3VyZSB0byBpbnN0YW50aWF0ZSAnICsgJ2l0IGJ5IHBhc3NpbmcgaXQgdG8gUmVhY3QuY3JlYXRlRWxlbWVudC4nIDogdHlwZW9mIG5leHRFbGVtZW50ID09PSAnZnVuY3Rpb24nID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBjb21wb25lbnQgY2xhc3MsIG1ha2Ugc3VyZSB0byBpbnN0YW50aWF0ZSAnICsgJ2l0IGJ5IHBhc3NpbmcgaXQgdG8gUmVhY3QuY3JlYXRlRWxlbWVudC4nIDpcbiAgICAvLyBDaGVjayBpZiBpdCBxdWFja3MgbGlrZSBhbiBlbGVtZW50XG4gICAgbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciBuZXh0V3JhcHBlZEVsZW1lbnQgPSBuZXcgUmVhY3RFbGVtZW50KFRvcExldmVsV3JhcHBlciwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgdmFyIHByZXZDb21wb25lbnQgPSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW2dldFJlYWN0Um9vdElEKGNvbnRhaW5lcildO1xuXG4gICAgaWYgKHByZXZDb21wb25lbnQpIHtcbiAgICAgIHZhciBwcmV2V3JhcHBlZEVsZW1lbnQgPSBwcmV2Q29tcG9uZW50Ll9jdXJyZW50RWxlbWVudDtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZXcmFwcGVkRWxlbWVudC5wcm9wcztcbiAgICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpKSB7XG4gICAgICAgIHZhciBwdWJsaWNJbnN0ID0gcHJldkNvbXBvbmVudC5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAgICAgdmFyIHVwZGF0ZWRDYWxsYmFjayA9IGNhbGxiYWNrICYmIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKHB1YmxpY0luc3QpO1xuICAgICAgICB9O1xuICAgICAgICBSZWFjdE1vdW50Ll91cGRhdGVSb290Q29tcG9uZW50KHByZXZDb21wb25lbnQsIG5leHRXcmFwcGVkRWxlbWVudCwgY29udGFpbmVyLCB1cGRhdGVkQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gcHVibGljSW5zdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZShjb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWFjdFJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGNvbnRhaW5lckhhc1JlYWN0TWFya3VwID0gcmVhY3RSb290RWxlbWVudCAmJiAhIWludGVybmFsR2V0SUQocmVhY3RSb290RWxlbWVudCk7XG4gICAgdmFyIGNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkID0gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoIWNvbnRhaW5lckhhc1JlYWN0TWFya3VwIHx8IHJlYWN0Um9vdEVsZW1lbnQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdmFyIHJvb3RFbGVtZW50U2libGluZyA9IHJlYWN0Um9vdEVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChyb290RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICBpZiAoaW50ZXJuYWxHZXRJRChyb290RWxlbWVudFNpYmxpbmcpKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ3JlbmRlcigpOiBUYXJnZXQgbm9kZSBoYXMgbWFya3VwIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgdGhlcmUgJyArICdhcmUgdW5yZWxhdGVkIG5vZGVzIGFzIHdlbGwuIFRoaXMgaXMgbW9zdCBjb21tb25seSBjYXVzZWQgYnkgJyArICd3aGl0ZS1zcGFjZSBpbnNlcnRlZCBhcm91bmQgc2VydmVyLXJlbmRlcmVkIG1hcmt1cC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb290RWxlbWVudFNpYmxpbmcgPSByb290RWxlbWVudFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkUmV1c2VNYXJrdXAgPSBjb250YWluZXJIYXNSZWFjdE1hcmt1cCAmJiAhcHJldkNvbXBvbmVudCAmJiAhY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQ7XG4gICAgdmFyIGNvbXBvbmVudCA9IFJlYWN0TW91bnQuX3JlbmRlck5ld1Jvb3RDb21wb25lbnQobmV4dFdyYXBwZWRFbGVtZW50LCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBwYXJlbnRDb21wb25lbnQgIT0gbnVsbCA/IHBhcmVudENvbXBvbmVudC5fcmVhY3RJbnRlcm5hbEluc3RhbmNlLl9wcm9jZXNzQ2hpbGRDb250ZXh0KHBhcmVudENvbXBvbmVudC5fcmVhY3RJbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0KSA6IGVtcHR5T2JqZWN0KS5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBJZiB0aGUgUmVhY3QgY29tcG9uZW50IHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGludG8gYGNvbnRhaW5lcmAsIHRoaXMgd2lsbFxuICAgKiBwZXJmb3JtIGFuIHVwZGF0ZSBvbiBpdCBhbmQgb25seSBtdXRhdGUgdGhlIERPTSBhcyBuZWNlc3NhcnkgdG8gcmVmbGVjdCB0aGVcbiAgICogbGF0ZXN0IFJlYWN0IGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5fcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBjb250YWluZXIgbm9kZSBpbnRvIHdoaWNoIFJlYWN0IGNvbXBvbmVudHMgd2lsbCBiZSByZW5kZXJlZC5cbiAgICogVGhpcyBhbHNvIGNyZWF0ZXMgdGhlIFwicmVhY3RSb290XCIgSUQgdGhhdCB3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSBlbGVtZW50XG4gICAqIHJlbmRlcmVkIHdpdGhpbi5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgYXMgYSBjb250YWluZXIuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFwicmVhY3RSb290XCIgSUQgb2YgZWxlbWVudHMgcmVuZGVyZWQgd2l0aGluLlxuICAgKi9cbiAgcmVnaXN0ZXJDb250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICB2YXIgcmVhY3RSb290SUQgPSBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpO1xuICAgIGlmIChyZWFjdFJvb3RJRCkge1xuICAgICAgLy8gSWYgb25lIGV4aXN0cywgbWFrZSBzdXJlIGl0IGlzIGEgdmFsaWQgXCJyZWFjdFJvb3RcIiBJRC5cbiAgICAgIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKHJlYWN0Um9vdElEKTtcbiAgICB9XG4gICAgaWYgKCFyZWFjdFJvb3RJRCkge1xuICAgICAgLy8gTm8gdmFsaWQgXCJyZWFjdFJvb3RcIiBJRCBmb3VuZCwgY3JlYXRlIG9uZS5cbiAgICAgIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB9XG4gICAgY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gY29udGFpbmVyO1xuICAgIHJldHVybiByZWFjdFJvb3RJRDtcbiAgfSxcblxuICAvKipcbiAgICogVW5tb3VudHMgYW5kIGRlc3Ryb3lzIHRoZSBSZWFjdCBjb21wb25lbnQgcmVuZGVyZWQgaW4gdGhlIGBjb250YWluZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCBjb250YWluaW5nIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgY29tcG9uZW50IHdhcyBmb3VuZCBpbiBhbmQgdW5tb3VudGVkIGZyb21cbiAgICogICAgICAgICAgICAgICAgICAgYGNvbnRhaW5lcmBcbiAgICovXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuIChTdHJpY3RseSBzcGVha2luZywgdW5tb3VudGluZyB3b24ndCBjYXVzZSBhXG4gICAgLy8gcmVuZGVyIGJ1dCB3ZSBzdGlsbCBkb24ndCBleHBlY3QgdG8gYmUgaW4gYSByZW5kZXIgY2FsbCBoZXJlLilcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGU7IHRyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyICcgKyAnaXMgbm90IGFsbG93ZWQuIElmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcblxuICAgICEoY29udGFpbmVyICYmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgcmVhY3RSb290SUQgPSBnZXRSZWFjdFJvb3RJRChjb250YWluZXIpO1xuICAgIHZhciBjb21wb25lbnQgPSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICBpZiAoIWNvbXBvbmVudCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIG5vZGUgYmVpbmcgdW5tb3VudGVkIHdhcyByZW5kZXJlZCBieSBSZWFjdCwgYnV0IGlzbid0IGFcbiAgICAgIC8vIHJvb3Qgbm9kZS5cbiAgICAgIHZhciBjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCA9IGhhc05vblJvb3RSZWFjdENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBjb250YWluZXIgaXRzZWxmIGlzIGEgUmVhY3Qgcm9vdCBub2RlLlxuICAgICAgdmFyIGNvbnRhaW5lcklEID0gaW50ZXJuYWxHZXRJRChjb250YWluZXIpO1xuICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVySUQgJiYgY29udGFpbmVySUQgPT09IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChjb250YWluZXJJRCk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91XFwncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50ICcgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXModW5tb3VudENvbXBvbmVudEZyb21Ob2RlLCBjb21wb25lbnQsIGNvbnRhaW5lcik7XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIGRlbGV0ZSBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlbGV0ZSByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBjb250YWlucyBSZWFjdCBjb21wb25lbnQgdG8gd2hpY2ggdGhlXG4gICAqIHN1cHBsaWVkIERPTSBgaWRgIGJlbG9uZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgYW4gZWxlbWVudCByZW5kZXJlZCBieSBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7P0RPTUVsZW1lbnR9IERPTSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIGBpZGAuXG4gICAqL1xuICBmaW5kUmVhY3RDb250YWluZXJGb3JJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKGlkKTtcbiAgICB2YXIgY29udGFpbmVyID0gY29udGFpbmVyc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgICAgaWYgKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50LnBhcmVudE5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhcbiAgICAgICAgLy8gQ2FsbCBpbnRlcm5hbEdldElEIGhlcmUgYmVjYXVzZSBnZXRJRCBjYWxscyBpc1ZhbGlkIHdoaWNoIGNhbGxzXG4gICAgICAgIC8vIGZpbmRSZWFjdENvbnRhaW5lckZvcklEICh0aGlzIGZ1bmN0aW9uKS5cbiAgICAgICAgaW50ZXJuYWxHZXRJRChyb290RWxlbWVudCkgPT09IHJlYWN0Um9vdElELCAnUmVhY3RNb3VudDogUm9vdCBlbGVtZW50IElEIGRpZmZlcmVkIGZyb20gcmVhY3RSb290SUQuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBjb250YWluZXJDaGlsZCA9IGNvbnRhaW5lci5maXJzdENoaWxkO1xuICAgICAgICBpZiAoY29udGFpbmVyQ2hpbGQgJiYgcmVhY3RSb290SUQgPT09IGludGVybmFsR2V0SUQoY29udGFpbmVyQ2hpbGQpKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGNvbnRhaW5lciBoYXMgYSBuZXcgY2hpbGQgd2l0aCB0aGUgc2FtZSBJRCBhcyB0aGUgb2xkXG4gICAgICAgICAgLy8gcm9vdCBlbGVtZW50LCB0aGVuIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdIGlzXG4gICAgICAgICAgLy8ganVzdCBzdGFsZSBhbmQgbmVlZHMgdG8gYmUgdXBkYXRlZC4gVGhlIGNhc2UgdGhhdCBkZXNlcnZlcyBhXG4gICAgICAgICAgLy8gd2FybmluZyBpcyB3aGVuIHRoZSBjb250YWluZXIgaXMgZW1wdHkuXG4gICAgICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBjb250YWluZXJDaGlsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0TW91bnQ6IFJvb3QgZWxlbWVudCBoYXMgYmVlbiByZW1vdmVkIGZyb20gaXRzIG9yaWdpbmFsICcgKyAnY29udGFpbmVyLiBOZXcgY29udGFpbmVyOiAlcycsIHJvb3RFbGVtZW50LnBhcmVudE5vZGUpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgYW4gZWxlbWVudCByZW5kZXJlZCBieSBSZWFjdCB3aXRoIHRoZSBzdXBwbGllZCBJRC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIElEIG9mIGEgRE9NIG5vZGUgaW4gdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gUm9vdCBET00gbm9kZSBvZiB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKi9cbiAgZmluZFJlYWN0Tm9kZUJ5SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciByZWFjdFJvb3QgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKGlkKTtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5maW5kQ29tcG9uZW50Um9vdChyZWFjdFJvb3QsIGlkKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJhdmVyc2VzIHVwIHRoZSBhbmNlc3RvcnMgb2YgdGhlIHN1cHBsaWVkIG5vZGUgdG8gZmluZCBhIG5vZGUgdGhhdCBpcyBhXG4gICAqIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIFJlYWN0IGNvbXBvbmVudCByZW5kZXJlZCBieSB0aGlzIGNvcHkgb2YgUmVhY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gbm9kZVxuICAgKiBAcmV0dXJuIHs/RE9NRXZlbnRUYXJnZXR9XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0Rmlyc3RSZWFjdERPTTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gZmluZEZpcnN0UmVhY3RET01JbXBsKG5vZGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgYHRhcmdldElEYCBpbnNpZGUgb2YgdGhlIHN1cHBsaWVkXG4gICAqIGBhbmNlc3Rvck5vZGVgLiAgRXhwbG9pdHMgdGhlIElEIG5hbWluZyBzY2hlbWUgdG8gcGVyZm9ybSB0aGUgc2VhcmNoXG4gICAqIHF1aWNrbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IGFuY2VzdG9yTm9kZSBTZWFyY2ggZnJvbSB0aGlzIHJvb3QuXG4gICAqIEBwYXJhcm0ge3N0cmluZ30gdGFyZ2V0SUQgSUQgb2YgdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgYHRhcmdldElEYC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBmaW5kQ29tcG9uZW50Um9vdDogZnVuY3Rpb24gKGFuY2VzdG9yTm9kZSwgdGFyZ2V0SUQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZHJlbiA9IGZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheTtcbiAgICB2YXIgY2hpbGRJbmRleCA9IDA7XG5cbiAgICB2YXIgZGVlcGVzdEFuY2VzdG9yID0gZmluZERlZXBlc3RDYWNoZWRBbmNlc3Rvcih0YXJnZXRJRCkgfHwgYW5jZXN0b3JOb2RlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBvbiB0aGUgbmV4dCBsaW5lOyBnaXZlIGFuIGVhcmx5IHdhcm5pbmdcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRlZXBlc3RBbmNlc3RvciAhPSBudWxsLCAnUmVhY3QgY2FuXFwndCBmaW5kIHRoZSByb290IGNvbXBvbmVudCBub2RlIGZvciBkYXRhLXJlYWN0aWQgdmFsdWUgJyArICdgJXNgLiBJZiB5b3VcXCdyZSBzZWVpbmcgdGhpcyBtZXNzYWdlLCBpdCBwcm9iYWJseSBtZWFucyB0aGF0ICcgKyAneW91XFwndmUgbG9hZGVkIHR3byBjb3BpZXMgb2YgUmVhY3Qgb24gdGhlIHBhZ2UuIEF0IHRoaXMgdGltZSwgb25seSAnICsgJ2Egc2luZ2xlIGNvcHkgb2YgUmVhY3QgY2FuIGJlIGxvYWRlZCBhdCBhIHRpbWUuJywgdGFyZ2V0SUQpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZpcnN0Q2hpbGRyZW5bMF0gPSBkZWVwZXN0QW5jZXN0b3IuZmlyc3RDaGlsZDtcbiAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IDE7XG5cbiAgICB3aGlsZSAoY2hpbGRJbmRleCA8IGZpcnN0Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQgPSBmaXJzdENoaWxkcmVuW2NoaWxkSW5kZXgrK107XG4gICAgICB2YXIgdGFyZ2V0Q2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY2hpbGQpO1xuICAgICAgICBpZiAoY2hpbGRJRCkge1xuICAgICAgICAgIC8vIEV2ZW4gaWYgd2UgZmluZCB0aGUgbm9kZSB3ZSdyZSBsb29raW5nIGZvciwgd2UgZmluaXNoIGxvb3BpbmdcbiAgICAgICAgICAvLyB0aHJvdWdoIGl0cyBzaWJsaW5ncyB0byBlbnN1cmUgdGhleSdyZSBjYWNoZWQgc28gdGhhdCB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgLy8gdG8gcmV2aXNpdCB0aGlzIG5vZGUgYWdhaW4uIE90aGVyd2lzZSwgd2UgbWFrZSBuXjIgY2FsbHMgdG8gZ2V0SURcbiAgICAgICAgICAvLyB3aGVuIHZpc2l0aW5nIHRoZSBtYW55IGNoaWxkcmVuIG9mIGEgc2luZ2xlIG5vZGUgaW4gb3JkZXIuXG5cbiAgICAgICAgICBpZiAodGFyZ2V0SUQgPT09IGNoaWxkSUQpIHtcbiAgICAgICAgICAgIHRhcmdldENoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChSZWFjdEluc3RhbmNlSGFuZGxlcy5pc0FuY2VzdG9ySURPZihjaGlsZElELCB0YXJnZXRJRCkpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGZpbmQgYSBjaGlsZCB3aG9zZSBJRCBpcyBhbiBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gSUQsXG4gICAgICAgICAgICAvLyB0aGVuIHdlIGNhbiBiZSBzdXJlIHRoYXQgd2Ugb25seSB3YW50IHRvIHNlYXJjaCB0aGUgc3VidHJlZVxuICAgICAgICAgICAgLy8gcm9vdGVkIGF0IHRoaXMgY2hpbGQsIHNvIHdlIGNhbiB0aHJvdyBvdXQgdGhlIHJlc3Qgb2YgdGhlXG4gICAgICAgICAgICAvLyBzZWFyY2ggc3RhdGUuXG4gICAgICAgICAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IGNoaWxkSW5kZXggPSAwO1xuICAgICAgICAgICAgZmlyc3RDaGlsZHJlbi5wdXNoKGNoaWxkLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGNoaWxkIGhhZCBubyBJRCwgdGhlbiB0aGVyZSdzIGEgY2hhbmNlIHRoYXQgaXQgd2FzXG4gICAgICAgICAgLy8gaW5qZWN0ZWQgYXV0b21hdGljYWxseSBieSB0aGUgYnJvd3NlciwgYXMgd2hlbiBhIGA8dGFibGU+YFxuICAgICAgICAgIC8vIGVsZW1lbnQgc3Byb3V0cyBhbiBleHRyYSBgPHRib2R5PmAgY2hpbGQgYXMgYSBzaWRlIGVmZmVjdCBvZlxuICAgICAgICAgIC8vIGAuaW5uZXJIVE1MYCBwYXJzaW5nLiBPcHRpbWlzdGljYWxseSBjb250aW51ZSBkb3duIHRoaXNcbiAgICAgICAgICAvLyBicmFuY2gsIGJ1dCBub3QgYmVmb3JlIGV4YW1pbmluZyB0aGUgb3RoZXIgc2libGluZ3MuXG4gICAgICAgICAgZmlyc3RDaGlsZHJlbi5wdXNoKGNoaWxkLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcmdldENoaWxkKSB7XG4gICAgICAgIC8vIEVtcHR5aW5nIGZpcnN0Q2hpbGRyZW4vZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5IGlzXG4gICAgICAgIC8vIG5vdCBuZWNlc3NhcnkgZm9yIGNvcnJlY3RuZXNzLCBidXQgaXQgaGVscHMgdGhlIEdDIHJlY2xhaW1cbiAgICAgICAgLy8gYW55IG5vZGVzIHRoYXQgd2VyZSBsZWZ0IGF0IHRoZSBlbmQgb2YgdGhlIHNlYXJjaC5cbiAgICAgICAgZmlyc3RDaGlsZHJlbi5sZW5ndGggPSAwO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXRDaGlsZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZmluZENvbXBvbmVudFJvb3QoLi4uLCAlcyk6IFVuYWJsZSB0byBmaW5kIGVsZW1lbnQuIFRoaXMgcHJvYmFibHkgJyArICdtZWFucyB0aGUgRE9NIHdhcyB1bmV4cGVjdGVkbHkgbXV0YXRlZCAoZS5nLiwgYnkgdGhlIGJyb3dzZXIpLCAnICsgJ3VzdWFsbHkgZHVlIHRvIGZvcmdldHRpbmcgYSA8dGJvZHk+IHdoZW4gdXNpbmcgdGFibGVzLCBuZXN0aW5nIHRhZ3MgJyArICdsaWtlIDxmb3JtPiwgPHA+LCBvciA8YT4sIG9yIHVzaW5nIG5vbi1TVkcgZWxlbWVudHMgaW4gYW4gPHN2Zz4gJyArICdwYXJlbnQuICcgKyAnVHJ5IGluc3BlY3RpbmcgdGhlIGNoaWxkIG5vZGVzIG9mIHRoZSBlbGVtZW50IHdpdGggUmVhY3QgSUQgYCVzYC4nLCB0YXJnZXRJRCwgUmVhY3RNb3VudC5nZXRJRChhbmNlc3Rvck5vZGUpKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgX21vdW50SW1hZ2VJbnRvTm9kZTogZnVuY3Rpb24gKG1hcmt1cCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pIHtcbiAgICAhKGNvbnRhaW5lciAmJiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtb3VudENvbXBvbmVudEludG9Ob2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IHZhbGlkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChzaG91bGRSZXVzZU1hcmt1cCkge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICBpZiAoUmVhY3RNYXJrdXBDaGVja3N1bS5jYW5SZXVzZU1hcmt1cChtYXJrdXAsIHJvb3RFbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hlY2tzdW0gPSByb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgICAgICByb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuXG4gICAgICAgIHZhciByb290TWFya3VwID0gcm9vdEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICByb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUsIGNoZWNrc3VtKTtcblxuICAgICAgICB2YXIgbm9ybWFsaXplZE1hcmt1cCA9IG1hcmt1cDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAvLyBiZWNhdXNlIHJvb3RNYXJrdXAgaXMgcmV0cmlldmVkIGZyb20gdGhlIERPTSwgdmFyaW91cyBub3JtYWxpemF0aW9uc1xuICAgICAgICAgIC8vIHdpbGwgaGF2ZSBvY2N1cnJlZCB3aGljaCB3aWxsIG5vdCBiZSBwcmVzZW50IGluIGBtYXJrdXBgLiBIZXJlLFxuICAgICAgICAgIC8vIGluc2VydCBtYXJrdXAgaW50byBhIDxkaXY+IG9yIDxpZnJhbWU+IGRlcGVuZGluZyBvbiB0aGUgY29udGFpbmVyXG4gICAgICAgICAgLy8gdHlwZSB0byBwZXJmb3JtIHRoZSBzYW1lIG5vcm1hbGl6YXRpb25zIGJlZm9yZSBjb21wYXJpbmcuXG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZXI7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuaW5uZXJIVE1MID0gbWFya3VwO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuaW5uZXJIVE1MO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQud3JpdGUobWFya3VwKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChub3JtYWxpemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZkluZGV4ID0gZmlyc3REaWZmZXJlbmNlSW5kZXgobm9ybWFsaXplZE1hcmt1cCwgcm9vdE1hcmt1cCk7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gJyAoY2xpZW50KSAnICsgbm9ybWFsaXplZE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKSArICdcXG4gKHNlcnZlcikgJyArIHJvb3RNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCk7XG5cbiAgICAgICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IHVzaW5nICcgKyAnc2VydmVyIHJlbmRlcmluZyBidXQgdGhlIGNoZWNrc3VtIHdhcyBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgJyArICdtZWFucyB5b3UgcmVuZGVyZWQgYSBkaWZmZXJlbnQgY29tcG9uZW50IHR5cGUgb3IgcHJvcHMgb24gJyArICd0aGUgY2xpZW50IGZyb20gdGhlIG9uZSBvbiB0aGUgc2VydmVyLCBvciB5b3VyIHJlbmRlcigpICcgKyAnbWV0aG9kcyBhcmUgaW1wdXJlLiBSZWFjdCBjYW5ub3QgaGFuZGxlIHRoaXMgY2FzZSBkdWUgdG8gJyArICdjcm9zcy1icm93c2VyIHF1aXJrcyBieSByZW5kZXJpbmcgYXQgdGhlIGRvY3VtZW50IHJvb3QuIFlvdSAnICsgJ3Nob3VsZCBsb29rIGZvciBlbnZpcm9ubWVudCBkZXBlbmRlbnQgY29kZSBpbiB5b3VyIGNvbXBvbmVudHMgJyArICdhbmQgZW5zdXJlIHRoZSBwcm9wcyBhcmUgdGhlIHNhbWUgY2xpZW50IGFuZCBzZXJ2ZXIgc2lkZTpcXG4lcycsIGRpZmZlcmVuY2UpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgYXR0ZW1wdGVkIHRvIHJldXNlIG1hcmt1cCBpbiBhIGNvbnRhaW5lciBidXQgdGhlICcgKyAnY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgZ2VuZXJhbGx5IG1lYW5zIHRoYXQgeW91IGFyZSAnICsgJ3VzaW5nIHNlcnZlciByZW5kZXJpbmcgYW5kIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSAnICsgJ3NlcnZlciB3YXMgbm90IHdoYXQgdGhlIGNsaWVudCB3YXMgZXhwZWN0aW5nLiBSZWFjdCBpbmplY3RlZCAnICsgJ25ldyBtYXJrdXAgdG8gY29tcGVuc2F0ZSB3aGljaCB3b3JrcyBidXQgeW91IGhhdmUgbG9zdCBtYW55ICcgKyAnb2YgdGhlIGJlbmVmaXRzIG9mIHNlcnZlciByZW5kZXJpbmcuIEluc3RlYWQsIGZpZ3VyZSBvdXQgJyArICd3aHkgdGhlIG1hcmt1cCBiZWluZyBnZW5lcmF0ZWQgaXMgZGlmZmVyZW50IG9uIHRoZSBjbGllbnQgJyArICdvciBzZXJ2ZXI6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBET0NfTk9ERV9UWVBFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdZb3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIGEgY29tcG9uZW50IHRvIHRoZSBkb2N1bWVudCBidXQgJyArICd5b3UgZGlkblxcJ3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFdlIGNhblxcJ3QgZG8gdGhpcyAnICsgJ3dpdGhvdXQgdXNpbmcgc2VydmVyIHJlbmRlcmluZyBkdWUgdG8gY3Jvc3MtYnJvd3NlciBxdWlya3MuICcgKyAnU2VlIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChtYXJrdXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJbm5lckhUTUwoY29udGFpbmVyLCBtYXJrdXApO1xuICAgIH1cbiAgfSxcblxuICBvd25lckRvY3VtZW50Q29udGV4dEtleTogb3duZXJEb2N1bWVudENvbnRleHRLZXksXG5cbiAgLyoqXG4gICAqIFJlYWN0IElEIHV0aWxpdGllcy5cbiAgICovXG5cbiAgZ2V0UmVhY3RSb290SUQ6IGdldFJlYWN0Um9vdElELFxuXG4gIGdldElEOiBnZXRJRCxcblxuICBzZXRJRDogc2V0SUQsXG5cbiAgZ2V0Tm9kZTogZ2V0Tm9kZSxcblxuICBnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlLFxuXG4gIGlzVmFsaWQ6IGlzVmFsaWQsXG5cbiAgcHVyZ2VJRDogcHVyZ2VJRFxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0TW91bnQsICdSZWFjdE1vdW50Jywge1xuICBfcmVuZGVyTmV3Um9vdENvbXBvbmVudDogJ19yZW5kZXJOZXdSb290Q29tcG9uZW50JyxcbiAgX21vdW50SW1hZ2VJbnRvTm9kZTogJ19tb3VudEltYWdlSW50b05vZGUnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1vdW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcycpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZFJlY29uY2lsZXInKTtcblxudmFyIGZsYXR0ZW5DaGlsZHJlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbkNoaWxkcmVuJyk7XG5cbi8qKlxuICogVXBkYXRpbmcgY2hpbGRyZW4gb2YgYSBjb21wb25lbnQgbWF5IHRyaWdnZXIgcmVjdXJzaXZlIHVwZGF0ZXMuIFRoZSBkZXB0aCBpc1xuICogdXNlZCB0byBiYXRjaCByZWN1cnNpdmUgdXBkYXRlcyB0byByZW5kZXIgbWFya3VwIG1vcmUgZWZmaWNpZW50bHkuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1cGRhdGVEZXB0aCA9IDA7XG5cbi8qKlxuICogUXVldWUgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb24gb2JqZWN0cy5cbiAqXG4gKiBFYWNoIG9iamVjdCBoYXMgYSBgdHlwZWAgcHJvcGVydHkgdGhhdCBpcyBpbiBgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXNgLlxuICpcbiAqIEB0eXBlIHthcnJheTxvYmplY3Q+fVxuICogQHByaXZhdGVcbiAqL1xudmFyIHVwZGF0ZVF1ZXVlID0gW107XG5cbi8qKlxuICogUXVldWUgb2YgbWFya3VwIHRvIGJlIHJlbmRlcmVkLlxuICpcbiAqIEB0eXBlIHthcnJheTxzdHJpbmc+fVxuICogQHByaXZhdGVcbiAqL1xudmFyIG1hcmt1cFF1ZXVlID0gW107XG5cbi8qKlxuICogRW5xdWV1ZXMgbWFya3VwIHRvIGJlIHJlbmRlcmVkIGFuZCBpbnNlcnRlZCBhdCBhIHN1cHBsaWVkIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVJbnNlcnRNYXJrdXAocGFyZW50SUQsIG1hcmt1cCwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVAsXG4gICAgbWFya3VwSW5kZXg6IG1hcmt1cFF1ZXVlLnB1c2gobWFya3VwKSAtIDEsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgdG9JbmRleDogdG9JbmRleFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBtb3ZpbmcgYW4gZXhpc3RpbmcgZWxlbWVudCB0byBhbm90aGVyIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggU291cmNlIGluZGV4IG9mIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlTW92ZShwYXJlbnRJRCwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuTU9WRV9FWElTVElORyxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogZnJvbUluZGV4LFxuICAgIHRvSW5kZXg6IHRvSW5kZXhcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgcmVtb3ZpbmcgYW4gZWxlbWVudCBhdCBhbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IEluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVSZW1vdmUocGFyZW50SUQsIGZyb21JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFLFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBmcm9tSW5kZXgsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBzZXR0aW5nIHRoZSBtYXJrdXAgb2YgYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlU2V0TWFya3VwKHBhcmVudElELCBtYXJrdXApIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5TRVRfTUFSS1VQLFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIGNvbnRlbnQ6IG1hcmt1cCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBzZXR0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVGV4dENvbnRlbnQocGFyZW50SUQsIHRleHRDb250ZW50KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuVEVYVF9DT05URU5ULFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsXG4gIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3NlcyBhbnkgZW5xdWV1ZWQgdXBkYXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwcm9jZXNzUXVldWUoKSB7XG4gIGlmICh1cGRhdGVRdWV1ZS5sZW5ndGgpIHtcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXModXBkYXRlUXVldWUsIG1hcmt1cFF1ZXVlKTtcbiAgICBjbGVhclF1ZXVlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGVhcnMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgdXBkYXRlUXVldWUubGVuZ3RoID0gMDtcbiAgbWFya3VwUXVldWUubGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBSZWFjdE11bHRpQ2hpbGQgYXJlIGNhcGFibGUgb2YgcmVjb25jaWxpbmcgbXVsdGlwbGUgY2hpbGRyZW4uXG4gKlxuICogQGNsYXNzIFJlYWN0TXVsdGlDaGlsZFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGQgPSB7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRzIHRoYXQgbXVzdCByZWNvbmNpbGUgbXVsdGlwbGVcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICBfcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW47XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzKTtcbiAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgbW91bnRlZCByZXByZXNlbnRhdGlvbnMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bbmFtZV07XG4gICAgICAgICAgLy8gSW5saW5lZCBmb3IgcGVyZm9ybWFuY2UsIHNlZSBgUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RJRGAuXG4gICAgICAgICAgdmFyIHJvb3RJRCA9IHRoaXMuX3Jvb3ROb2RlSUQgKyBuYW1lO1xuICAgICAgICAgIHZhciBtb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4Kys7XG4gICAgICAgICAgbW91bnRJbWFnZXMucHVzaChtb3VudEltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1vdW50SW1hZ2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIHRleHQgY29udGVudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dENvbnRlbnQgU3RyaW5nIG9mIGNvbnRlbnQuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlVGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChuZXh0Q29udGVudCkge1xuICAgICAgdXBkYXRlRGVwdGgrKztcbiAgICAgIHZhciBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbik7XG4gICAgICAgIC8vIFRPRE86IFRoZSBzZXRUZXh0Q29udGVudCBvcGVyYXRpb24gc2hvdWxkIGJlIGVub3VnaFxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZChwcmV2Q2hpbGRyZW5bbmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgbmV3IHRleHQgY29udGVudC5cbiAgICAgICAgdGhpcy5zZXRUZXh0Q29udGVudChuZXh0Q29udGVudCk7XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1cGRhdGVEZXB0aC0tO1xuICAgICAgICBpZiAoIXVwZGF0ZURlcHRoKSB7XG4gICAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICBjbGVhclF1ZXVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG1hcmt1cCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dE1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZU1hcmt1cDogZnVuY3Rpb24gKG5leHRNYXJrdXApIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4pO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZEJ5TmFtZShwcmV2Q2hpbGRyZW5bbmFtZV0sIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE1hcmt1cChuZXh0TWFya3VwKTtcbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVwZGF0ZURlcHRoLS07XG4gICAgICAgIGlmICghdXBkYXRlRGVwdGgpIHtcbiAgICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIGNsZWFyUXVldWUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggbmV3IGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdXBkYXRlRGVwdGgrKztcbiAgICAgIHZhciBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl91cGRhdGVDaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlRGVwdGgtLTtcbiAgICAgICAgaWYgKCF1cGRhdGVEZXB0aCkge1xuICAgICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgICAgY2xlYXJRdWV1ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzUXVldWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW1wcm92ZSBwZXJmb3JtYW5jZSBieSBpc29sYXRpbmcgdGhpcyBob3QgY29kZSBwYXRoIGZyb20gdGhlIHRyeS9jYXRjaFxuICAgICAqIGJsb2NrIGluIGB1cGRhdGVDaGlsZHJlbmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbmV4dENoaWxkcmVuO1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIC8vIGBuZXh0SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIGNoaWxkIGluIGBuZXh0Q2hpbGRyZW5gLCBidXRcbiAgICAgIC8vIGBsYXN0SW5kZXhgIHdpbGwgYmUgdGhlIGxhc3QgaW5kZXggdmlzaXRlZCBpbiBgcHJldkNoaWxkcmVuYC5cbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIGlmIChwcmV2Q2hpbGQgPT09IG5leHRDaGlsZCkge1xuICAgICAgICAgIHRoaXMubW92ZUNoaWxkKHByZXZDaGlsZCwgbmV4dEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICBwcmV2Q2hpbGQuX21vdW50SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGBsYXN0SW5kZXhgIGJlZm9yZSBgX21vdW50SW5kZXhgIGdldHMgdW5zZXQgYnkgdW5tb3VudGluZy5cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZChwcmV2Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgICB0aGlzLl9tb3VudENoaWxkQnlOYW1lQXRJbmRleChuZXh0Q2hpbGQsIG5hbWUsIG5leHRJbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpICYmICEobmV4dENoaWxkcmVuICYmIG5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcbiAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkcmVuW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlbmRlcmVkQ2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHJlbmRlcmVkQ2hpbGRyZW4pO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY2hpbGQgY29tcG9uZW50IHRvIHRoZSBzdXBwbGllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0SW5kZXggTGFzdCBpbmRleCB2aXNpdGVkIG9mIHRoZSBzaWJsaW5ncyBvZiBgY2hpbGRgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgdG9JbmRleCwgbGFzdEluZGV4KSB7XG4gICAgICAvLyBJZiB0aGUgaW5kZXggb2YgYGNoaWxkYCBpcyBsZXNzIHRoYW4gYGxhc3RJbmRleGAsIHRoZW4gaXQgbmVlZHMgdG9cbiAgICAgIC8vIGJlIG1vdmVkLiBPdGhlcndpc2UsIHdlIGRvIG5vdCBuZWVkIHRvIG1vdmUgaXQgYmVjYXVzZSBhIGNoaWxkIHdpbGwgYmVcbiAgICAgIC8vIGluc2VydGVkIG9yIG1vdmVkIGJlZm9yZSBgY2hpbGRgLlxuICAgICAgaWYgKGNoaWxkLl9tb3VudEluZGV4IDwgbGFzdEluZGV4KSB7XG4gICAgICAgIGVucXVldWVNb3ZlKHRoaXMuX3Jvb3ROb2RlSUQsIGNoaWxkLl9tb3VudEluZGV4LCB0b0luZGV4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vdW50SW1hZ2UgTWFya3VwIHRvIGluc2VydC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbW91bnRJbWFnZSkge1xuICAgICAgZW5xdWV1ZUluc2VydE1hcmt1cCh0aGlzLl9yb290Tm9kZUlELCBtb3VudEltYWdlLCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDaGlsZCB0byByZW1vdmUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGVucXVldWVSZW1vdmUodGhpcy5fcm9vdE5vZGVJRCwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0Q29udGVudCBUZXh0IGNvbnRlbnQgdG8gc2V0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKHRleHRDb250ZW50KSB7XG4gICAgICBlbnF1ZXVlVGV4dENvbnRlbnQodGhpcy5fcm9vdE5vZGVJRCwgdGV4dENvbnRlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgbWFya3VwIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHNldC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2V0TWFya3VwOiBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgICBlbnF1ZXVlU2V0TWFya3VwKHRoaXMuX3Jvb3ROb2RlSUQsIG1hcmt1cCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdW50cyBhIGNoaWxkIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW91bnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdW50Q2hpbGRCeU5hbWVBdEluZGV4OiBmdW5jdGlvbiAoY2hpbGQsIG5hbWUsIGluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgLy8gSW5saW5lZCBmb3IgcGVyZm9ybWFuY2UsIHNlZSBgUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RJRGAuXG4gICAgICB2YXIgcm9vdElEID0gdGhpcy5fcm9vdE5vZGVJRCArIG5hbWU7XG4gICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xuICAgICAgdGhpcy5jcmVhdGVDaGlsZChjaGlsZCwgbW91bnRJbWFnZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGEgcmVuZGVyZWQgY2hpbGQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gdW5tb3VudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bm1vdW50Q2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IG51bGw7XG4gICAgfVxuXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbi8qKlxuICogV2hlbiBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGFyZSB1cGRhdGVkLCBhIHNlcmllcyBvZiB1cGRhdGUgY29uZmlndXJhdGlvblxuICogb2JqZWN0cyBhcmUgY3JlYXRlZCBpbiBvcmRlciB0byBiYXRjaCBhbmQgc2VyaWFsaXplIHRoZSByZXF1aXJlZCBjaGFuZ2VzLlxuICpcbiAqIEVudW1lcmF0ZXMgYWxsIHRoZSBwb3NzaWJsZSB0eXBlcyBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IGtleU1pcnJvcih7XG4gIElOU0VSVF9NQVJLVVA6IG51bGwsXG4gIE1PVkVfRVhJU1RJTkc6IG51bGwsXG4gIFJFTU9WRV9OT0RFOiBudWxsLFxuICBTRVRfTUFSS1VQOiBudWxsLFxuICBURVhUX0NPTlRFTlQ6IG51bGxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE5hdGl2ZUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzID0gbnVsbDtcbnZhciBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBudWxsO1xuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB3cmFwcGVyIGNsYXNzZXMgYXJvdW5kIG5hdGl2ZSB0YWdzLlxudmFyIHRhZ1RvQ29tcG9uZW50Q2xhc3MgPSB7fTtcbnZhciB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBudWxsO1xuXG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIC8vIFRoaXMgYWNjZXB0cyBhIGNsYXNzIHRoYXQgcmVjZWl2ZXMgdGhlIHRhZyBzdHJpbmcuIFRoaXMgaXMgYSBjYXRjaCBhbGxcbiAgLy8gdGhhdCBjYW4gcmVuZGVyIGFueSBraW5kIG9mIHRhZy5cbiAgaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEgdGV4dCBjb21wb25lbnQgY2xhc3MgdGhhdCB0YWtlcyB0aGUgdGV4dCBzdHJpbmcgdG8gYmVcbiAgLy8gcmVuZGVyZWQgYXMgcHJvcHMuXG4gIGluamVjdFRleHRDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgdGV4dENvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH0sXG4gIC8vIFRoaXMgYWNjZXB0cyBhIGtleWVkIG9iamVjdCB3aXRoIGNsYXNzZXMgYXMgdmFsdWVzLiBFYWNoIGtleSByZXByZXNlbnRzIGFcbiAgLy8gdGFnLiBUaGF0IHBhcnRpY3VsYXIgdGFnIHdpbGwgdXNlIHRoaXMgY2xhc3MgaW5zdGVhZCBvZiB0aGUgZ2VuZXJpYyBvbmUuXG4gIGluamVjdENvbXBvbmVudENsYXNzZXM6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzc2VzKSB7XG4gICAgYXNzaWduKHRhZ1RvQ29tcG9uZW50Q2xhc3MsIGNvbXBvbmVudENsYXNzZXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGNvbXBvc2l0ZSBjb21wb25lbnQgd3JhcHBlciBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgVGhlIHRhZyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBjbGFzcy5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgUmVhY3QgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudChlbGVtZW50KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgfVxuICB2YXIgdGFnID0gZWxlbWVudC50eXBlO1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSB0YWdUb0NvbXBvbmVudENsYXNzW3RhZ107XG4gIGlmIChjb21wb25lbnRDbGFzcyA9PSBudWxsKSB7XG4gICAgdGFnVG9Db21wb25lbnRDbGFzc1t0YWddID0gY29tcG9uZW50Q2xhc3MgPSBhdXRvR2VuZXJhdGVXcmFwcGVyQ2xhc3ModGFnKTtcbiAgfVxuICByZXR1cm4gY29tcG9uZW50Q2xhc3M7XG59XG5cbi8qKlxuICogR2V0IGEgbmF0aXZlIGludGVybmFsIGNvbXBvbmVudCBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gY3JlYXRlLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBpbnRlcm5hbCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCkge1xuICAhZ2VuZXJpY0NvbXBvbmVudENsYXNzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIGlzIG5vIHJlZ2lzdGVyZWQgY29tcG9uZW50IGZvciB0aGUgdGFnICVzJywgZWxlbWVudC50eXBlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBuZXcgZ2VuZXJpY0NvbXBvbmVudENsYXNzKGVsZW1lbnQudHlwZSwgZWxlbWVudC5wcm9wcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdFRleHR9IHRleHRcbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUZvclRleHQodGV4dCkge1xuICByZXR1cm4gbmV3IHRleHRDb21wb25lbnRDbGFzcyh0ZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVGV4dENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIGNvbXBvbmVudCBpbnN0YW5jZW9mIHRleHRDb21wb25lbnRDbGFzcztcbn1cblxudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0ge1xuICBnZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQ6IGdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudCxcbiAgY3JlYXRlSW50ZXJuYWxDb21wb25lbnQ6IGNyZWF0ZUludGVybmFsQ29tcG9uZW50LFxuICBjcmVhdGVJbnN0YW5jZUZvclRleHQ6IGNyZWF0ZUluc3RhbmNlRm9yVGV4dCxcbiAgaXNUZXh0Q29tcG9uZW50OiBpc1RleHRDb21wb25lbnQsXG4gIGluamVjdGlvbjogUmVhY3ROYXRpdmVDb21wb25lbnRJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROYXRpdmVDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE5vb3BVcGRhdGVRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5URFoocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvciAmJiBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnJykgOiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7fSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgd2FyblREWihwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRQcm9wczogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsUHJvcHMpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAnc2V0UHJvcHMnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBOZXcgcHJvcHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VQcm9wczogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwcm9wcykge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdyZXBsYWNlUHJvcHMnKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE93bmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmVhY3RPd25lcnMgYXJlIGNhcGFibGUgb2Ygc3RvcmluZyByZWZlcmVuY2VzIHRvIG93bmVkIGNvbXBvbmVudHMuXG4gKlxuICogQWxsIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9iZWluZy8vIHJlZmVyZW5jZWQgYnkgb3duZXIgY29tcG9uZW50cywgYnV0XG4gKiBvbmx5IFJlYWN0T3duZXIgY29tcG9uZW50cyBhcmUgY2FwYWJsZSBvZiAvL3JlZmVyZW5jaW5nLy8gb3duZWQgY29tcG9uZW50cy5cbiAqIFRoZSBuYW1lZCByZWZlcmVuY2UgaXMga25vd24gYXMgYSBcInJlZlwiLlxuICpcbiAqIFJlZnMgYXJlIGF2YWlsYWJsZSB3aGVuIG1vdW50ZWQgYW5kIHVwZGF0ZWQgZHVyaW5nIHJlY29uY2lsaWF0aW9uLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gKFxuICogICAgICAgICA8ZGl2IG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xpY2t9PlxuICogICAgICAgICAgIDxDdXN0b21Db21wb25lbnQgcmVmPVwiY3VzdG9tXCIgLz5cbiAqICAgICAgICAgPC9kaXY+XG4gKiAgICAgICApO1xuICogICAgIH0sXG4gKiAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5oYW5kbGVDbGljaygpO1xuICogICAgIH0sXG4gKiAgICAgY29tcG9uZW50RGlkTW91bnQ6IGZ1bmN0aW9uKCkge1xuICogICAgICAgdGhpcy5yZWZzLmN1c3RvbS5pbml0aWFsaXplKCk7XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBSZWZzIHNob3VsZCByYXJlbHkgYmUgdXNlZC4gV2hlbiByZWZzIGFyZSB1c2VkLCB0aGV5IHNob3VsZCBvbmx5IGJlIGRvbmUgdG9cbiAqIGNvbnRyb2wgZGF0YSB0aGF0IGlzIG5vdCBoYW5kbGVkIGJ5IFJlYWN0J3MgZGF0YSBmbG93LlxuICpcbiAqIEBjbGFzcyBSZWFjdE93bmVyXG4gKi9cbnZhciBSZWFjdE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgb3duZXIuXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNWYWxpZE93bmVyOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuICEhKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0LmF0dGFjaFJlZiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqZWN0LmRldGFjaFJlZiA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjb21wb25lbnQgYnkgcmVmIHRvIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byByZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBieSB3aGljaCB0byByZWZlciB0byB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0byByZWNvcmQgdGhlIHJlZi5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYWRkQ29tcG9uZW50QXNSZWZUbzogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYWRkQ29tcG9uZW50QXNSZWZUbyguLi4pOiBPbmx5IGEgUmVhY3RPd25lciBjYW4gaGF2ZSByZWZzLiBZb3UgbWlnaHQgJyArICdiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAnICsgJyhkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgb3duZXIuYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNvbXBvbmVudCBieSByZWYgZnJvbSBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBvZiB0aGUgcmVmIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdGhlIHJlZiBpcyByZWNvcmRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIVJlYWN0T3duZXIuaXNWYWxpZE93bmVyKG93bmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW1vdmVDb21wb25lbnRBc1JlZkZyb20oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0ICcgKyAnYmUgcmVtb3ZpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAnICsgJyhkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgLy8gQ2hlY2sgdGhhdCBgY29tcG9uZW50YCBpcyBzdGlsbCB0aGUgY3VycmVudCByZWYgYmVjYXVzZSB3ZSBkbyBub3Qgd2FudCB0b1xuICAgIC8vIGRldGFjaCB0aGUgcmVmIGlmIGFub3RoZXIgY29tcG9uZW50IHN0b2xlIGl0LlxuICAgIGlmIChvd25lci5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnNbcmVmXSA9PT0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCkpIHtcbiAgICAgIG93bmVyLmRldGFjaFJlZihyZWYpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0T3duZXI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UGVyZlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVhY3RQZXJmIGlzIGEgZ2VuZXJhbCBBT1Agc3lzdGVtIGRlc2lnbmVkIHRvIG1lYXN1cmUgcGVyZm9ybWFuY2UuIFRoaXNcbiAqIG1vZHVsZSBvbmx5IGhhcyB0aGUgaG9va3M6IHNlZSBSZWFjdERlZmF1bHRQZXJmIGZvciB0aGUgYW5hbHlzaXMgdG9vbC5cbiAqL1xudmFyIFJlYWN0UGVyZiA9IHtcbiAgLyoqXG4gICAqIEJvb2xlYW4gdG8gZW5hYmxlL2Rpc2FibGUgbWVhc3VyZW1lbnQuIFNldCB0byBmYWxzZSBieSBkZWZhdWx0IHRvIHByZXZlbnRcbiAgICogYWNjaWRlbnRhbCBsb2dnaW5nIGFuZCBwZXJmIGxvc3MuXG4gICAqL1xuICBlbmFibGVNZWFzdXJlOiBmYWxzZSxcblxuICAvKipcbiAgICogSG9sZHMgb250byB0aGUgbWVhc3VyZSBmdW5jdGlvbiBpbiB1c2UuIEJ5IGRlZmF1bHQsIGRvbid0IG1lYXN1cmVcbiAgICogYW55dGhpbmcsIGJ1dCB3ZSdsbCBvdmVycmlkZSB0aGlzIGlmIHdlIGluamVjdCBhIG1lYXN1cmUgZnVuY3Rpb24uXG4gICAqL1xuICBzdG9yZWRNZWFzdXJlOiBfbm9NZWFzdXJlLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvYmplY3ROYW1lXG4gICAqIEBwYXJhbSB7b2JqZWN0PHN0cmluZz59IG1ldGhvZE5hbWVzXG4gICAqL1xuICBtZWFzdXJlTWV0aG9kczogZnVuY3Rpb24gKG9iamVjdCwgb2JqZWN0TmFtZSwgbWV0aG9kTmFtZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG1ldGhvZE5hbWVzKSB7XG4gICAgICAgIGlmICghbWV0aG9kTmFtZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdFtrZXldID0gUmVhY3RQZXJmLm1lYXN1cmUob2JqZWN0TmFtZSwgbWV0aG9kTmFtZXNba2V5XSwgb2JqZWN0W2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXNlIHRoaXMgdG8gd3JhcCBtZXRob2RzIHlvdSB3YW50IHRvIG1lYXN1cmUuIFplcm8gb3ZlcmhlYWQgaW4gcHJvZHVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9iak5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICAgKi9cbiAgbWVhc3VyZTogZnVuY3Rpb24gKG9iak5hbWUsIGZuTmFtZSwgZnVuYykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWVhc3VyZWRGdW5jID0gbnVsbDtcbiAgICAgIHZhciB3cmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoUmVhY3RQZXJmLmVuYWJsZU1lYXN1cmUpIHtcbiAgICAgICAgICBpZiAoIW1lYXN1cmVkRnVuYykge1xuICAgICAgICAgICAgbWVhc3VyZWRGdW5jID0gUmVhY3RQZXJmLnN0b3JlZE1lYXN1cmUob2JqTmFtZSwgZm5OYW1lLCBmdW5jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lYXN1cmVkRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgd3JhcHBlci5kaXNwbGF5TmFtZSA9IG9iak5hbWUgKyAnXycgKyBmbk5hbWU7XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWVhc3VyZVxuICAgICAqL1xuICAgIGluamVjdE1lYXN1cmU6IGZ1bmN0aW9uIChtZWFzdXJlKSB7XG4gICAgICBSZWFjdFBlcmYuc3RvcmVkTWVhc3VyZSA9IG1lYXN1cmU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFNpbXBseSBwYXNzZXMgdGhyb3VnaCB0aGUgbWVhc3VyZWQgZnVuY3Rpb24sIHdpdGhvdXQgbWVhc3VyaW5nIGl0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBvYmpOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gX25vTWVhc3VyZShvYmpOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQZXJmOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZUxvY2F0aW9uc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IGtleU1pcnJvcih7XG4gIHByb3A6IG51bGwsXG4gIGNvbnRleHQ6IG51bGwsXG4gIGNoaWxkQ29udGV4dDogbnVsbFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG5cbi8qKlxuICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gKlxuICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHByb3BUeXBlczoge1xuICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAqXG4gKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gKlxuICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gKiAgICAgfSxcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICogICB9KTtcbiAqXG4gKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gKlxuICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAqXG4gKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gKlxuICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICBwcm9wVHlwZXM6IHtcbiAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAqICAgICAgICAgICk7XG4gKiAgICAgICAgfVxuICogICAgICB9XG4gKiAgICB9LFxuICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gKiAgfSk7XG4gKlxuICogQGludGVybmFsXG4gKi9cblxudmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxudmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuXG4gIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXJcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1JlcXVpcmVkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agd2FzIG5vdCBzcGVjaWZpZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zKG51bGwpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nKTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBleHBlY3RlZFZhbHVlc1tpXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXkpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG5mdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG4gIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgcmV0dXJuICdvYmplY3QnO1xuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG5mdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbmZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgcmV0dXJuICc8PGFub255bW91cz4+JztcbiAgfVxuICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG5cbi8qKlxuICogRW5zdXJlcyB0aGF0LCB3aGVuIHBvc3NpYmxlLCB0aGUgc2VsZWN0aW9uIHJhbmdlIChjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dFxuICogaW5wdXQpIGlzIG5vdCBkaXN0dXJiZWQgYnkgcGVyZm9ybWluZyB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBTRUxFQ1RJT05fUkVTVE9SQVRJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtTZWxlY3Rpb259IFNlbGVjdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24sXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NlbGVjdGlvbn0gc2VsIFNlbGVjdGlvbiBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIGBpbml0aWFsaXplYC5cbiAgICovXG4gIGNsb3NlOiBSZWFjdElucHV0U2VsZWN0aW9uLnJlc3RvcmVTZWxlY3Rpb25cbn07XG5cbi8qKlxuICogU3VwcHJlc3NlcyBldmVudHMgKGJsdXIvZm9jdXMpIHRoYXQgY291bGQgYmUgaW5hZHZlcnRlbnRseSBkaXNwYXRjaGVkIGR1ZSB0b1xuICogaGlnaCBsZXZlbCBET00gbWFuaXB1bGF0aW9ucyAobGlrZSB0ZW1wb3JhcmlseSByZW1vdmluZyBhIHRleHQgaW5wdXQgZnJvbSB0aGVcbiAqIERPTSkuXG4gKi9cbnZhciBFVkVOVF9TVVBQUkVTU0lPTiA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSBlbmFibGVkIHN0YXR1cyBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmVcbiAgICogdGhlIHJlY29uY2lsaWF0aW9uLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50bHlFbmFibGVkID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmlzRW5hYmxlZCgpO1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKGZhbHNlKTtcbiAgICByZXR1cm4gY3VycmVudGx5RW5hYmxlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBwcmV2aW91c2x5RW5hYmxlZCBFbmFibGVkIHN0YXR1cyBvZlxuICAgKiAgIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGJlZm9yZSB0aGUgcmVjb25jaWxpYXRpb24gb2NjdXJyZWQuIGBjbG9zZWBcbiAgICogICByZXN0b3JlcyB0aGUgcHJldmlvdXMgdmFsdWUuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24gKHByZXZpb3VzbHlFbmFibGVkKSB7XG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnNldEVuYWJsZWQocHJldmlvdXNseUVuYWJsZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgcXVldWUgZm9yIGNvbGxlY3RpbmcgYGNvbXBvbmVudERpZE1vdW50YCBhbmRcbiAqIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBkdXJpbmcgdGhlIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgRE9NIGlzIGZsdXNoZWQsIGludm9rZSBhbGwgcmVnaXN0ZXJlZCBgb25ET01SZWFkeWAgY2FsbGJhY2tzLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW1NFTEVDVElPTl9SRVNUT1JBVElPTiwgRVZFTlRfU1VQUFJFU1NJT04sIE9OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbi8qKlxuICogQ3VycmVudGx5OlxuICogLSBUaGUgb3JkZXIgdGhhdCB0aGVzZSBhcmUgbGlzdGVkIGluIHRoZSB0cmFuc2FjdGlvbiBpcyBjcml0aWNhbDpcbiAqIC0gU3VwcHJlc3NlcyBldmVudHMuXG4gKiAtIFJlc3RvcmVzIHNlbGVjdGlvbiByYW5nZS5cbiAqXG4gKiBGdXR1cmU6XG4gKiAtIFJlc3RvcmUgZG9jdW1lbnQvb3ZlcmZsb3cgc2Nyb2xsIHBvc2l0aW9ucyB0aGF0IHdlcmUgdW5pbnRlbnRpb25hbGx5XG4gKiAgIG1vZGlmaWVkIHZpYSBET00gaW5zZXJ0aW9ucyBhYm92ZSB0aGUgdG9wIHZpZXdwb3J0IGJvdW5kYXJ5LlxuICogLSBJbXBsZW1lbnQvaW50ZWdyYXRlIHdpdGggY3VzdG9taXplZCBjb25zdHJhaW50IGJhc2VkIGxheW91dCBzeXN0ZW0gYW5kIGtlZXBcbiAqICAgdHJhY2sgb2Ygd2hpY2ggZGltZW5zaW9ucyBtdXN0IGJlIHJlbWVhc3VyZWQuXG4gKlxuICogQGNsYXNzIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbihmb3JjZUhUTUwpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICAvLyBPbmx5IHNlcnZlci1zaWRlIHJlbmRlcmluZyByZWFsbHkgbmVlZHMgdGhpcyBvcHRpb24gKHNlZVxuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdgKSwgYnV0IHNlcnZlci1zaWRlIHVzZXNcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb25gIGluc3RlYWQuIFRoaXMgb3B0aW9uIGlzIGhlcmUgc28gdGhhdCBpdCdzXG4gIC8vIGFjY2Vzc2libGUgYW5kIGRlZmF1bHRzIHRvIGZhbHNlIHdoZW4gYFJlYWN0RE9NQ29tcG9uZW50YCBhbmRcbiAgLy8gYFJlYWN0VGV4dENvbXBvbmVudGAgY2hlY2tzIGl0IGluIGBtb3VudENvbXBvbmVudGAuYFxuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gZmFsc2U7XG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9ICFmb3JjZUhUTUwgJiYgUmVhY3RET01GZWF0dXJlRmxhZ3MudXNlQ3JlYXRlRWxlbWVudDtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5PG9iamVjdD59IExpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICogICBUT0RPOiBjb252ZXJ0IHRvIGFycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG4gIH1cbn07XG5cbmFzc2lnbihSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVjb25jaWxlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UmVmID0gcmVxdWlyZSgnLi9SZWFjdFJlZicpO1xuXG4vKipcbiAqIEhlbHBlciB0byBjYWxsIFJlYWN0UmVmLmF0dGFjaFJlZnMgd2l0aCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQsIHNwbGl0IG91dFxuICogdG8gYXZvaWQgYWxsb2NhdGlvbnMgaW4gdGhlIHRyYW5zYWN0aW9uIG1vdW50LXJlYWR5IHF1ZXVlLlxuICovXG5mdW5jdGlvbiBhdHRhY2hSZWZzKCkge1xuICBSZWFjdFJlZi5hdHRhY2hSZWZzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbn1cblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbWFya3VwID0gaW50ZXJuYWxJbnN0YW5jZS5tb3VudENvbXBvbmVudChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS51bm1vdW50Q29tcG9uZW50KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIGNvbXBvbmVudCB1c2luZyBhIG5ldyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgaWYgKG5leHRFbGVtZW50ID09PSBwcmV2RWxlbWVudCAmJiBjb250ZXh0ID09PSBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0KSB7XG4gICAgICAvLyBTaW5jZSBlbGVtZW50cyBhcmUgaW1tdXRhYmxlIGFmdGVyIHRoZSBvd25lciBpcyByZW5kZXJlZCxcbiAgICAgIC8vIHdlIGNhbiBkbyBhIGNoZWFwIGlkZW50aXR5IGNvbXBhcmUgaGVyZSB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhXG4gICAgICAvLyBzdXBlcmZsdW91cyByZWNvbmNpbGUuIEl0J3MgcG9zc2libGUgZm9yIHN0YXRlIHRvIGJlIG11dGFibGUgYnV0IHN1Y2hcbiAgICAgIC8vIGNoYW5nZSBzaG91bGQgdHJpZ2dlciBhbiB1cGRhdGUgb2YgdGhlIG93bmVyIHdoaWNoIHdvdWxkIHJlY3JlYXRlXG4gICAgICAvLyB0aGUgZWxlbWVudC4gV2UgZXhwbGljaXRseSBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBvd25lciBzaW5jZVxuICAgICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgYW4gZWxlbWVudCBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG5cbiAgICAgIC8vIFRPRE86IEJhaWxpbmcgb3V0IGVhcmx5IGlzIGp1c3QgYSBwZXJmIG9wdGltaXphdGlvbiByaWdodD9cbiAgICAgIC8vIFRPRE86IFJlbW92aW5nIHRoZSByZXR1cm4gc3RhdGVtZW50IHNob3VsZCBhZmZlY3QgY29ycmVjdG5lc3M/XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlZnNDaGFuZ2VkID0gUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyhwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkKSB7XG4gICAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIHByZXZFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZsdXNoIGFueSBkaXJ0eSBjaGFuZ2VzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbikge1xuICAgIGludGVybmFsSW5zdGFuY2UucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KHRyYW5zYWN0aW9uKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWZcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdE93bmVyJyk7XG5cbnZhciBSZWFjdFJlZiA9IHt9O1xuXG5mdW5jdGlvbiBhdHRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5hZGRDb21wb25lbnRBc1JlZlRvKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihudWxsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5yZW1vdmVDb21wb25lbnRBc1JlZkZyb20oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5SZWFjdFJlZi5hdHRhY2hSZWZzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgYXR0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxuUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyA9IGZ1bmN0aW9uIChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgLy8gSWYgZWl0aGVyIHRoZSBvd25lciBvciBhIGByZWZgIGhhcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdGhlIG5ld2VzdCBvd25lclxuICAvLyBoYXMgc3RvcmVkIGEgcmVmZXJlbmNlIHRvIGB0aGlzYCwgYW5kIHRoZSBwcmV2aW91cyBvd25lciAoaWYgZGlmZmVyZW50KVxuICAvLyBoYXMgZm9yZ290dGVuIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgLiBXZSB1c2UgdGhlIGVsZW1lbnQgaW5zdGVhZFxuICAvLyBvZiB0aGUgcHVibGljIHRoaXMucHJvcHMgYmVjYXVzZSB0aGUgcG9zdCBwcm9jZXNzaW5nIGNhbm5vdCBkZXRlcm1pbmVcbiAgLy8gYSByZWYuIFRoZSByZWYgY29uY2VwdHVhbGx5IGxpdmVzIG9uIHRoZSBlbGVtZW50LlxuXG4gIC8vIFRPRE86IFNob3VsZCB0aGlzIGV2ZW4gYmUgcG9zc2libGU/IFRoZSBvd25lciBjYW5ub3QgY2hhbmdlIGJlY2F1c2VcbiAgLy8gaXQncyBmb3JiaWRkZW4gYnkgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuIFRoZSByZWYgY2FuIGNoYW5nZVxuICAvLyBpZiB5b3Ugc3dhcCB0aGUga2V5cyBvZiBidXQgbm90IHRoZSByZWZzLiBSZWNvbnNpZGVyIHdoZXJlIHRoaXMgY2hlY2tcbiAgLy8gaXMgbWFkZS4gSXQgcHJvYmFibHkgYmVsb25ncyB3aGVyZSB0aGUga2V5IGNoZWNraW5nIGFuZFxuICAvLyBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IGlzIGRvbmUuXG5cbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcblxuICByZXR1cm4oXG4gICAgLy8gVGhpcyBoYXMgYSBmZXcgZmFsc2UgcG9zaXRpdmVzIHcvci90IGVtcHR5IGNvbXBvbmVudHMuXG4gICAgcHJldkVtcHR5IHx8IG5leHRFbXB0eSB8fCBuZXh0RWxlbWVudC5fb3duZXIgIT09IHByZXZFbGVtZW50Ll9vd25lciB8fCBuZXh0RWxlbWVudC5yZWYgIT09IHByZXZFbGVtZW50LnJlZlxuICApO1xufTtcblxuUmVhY3RSZWYuZGV0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChyZWYgIT0gbnVsbCkge1xuICAgIGRldGFjaFJlZihyZWYsIGluc3RhbmNlLCBlbGVtZW50Ll9vd25lcik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWY7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Um9vdEluZGV4SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gX2NyZWF0ZVJlYWN0Um9vdEluZGV4XG4gICAqL1xuICBpbmplY3RDcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24gKF9jcmVhdGVSZWFjdFJvb3RJbmRleCkge1xuICAgIFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4ID0gX2NyZWF0ZVJlYWN0Um9vdEluZGV4O1xuICB9XG59O1xuXG52YXIgUmVhY3RSb290SW5kZXggPSB7XG4gIGNyZWF0ZVJlYWN0Um9vdEluZGV4OiBudWxsLFxuICBpbmplY3Rpb246IFJlYWN0Um9vdEluZGV4SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Um9vdEluZGV4OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3lcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5ID0ge1xuICBpc0JhdGNoaW5nVXBkYXRlczogZmFsc2UsXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBoZXJlLiBEdXJpbmcgdGhlIHNlcnZlciByZW5kZXJpbmcgd2UgZG9uJ3Qgd2FudCB0b1xuICAgIC8vIHNjaGVkdWxlIGFueSB1cGRhdGVzLiBXZSB3aWxsIHNpbXBseSBpZ25vcmUgdGhlbS5cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3k7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFNlcnZlclJlbmRlcmluZ1xuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZSgnLi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5Jyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlSGFuZGxlcyA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZUhhbmRsZXMnKTtcbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0gcmVxdWlyZSgnLi9SZWFjdE1hcmt1cENoZWNrc3VtJyk7XG52YXIgUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5ID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIEhUTUwgbWFya3VwXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nKGVsZW1lbnQpIHtcbiAgIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW5kZXJUb1N0cmluZygpOiBZb3UgbXVzdCBwYXNzIGEgdmFsaWQgUmVhY3RFbGVtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgdHJhbnNhY3Rpb247XG4gIHRyeSB7XG4gICAgUmVhY3RVcGRhdGVzLmluamVjdGlvbi5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneSk7XG5cbiAgICB2YXIgaWQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIHRyYW5zYWN0aW9uID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5nZXRQb29sZWQoZmFsc2UpO1xuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChlbGVtZW50LCBudWxsKTtcbiAgICAgIHZhciBtYXJrdXAgPSBjb21wb25lbnRJbnN0YW5jZS5tb3VudENvbXBvbmVudChpZCwgdHJhbnNhY3Rpb24sIGVtcHR5T2JqZWN0KTtcbiAgICAgIHJldHVybiBSZWFjdE1hcmt1cENoZWNrc3VtLmFkZENoZWNrc3VtVG9NYXJrdXAobWFya3VwKTtcbiAgICB9LCBudWxsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICAgIC8vIFJldmVydCB0byB0aGUgRE9NIGJhdGNoaW5nIHN0cmF0ZWd5IHNpbmNlIHRoZXNlIHR3byByZW5kZXJlcnNcbiAgICAvLyBjdXJyZW50bHkgc2hhcmUgdGhlc2Ugc3RhdGVmdWwgbW9kdWxlcy5cbiAgICBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgSFRNTCBtYXJrdXAsIHdpdGhvdXQgdGhlIGV4dHJhIFJlYWN0IElEIGFuZCBjaGVja3N1bVxuICogKGZvciBnZW5lcmF0aW5nIHN0YXRpYyBwYWdlcylcbiAqL1xuZnVuY3Rpb24gcmVuZGVyVG9TdGF0aWNNYXJrdXAoZWxlbWVudCkge1xuICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclRvU3RhdGljTWFya3VwKCk6IFlvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdEVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciB0cmFuc2FjdGlvbjtcbiAgdHJ5IHtcbiAgICBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICAgIHZhciBpZCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgdHJhbnNhY3Rpb24gPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmdldFBvb2xlZCh0cnVlKTtcblxuICAgIHJldHVybiB0cmFuc2FjdGlvbi5wZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoZWxlbWVudCwgbnVsbCk7XG4gICAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2UubW91bnRDb21wb25lbnQoaWQsIHRyYW5zYWN0aW9uLCBlbXB0eU9iamVjdCk7XG4gICAgfSwgbnVsbCk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICAvLyBSZXZlcnQgdG8gdGhlIERPTSBiYXRjaGluZyBzdHJhdGVneSBzaW5jZSB0aGVzZSB0d28gcmVuZGVyZXJzXG4gICAgLy8gY3VycmVudGx5IHNoYXJlIHRoZXNlIHN0YXRlZnVsIG1vZHVsZXMuXG4gICAgUmVhY3RVcGRhdGVzLmluamVjdGlvbi5pbmplY3RCYXRjaGluZ1N0cmF0ZWd5KFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICByZW5kZXJUb1N0cmluZzogcmVuZGVyVG9TdHJpbmcsXG4gIHJlbmRlclRvU3RhdGljTWFya3VwOiByZW5kZXJUb1N0YXRpY01hcmt1cFxufTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgYENhbGxiYWNrUXVldWVgIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBvbkRPTVJlYWR5YCBjYWxsYmFja3NcbiAqIGR1cmluZyB0aGUgcGVyZm9ybWluZyBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBPTl9ET01fUkVBRFlfUVVFVUVJTkcgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgYG9uRE9NUmVhZHlgIHF1ZXVlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJlc2V0KCk7XG4gIH0sXG5cbiAgY2xvc2U6IGVtcHR5RnVuY3Rpb25cbn07XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtPTl9ET01fUkVBRFlfUVVFVUVJTkddO1xuXG4vKipcbiAqIEBjbGFzcyBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlclRvU3RhdGljTWFya3VwXG4gKi9cbmZ1bmN0aW9uIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ocmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9IGZhbHNlO1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXl9IEVtcHR5IGxpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG4gIH1cbn07XG5cbmFzc2lnbihSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFVwZGF0ZVF1ZXVlXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSkge1xuICBSZWFjdFVwZGF0ZXMuZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gT25seSB3YXJuIHdoZW4gd2UgaGF2ZSBhIGNhbGxlck5hbWUuIE90aGVyd2lzZSB3ZSBzaG91bGQgYmUgc2lsZW50LlxuICAgICAgLy8gV2UncmUgcHJvYmFibHkgY2FsbGluZyBmcm9tIGVucXVldWVDYWxsYmFjay4gV2UgZG9uJ3Qgd2FudCB0byB3YXJuXG4gICAgICAvLyB0aGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgd2FybmVkIGZvciB0aGUgY29ycmVzcG9uZGluZyBsaWZlY3ljbGUgbWV0aG9kLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNhbGxlck5hbWUsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IuZGlzcGxheU5hbWUpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnJXMoLi4uKTogQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAnICsgJyhzdWNoIGFzIHdpdGhpbiBgcmVuZGVyYCkuIFJlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gJyArICdvZiBwcm9wcyBhbmQgc3RhdGUuJywgY2FsbGVyTmFtZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBSZWFjdFVwZGF0ZVF1ZXVlIGFsbG93cyBmb3Igc3RhdGUgdXBkYXRlcyB0byBiZSBzY2hlZHVsZWQgaW50byBhIGxhdGVyXG4gKiByZWNvbmNpbGlhdGlvbiBzdGVwLlxuICovXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICAvLyBEdXJpbmcgY29tcG9uZW50V2lsbE1vdW50IGFuZCByZW5kZXIgdGhpcyB3aWxsIHN0aWxsIGJlIG51bGwgYnV0IGFmdGVyXG4gICAgICAvLyB0aGF0IHdpbGwgYWx3YXlzIHJlbmRlciB0byBzb21ldGhpbmcuIEF0IGxlYXN0IGZvciBub3cuIFNvIHdlIGNhbiB1c2VcbiAgICAgIC8vIHRoaXMgaGFjay5cbiAgICAgIHJldHVybiAhIWludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZW5xdWV1ZUNhbGxiYWNrKC4uLik6IFlvdSBjYWxsZWQgYHNldFByb3BzYCwgYHJlcGxhY2VQcm9wc2AsICcgKyAnYHNldFN0YXRlYCwgYHJlcGxhY2VTdGF0ZWAsIG9yIGBmb3JjZVVwZGF0ZWAgd2l0aCBhIGNhbGxiYWNrIHRoYXQgJyArICdpc25cXCd0IGNhbGxhYmxlLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG5cbiAgICAvLyBQcmV2aW91c2x5IHdlIHdvdWxkIHRocm93IGFuIGVycm9yIGlmIHdlIGRpZG4ndCBoYXZlIGFuIGludGVybmFsXG4gICAgLy8gaW5zdGFuY2UuIFNpbmNlIHdlIHdhbnQgdG8gbWFrZSBpdCBhIG5vLW9wIGluc3RlYWQsIHdlIG1pcnJvciB0aGUgc2FtZVxuICAgIC8vIGJlaGF2aW9yIHdlIGhhdmUgaW4gb3RoZXIgZW5xdWV1ZSogbWV0aG9kcy5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gaWdub3JlIGNhbGxiYWNrcyBpbiBjb21wb25lbnRXaWxsTW91bnQuIFNlZVxuICAgIC8vIGVucXVldWVVcGRhdGVzLlxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBUaGUgY2FsbGJhY2sgaGVyZSBpcyBpZ25vcmVkIHdoZW4gc2V0U3RhdGUgaXMgY2FsbGVkIGZyb21cbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQuIEVpdGhlciBmaXggaXQgb3IgZGlzYWxsb3cgZG9pbmcgc28gY29tcGxldGVseSBpblxuICAgIC8vIGZhdm9yIG9mIGdldEluaXRpYWxTdGF0ZS4gQWx0ZXJuYXRpdmVseSwgd2UgY2FuIGRpc2FsbG93XG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGR1cmluZyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICBlbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2VucXVldWVDYWxsYmFjayguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2AsIGByZXBsYWNlUHJvcHNgLCAnICsgJ2BzZXRTdGF0ZWAsIGByZXBsYWNlU3RhdGVgLCBvciBgZm9yY2VVcGRhdGVgIHdpdGggYSBjYWxsYmFjayB0aGF0ICcgKyAnaXNuXFwndCBjYWxsYWJsZS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgPSBbY29tcGxldGVTdGF0ZV07XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IHRydWU7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBxdWV1ZSA9IGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlIHx8IChpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtdKTtcbiAgICBxdWV1ZS5wdXNoKHBhcnRpYWxTdGF0ZSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsUHJvcHMgU3Vic2V0IG9mIHRoZSBuZXh0IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRQcm9wczogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsUHJvcHMpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3NldFByb3BzJyk7XG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVNldFByb3BzSW50ZXJuYWwoaW50ZXJuYWxJbnN0YW5jZSwgcGFydGlhbFByb3BzKTtcbiAgfSxcblxuICBlbnF1ZXVlU2V0UHJvcHNJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHBhcnRpYWxQcm9wcykge1xuICAgIHZhciB0b3BMZXZlbFdyYXBwZXIgPSBpbnRlcm5hbEluc3RhbmNlLl90b3BMZXZlbFdyYXBwZXI7XG4gICAgIXRvcExldmVsV3JhcHBlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRQcm9wcyguLi4pOiBZb3UgY2FsbGVkIGBzZXRQcm9wc2Agb24gYSAnICsgJ2NvbXBvbmVudCB3aXRoIGEgcGFyZW50LiBUaGlzIGlzIGFuIGFudGktcGF0dGVybiBzaW5jZSBwcm9wcyB3aWxsICcgKyAnZ2V0IHJlYWN0aXZlbHkgdXBkYXRlZCB3aGVuIHJlbmRlcmVkLiBJbnN0ZWFkLCBjaGFuZ2UgdGhlIG93bmVyXFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCB0byBwYXNzIHRoZSBjb3JyZWN0IHZhbHVlIGFzIHByb3BzIHRvIHRoZSBjb21wb25lbnQgJyArICd3aGVyZSBpdCBpcyBjcmVhdGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIE1lcmdlIHdpdGggdGhlIHBlbmRpbmcgZWxlbWVudCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB3aXRoIGV4aXN0aW5nXG4gICAgLy8gZWxlbWVudCBwcm9wcy5cbiAgICB2YXIgd3JhcEVsZW1lbnQgPSB0b3BMZXZlbFdyYXBwZXIuX3BlbmRpbmdFbGVtZW50IHx8IHRvcExldmVsV3JhcHBlci5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIGVsZW1lbnQgPSB3cmFwRWxlbWVudC5wcm9wcztcbiAgICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGVsZW1lbnQucHJvcHMsIHBhcnRpYWxQcm9wcyk7XG4gICAgdG9wTGV2ZWxXcmFwcGVyLl9wZW5kaW5nRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyh3cmFwRWxlbWVudCwgUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKGVsZW1lbnQsIHByb3BzKSk7XG5cbiAgICBlbnF1ZXVlVXBkYXRlKHRvcExldmVsV3JhcHBlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgTmV3IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlUHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcHJvcHMpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VQcm9wcycpO1xuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlUHJvcHNJbnRlcm5hbChpbnRlcm5hbEluc3RhbmNlLCBwcm9wcyk7XG4gIH0sXG5cbiAgZW5xdWV1ZVJlcGxhY2VQcm9wc0ludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgcHJvcHMpIHtcbiAgICB2YXIgdG9wTGV2ZWxXcmFwcGVyID0gaW50ZXJuYWxJbnN0YW5jZS5fdG9wTGV2ZWxXcmFwcGVyO1xuICAgICF0b3BMZXZlbFdyYXBwZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVwbGFjZVByb3BzKC4uLik6IFlvdSBjYWxsZWQgYHJlcGxhY2VQcm9wc2Agb24gYSAnICsgJ2NvbXBvbmVudCB3aXRoIGEgcGFyZW50LiBUaGlzIGlzIGFuIGFudGktcGF0dGVybiBzaW5jZSBwcm9wcyB3aWxsICcgKyAnZ2V0IHJlYWN0aXZlbHkgdXBkYXRlZCB3aGVuIHJlbmRlcmVkLiBJbnN0ZWFkLCBjaGFuZ2UgdGhlIG93bmVyXFwncyAnICsgJ2ByZW5kZXJgIG1ldGhvZCB0byBwYXNzIHRoZSBjb3JyZWN0IHZhbHVlIGFzIHByb3BzIHRvIHRoZSBjb21wb25lbnQgJyArICd3aGVyZSBpdCBpcyBjcmVhdGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIE1lcmdlIHdpdGggdGhlIHBlbmRpbmcgZWxlbWVudCBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB3aXRoIGV4aXN0aW5nXG4gICAgLy8gZWxlbWVudCBwcm9wcy5cbiAgICB2YXIgd3JhcEVsZW1lbnQgPSB0b3BMZXZlbFdyYXBwZXIuX3BlbmRpbmdFbGVtZW50IHx8IHRvcExldmVsV3JhcHBlci5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIGVsZW1lbnQgPSB3cmFwRWxlbWVudC5wcm9wcztcbiAgICB0b3BMZXZlbFdyYXBwZXIuX3BlbmRpbmdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKHdyYXBFbGVtZW50LCBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMoZWxlbWVudCwgcHJvcHMpKTtcblxuICAgIGVucXVldWVVcGRhdGUodG9wTGV2ZWxXcmFwcGVyKTtcbiAgfSxcblxuICBlbnF1ZXVlRWxlbWVudEludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgbmV3RWxlbWVudCkge1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50ID0gbmV3RWxlbWVudDtcbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVRdWV1ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RVcGRhdGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZGlydHlDb21wb25lbnRzID0gW107XG52YXIgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuXG52YXIgYmF0Y2hpbmdTdHJhdGVneSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xuICAhKFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBpbmplY3QgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MgYW5kIGJhdGNoaW5nICcgKyAnc3RyYXRlZ3knKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBORVNURURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgdXBkYXRlcyB3ZXJlIGVucXVldWVkIGJ5IGNvbXBvbmVudERpZFVwZGF0ZSBoYW5kbGVycyBvclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXG4gICAgICAvLyBCLCBCIHdpbGwgdXBkYXRlIGJlZm9yZSB0aGUgY2FsbGJhY2sgQSdzIHVwZGF0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nXG4gICAgICAvLyBzZXRTdGF0ZS5cbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xuICAgICAgZmx1c2hCYXRjaGVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUucmVzZXQoKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcblxuZnVuY3Rpb24gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoIC8qIGZvcmNlSFRNTCAqL2ZhbHNlKTtcbn1cblxuYXNzaWduKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMuY2FsbGJhY2tRdWV1ZSk7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlID0gbnVsbDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICAgIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBudWxsO1xuICB9LFxuXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhKSB7XG4gICAgLy8gRXNzZW50aWFsbHkgY2FsbHMgYHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybShtZXRob2QsIHNjb3BlLCBhKWBcbiAgICAvLyB3aXRoIHRoaXMgdHJhbnNhY3Rpb24ncyB3cmFwcGVycyBhcm91bmQgaXQuXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uLk1peGluLnBlcmZvcm0uY2FsbCh0aGlzLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0sIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24sIG1ldGhvZCwgc2NvcGUsIGEpO1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24pO1xuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKTtcbn1cblxuLyoqXG4gKiBBcnJheSBjb21wYXJhdG9yIGZvciBSZWFjdENvbXBvbmVudHMgYnkgbW91bnQgb3JkZXJpbmcuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzEgZmlyc3QgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMyIHNlY29uZCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm4gdmFsdWUgdXNhYmxlIGJ5IEFycmF5LnByb3RvdHlwZS5zb3J0KCkuXG4gKi9cbmZ1bmN0aW9uIG1vdW50T3JkZXJDb21wYXJhdG9yKGMxLCBjMikge1xuICByZXR1cm4gYzEuX21vdW50T3JkZXIgLSBjMi5fbW91bnRPcmRlcjtcbn1cblxuZnVuY3Rpb24gcnVuQmF0Y2hlZFVwZGF0ZXModHJhbnNhY3Rpb24pIHtcbiAgdmFyIGxlbiA9IHRyYW5zYWN0aW9uLmRpcnR5Q29tcG9uZW50c0xlbmd0aDtcbiAgIShsZW4gPT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGZsdXNoIHRyYW5zYWN0aW9uXFwncyBzdG9yZWQgZGlydHktY29tcG9uZW50cyBsZW5ndGggKCVzKSB0byAnICsgJ21hdGNoIGRpcnR5LWNvbXBvbmVudHMgYXJyYXkgbGVuZ3RoICglcykuJywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgLy8gU2luY2UgcmVjb25jaWxpbmcgYSBjb21wb25lbnQgaGlnaGVyIGluIHRoZSBvd25lciBoaWVyYXJjaHkgdXN1YWxseSAobm90XG4gIC8vIGFsd2F5cyAtLSBzZWUgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkpIHdpbGwgcmVjb25jaWxlIGNoaWxkcmVuLCByZWNvbmNpbGVcbiAgLy8gdGhlbSBiZWZvcmUgdGhlaXIgY2hpbGRyZW4gYnkgc29ydGluZyB0aGUgYXJyYXkuXG4gIGRpcnR5Q29tcG9uZW50cy5zb3J0KG1vdW50T3JkZXJDb21wYXJhdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBwZW5kaW5nIGNoYW5nZXMgYXBwbHksIGl0IHdpbGwgc3RpbGxcbiAgICAvLyBiZSBoZXJlLCBidXQgd2UgYXNzdW1lIHRoYXQgaXQgaGFzIGNsZWFyZWQgaXRzIF9wZW5kaW5nQ2FsbGJhY2tzIGFuZFxuICAgIC8vIHRoYXQgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGlzIGEgbm9vcC5cbiAgICB2YXIgY29tcG9uZW50ID0gZGlydHlDb21wb25lbnRzW2ldO1xuXG4gICAgLy8gSWYgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGhhcHBlbnMgdG8gZW5xdWV1ZSBhbnkgbmV3IHVwZGF0ZXMsIHdlXG4gICAgLy8gc2hvdWxkbid0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgaGFwcGVucywgc29cbiAgICAvLyBzdGFzaCB0aGUgY2FsbGJhY2tzIGZpcnN0XG4gICAgdmFyIGNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcztcbiAgICBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgUmVhY3RSZWNvbmNpbGVyLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeShjb21wb25lbnQsIHRyYW5zYWN0aW9uLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmNhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFja3Nbal0sIGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ncyB3cmFwcGVycyB3aWxsIGNsZWFyIHRoZSBkaXJ0eUNvbXBvbmVudHNcbiAgLy8gYXJyYXkgYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgZW5xdWV1ZWQgYnkgbW91bnQtcmVhZHkgaGFuZGxlcnMgKGkuZS4sXG4gIC8vIGNvbXBvbmVudERpZFVwZGF0ZSkgYnV0IHdlIG5lZWQgdG8gY2hlY2sgaGVyZSB0b28gaW4gb3JkZXIgdG8gY2F0Y2hcbiAgLy8gdXBkYXRlcyBlbnF1ZXVlZCBieSBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIGFzYXAgY2FsbHMuXG4gIHdoaWxlIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoIHx8IGFzYXBFbnF1ZXVlZCkge1xuICAgIGlmIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShydW5CYXRjaGVkVXBkYXRlcywgbnVsbCwgdHJhbnNhY3Rpb24pO1xuICAgICAgUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYXNhcEVucXVldWVkKSB7XG4gICAgICBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBxdWV1ZSA9IGFzYXBDYWxsYmFja1F1ZXVlO1xuICAgICAgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICAgICAgcXVldWUubm90aWZ5QWxsKCk7XG4gICAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UocXVldWUpO1xuICAgIH1cbiAgfVxufTtcbmZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBSZWFjdFBlcmYubWVhc3VyZSgnUmVhY3RVcGRhdGVzJywgJ2ZsdXNoQmF0Y2hlZFVwZGF0ZXMnLCBmbHVzaEJhdGNoZWRVcGRhdGVzKTtcblxuLyoqXG4gKiBNYXJrIGEgY29tcG9uZW50IGFzIG5lZWRpbmcgYSByZXJlbmRlciwgYWRkaW5nIGFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGFcbiAqIGxpc3Qgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb25jZSB0aGUgcmVyZW5kZXIgb2NjdXJzLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGNvbXBvbmVudCkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuXG4gIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoVGhpcyBpcyBjYWxsZWQgYnkgZWFjaCB0b3AtbGV2ZWwgdXBkYXRlXG4gIC8vIGZ1bmN0aW9uLCBsaWtlIHNldFByb3BzLCBzZXRTdGF0ZSwgZm9yY2VVcGRhdGUsIGV0Yy47IGNyZWF0aW9uIGFuZFxuICAvLyBkZXN0cnVjdGlvbiBvZiB0b3AtbGV2ZWwgY29tcG9uZW50cyBpcyBndWFyZGVkIGluIFJlYWN0TW91bnQuKVxuXG4gIGlmICghYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcykge1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoZW5xdWV1ZVVwZGF0ZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXJ0eUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xufVxuXG4vKipcbiAqIEVucXVldWUgYSBjYWxsYmFjayB0byBiZSBydW4gYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBiYXRjaGluZyBjeWNsZS4gVGhyb3dzXG4gKiBpZiBubyB1cGRhdGVzIGFyZSBjdXJyZW50bHkgYmVpbmcgcGVyZm9ybWVkLlxuICovXG5mdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlcy5hc2FwOiBDYW5cXCd0IGVucXVldWUgYW4gYXNhcCBjYWxsYmFjayBpbiBhIGNvbnRleHQgd2hlcmUnICsgJ3VwZGF0ZXMgYXJlIG5vdCBiZWluZyBiYXRjaGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgYXNhcENhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCk7XG4gIGFzYXBFbnF1ZXVlZCA9IHRydWU7XG59XG5cbnZhciBSZWFjdFVwZGF0ZXNJbmplY3Rpb24gPSB7XG4gIGluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoUmVjb25jaWxlVHJhbnNhY3Rpb24pIHtcbiAgICAhUmVjb25jaWxlVHJhbnNhY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWNvbmNpbGVUcmFuc2FjdGlvbjtcbiAgfSxcblxuICBpbmplY3RCYXRjaGluZ1N0cmF0ZWd5OiBmdW5jdGlvbiAoX2JhdGNoaW5nU3RyYXRlZ3kpIHtcbiAgICAhX2JhdGNoaW5nU3RyYXRlZ3kgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGluZyBzdHJhdGVneScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGVkVXBkYXRlcygpIGZ1bmN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID09PSAnYm9vbGVhbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGFuIGlzQmF0Y2hpbmdVcGRhdGVzIGJvb2xlYW4gYXR0cmlidXRlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kgPSBfYmF0Y2hpbmdTdHJhdGVneTtcbiAgfVxufTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHtcbiAgLyoqXG4gICAqIFJlYWN0IHJlZmVyZW5jZXMgYFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25gIHVzaW5nIHRoaXMgcHJvcGVydHkgaW4gb3JkZXJcbiAgICogdG8gYWxsb3cgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogbnVsbCxcblxuICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gIGVucXVldWVVcGRhdGU6IGVucXVldWVVcGRhdGUsXG4gIGZsdXNoQmF0Y2hlZFVwZGF0ZXM6IGZsdXNoQmF0Y2hlZFVwZGF0ZXMsXG4gIGluamVjdGlvbjogUmVhY3RVcGRhdGVzSW5qZWN0aW9uLFxuICBhc2FwOiBhc2FwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RWZXJzaW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICcwLjE0LjcnOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTVkdET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xuXG52YXIgTVVTVF9VU0VfQVRUUklCVVRFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX0FUVFJJQlVURTtcblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICBjbGlwUGF0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGN4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY3k6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZpbGw6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmaWxsT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvbnRGYW1pbHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb250U2l6ZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZ4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZnk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBncmFkaWVudFRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGdyYWRpZW50VW5pdHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJFbmQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJNaWQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJTdGFydDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9mZnNldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcGF0dGVyblVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcG9pbnRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJ5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3ByZWFkTWV0aG9kOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcENvbG9yOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcE9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VEYXNoYXJyYXk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VMaW5lY2FwOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZVdpZHRoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdGV4dEFuY2hvcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHZlcnNpb246IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2aWV3Qm94OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeDE6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4MjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0FjdHVhdGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0FyY3JvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0hyZWY6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1JvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1Nob3c6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1RpdGxlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtUeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeG1sQmFzZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhtbExhbmc6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bWxTcGFjZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHkxOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeTI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB5OiBNVVNUX1VTRV9BVFRSSUJVVEVcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGNsaXBQYXRoOiAnY2xpcC1wYXRoJyxcbiAgICBmaWxsT3BhY2l0eTogJ2ZpbGwtb3BhY2l0eScsXG4gICAgZm9udEZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcbiAgICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXG4gICAgZ3JhZGllbnRUcmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gICAgZ3JhZGllbnRVbml0czogJ2dyYWRpZW50VW5pdHMnLFxuICAgIG1hcmtlckVuZDogJ21hcmtlci1lbmQnLFxuICAgIG1hcmtlck1pZDogJ21hcmtlci1taWQnLFxuICAgIG1hcmtlclN0YXJ0OiAnbWFya2VyLXN0YXJ0JyxcbiAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gICAgcGF0dGVyblVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gICAgc3ByZWFkTWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgICBzdG9wQ29sb3I6ICdzdG9wLWNvbG9yJyxcbiAgICBzdG9wT3BhY2l0eTogJ3N0b3Atb3BhY2l0eScsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiAnc3Ryb2tlLWRhc2hhcnJheScsXG4gICAgc3Ryb2tlTGluZWNhcDogJ3N0cm9rZS1saW5lY2FwJyxcbiAgICBzdHJva2VPcGFjaXR5OiAnc3Ryb2tlLW9wYWNpdHknLFxuICAgIHN0cm9rZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgICB0ZXh0QW5jaG9yOiAndGV4dC1hbmNob3InLFxuICAgIHZpZXdCb3g6ICd2aWV3Qm94JyxcbiAgICB4bGlua0FjdHVhdGU6ICd4bGluazphY3R1YXRlJyxcbiAgICB4bGlua0FyY3JvbGU6ICd4bGluazphcmNyb2xlJyxcbiAgICB4bGlua0hyZWY6ICd4bGluazpocmVmJyxcbiAgICB4bGlua1JvbGU6ICd4bGluazpyb2xlJyxcbiAgICB4bGlua1Nob3c6ICd4bGluazpzaG93JyxcbiAgICB4bGlua1RpdGxlOiAneGxpbms6dGl0bGUnLFxuICAgIHhsaW5rVHlwZTogJ3hsaW5rOnR5cGUnLFxuICAgIHhtbEJhc2U6ICd4bWw6YmFzZScsXG4gICAgeG1sTGFuZzogJ3htbDpsYW5nJyxcbiAgICB4bWxTcGFjZTogJ3htbDpzcGFjZSdcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2VsZWN0RXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlbGVjdDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2VsZWN0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51LCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLy8gVHJhY2sgd2hldGhlciBhIGxpc3RlbmVyIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4vLyBub3QgZXh0cmFjdCBldmVudHMuXG52YXIgaGFzTGlzdGVuZXIgPSBmYWxzZTtcbnZhciBPTl9TRUxFQ1RfS0VZID0ga2V5T2YoeyBvblNlbGVjdDogbnVsbCB9KTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHJhbmdlLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgbGVmdDogcmFuZ2UuYm91bmRpbmdMZWZ0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLnNlbGVjdCwgYWN0aXZlRWxlbWVudElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICghaGFzTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BGb2N1czpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0b3BMZXZlbFRhcmdldCkgfHwgdG9wTGV2ZWxUYXJnZXQuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudElEID0gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9TRUxFQ1RfS0VZKSB7XG4gICAgICBoYXNMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEV2ZW50UGx1Z2luOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTZXJ2ZXJSZWFjdFJvb3RJbmRleFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2l6ZSBvZiB0aGUgcmVhY3RSb290IElEIHNwYWNlLiBXZSBnZW5lcmF0ZSByYW5kb20gbnVtYmVycyBmb3IgUmVhY3Qgcm9vdFxuICogSURzIGFuZCBpZiB0aGVyZSdzIGEgY29sbGlzaW9uIHRoZSBldmVudHMgYW5kIERPTSB1cGRhdGUgc3lzdGVtIHdpbGxcbiAqIGdldCBjb25mdXNlZC4gSW4gdGhlIGZ1dHVyZSB3ZSBuZWVkIGEgd2F5IHRvIGdlbmVyYXRlIEdVSURzIGJ1dCBmb3JcbiAqIG5vdyB0aGlzIHdpbGwgd29yayBvbiBhIHNtYWxsZXIgc2NhbGUuXG4gKi9cbnZhciBHTE9CQUxfTU9VTlRfUE9JTlRfTUFYID0gTWF0aC5wb3coMiwgNTMpO1xuXG52YXIgU2VydmVyUmVhY3RSb290SW5kZXggPSB7XG4gIGNyZWF0ZVJlYWN0Um9vdEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChNYXRoLnJhbmRvbSgpICogR0xPQkFMX01PVU5UX1BPSU5UX01BWCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VydmVyUmVhY3RSb290SW5kZXg7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNpbXBsZUV2ZW50UGx1Z2luXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0ZvY3VzRXZlbnQnKTtcbnZhciBTeW50aGV0aWNLZXlib2FyZEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNLZXlib2FyZEV2ZW50Jyk7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xudmFyIFN5bnRoZXRpY0RyYWdFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRHJhZ0V2ZW50Jyk7XG52YXIgU3ludGhldGljVG91Y2hFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVG91Y2hFdmVudCcpO1xudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBTeW50aGV0aWNXaGVlbEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNXaGVlbEV2ZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGFib3J0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25BYm9ydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQWJvcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBibHVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25CbHVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25CbHVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2FuUGxheToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2FuUGxheTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2FuUGxheUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNhblBsYXlUaHJvdWdoOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DYW5QbGF5VGhyb3VnaDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ2FuUGxheVRocm91Z2hDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjbGljazoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2xpY2s6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNsaWNrQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY29udGV4dE1lbnU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvbnRleHRNZW51OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db250ZXh0TWVudUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNvcHk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNvcHk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvcHlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkN1dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ3V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZG91YmxlQ2xpY2s6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRvdWJsZUNsaWNrOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Eb3VibGVDbGlja0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnRW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0VudGVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnRW50ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFbnRlckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFeGl0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnRXhpdDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0V4aXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnTGVhdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdMZWF2ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0xlYXZlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ092ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdPdmVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnT3ZlckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ1N0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcm9wOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ecm9wOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ecm9wQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHVyYXRpb25DaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkR1cmF0aW9uQ2hhbmdlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EdXJhdGlvbkNoYW5nZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVtcHRpZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVtcHRpZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVtcHRpZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbmNyeXB0ZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVuY3J5cHRlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW5jcnlwdGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW5kZWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkVuZGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbmRlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVycm9yOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FcnJvcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRXJyb3JDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBmb2N1czoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRm9jdXM6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkZvY3VzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgaW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbklucHV0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25JbnB1dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleURvd25DYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlQcmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uS2V5UHJlc3M6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbktleVByZXNzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5VXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleVVwOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkxvYWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkZWREYXRhOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkZWREYXRhOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkZWREYXRhQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZGVkTWV0YWRhdGE6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRlZE1ldGFkYXRhOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkZWRNZXRhZGF0YUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZFN0YXJ0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICAvLyBOb3RlOiBXZSBkbyBub3QgYWxsb3cgbGlzdGVuaW5nIHRvIG1vdXNlT3ZlciBldmVudHMuIEluc3RlYWQsIHVzZSB0aGVcbiAgLy8gb25Nb3VzZUVudGVyL29uTW91c2VMZWF2ZSBjcmVhdGVkIGJ5IGBFbnRlckxlYXZlRXZlbnRQbHVnaW5gLlxuICBtb3VzZURvd246IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlRG93bjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VEb3duQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VNb3ZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlT3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU91dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU92ZXI6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VPdmVyQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VVcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VVcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTW91c2VVcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBhc3RlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QYXN0ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGFzdGVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwYXVzZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGF1c2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBhdXNlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGxheToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGxheTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUGxheUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBsYXlpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBsYXlpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBsYXlpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwcm9ncmVzczoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUHJvZ3Jlc3M6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblByb2dyZXNzQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcmF0ZUNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUmF0ZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUmF0ZUNoYW5nZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHJlc2V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25SZXNldDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uUmVzZXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzY3JvbGw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNjcm9sbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2Nyb2xsQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Vla2VkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWVrZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlZWtlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNlZWtpbmc6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlZWtpbmc6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNlZWtpbmdDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdGFsbGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdGFsbGVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdGFsbGVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3VibWl0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdWJtaXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN1Ym1pdENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN1c3BlbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblN1c3BlbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblN1c3BlbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0aW1lVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25UaW1lVXBkYXRlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25UaW1lVXBkYXRlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hDYW5jZWw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoQ2FuY2VsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Ub3VjaENhbmNlbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaEVuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hFbmRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaE1vdmU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoTW92ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hNb3ZlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hTdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hTdGFydENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHZvbHVtZUNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVm9sdW1lQ2hhbmdlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Wb2x1bWVDaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB3YWl0aW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XYWl0aW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25XYWl0aW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2hlZWw6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbldoZWVsOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25XaGVlbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7XG4gIHRvcEFib3J0OiBldmVudFR5cGVzLmFib3J0LFxuICB0b3BCbHVyOiBldmVudFR5cGVzLmJsdXIsXG4gIHRvcENhblBsYXk6IGV2ZW50VHlwZXMuY2FuUGxheSxcbiAgdG9wQ2FuUGxheVRocm91Z2g6IGV2ZW50VHlwZXMuY2FuUGxheVRocm91Z2gsXG4gIHRvcENsaWNrOiBldmVudFR5cGVzLmNsaWNrLFxuICB0b3BDb250ZXh0TWVudTogZXZlbnRUeXBlcy5jb250ZXh0TWVudSxcbiAgdG9wQ29weTogZXZlbnRUeXBlcy5jb3B5LFxuICB0b3BDdXQ6IGV2ZW50VHlwZXMuY3V0LFxuICB0b3BEb3VibGVDbGljazogZXZlbnRUeXBlcy5kb3VibGVDbGljayxcbiAgdG9wRHJhZzogZXZlbnRUeXBlcy5kcmFnLFxuICB0b3BEcmFnRW5kOiBldmVudFR5cGVzLmRyYWdFbmQsXG4gIHRvcERyYWdFbnRlcjogZXZlbnRUeXBlcy5kcmFnRW50ZXIsXG4gIHRvcERyYWdFeGl0OiBldmVudFR5cGVzLmRyYWdFeGl0LFxuICB0b3BEcmFnTGVhdmU6IGV2ZW50VHlwZXMuZHJhZ0xlYXZlLFxuICB0b3BEcmFnT3ZlcjogZXZlbnRUeXBlcy5kcmFnT3ZlcixcbiAgdG9wRHJhZ1N0YXJ0OiBldmVudFR5cGVzLmRyYWdTdGFydCxcbiAgdG9wRHJvcDogZXZlbnRUeXBlcy5kcm9wLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogZXZlbnRUeXBlcy5kdXJhdGlvbkNoYW5nZSxcbiAgdG9wRW1wdGllZDogZXZlbnRUeXBlcy5lbXB0aWVkLFxuICB0b3BFbmNyeXB0ZWQ6IGV2ZW50VHlwZXMuZW5jcnlwdGVkLFxuICB0b3BFbmRlZDogZXZlbnRUeXBlcy5lbmRlZCxcbiAgdG9wRXJyb3I6IGV2ZW50VHlwZXMuZXJyb3IsXG4gIHRvcEZvY3VzOiBldmVudFR5cGVzLmZvY3VzLFxuICB0b3BJbnB1dDogZXZlbnRUeXBlcy5pbnB1dCxcbiAgdG9wS2V5RG93bjogZXZlbnRUeXBlcy5rZXlEb3duLFxuICB0b3BLZXlQcmVzczogZXZlbnRUeXBlcy5rZXlQcmVzcyxcbiAgdG9wS2V5VXA6IGV2ZW50VHlwZXMua2V5VXAsXG4gIHRvcExvYWQ6IGV2ZW50VHlwZXMubG9hZCxcbiAgdG9wTG9hZGVkRGF0YTogZXZlbnRUeXBlcy5sb2FkZWREYXRhLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogZXZlbnRUeXBlcy5sb2FkZWRNZXRhZGF0YSxcbiAgdG9wTG9hZFN0YXJ0OiBldmVudFR5cGVzLmxvYWRTdGFydCxcbiAgdG9wTW91c2VEb3duOiBldmVudFR5cGVzLm1vdXNlRG93bixcbiAgdG9wTW91c2VNb3ZlOiBldmVudFR5cGVzLm1vdXNlTW92ZSxcbiAgdG9wTW91c2VPdXQ6IGV2ZW50VHlwZXMubW91c2VPdXQsXG4gIHRvcE1vdXNlT3ZlcjogZXZlbnRUeXBlcy5tb3VzZU92ZXIsXG4gIHRvcE1vdXNlVXA6IGV2ZW50VHlwZXMubW91c2VVcCxcbiAgdG9wUGFzdGU6IGV2ZW50VHlwZXMucGFzdGUsXG4gIHRvcFBhdXNlOiBldmVudFR5cGVzLnBhdXNlLFxuICB0b3BQbGF5OiBldmVudFR5cGVzLnBsYXksXG4gIHRvcFBsYXlpbmc6IGV2ZW50VHlwZXMucGxheWluZyxcbiAgdG9wUHJvZ3Jlc3M6IGV2ZW50VHlwZXMucHJvZ3Jlc3MsXG4gIHRvcFJhdGVDaGFuZ2U6IGV2ZW50VHlwZXMucmF0ZUNoYW5nZSxcbiAgdG9wUmVzZXQ6IGV2ZW50VHlwZXMucmVzZXQsXG4gIHRvcFNjcm9sbDogZXZlbnRUeXBlcy5zY3JvbGwsXG4gIHRvcFNlZWtlZDogZXZlbnRUeXBlcy5zZWVrZWQsXG4gIHRvcFNlZWtpbmc6IGV2ZW50VHlwZXMuc2Vla2luZyxcbiAgdG9wU3RhbGxlZDogZXZlbnRUeXBlcy5zdGFsbGVkLFxuICB0b3BTdWJtaXQ6IGV2ZW50VHlwZXMuc3VibWl0LFxuICB0b3BTdXNwZW5kOiBldmVudFR5cGVzLnN1c3BlbmQsXG4gIHRvcFRpbWVVcGRhdGU6IGV2ZW50VHlwZXMudGltZVVwZGF0ZSxcbiAgdG9wVG91Y2hDYW5jZWw6IGV2ZW50VHlwZXMudG91Y2hDYW5jZWwsXG4gIHRvcFRvdWNoRW5kOiBldmVudFR5cGVzLnRvdWNoRW5kLFxuICB0b3BUb3VjaE1vdmU6IGV2ZW50VHlwZXMudG91Y2hNb3ZlLFxuICB0b3BUb3VjaFN0YXJ0OiBldmVudFR5cGVzLnRvdWNoU3RhcnQsXG4gIHRvcFZvbHVtZUNoYW5nZTogZXZlbnRUeXBlcy52b2x1bWVDaGFuZ2UsXG4gIHRvcFdhaXRpbmc6IGV2ZW50VHlwZXMud2FpdGluZyxcbiAgdG9wV2hlZWw6IGV2ZW50VHlwZXMud2hlZWxcbn07XG5cbmZvciAodmFyIHR5cGUgaW4gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnKSB7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0eXBlXS5kZXBlbmRlbmNpZXMgPSBbdHlwZV07XG59XG5cbnZhciBPTl9DTElDS19LRVkgPSBrZXlPZih7IG9uQ2xpY2s6IG51bGwgfSk7XG52YXIgb25DbGlja0xpc3RlbmVycyA9IHt9O1xuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQWJvcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2FuUGxheTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDYW5QbGF5VGhyb3VnaDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEdXJhdGlvbkNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbXB0aWVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEVuY3J5cHRlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbmRlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFcnJvcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BJbnB1dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRlZERhdGE6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZGVkTWV0YWRhdGE6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZFN0YXJ0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhdXNlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBsYXk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGxheWluZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQcm9ncmVzczpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BSYXRlQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFJlc2V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNlZWtlZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWVraW5nOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN0YWxsZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU3VibWl0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1c3BlbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVGltZVVwZGF0ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BWb2x1bWVDaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wV2FpdGluZzpcbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3M6XG4gICAgICAgIC8vIEZpcmVGb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRm9jdXM6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDbGljazpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRG91YmxlQ2xpY2s6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlTW92ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnRW50ZXI6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0V4aXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0xlYXZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcm9wOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaENhbmNlbDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaEVuZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdoZWVsOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljV2hlZWxFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29weTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUGFzdGU6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgICFFdmVudENvbnN0cnVjdG9yID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4nLCB0b3BMZXZlbFR5cGUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIC8vIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uXG4gICAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAgIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgICAvLyBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09IE9OX0NMSUNLX0tFWSkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgICAgaWYgKCFvbkNsaWNrTGlzdGVuZXJzW2lkXSkge1xuICAgICAgICBvbkNsaWNrTGlzdGVuZXJzW2lkXSA9IEV2ZW50TGlzdGVuZXIubGlzdGVuKG5vZGUsICdjbGljaycsIGVtcHR5RnVuY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB3aWxsRGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9DTElDS19LRVkpIHtcbiAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNbaWRdLnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIG9uQ2xpY2tMaXN0ZW5lcnNbaWRdO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUV2ZW50UGx1Z2luOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ29tcG9zaXRpb25FdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ29tcG9zaXRpb25FdmVudCwgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRHJhZ0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNEcmFnRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5kaXNwYXRjaE1hcmtlciA9IGRpc3BhdGNoTWFya2VyO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG59XG5cbmFzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZXZlbnQsICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGNhbGxpbmcgYHByZXZlbnREZWZhdWx0YCBvbiBhICcgKyAncmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gVGhpcyBpcyBhIG5vLW9wLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZXZlbnQsICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGNhbGxpbmcgYHN0b3BQcm9wYWdhdGlvbmAgb24gYSAnICsgJ3JlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuIFRoaXMgaXMgYSBuby1vcC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmRpc3BhdGNoTWFya2VyID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgfVxuXG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBhc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuXG4gIFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDbGFzcywgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcbn07XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCwgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljRm9jdXNFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRm9jdXNFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljSW5wdXRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbnZhciBJbnB1dEV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljSW5wdXRFdmVudCwgSW5wdXRFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljSW5wdXRFdmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljS2V5Ym9hcmRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgZ2V0RXZlbnRLZXkgPSByZXF1aXJlKCcuL2dldEV2ZW50S2V5Jyk7XG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY01vdXNlRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gV2Via2l0LCBGaXJlZm94LCBJRTkrXG4gICAgLy8gd2hpY2g6ICAxIDIgM1xuICAgIC8vIGJ1dHRvbjogMCAxIDIgKHN0YW5kYXJkKVxuICAgIHZhciBidXR0b24gPSBldmVudC5idXR0b247XG4gICAgaWYgKCd3aGljaCcgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBidXR0b247XG4gICAgfVxuICAgIC8vIElFPDlcbiAgICAvLyB3aGljaDogIHVuZGVmaW5lZFxuICAgIC8vIGJ1dHRvbjogMCAwIDBcbiAgICAvLyBidXR0b246IDEgNCAyIChvbm1vdXNldXApXG4gICAgcmV0dXJuIGJ1dHRvbiA9PT0gMiA/IDIgOiBidXR0b24gPT09IDQgPyAxIDogMDtcbiAgfSxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9LFxuICAvLyBcIlByb3ByaWV0YXJ5XCIgSW50ZXJmYWNlLlxuICBwYWdlWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWCcgaW4gZXZlbnQgPyBldmVudC5wYWdlWCA6IGV2ZW50LmNsaWVudFggKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQ7XG4gIH0sXG4gIHBhZ2VZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VZJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VZIDogZXZlbnQuY2xpZW50WSArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1RvdWNoRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljVUlFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljVUlFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IHtcbiAgdG91Y2hlczogbnVsbCxcbiAgdGFyZ2V0VG91Y2hlczogbnVsbCxcbiAgY2hhbmdlZFRvdWNoZXM6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVG91Y2hFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUb3VjaEV2ZW50LCBUb3VjaEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUb3VjaEV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNVSUV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBVSUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHZpZXc6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC52aWV3KSB7XG4gICAgICByZXR1cm4gZXZlbnQudmlldztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQud2luZG93ID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIHRhcmdldCBpcyBhIHdpbmRvdyBvYmplY3RcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICBpZiAoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICB9LFxuICBkZXRhaWw6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5kZXRhaWwgfHwgMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNVSUV2ZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNXaGVlbEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFRyYW5zYWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogYFRyYW5zYWN0aW9uYCBjcmVhdGVzIGEgYmxhY2sgYm94IHRoYXQgaXMgYWJsZSB0byB3cmFwIGFueSBtZXRob2Qgc3VjaCB0aGF0XG4gKiBjZXJ0YWluIGludmFyaWFudHMgYXJlIG1haW50YWluZWQgYmVmb3JlIGFuZCBhZnRlciB0aGUgbWV0aG9kIGlzIGludm9rZWRcbiAqIChFdmVuIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gd2hpbGUgaW52b2tpbmcgdGhlIHdyYXBwZWQgbWV0aG9kKS4gV2hvZXZlclxuICogaW5zdGFudGlhdGVzIGEgdHJhbnNhY3Rpb24gY2FuIHByb3ZpZGUgZW5mb3JjZXJzIG9mIHRoZSBpbnZhcmlhbnRzIGF0XG4gKiBjcmVhdGlvbiB0aW1lLiBUaGUgYFRyYW5zYWN0aW9uYCBjbGFzcyBpdHNlbGYgd2lsbCBzdXBwbHkgb25lIGFkZGl0aW9uYWxcbiAqIGF1dG9tYXRpYyBpbnZhcmlhbnQgZm9yIHlvdSAtIHRoZSBpbnZhcmlhbnQgdGhhdCBhbnkgdHJhbnNhY3Rpb24gaW5zdGFuY2VcbiAqIHNob3VsZCBub3QgYmUgcnVuIHdoaWxlIGl0IGlzIGFscmVhZHkgYmVpbmcgcnVuLiBZb3Ugd291bGQgdHlwaWNhbGx5IGNyZWF0ZSBhXG4gKiBzaW5nbGUgaW5zdGFuY2Ugb2YgYSBgVHJhbnNhY3Rpb25gIGZvciByZXVzZSBtdWx0aXBsZSB0aW1lcywgdGhhdCBwb3RlbnRpYWxseVxuICogaXMgdXNlZCB0byB3cmFwIHNldmVyYWwgZGlmZmVyZW50IG1ldGhvZHMuIFdyYXBwZXJzIGFyZSBleHRyZW1lbHkgc2ltcGxlIC1cbiAqIHRoZXkgb25seSByZXF1aXJlIGltcGxlbWVudGluZyB0d28gbWV0aG9kcy5cbiAqXG4gKiA8cHJlPlxuICogICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXJzIChpbmplY3RlZCBhdCBjcmVhdGlvbiB0aW1lKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgICAgICAgICtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgIHYgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgKy0tLS0tLS0tLS0tLS0tLSsgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICstLXwgICAgd3JhcHBlcjEgICB8LS0tfC0tLS0rICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICArLS0tLS0tLS0tLS0tLS0tKyAgIHYgICAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgICAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICstLS0tfCAgIHdyYXBwZXIyICB8LS0tLS0tLS0rICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHYgICAgIHYgICAgICAgICAgICAgICAgICAgICB2ICAgICB2ICAgfCB3cmFwcGVyXG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfCBpbnZhcmlhbnRzXG4gKiBwZXJmb3JtKGFueU1ldGhvZCkgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfCBtYWludGFpbmVkXG4gKiArLS0tLS0tLS0tLS0tLS0tLS0+fC18LS0tfC18LS0tfC0tPnxhbnlNZXRob2R8LS0tfC0tLXwtfC0tLXwtfC0tLS0tLS0tPlxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICBpbml0aWFsaXplICAgICAgICAgICAgICAgICAgICBjbG9zZSAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICogPC9wcmU+XG4gKlxuICogVXNlIGNhc2VzOlxuICogLSBQcmVzZXJ2aW5nIHRoZSBpbnB1dCBzZWxlY3Rpb24gcmFuZ2VzIGJlZm9yZS9hZnRlciByZWNvbmNpbGlhdGlvbi5cbiAqICAgUmVzdG9yaW5nIHNlbGVjdGlvbiBldmVuIGluIHRoZSBldmVudCBvZiBhbiB1bmV4cGVjdGVkIGVycm9yLlxuICogLSBEZWFjdGl2YXRpbmcgZXZlbnRzIHdoaWxlIHJlYXJyYW5naW5nIHRoZSBET00sIHByZXZlbnRpbmcgYmx1cnMvZm9jdXNlcyxcbiAqICAgd2hpbGUgZ3VhcmFudGVlaW5nIHRoYXQgYWZ0ZXJ3YXJkcywgdGhlIGV2ZW50IHN5c3RlbSBpcyByZWFjdGl2YXRlZC5cbiAqIC0gRmx1c2hpbmcgYSBxdWV1ZSBvZiBjb2xsZWN0ZWQgRE9NIG11dGF0aW9ucyB0byB0aGUgbWFpbiBVSSB0aHJlYWQgYWZ0ZXIgYVxuICogICByZWNvbmNpbGlhdGlvbiB0YWtlcyBwbGFjZSBpbiBhIHdvcmtlciB0aHJlYWQuXG4gKiAtIEludm9raW5nIGFueSBjb2xsZWN0ZWQgYGNvbXBvbmVudERpZFVwZGF0ZWAgY2FsbGJhY2tzIGFmdGVyIHJlbmRlcmluZyBuZXdcbiAqICAgY29udGVudC5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IFdyYXBwaW5nIHBhcnRpY3VsYXIgZmx1c2hlcyBvZiB0aGUgYFJlYWN0V29ya2VyYCBxdWV1ZVxuICogICB0byBwcmVzZXJ2ZSB0aGUgYHNjcm9sbFRvcGAgKGFuIGF1dG9tYXRpYyBzY3JvbGwgYXdhcmUgRE9NKS5cbiAqIC0gKEZ1dHVyZSB1c2UgY2FzZSk6IExheW91dCBjYWxjdWxhdGlvbnMgYmVmb3JlIGFuZCBhZnRlciBET00gdXBkYXRlcy5cbiAqXG4gKiBUcmFuc2FjdGlvbmFsIHBsdWdpbiBBUEk6XG4gKiAtIEEgbW9kdWxlIHRoYXQgaGFzIGFuIGBpbml0aWFsaXplYCBtZXRob2QgdGhhdCByZXR1cm5zIGFueSBwcmVjb21wdXRhdGlvbi5cbiAqIC0gYW5kIGEgYGNsb3NlYCBtZXRob2QgdGhhdCBhY2NlcHRzIHRoZSBwcmVjb21wdXRhdGlvbi4gYGNsb3NlYCBpcyBpbnZva2VkXG4gKiAgIHdoZW4gdGhlIHdyYXBwZWQgcHJvY2VzcyBpcyBjb21wbGV0ZWQsIG9yIGhhcyBmYWlsZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbmFsV3JhcHBlcj59IHRyYW5zYWN0aW9uV3JhcHBlciBXcmFwcGVyIG1vZHVsZXNcbiAqIHRoYXQgaW1wbGVtZW50IGBpbml0aWFsaXplYCBhbmQgYGNsb3NlYC5cbiAqIEByZXR1cm4ge1RyYW5zYWN0aW9ufSBTaW5nbGUgdHJhbnNhY3Rpb24gZm9yIHJldXNlIGluIHRocmVhZC5cbiAqXG4gKiBAY2xhc3MgVHJhbnNhY3Rpb25cbiAqL1xudmFyIE1peGluID0ge1xuICAvKipcbiAgICogU2V0cyB1cCB0aGlzIGluc3RhbmNlIHNvIHRoYXQgaXQgaXMgcHJlcGFyZWQgZm9yIGNvbGxlY3RpbmcgbWV0cmljcy4gRG9lc1xuICAgKiBzbyBzdWNoIHRoYXQgdGhpcyBzZXR1cCBtZXRob2QgbWF5IGJlIHVzZWQgb24gYW4gaW5zdGFuY2UgdGhhdCBpcyBhbHJlYWR5XG4gICAqIGluaXRpYWxpemVkLCBpbiBhIHdheSB0aGF0IGRvZXMgbm90IGNvbnN1bWUgYWRkaXRpb25hbCBtZW1vcnkgdXBvbiByZXVzZS5cbiAgICogVGhhdCBjYW4gYmUgdXNlZnVsIGlmIHlvdSBkZWNpZGUgdG8gbWFrZSB5b3VyIHN1YmNsYXNzIG9mIHRoaXMgbWl4aW4gYVxuICAgKiBcIlBvb2xlZENsYXNzXCIuXG4gICAqL1xuICByZWluaXRpYWxpemVUcmFuc2FjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25XcmFwcGVycygpO1xuICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YSkge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53cmFwcGVySW5pdERhdGEgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gIH0sXG5cbiAgX2lzSW5UcmFuc2FjdGlvbjogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHtBcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+fSBBcnJheSBvZiB0cmFuc2FjdGlvbiB3cmFwcGVycy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IG51bGwsXG5cbiAgaXNJblRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5faXNJblRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgZnVuY3Rpb24gd2l0aGluIGEgc2FmZXR5IHdpbmRvdy4gVXNlIHRoaXMgZm9yIHRoZSB0b3AgbGV2ZWxcbiAgICogbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiBsYXJnZSBhbW91bnRzIG9mIGNvbXB1dGF0aW9uL211dGF0aW9ucyB0aGF0IHdvdWxkXG4gICAqIG5lZWQgdG8gYmUgc2FmZXR5IGNoZWNrZWQuIFRoZSBvcHRpb25hbCBhcmd1bWVudHMgaGVscHMgcHJldmVudCB0aGUgbmVlZFxuICAgKiB0byBiaW5kIGluIG1hbnkgY2FzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZW1iZXIgb2Ygc2NvcGUgdG8gY2FsbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3BlIFNjb3BlIHRvIGludm9rZSBmcm9tLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBhIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGMgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBkIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZSBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGYgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJuIHsqfSBSZXR1cm4gdmFsdWUgZnJvbSBgbWV0aG9kYC5cbiAgICovXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgISF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLnBlcmZvcm0oLi4uKTogQ2Fubm90IGluaXRpYWxpemUgYSB0cmFuc2FjdGlvbiB3aGVuIHRoZXJlICcgKyAnaXMgYWxyZWFkeSBhbiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGVycm9yVGhyb3duO1xuICAgIHZhciByZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgLy8gb25lIG9mIHRoZXNlIGNhbGxzIHRocmV3LlxuICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdGhpcy5pbml0aWFsaXplQWxsKDApO1xuICAgICAgcmV0ID0gbWV0aG9kLmNhbGwoc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gSWYgYG1ldGhvZGAgdGhyb3dzLCBwcmVmZXIgdG8gc2hvdyB0aGF0IHN0YWNrIHRyYWNlIG92ZXIgYW55IHRocm93blxuICAgICAgICAgIC8vIGJ5IGludm9raW5nIGBjbG9zZUFsbGAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmNlIGBtZXRob2RgIGRpZG4ndCB0aHJvdywgd2UgZG9uJ3Qgd2FudCB0byBzaWxlbmNlIHRoZSBleGNlcHRpb25cbiAgICAgICAgICAvLyBoZXJlLlxuICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGluaXRpYWxpemVBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoIHRoZVxuICAgICAgICAvLyBPQlNFUlZFRF9FUlJPUiBzdGF0ZSBiZWZvcmUgb3ZlcndyaXRpbmcgaXQgd2l0aCB0aGUgcmVhbCByZXR1cm4gdmFsdWVcbiAgICAgICAgLy8gb2YgaW5pdGlhbGl6ZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byBPQlNFUlZFRF9FUlJPUiBpbiB0aGUgZmluYWxseVxuICAgICAgICAvLyBibG9jaywgaXQgbWVhbnMgd3JhcHBlci5pbml0aWFsaXplIHRocmV3LlxuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SO1xuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IHdyYXBwZXIuaW5pdGlhbGl6ZSA/IHdyYXBwZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpIDogbnVsbDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9PT0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1IpIHtcbiAgICAgICAgICAvLyBUaGUgaW5pdGlhbGl6ZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgaW5pdGlhbGl6ZSB0aGVcbiAgICAgICAgICAvLyByZW1haW5pbmcgd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZVxuICAgICAgICAgIC8vIHRoYXQgdGhlIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBlYWNoIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuY2xvc2VbaV1gIGZ1bmN0aW9ucywgcGFzc2luZyBpbnRvXG4gICAqIHRoZW0gdGhlIHJlc3BlY3RpdmUgcmV0dXJuIHZhbHVlcyBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmluaXRbaV1gXG4gICAqIChgY2xvc2VgcnMgdGhhdCBjb3JyZXNwb25kIHRvIGluaXRpYWxpemVycyB0aGF0IGZhaWxlZCB3aWxsIG5vdCBiZVxuICAgKiBpbnZva2VkKS5cbiAgICovXG4gIGNsb3NlQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgICF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLmNsb3NlQWxsKCk6IENhbm5vdCBjbG9zZSB0cmFuc2FjdGlvbiB3aGVuIG5vbmUgYXJlIG9wZW4uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciB0cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgdHJhbnNhY3Rpb25XcmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdyYXBwZXIgPSB0cmFuc2FjdGlvbldyYXBwZXJzW2ldO1xuICAgICAgdmFyIGluaXREYXRhID0gdGhpcy53cmFwcGVySW5pdERhdGFbaV07XG4gICAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgICAgLy8gY2xvc2UgLS0gaWYgaXQncyBzdGlsbCBzZXQgdG8gdHJ1ZSBpbiB0aGUgZmluYWxseSBibG9jaywgaXQgbWVhbnNcbiAgICAgICAgLy8gd3JhcHBlci5jbG9zZSB0aHJldy5cbiAgICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICBpZiAoaW5pdERhdGEgIT09IFRyYW5zYWN0aW9uLk9CU0VSVkVEX0VSUk9SICYmIHdyYXBwZXIuY2xvc2UpIHtcbiAgICAgICAgICB3cmFwcGVyLmNsb3NlLmNhbGwodGhpcywgaW5pdERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBUaGUgY2xvc2VyIGZvciB3cmFwcGVyIGkgdGhyZXcgYW4gZXJyb3I7IGNsb3NlIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAvLyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlIHRoYXQgdGhlXG4gICAgICAgICAgLy8gZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy53cmFwcGVySW5pdERhdGEubGVuZ3RoID0gMDtcbiAgfVxufTtcblxudmFyIFRyYW5zYWN0aW9uID0ge1xuXG4gIE1peGluOiBNaXhpbixcblxuICAvKipcbiAgICogVG9rZW4gdG8gbG9vayBmb3IgdG8gZGV0ZXJtaW5lIGlmIGFuIGVycm9yIG9jY3VycmVkLlxuICAgKi9cbiAgT0JTRVJWRURfRVJST1I6IHt9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFZpZXdwb3J0TWV0cmljc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcblxuICBjdXJyZW50U2Nyb2xsTGVmdDogMCxcblxuICBjdXJyZW50U2Nyb2xsVG9wOiAwLFxuXG4gIHJlZnJlc2hTY3JvbGxWYWx1ZXM6IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhY2N1bXVsYXRlSW50b1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIHZhciBjdXJyZW50SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY3VycmVudCk7XG4gIHZhciBuZXh0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkobmV4dCk7XG5cbiAgaWYgKGN1cnJlbnRJc0FycmF5ICYmIG5leHRJc0FycmF5KSB7XG4gICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKGN1cnJlbnRJc0FycmF5KSB7XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKG5leHRJc0FycmF5KSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhY2N1bXVsYXRlSW50bzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgYWRsZXIzMlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE1PRCA9IDY1NTIxO1xuXG4vLyBhZGxlcjMyIGlzIG5vdCBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcsIGFuZCBpcyBvbmx5IHVzZWQgdG8gc2FuaXR5IGNoZWNrIHRoYXRcbi8vIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIHNlcnZlciBtYXRjaGVzIHRoZSBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBjbGllbnQuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIChhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIFNoZWV0SlMgdmVyc2lvbikgaGFzIGJlZW4gb3B0aW1pemVkXG4vLyBmb3Igb3VyIHVzZSBjYXNlLCBhdCB0aGUgZXhwZW5zZSBvZiBjb25mb3JtaW5nIHRvIHRoZSBhZGxlcjMyIHNwZWNpZmljYXRpb25cbi8vIGZvciBub24tYXNjaWkgaW5wdXRzLlxuZnVuY3Rpb24gYWRsZXIzMihkYXRhKSB7XG4gIHZhciBhID0gMTtcbiAgdmFyIGIgPSAwO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0gZGF0YS5sZW5ndGg7XG4gIHZhciBtID0gbCAmIH4weDM7XG4gIHdoaWxlIChpIDwgbSkge1xuICAgIGZvciAoOyBpIDwgTWF0aC5taW4oaSArIDQwOTYsIG0pOyBpICs9IDQpIHtcbiAgICAgIGIgKz0gKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAyKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDMpKTtcbiAgICB9XG4gICAgYSAlPSBNT0Q7XG4gICAgYiAlPSBNT0Q7XG4gIH1cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBiICs9IGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIGEgJT0gTU9EO1xuICBiICU9IE1PRDtcbiAgcmV0dXJuIGEgfCBiIDw8IDE2O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbkRlZmluZVByb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBkYW5nZXJvdXNTdHlsZVZhbHVlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xuXG52YXIgaXNVbml0bGVzc051bWJlciA9IENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXI7XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgc3R5bGUgdmFsdWUgd2l0aCBkaW1lbnNpb25zIGFwcGxpZWQuXG4gKi9cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcblxuICB2YXIgaXNFbXB0eSA9IHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdmFsdWUgPT09ICcnO1xuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciBpc05vbk51bWVyaWMgPSBpc05hTih2YWx1ZSk7XG4gIGlmIChpc05vbk51bWVyaWMgfHwgdmFsdWUgPT09IDAgfHwgaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7IC8vIGNhc3QgdG8gc3RyaW5nXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZSArICdweCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZGVwcmVjYXRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogVGhpcyB3aWxsIGxvZyBhIHNpbmdsZSBkZXByZWNhdGlvbiBub3RpY2UgcGVyIGZ1bmN0aW9uIGFuZCBmb3J3YXJkIHRoZSBjYWxsXG4gKiBvbiB0byB0aGUgbmV3IEFQSS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5ld01vZHVsZSBUaGUgbW9kdWxlIHRoYXQgZm4gd2lsbCBleGlzdCBpblxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1BhY2thZ2UgVGhlIG1vZHVsZSB0aGF0IGZuIHdpbGwgZXhpc3QgaW5cbiAqIEBwYXJhbSB7Kn0gY3R4IFRoZSBjb250ZXh0IHRoaXMgZm9yd2FyZGVkIGNhbGwgc2hvdWxkIHJ1biBpblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGZvcndhcmQgb24gdG9cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIHdhcm4gb25jZSBhbmQgdGhlbiBjYWxsIGZuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoZm5OYW1lLCBuZXdNb2R1bGUsIG5ld1BhY2thZ2UsIGN0eCwgZm4pIHtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBuZXdGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5lZCxcbiAgICAgIC8vIFJlcXVpcmUgZXhhbXBsZXMgaW4gdGhpcyBzdHJpbmcgbXVzdCBiZSBzcGxpdCB0byBwcmV2ZW50IFJlYWN0J3NcbiAgICAgIC8vIGJ1aWxkIHRvb2xzIGZyb20gbWlzdGFraW5nIHRoZW0gZm9yIHJlYWwgcmVxdWlyZXMuXG4gICAgICAvLyBPdGhlcndpc2UgdGhlIGJ1aWxkIHRvb2xzIHdpbGwgYXR0ZW1wdCB0byBidWlsZCBhICclcycgbW9kdWxlLlxuICAgICAgJ1JlYWN0LiVzIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgJXMuJXMgZnJvbSByZXF1aXJlJyArICcoXFwnJXNcXCcpICcgKyAnaW5zdGVhZC4nLCBmbk5hbWUsIG5ld01vZHVsZSwgZm5OYW1lLCBuZXdQYWNrYWdlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgYWxsIHByb3BlcnRpZXMgb2YgdGhlIG9yaWdpbmFsIGZuIGFyZSBjb3BpZWQgb3Zlci5cbiAgICAvLyBJbiBwYXJ0aWN1bGFyLCB0aGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IFByb3BUeXBlc1xuICAgIHJldHVybiBhc3NpZ24obmV3Rm4sIGZuKTtcbiAgfVxuXG4gIHJldHVybiBmbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGVkOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFU0NBUEVfTE9PS1VQID0ge1xuICAnJic6ICcmYW1wOycsXG4gICc+JzogJyZndDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJ1wiJzogJyZxdW90OycsXG4gICdcXCcnOiAnJiN4Mjc7J1xufTtcblxudmFyIEVTQ0FQRV9SRUdFWCA9IC9bJj48XCInXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVyKG1hdGNoKSB7XG4gIHJldHVybiBFU0NBUEVfTE9PS1VQW21hdGNoXTtcbn1cblxuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgVGV4dCB2YWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZShFU0NBUEVfUkVHRVgsIGVzY2FwZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmluZERPTU5vZGVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR8RE9NRWxlbWVudH0gY29tcG9uZW50T3JFbGVtZW50XG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgZ2V0RE9NTm9kZSBvciBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gIH1cbiAgaWYgKFJlYWN0SW5zdGFuY2VNYXAuaGFzKGNvbXBvbmVudE9yRWxlbWVudCkpIHtcbiAgICByZXR1cm4gUmVhY3RNb3VudC5nZXROb2RlRnJvbUluc3RhbmNlKGNvbXBvbmVudE9yRWxlbWVudCk7XG4gIH1cbiAgIShjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09IG51bGwgfHwgdHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2ZpbmRET01Ob2RlIHdhcyBjYWxsZWQgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IGFwcGVhcnMgdG8gYmUgbmVpdGhlciBSZWFjdENvbXBvbmVudCBub3IgRE9NTm9kZSAoa2V5czogJXMpJywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRET01Ob2RlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmbGF0dGVuQ2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBwYXNzZWQgdGhyb3VnaCB0cmF2ZXJzYWwuXG4gKiBAcGFyYW0gez9SZWFjdENvbXBvbmVudH0gY2hpbGQgUmVhY3QgY2hpbGQgY29tcG9uZW50LlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lIFN0cmluZyBuYW1lIG9mIGtleSBwYXRoIHRvIGNoaWxkLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICB2YXIgcmVzdWx0ID0gdHJhdmVyc2VDb250ZXh0O1xuICB2YXIga2V5VW5pcXVlID0gcmVzdWx0W25hbWVdID09PSB1bmRlZmluZWQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoa2V5VW5pcXVlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJywgbmFtZSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGtleVVuaXF1ZSAmJiBjaGlsZCAhPSBudWxsKSB7XG4gICAgcmVzdWx0W25hbWVdID0gY2hpbGQ7XG4gIH1cbn1cblxuLyoqXG4gKiBGbGF0dGVucyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAuIEFueSBudWxsXG4gKiBjaGlsZHJlbiB3aWxsIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqIEByZXR1cm4geyFvYmplY3R9IGZsYXR0ZW5lZCBjaGlsZHJlbiBrZXllZCBieSBuYW1lLlxuICovXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuQ2hpbGRyZW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGZvckVhY2hBY2N1bXVsYXRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqL1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IGZ1bmN0aW9uIChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hBY2N1bXVsYXRlZDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRDaGFyQ29kZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXG4gKiBgU3RyaW5nLmZyb21DaGFyQ29kZWAuIEFzIHN1Y2gsIG9ubHkga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gcHJpbnRhYmxlXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXG4gKiBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIHRhYi1jaGFyYWN0ZXIgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGBjaGFyQ29kZWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGNoYXJDb2RlO1xuICB2YXIga2V5Q29kZSA9IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG5cbiAgaWYgKCdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBjaGFyQ29kZSA9IG5hdGl2ZUV2ZW50LmNoYXJDb2RlO1xuXG4gICAgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH1cblxuICAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50Q2hhckNvZGU7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50S2V5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICAnRXNjJzogJ0VzY2FwZScsXG4gICdTcGFjZWJhcic6ICcgJyxcbiAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgJ1VwJzogJ0Fycm93VXAnLFxuICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICdEb3duJzogJ0Fycm93RG93bicsXG4gICdEZWwnOiAnRGVsZXRlJyxcbiAgJ1dpbic6ICdPUycsXG4gICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgJ0FwcHMnOiAnQ29udGV4dE1lbnUnLFxuICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAnTW96UHJpbnRhYmxlS2V5JzogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gIDg6ICdCYWNrc3BhY2UnLFxuICA5OiAnVGFiJyxcbiAgMTI6ICdDbGVhcicsXG4gIDEzOiAnRW50ZXInLFxuICAxNjogJ1NoaWZ0JyxcbiAgMTc6ICdDb250cm9sJyxcbiAgMTg6ICdBbHQnLFxuICAxOTogJ1BhdXNlJyxcbiAgMjA6ICdDYXBzTG9jaycsXG4gIDI3OiAnRXNjYXBlJyxcbiAgMzI6ICcgJyxcbiAgMzM6ICdQYWdlVXAnLFxuICAzNDogJ1BhZ2VEb3duJyxcbiAgMzU6ICdFbmQnLFxuICAzNjogJ0hvbWUnLFxuICAzNzogJ0Fycm93TGVmdCcsXG4gIDM4OiAnQXJyb3dVcCcsXG4gIDM5OiAnQXJyb3dSaWdodCcsXG4gIDQwOiAnQXJyb3dEb3duJyxcbiAgNDU6ICdJbnNlcnQnLFxuICA0NjogJ0RlbGV0ZScsXG4gIDExMjogJ0YxJywgMTEzOiAnRjInLCAxMTQ6ICdGMycsIDExNTogJ0Y0JywgMTE2OiAnRjUnLCAxMTc6ICdGNicsXG4gIDExODogJ0Y3JywgMTE5OiAnRjgnLCAxMjA6ICdGOScsIDEyMTogJ0YxMCcsIDEyMjogJ0YxMScsIDEyMzogJ0YxMicsXG4gIDE0NDogJ051bUxvY2snLFxuICAxNDU6ICdTY3JvbGxMb2NrJyxcbiAgMjI0OiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudEtleTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRNb2RpZmllclN0YXRlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gICdBbHQnOiAnYWx0S2V5JyxcbiAgJ0NvbnRyb2wnOiAnY3RybEtleScsXG4gICdNZXRhJzogJ21ldGFLZXknLFxuICAnU2hpZnQnOiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50TW9kaWZpZXJTdGF0ZTsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRUYXJnZXRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEl0ZXJhdG9yRm5cbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgU3ltYm9sICovXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gKlxuICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gKlxuICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICogICAgICAgLi4uXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvckZuOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldFRleHRDb250ZW50QWNjZXNzb3JcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRleHRDb250ZW50QWNjZXNzb3I7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdE5hdGl2ZUNvbXBvbmVudCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gVG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSwgd2UgY3JlYXRlIHRoZSBmaW5hbCBjbGFzcyBpbiB0aGlzIG1vZHVsZVxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uICgpIHt9O1xuYXNzaWduKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUsIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50Lk1peGluLCB7XG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG59KTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHR5cGUgcmVmZXJlbmNlIGlzIGEga25vd24gaW50ZXJuYWwgdHlwZS4gSS5lLiBub3QgYSB1c2VyXG4gKiBwcm92aWRlZCBjb21wb3NpdGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIHZhbGlkIGludGVybmFsIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJuYWxDb21wb25lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3ROb2RlLCBjcmVhdGUgYW4gaW5zdGFuY2UgdGhhdCB3aWxsIGFjdHVhbGx5IGJlIG1vdW50ZWQuXG4gKlxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH0gQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQncyBjb25zdHJ1Y3Rvci5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChub2RlKSB7XG4gIHZhciBpbnN0YW5jZTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgIGluc3RhbmNlID0gbmV3IFJlYWN0RW1wdHlDb21wb25lbnQoaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgICEoZWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpICcgKyAnb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHN0cmluZyB2YWx1ZXNcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGluc3RhbmNlID0gUmVhY3ROYXRpdmVDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZSA9IG5ldyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIGluc3RhbmNlID0gUmVhY3ROYXRpdmVDb21wb25lbnQuY3JlYXRlSW5zdGFuY2VGb3JUZXh0KG5vZGUpO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbmNvdW50ZXJlZCBpbnZhbGlkIFJlYWN0IG5vZGUgb2YgdHlwZSAlcycsIHR5cGVvZiBub2RlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0YW5jZS5jb25zdHJ1Y3QgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nLCAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLicpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gU2V0cyB1cCB0aGUgaW5zdGFuY2UuIFRoaXMgY2FuIHByb2JhYmx5IGp1c3QgbW92ZSBpbnRvIHRoZSBjb25zdHJ1Y3RvciBub3cuXG4gIGluc3RhbmNlLmNvbnN0cnVjdChub2RlKTtcblxuICAvLyBUaGVzZSB0d28gZmllbGRzIGFyZSB1c2VkIGJ5IHRoZSBET00gYW5kIEFSVCBkaWZmaW5nIGFsZ29yaXRobXNcbiAgLy8gcmVzcGVjdGl2ZWx5LiBJbnN0ZWFkIG9mIHVzaW5nIGV4cGFuZG9zIG9uIGNvbXBvbmVudHMsIHdlIHNob3VsZCBiZVxuICAvLyBzdG9yaW5nIHRoZSBzdGF0ZSBuZWVkZWQgYnkgdGhlIGRpZmZpbmcgYWxnb3JpdGhtcyBlbHNld2hlcmUuXG4gIGluc3RhbmNlLl9tb3VudEluZGV4ID0gMDtcbiAgaW5zdGFuY2UuX21vdW50SW1hZ2UgPSBudWxsO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuX2lzT3duZXJOZWNlc3NhcnkgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNFdmVudFN1cHBvcnRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSAoZXZlbnROYW1lIGluIGRvY3VtZW50KTtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCAmJiB1c2VIYXNGZWF0dXJlICYmIGV2ZW50TmFtZVN1ZmZpeCA9PT0gJ3doZWVsJykge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHRlc3Qgc3VwcG9ydCBmb3IgdGhlIGB3aGVlbGAgZXZlbnQgaW4gSUU5Ky5cbiAgICBpc1N1cHBvcnRlZCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ0V2ZW50cy53aGVlbCcsICczLjAnKTtcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0V2ZW50U3VwcG9ydGVkOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc1RleHRJbnB1dEVsZW1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICAnY29sb3InOiB0cnVlLFxuICAnZGF0ZSc6IHRydWUsXG4gICdkYXRldGltZSc6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gICdlbWFpbCc6IHRydWUsXG4gICdtb250aCc6IHRydWUsXG4gICdudW1iZXInOiB0cnVlLFxuICAncGFzc3dvcmQnOiB0cnVlLFxuICAncmFuZ2UnOiB0cnVlLFxuICAnc2VhcmNoJzogdHJ1ZSxcbiAgJ3RlbCc6IHRydWUsXG4gICd0ZXh0JzogdHJ1ZSxcbiAgJ3RpbWUnOiB0cnVlLFxuICAndXJsJzogdHJ1ZSxcbiAgJ3dlZWsnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIHN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXSB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0SW5wdXRFbGVtZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBvbmx5Q2hpbGRcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXNcbiAqIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZVxuICogcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0byBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZVxuICogb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0Q29tcG9uZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdvbmx5Q2hpbGQgbXVzdCBiZSBwYXNzZWQgYSBjaGlsZHJlbiB3aXRoIGV4YWN0bHkgb25lIGNoaWxkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9ubHlDaGlsZDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXJcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xuXG4vKipcbiAqIEVzY2FwZXMgYXR0cmlidXRlIHZhbHVlIHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBlc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSkge1xuICByZXR1cm4gJ1wiJyArIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih2YWx1ZSkgKyAnXCInO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiogQHByb3ZpZGVzTW9kdWxlIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudC5yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0SW5uZXJIVE1MXG4gKi9cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBXSElURVNQQUNFX1RFU1QgPSAvXlsgXFxyXFxuXFx0XFxmXS87XG52YXIgTk9OVklTSUJMRV9URVNUID0gLzwoIS0tfGxpbmt8bm9zY3JpcHR8bWV0YXxzY3JpcHR8c3R5bGUpWyBcXHJcXG5cXHRcXGZcXC8+XS87XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbn07XG5cbi8vIFdpbjggYXBwczogQWxsb3cgYWxsIGh0bWwgdG8gYmUgaW5zZXJ0ZWRcbmlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG4gIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0pO1xuICB9O1xufVxuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFODogV2hlbiB1cGRhdGluZyBhIGp1c3QgY3JlYXRlZCBub2RlIHdpdGggaW5uZXJIVE1MIG9ubHkgbGVhZGluZ1xuICAvLyB3aGl0ZXNwYWNlIGlzIHJlbW92ZWQuIFdoZW4gdXBkYXRpbmcgYW4gZXhpc3Rpbmcgbm9kZSB3aXRoIGlubmVySFRNTFxuICAvLyB3aGl0ZXNwYWNlIGluIHJvb3QgVGV4dE5vZGVzIGlzIGFsc28gY29sbGFwc2VkLlxuICAvLyBAc2VlIHF1aXJrc21vZGUub3JnL2J1Z3JlcG9ydHMvYXJjaGl2ZXMvMjAwNC8xMS9pbm5lcmh0bWxfYW5kX3QuaHRtbFxuXG4gIC8vIEZlYXR1cmUgZGV0ZWN0aW9uOyBvbmx5IElFOCBpcyBrbm93biB0byBiZWhhdmUgaW1wcm9wZXJseSBsaWtlIHRoaXMuXG4gIHZhciB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSAnICc7XG4gIGlmICh0ZXN0RWxlbWVudC5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgc2V0SW5uZXJIVE1MID0gZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgICAgIC8vIE1hZ2ljIHRoZW9yeTogSUU4IHN1cHBvc2VkbHkgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhZGRlZCBhbmQgdXBkYXRlZFxuICAgICAgLy8gbm9kZXMgd2hlbiBwcm9jZXNzaW5nIGlubmVySFRNTCwgaW5uZXJIVE1MIG9uIHVwZGF0ZWQgbm9kZXMgc3VmZmVyc1xuICAgICAgLy8gZnJvbSB3b3JzZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLiBSZS1hZGRpbmcgYSBub2RlIGxpa2UgdGhpcyB0cmlnZ2Vyc1xuICAgICAgLy8gdGhlIGluaXRpYWwgYW5kIG1vcmUgZmF2b3JhYmxlIHdoaXRlc3BhY2UgYmVoYXZpb3IuXG4gICAgICAvLyBUT0RPOiBXaGF0IHRvIGRvIG9uIGEgZGV0YWNoZWQgbm9kZT9cbiAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChub2RlLCBub2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgYWxzbyBpbXBsZW1lbnQgYSB3b3JrYXJvdW5kIGZvciBub24tdmlzaWJsZSB0YWdzIGRpc2FwcGVhcmluZyBpbnRvXG4gICAgICAvLyB0aGluIGFpciBvbiBJRTgsIHRoaXMgb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgdGV4dFxuICAgICAgLy8gaW4tZnJvbnQgb2YgdGhlIG5vbi12aXNpYmxlIHRhZ3MuIFBpZ2d5YmFjayBvbiB0aGUgd2hpdGVzcGFjZSBmaXhcbiAgICAgIC8vIGFuZCBzaW1wbHkgY2hlY2sgaWYgYW55IG5vbi12aXNpYmxlIHRhZ3MgYXBwZWFyIGluIHRoZSBzb3VyY2UuXG4gICAgICBpZiAoV0hJVEVTUEFDRV9URVNULnRlc3QoaHRtbCkgfHwgaHRtbFswXSA9PT0gJzwnICYmIE5PTlZJU0lCTEVfVEVTVC50ZXN0KGh0bWwpKSB7XG4gICAgICAgIC8vIFJlY292ZXIgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHRlbXBvcmFyaWx5IHByZXBlbmRpbmcgYW55IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gXFx1RkVGRiBoYXMgdGhlIHBvdGVudGlhbCBhZHZhbnRhZ2Ugb2YgYmVpbmcgemVyby13aWR0aC9pbnZpc2libGUuXG4gICAgICAgIC8vIFVnbGlmeUpTIGRyb3BzIFUrRkVGRiBjaGFycyB3aGVuIHBhcnNpbmcsIHNvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlXG4gICAgICAgIC8vIGluIGhvcGVzIHRoYXQgdGhpcyBpcyBwcmVzZXJ2ZWQgZXZlbiBpZiBcIlxcdUZFRkZcIiBpcyB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyB0aGUgYWN0dWFsIFVuaWNvZGUgY2hhcmFjdGVyIChieSBCYWJlbCwgZm9yIGV4YW1wbGUpLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWlzaG9vL1VnbGlmeUpTMi9ibG9iL3YyLjQuMjAvbGliL3BhcnNlLmpzI0wyMTZcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkVGRikgKyBodG1sO1xuXG4gICAgICAgIC8vIGRlbGV0ZURhdGEgbGVhdmVzIGFuIGVtcHR5IGBUZXh0Tm9kZWAgd2hpY2ggb2Zmc2V0cyB0aGUgaW5kZXggb2YgYWxsXG4gICAgICAgIC8vIGNoaWxkcmVuLiBEZWZpbml0ZWx5IHdhbnQgdG8gYXZvaWQgdGhpcy5cbiAgICAgICAgdmFyIHRleHROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICBpZiAodGV4dE5vZGUuZGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKHRleHROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0Tm9kZS5kZWxldGVEYXRhKDAsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldElubmVySFRNTDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2V0VGV4dENvbnRlbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC4gaW5uZXJUZXh0IGlzIGEgcG9vciBzdWJzdGl0dXRlIGZvciB0ZXh0Q29udGVudCBhbmQsIGFtb25nIG1hbnlcbiAqIGlzc3VlcywgaW5zZXJ0cyA8YnI+IGluc3RlYWQgb2YgdGhlIGxpdGVyYWwgbmV3bGluZSBjaGFycy4gaW5uZXJIVE1MIGJlaGF2ZXNcbiAqIGFzIGl0IHNob3VsZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSkge1xuICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgICAgIHNldElubmVySFRNTChub2RlLCBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGV4dCkpO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUZXh0Q29udGVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdpdmVuIGEgYHByZXZFbGVtZW50YCBhbmQgYG5leHRFbGVtZW50YCwgZGV0ZXJtaW5lcyBpZiB0aGUgZXhpc3RpbmdcbiAqIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkIGFzIG9wcG9zZWQgdG8gYmVpbmcgZGVzdHJveWVkIG9yIHJlcGxhY2VkIGJ5IGEgbmV3XG4gKiBpbnN0YW5jZS4gQm90aCBhcmd1bWVudHMgYXJlIGVsZW1lbnRzLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGlzIGxvZ2ljIGNhblxuICogb3BlcmF0ZSBvbiBzdGF0ZWxlc3MgdHJlZXMgd2l0aG91dCBhbnkgYmFja2luZyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IHByZXZFbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG5leHRFbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBleGlzdGluZyBpbnN0YW5jZSBzaG91bGQgYmUgdXBkYXRlZC5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSB7XG4gIHZhciBwcmV2RW1wdHkgPSBwcmV2RWxlbWVudCA9PT0gbnVsbCB8fCBwcmV2RWxlbWVudCA9PT0gZmFsc2U7XG4gIHZhciBuZXh0RW1wdHkgPSBuZXh0RWxlbWVudCA9PT0gbnVsbCB8fCBuZXh0RWxlbWVudCA9PT0gZmFsc2U7XG4gIGlmIChwcmV2RW1wdHkgfHwgbmV4dEVtcHR5KSB7XG4gICAgcmV0dXJuIHByZXZFbXB0eSA9PT0gbmV4dEVtcHR5O1xuICB9XG5cbiAgdmFyIHByZXZUeXBlID0gdHlwZW9mIHByZXZFbGVtZW50O1xuICB2YXIgbmV4dFR5cGUgPSB0eXBlb2YgbmV4dEVsZW1lbnQ7XG4gIGlmIChwcmV2VHlwZSA9PT0gJ3N0cmluZycgfHwgcHJldlR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5leHRUeXBlID09PSAnc3RyaW5nJyB8fCBuZXh0VHlwZSA9PT0gJ251bWJlcic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5leHRUeXBlID09PSAnb2JqZWN0JyAmJiBwcmV2RWxlbWVudC50eXBlID09PSBuZXh0RWxlbWVudC50eXBlICYmIHByZXZFbGVtZW50LmtleSA9PT0gbmV4dEVsZW1lbnQua2V5O1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdHJhdmVyc2VBbGxDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG5cbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFNFUEFSQVRPUiA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLlNFUEFSQVRPUjtcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyTG9va3VwID0ge1xuICAnPSc6ICc9MCcsXG4gICcuJzogJz0xJyxcbiAgJzonOiAnPTInXG59O1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvWz0uOl0vZztcblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXNlclByb3ZpZGVkS2V5RXNjYXBlcihtYXRjaCkge1xuICByZXR1cm4gdXNlclByb3ZpZGVkS2V5RXNjYXBlckxvb2t1cFttYXRjaF07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gd3JhcFVzZXJQcm92aWRlZEtleShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIEVzY2FwZSBhIGNvbXBvbmVudCBrZXkgc28gdGhhdCBpdCBpcyBzYWZlIHRvIHVzZSBpbiBhIHJlYWN0aWQuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IENvbXBvbmVudCBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCB1c2VyUHJvdmlkZWRLZXlFc2NhcGVyKTtcbn1cblxuLyoqXG4gKiBXcmFwIGEgYGtleWAgdmFsdWUgZXhwbGljaXRseSBwcm92aWRlZCBieSB0aGUgdXNlciB0byBkaXN0aW5ndWlzaCBpdCBmcm9tXG4gKiBpbXBsaWNpdGx5LWdlbmVyYXRlZCBrZXlzIGdlbmVyYXRlZCBieSBhIGNvbXBvbmVudCdzIGluZGV4IGluIGl0cyBwYXJlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBWYWx1ZSBvZiBhIHVzZXItcHJvdmlkZWQgYGtleWAgYXR0cmlidXRlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHdyYXBVc2VyUHJvdmlkZWRLZXkoa2V5KSB7XG4gIHJldHVybiAnJCcgKyBlc2NhcGVVc2VyUHJvdmlkZWRLZXkoa2V5KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIHdyYXBVc2VyUHJvdmlkZWRLZXkoZW50cnlbMF0pICsgU1VCU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCAwKTtcbiAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkIG9yIHdyYXAgdGhlIG9iamVjdCB1c2luZyBjcmVhdGVGcmFnbWVudChvYmplY3QpIGZyb20gdGhlICcgKyAnUmVhY3QgYWRkLW9ucy4nO1xuICAgICAgICBpZiAoY2hpbGRyZW4uX2lzUmVhY3RFbGVtZW50KSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEl0IGxvb2tzIGxpa2UgeW91XFwncmUgdXNpbmcgYW4gZWxlbWVudCBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50ICcgKyAndmVyc2lvbiBvZiBSZWFjdC4gTWFrZSBzdXJlIHRvIHVzZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSArPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHZhbGlkYXRlRE9NTmVzdGluZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgcGFyZW50VGFnOiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8ucGFyZW50VGFnID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcblxuICAgICAgY2FzZSAnaHInOlxuXG4gICAgICBjYXNlICd4bXAnOlxuXG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCBpbnN0YW5jZSwgcmV0dXJuIGEgbGlzdCBvZiBpdHMgcmVjdXJzaXZlXG4gICAqIG93bmVycywgc3RhcnRpbmcgYXQgdGhlIHJvb3QgYW5kIGVuZGluZyB3aXRoIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICB2YXIgZmluZE93bmVyU3RhY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgLyplc2xpbnQtZGlzYWJsZSBzcGFjZS1hZnRlci1rZXl3b3JkcyAqL1xuICAgIGRvIHtcbiAgICAgIC8qZXNsaW50LWVuYWJsZSBzcGFjZS1hZnRlci1rZXl3b3JkcyAqL1xuICAgICAgc3RhY2sucHVzaChpbnN0YW5jZSk7XG4gICAgfSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZEluc3RhbmNlLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8ucGFyZW50VGFnO1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIHByb2JsZW1hdGljID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAocHJvYmxlbWF0aWMpIHtcbiAgICAgIHZhciBhbmNlc3RvclRhZyA9IHByb2JsZW1hdGljLnRhZztcbiAgICAgIHZhciBhbmNlc3Rvckluc3RhbmNlID0gcHJvYmxlbWF0aWMuaW5zdGFuY2U7XG5cbiAgICAgIHZhciBjaGlsZE93bmVyID0gY2hpbGRJbnN0YW5jZSAmJiBjaGlsZEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lciA9IGFuY2VzdG9ySW5zdGFuY2UgJiYgYW5jZXN0b3JJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICB2YXIgY2hpbGRPd25lcnMgPSBmaW5kT3duZXJTdGFjayhjaGlsZE93bmVyKTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVycyA9IGZpbmRPd25lclN0YWNrKGFuY2VzdG9yT3duZXIpO1xuXG4gICAgICB2YXIgbWluU3RhY2tMZW4gPSBNYXRoLm1pbihjaGlsZE93bmVycy5sZW5ndGgsIGFuY2VzdG9yT3duZXJzLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcblxuICAgICAgdmFyIGRlZXBlc3RDb21tb24gPSAtMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5TdGFja0xlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZE93bmVyc1tpXSA9PT0gYW5jZXN0b3JPd25lcnNbaV0pIHtcbiAgICAgICAgICBkZWVwZXN0Q29tbW9uID0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgVU5LTk9XTiA9ICcodW5rbm93biknO1xuICAgICAgdmFyIGNoaWxkT3duZXJOYW1lcyA9IGNoaWxkT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyTmFtZXMgPSBhbmNlc3Rvck93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3duZXJJbmZvID0gW10uY29uY2F0KFxuICAgICAgLy8gSWYgdGhlIHBhcmVudCBhbmQgY2hpbGQgaW5zdGFuY2VzIGhhdmUgYSBjb21tb24gb3duZXIgYW5jZXN0b3IsIHN0YXJ0XG4gICAgICAvLyB3aXRoIHRoYXQgLS0gb3RoZXJ3aXNlIHdlIGp1c3Qgc3RhcnQgd2l0aCB0aGUgcGFyZW50J3Mgb3duZXJzLlxuICAgICAgZGVlcGVzdENvbW1vbiAhPT0gLTEgPyBjaGlsZE93bmVyc1tkZWVwZXN0Q29tbW9uXS5nZXROYW1lKCkgfHwgVU5LTk9XTiA6IFtdLCBhbmNlc3Rvck93bmVyTmFtZXMsIGFuY2VzdG9yVGFnLFxuICAgICAgLy8gSWYgd2UncmUgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIChub24tcGFyZW50KSBhbmNlc3RyeSwgYWRkICcuLi4nXG4gICAgICBpbnZhbGlkQW5jZXN0b3IgPyBbJy4uLiddIDogW10sIGNoaWxkT3duZXJOYW1lcywgY2hpbGRUYWcpLmpvaW4oJyA+ICcpO1xuXG4gICAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBvd25lckluZm87XG4gICAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6IDwlcz4gY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uICcgKyAnU2VlICVzLiVzJywgY2hpbGRUYWcsIGFuY2VzdG9yVGFnLCBvd25lckluZm8sIGluZm8pIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogPCVzPiBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uIFNlZSAlcy4nLCBjaGlsZFRhZywgYW5jZXN0b3JUYWcsIG93bmVySW5mbykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5ID0gJ19fdmFsaWRhdGVET01OZXN0aW5nX2FuY2VzdG9ySW5mbyQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLnBhcmVudFRhZztcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcbiAgICByZXR1cm4gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpICYmICFmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKHRhZywgYW5jZXN0b3JJbmZvKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7IiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0Jyk7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuY29uc3QgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuY29uc3QgUmVhY3RET00gPSByZXF1aXJlKCdyZWFjdC1kb20nKVxuY29uc3QgRXZlbnRzID0gcmVxdWlyZSgnLi4vZXZlbnRzJyk7XG5jb25zdCBVc2VyID0gcmVxdWlyZSgnLi4vdXNlcicpO1xuXG5jb25zdCBBcHAgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG5cbiAgLy8gUmVuZGVyIHRoZSB1c2VycyBpbiBvcmRlciBvZiB1c2VycyBpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIHdpbiByYXRpb1xuICAvLyByZW5kZXJMZWFkZXJib2FyZCgpIHtcbiAgLy8gICBjb25zdCBvdXRwdXQgPSB1c2Vyc0xpc3Quc29ydCgoYSxiKSA9PiB7XG4gIC8vICAgICByZXR1cm4gdGhpcy51c2VyV2luUmF0aW8oYikgLSB0aGlzLnVzZXJXaW5SYXRpbyhhKTtcbiAgLy8gICB9KS5tYXAoKHVzZXIpID0+IHtcbiAgLy8gICAgIHJldHVybiA8ZGl2PlxuICAvLyAgICAgICB7dGhpcy5yZW5kZXJVc2VyKHVzZXIpfVxuICAvLyAgICAgPC9kaXY+XG4gIC8vICAgfSlcbiAgLy8gICByZXR1cm4gb3V0cHV0O1xuICAvLyB9LFxuXG4gIHJlbmRlcigpIHtcblxuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRlbnRcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2xcIj5cbiAgICAgICAgICA8RXZlbnRzIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbFwiPlxuICAgICAgICAgIDxVc2VyIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG59KTtcblxuXG5SZWFjdERPTS5yZW5kZXIoPEFwcCAvPiwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRhaW5lcicpKTtcblxuLy8gUmVhY3RET00ucmVuZGVyKEFwcCwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRhaW5lcicpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNsYXNzTmFtZXMgPSByZXF1aXJlKCdjbGFzc25hbWVzJyk7XG5cbmZ1bmN0aW9uIGdldE9yZGluYWwobikge1xuICB2YXIgcz1bXCJ0aFwiLFwic3RcIixcIm5kXCIsXCJyZFwiXSxcbiAgdj1uJTEwMDtcbiAgcmV0dXJuIG4rKHNbKHYtMjApJTEwXXx8c1t2XXx8c1swXSk7XG59XG5cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKHBvaW50cywgaSkge1xuICAvLyBJZiBwbGF5ZXIgcG9pbnRzIGFyZSB0aGUgc2FtZSBhcyBwcmV2aW91cyBwbGF5ZXIgcG9pbnRzLCByZXR1cm4gXCI9XCJcbiAgcmV0dXJuIGdldE9yZGluYWwoKGkrMSkpO1xufVxuXG5mdW5jdGlvbiBFdmVudFBsYXllcnMoe2V2ZW50LCB0eXBlfSkge1xuICBjb25zdCBkaXNwbGF5RXZlbnRVc2VycyA9IGV2ZW50LnBsYXllcnMubWFwKChwbGF5ZXIsIGkpID0+IHtcbiAgICBsZXQgcGxheWVyUmVzdWx0O1xuICAgIHBsYXllclJlc3VsdCA9IHBsYXllci5wb2ludHM7XG4gICAgaWYgKHR5cGUgPT09ICd0ZWFtJyB8fCB0eXBlID09PSAncmFjZScpIHtcbiAgICAgIGlmIChwbGF5ZXIucG9pbnRzID09PSBcIjFcIikge1xuICAgICAgICBwbGF5ZXJSZXN1bHQgPSAnVyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwbGF5ZXJSZXN1bHQgPSAnTCc7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHdpbm5pbmdQb2ludHMgPSBnZXRXaW5uZXIoZXZlbnQucGxheWVycyk7XG4gICAgY29uc3QgY2xhc3NlcyA9IGNsYXNzTmFtZXMoJ2V2ZW50LXBsYXllcicsIHBsYXllci5jb2xvdXIsIHtcbiAgICAgIHdpbm5lcjogZXZlbnQud2lubmVyLmluY2x1ZGVzKHBsYXllci5uYW1lKVxuICAgIH0pO1xuICAgIGxldCBmYWN0aW9uID0gKHBsYXllci5mYWN0aW9uKSA/IGAoJHtwbGF5ZXIuZmFjdGlvbn0pYCA6IGZhbHNlO1xuICAgIHJldHVybiA8bGkgY2xhc3NOYW1lPXtjbGFzc2VzfSBrZXk9e3BsYXllci5pZH0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInBvc2l0aW9uXCI+e2dldFBvc2l0aW9uKHBsYXllci5wb2ludHMsIGkpfTwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJuYW1lXCI+e3BsYXllci5uYW1lfSB7ZmFjdGlvbn08L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicG9pbnRzXCI+e3BsYXllclJlc3VsdH08L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sb3VyXCI+PC9kaXY+XG4gICAgPC9saT5cbiAgfSk7XG5cbiAgcmV0dXJuIDx1bCBjbGFzc05hbWU9XCJldmVudC1wbGF5ZXJzXCI+XG4gICAge2Rpc3BsYXlFdmVudFVzZXJzfVxuICA8L3VsPjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsYXllcnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG52YXIgRXZlbnRQbGF5ZXJzID0gcmVxdWlyZSgnLi4vZXZlbnQtcGxheWVycycpO1xuXG5mdW5jdGlvbiBFdmVudCgpIHtcbiAgY29uc3QgZXZlbnRzID0gZXZlbnRzTGlzdC5tYXAoZXZlbnQgPT4ge1xuICAgIGNvbnN0IGRhdGUgPSBtb21lbnQoZXZlbnQuZGF0ZSkuZm9ybWF0KCdEbyBNTU1NIFlZWVknKTtcbiAgICBjb25zdCBldmVudFR5cGUgPSBfLmNhcGl0YWxpemUoZXZlbnQudHlwZSk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxsaSBjbGFzc05hbWU9XCJyb3cgZXZlbnQtY2FyZFwiIGtleT17ZXZlbnQuaWR9PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW1hZ2VcIj48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImluZm9cIj5cbiAgICAgICAgICAgIDxoMj57ZXZlbnQuZ2FtZU5hbWV9PC9oMj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGF0ZVwiPntkYXRlfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0eXBlXCI+R2FtZSB0eXBlOiB7ZXZlbnRUeXBlfTwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGgzPlBsYXllcnM8L2gzPlxuICAgICAgICA8RXZlbnRQbGF5ZXJzIGV2ZW50PXtldmVudH0gdHlwZT17ZXZlbnQudHlwZX0gLz5cbiAgICAgIDwvbGk+XG4gICAgKTtcbiAgfSk7XG4gIHJldHVybiAoXG4gICAgPHVsPlxuICAgICAge2V2ZW50c31cbiAgICA8L3VsPlxuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgY2xhc3NOYW1lcyA9IHJlcXVpcmUoJ2NsYXNzbmFtZXMnKTtcblxuZnVuY3Rpb24gaXNOb3RXaW5uZXIodXNlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICFldmVudC53aW5uZXIuaW5jbHVkZXModXNlci5uYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbmVtZXNpc0NvdW50KGNvdW50cywgdXNlcikge1xuICB2YXIgZmluZCA9IF8uZmluZChjb3VudHMsIFsnbmFtZScsIHVzZXJdKTtcblxuICBpZiAoZmluZCkge1xuICAgIGZpbmQuY291bnQgKz0gMTtcbiAgICByZXR1cm4gY291bnRzO1xuICB9XG5cbiAgcmV0dXJuIGNvdW50cy5jb25jYXQoeyBuYW1lOiB1c2VyLCBjb3VudDogMSB9KTtcbn1cblxuZnVuY3Rpb24gbmVtZXNpc1BpY2tlcihuZW1lc2lpLCBuZW1lc2lzKSB7XG4gIGlmIChuZW1lc2lpLmxlbmd0aCA9PT0gMCkge1xuICAgIG5lbWVzaWkucHVzaChuZW1lc2lzKTtcbiAgfSBlbHNlIGlmIChuZW1lc2lpWzBdLmNvdW50IDwgbmVtZXNpcy5jb3VudCkge1xuICAgIG5lbWVzaWkgPSBbbmVtZXNpc107XG4gIH0gZWxzZSBpZiAobmVtZXNpaVswXS5jb3VudCA9PT0gbmVtZXNpcy5jb3VudCkge1xuICAgIG5lbWVzaWkucHVzaChuZW1lc2lzKTtcbiAgfVxuXG4gIHJldHVybiBuZW1lc2lpO1xufVxuXG4vLyBFeHBlcmltZW50IHRvIG1lcmdlIHRoZSBmaXJzdCBmaWx0ZXIgYW5kIG1hcCBvZiBmaW5kTmVtZXNpc1xuLy8gZnVuY3Rpb24gZmlsdGVyTWFwKHVzZXIpIHtcbi8vICAgcmV0dXJuIChhY2MsIGN1cikgPT4ge1xuLy8gICAgIGlmICghY3VyLndpbm5lci5pbmNsdWRlcyh1c2VyLm5hbWUpKSB7XG4vLyAgICAgICBhY2MucHVzaChjdXIud2lubmVyKVxuLy8gICAgIH1cbi8vICAgICByZXR1cm4gYWNjO1xuLy8gICB9LCBbXSk7XG4vLyB9XG5cbmZ1bmN0aW9uIGZpbmROZW1lc2lzKHVzZXIpIHtcbiAgdmFyIGNvdW50cyA9IHVzZXIuZXZlbnRzLmZpbHRlcihpc05vdFdpbm5lcih1c2VyKSkubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIHdpbm5lciA9IF9yZWYud2lubmVyO1xuICAgIHJldHVybiB3aW5uZXI7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgfSwgW10pLnJlZHVjZShuZW1lc2lzQ291bnQsIFtdKTtcblxuICB2YXIgbmVtZXNpaSA9IGNvdW50cy5yZWR1Y2UobmVtZXNpc1BpY2tlciwgW10pO1xuXG4gIGlmIChuZW1lc2lpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIldvbiBldmVyeXRoaW5nXCI7XG4gIH1cblxuICByZXR1cm4gbmVtZXNpaS5tYXAoZnVuY3Rpb24gKG5lbWVzaXMpIHtcbiAgICByZXR1cm4gbmVtZXNpcy5uYW1lICsgJyAoJyArIG5lbWVzaXMuY291bnQgKyAnKSAnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gTmVtZXNpcyhfcmVmMikge1xuICB2YXIgdXNlciA9IF9yZWYyLnVzZXI7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwibmVtZXNpc1wiIH0sIFwiTmVtZXNpczogXCIsIGZpbmROZW1lc2lzKHVzZXIpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBOZW1lc2lzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pTDFWelpYSnpMM0JvYVd3dmQyOXlheTlmWTJodkxtRnRMMmQxYVd4a0wzTnlZeTlqYjIxd2IyNWxiblJ6TDI1bGJXVnphWE12YVc1a1pYZ3Vhbk40SWl3aWMyOTFjbU5sY3lJNld5SXZWWE5sY25NdmNHaHBiQzkzYjNKckwxOWphRzh1WVcwdlozVnBiR1F2YzNKakwyTnZiWEJ2Ym1WdWRITXZibVZ0WlhOcGN5OXBibVJsZUM1cWMzZ2lYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklrRkJRVUVzUVVGQldTeEJRVUZET3p0QlFVVmlMRWxCUVVrc1FVRkJTeXhSUVVGSExFRkJRVThzVVVGQlF5eEJRVUZQTEVGQlFVTXNRVUZCUXp0QlFVTTNRaXhKUVVGSkxFRkJRVlVzWVVGQlJ5eEJRVUZQTEZGQlFVTXNRVUZCV1N4QlFVRkRMRUZCUVVNN08wRkJSWFpETEZOQlFWTXNRVUZCVnl4WlFVRkRMRUZCUVVrN2JVSkJRMDRzUVVGQlN5eFBRVUZGTEVGQlEzUkNPMWRCUVU4c1EwRkJReXhCUVVGTExFMUJRVU1zUVVGQlRTeFBRVUZETEVGQlFWRXNVMEZCUXl4QlFVRkpMRXRCUmxnc1FVRkRla0lzUVVGQlR5eEJRVU00UWl4QlFVRkpMRUZCUVVNc1FVRkJReXhCUVVNeFF5eEJRVUZETEVGQlEwb3NRVUZCUXpzN096dEJRVVZFTEZOQlFWTXNRVUZCV1N4aFFVRkRMRUZCUVUwc1VVRkJSU3hCUVVGSkxFMUJRVVVzUVVGRGNFTXNRVUZCUlR0TlFVRkpMRUZCUVVrc1QwRkJSeXhCUVVGRExFVkJRVU1zUVVGQlNTeExRVUZETEVGQlFVMHNVVUZCUlN4RFFVRkRMRUZCUVUwc1VVRkJSU3hCUVVGSkxFRkJRVU1zUVVGQlF5eEJRVUZETEVGQlJURkRPenROUVVGSkxFRkJRVWtzVFVGQlJTeEJRVU5TTEVGQlFVazdVMEZCUXl4QlFVRkxMRk5CUVVrc1FVRkJReXhCUVVGRExFRkJRMmhDTzFkQlFVOHNRVUZCVFN4QlFVRkRMRUZCUTJ4Q0xFRkJRVWNzUVVGRlJEczdPMU5CUVU4c1FVRkJUU3hQUVVGRExFRkJRVTBzVDBGQlF5eEZRVUZGTEVGQlFVa3NUVUZCUlN4QlFVRkpMRTFCUVVVc1FVRkJTeXhQUVVGRkxFRkJRVU1zUVVGQlJTeEJRVUZETEVGQlFVTXNRVUZEYWtRc1FVRkJRenM3TzBGQlJVUXNVMEZCVXl4QlFVRmhMR05CUVVNc1FVRkJUeXhUUVVGRkxFRkJRVTg3VFVGRGFrTXNRVUZCVHl4UlFVRkRMRUZCUVUwc1YwRkJTeXhCUVVGRE8xbEJRMlFzUVVGQlNTeExRVVJaTEVGQlEzaENMRUZCUVU4c1FVRkJUU3hCUVVGUExFRkJRVU1zUVVGQlF5eEJRVU4yUWp0aFFVRlZMRUZCUVU4c1VVRkJReXhCUVVGRExFRkJRVU1zUjBGQlF5eEJRVUZMTEZGQlFVY3NRVUZCVHl4UlFVRkRMRUZCUVVzN1kwRkRMMElzUTBGRVRDeEJRVUZ6UXl4QlFVTXpReXhCUVVGUExFRkJRVWtzUVVGQlR5eEJRVUZETEVGQlFVTXNRVUZEY2tJN1lVRkJWU3hCUVVGUExGRkJRVU1zUVVGQlF5eEJRVUZETEVkQlFVTXNRVUZCU3l4VlFVRkxMRUZCUVU4c1VVRkJReXhCUVVGTE8xbEJRMjVETEVGQlFVa3NTMEZFVUN4QlFVRjNReXhCUVVNM1F5eEJRVUZQTEVGQlFVMHNRVUZCVHl4QlFVRkRMRUZCUVVNc1FVRkRNVUlzUVVGQlJ5eEJRVVZFT3pzN1UwRlVkVU1zUVVGRGRrTXNRVUZSVHl4QlFVRlBMRUZCUVVNc1FVRkRha0lzUVVGQlF5eEJRVVZFTEVGQlFUaEVMRUZCUXpsRUxFRkJRVFpDTEVGQlF6ZENMRUZCUVRKQ0xFRkJRek5DTEVGQlFUWkRMRUZCUXpkRExFRkJRVFpDTEVGQlF6ZENMRUZCUVZFc1FVRkRVaXhCUVVGclFpeEJRVU5zUWl4QlFVRlpMRUZCUTFvc1FVRkJTVHM3T3pzN096czdPenM3T3p0QlFVVktMRk5CUVZNc1FVRkJWeXhaUVVGRExFRkJRVWs3VFVGRGJrSXNRVUZCVFN4alFVRlJMRUZCUVUwc1QwRkJReXhCUVVGTkxFOUJRVU1zUVVGQlZ5eFpRVUZETEVGQlFVa3NRVUZCUXl4QlFVRkRMRTlCUVVNc1FVRkJSeXhqUVVGWExFRkJRVWs3VVVGREwwUXNRVUZCVFN4VFFVRkhMRUZCUVVrc1MwRkJReXhCUVVGTkxFRkJRVU1zUVVGRGVrSTdWMEZHVnl4QlFVRkpMRUZCUVhORExFRkJRV2RDTEVGQlEzSkZMRUZCUTA4c1FVRkJUU3hCUVVGRExFRkJRMllzUVVGQlF6dExRVUZETEVGQlFVMHNhVUpCUVZjc1FVRkJReXhIUVVGRkxFRkJRVU03VjBGRFppeEJRVUZETEVWQlFVTXNRVUZCVFN4UFFVUlFMRUZCUVdkQ0xFRkJRM2hDTEVGQlFXZENMRUZCUVVNc1FVRkJReXhCUVVGRExFRkJRM1pDTEVGQlFVYzdTMEZCUlN4QlFVRkZMRUZCUVVNc1NVRkJReXhCUVVGTkxFOUJRVU1zUVVGQldTeGpRVUZGTEVGQlFVVXNRVUZCUXl4QlFVRkRMRUZCUld4RExFRkJRVVU3TzAxQlFVa3NRVUZCVHl4VlFVRkhMRUZCUVUwc1QwRkJReXhCUVVGTkxFOUJRVU1zUVVGQllTeGxRVUZGTEVGQlFVVXNRVUZCUXl4QlFVRkRMRUZCUlM5RE96dE5RVUZKTEVGQlFVOHNVVUZCUXl4QlFVRk5MRmRCUVVzc1FVRkJReXhIUVVGRkxFRkJRM2hDTzFkQlFVOHNRVUZCWjBJc1FVRkJReXhCUVVNMVFpeEJRVUZITEVGQlJVUTdPenRUUVVGUExFRkJRVThzVVVGQlF5eEJRVUZITEdOQlFWY3NRVUZCVHl4VFFVRkZMRUZCUTNCRE8xZEJRVThzUVVGQlR5eFJRVUZETEVGQlFVa3NUMEZCUnl4QlFVRkpMRTlCUVVjc1FVRkJUeXhSUVVGRExFRkJRVXNzVVVGbWJrSXNRVUZEZWtJc1FVRmhiVUlzUVVGRE5FSXNRVUZCU1N4QlFVRkRMRUZCUTI1RUxFRkJRVU1zUVVGQlF5eEJRVU5NTEVGQlFVTTdPenM3UVVGRlJDeFRRVUZUTEVGQlFVOHNVVUZCUXl4QlFVRkxMRTlCUVVVc1FVRkRlRUlzUVVGQlJUdE5RVUZKTEVGQlFVa3NUMEZCUnl4QlFVRkxMRTFCUVVNc1FVRkJTU3hCUVVGRExFRkJSWFJDT3p0VFFVRlBMRUZCUVVzc1RVRkJReXhCUVVGaExHTkJRVU1zUVVGQlN5eFBRVUZGTEVWQlFVVXNRVUZCVXl4WFFVRkZMRUZCUVZNc1FVRkJSU3hoUVVGRkxFRkJRVmNzWVVGQlJTeEJRVUZYTEZsQlFVTXNRVUZCU1N4QlFVRkRMRUZCUVVNc1FVRkJReXhCUVVNNVJpeEJRVUZET3pzN1FVRkZSQ3hCUVVGTkxFOUJRVU1zUVVGQlR5eFZRVUZITEVGQlFVOHNRVUZCUXl4QlFVTjZRaUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSWx3aWRYTmxJSE4wY21samRGd2lPMXh1WEc1MllYSWdVbVZoWTNRZ1BTQnlaWEYxYVhKbEtDZHlaV0ZqZENjcE8xeHVkbUZ5SUdOc1lYTnpUbUZ0WlhNZ1BTQnlaWEYxYVhKbEtDZGpiR0Z6YzI1aGJXVnpKeWs3WEc1Y2JtWjFibU4wYVc5dUlHbHpUbTkwVjJsdWJtVnlLSFZ6WlhJcElIdGNiaUFnY21WMGRYSnVJR1oxYm1OMGFXOXVJQ2hsZG1WdWRDa2dlMXh1SUNBZ0lISmxkSFZ5YmlBaFpYWmxiblF1ZDJsdWJtVnlMbWx1WTJ4MVpHVnpLSFZ6WlhJdWJtRnRaU2s3WEc0Z0lIMDdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHNWxiV1Z6YVhORGIzVnVkQ2hqYjNWdWRITXNJSFZ6WlhJcElIdGNiaUFnZG1GeUlHWnBibVFnUFNCZkxtWnBibVFvWTI5MWJuUnpMQ0JiSjI1aGJXVW5MQ0IxYzJWeVhTazdYRzVjYmlBZ2FXWWdLR1pwYm1RcElIdGNiaUFnSUNCbWFXNWtMbU52ZFc1MElDczlJREU3WEc0Z0lDQWdjbVYwZFhKdUlHTnZkVzUwY3p0Y2JpQWdmVnh1WEc0Z0lISmxkSFZ5YmlCamIzVnVkSE11WTI5dVkyRjBLSHNnYm1GdFpUb2dkWE5sY2l3Z1kyOTFiblE2SURFZ2ZTazdYRzU5WEc1Y2JtWjFibU4wYVc5dUlHNWxiV1Z6YVhOUWFXTnJaWElvYm1WdFpYTnBhU3dnYm1WdFpYTnBjeWtnZTF4dUlDQnBaaUFvYm1WdFpYTnBhUzVzWlc1bmRHZ2dQVDA5SURBcElIdGNiaUFnSUNCdVpXMWxjMmxwTG5CMWMyZ29ibVZ0WlhOcGN5azdYRzRnSUgwZ1pXeHpaU0JwWmlBb2JtVnRaWE5wYVZzd1hTNWpiM1Z1ZENBOElHNWxiV1Z6YVhNdVkyOTFiblFwSUh0Y2JpQWdJQ0J1WlcxbGMybHBJRDBnVzI1bGJXVnphWE5kTzF4dUlDQjlJR1ZzYzJVZ2FXWWdLRzVsYldWemFXbGJNRjB1WTI5MWJuUWdQVDA5SUc1bGJXVnphWE11WTI5MWJuUXBJSHRjYmlBZ0lDQnVaVzFsYzJscExuQjFjMmdvYm1WdFpYTnBjeWs3WEc0Z0lIMWNibHh1SUNCeVpYUjFjbTRnYm1WdFpYTnBhVHRjYm4xY2JseHVMeThnUlhod1pYSnBiV1Z1ZENCMGJ5QnRaWEpuWlNCMGFHVWdabWx5YzNRZ1ptbHNkR1Z5SUdGdVpDQnRZWEFnYjJZZ1ptbHVaRTVsYldWemFYTmNiaTh2SUdaMWJtTjBhVzl1SUdacGJIUmxjazFoY0NoMWMyVnlLU0I3WEc0dkx5QWdJSEpsZEhWeWJpQW9ZV05qTENCamRYSXBJRDArSUh0Y2JpOHZJQ0FnSUNCcFppQW9JV04xY2k1M2FXNXVaWEl1YVc1amJIVmtaWE1vZFhObGNpNXVZVzFsS1NrZ2UxeHVMeThnSUNBZ0lDQWdZV05qTG5CMWMyZ29ZM1Z5TG5kcGJtNWxjaWxjYmk4dklDQWdJQ0I5WEc0dkx5QWdJQ0FnY21WMGRYSnVJR0ZqWXp0Y2JpOHZJQ0FnZlN3Z1cxMHBPMXh1THk4Z2ZWeHVYRzVtZFc1amRHbHZiaUJtYVc1a1RtVnRaWE5wY3loMWMyVnlLU0I3WEc0Z0lIWmhjaUJqYjNWdWRITWdQU0IxYzJWeUxtVjJaVzUwY3k1bWFXeDBaWElvYVhOT2IzUlhhVzV1WlhJb2RYTmxjaWtwTG0xaGNDaG1kVzVqZEdsdmJpQW9YM0psWmlrZ2UxeHVJQ0FnSUhaaGNpQjNhVzV1WlhJZ1BTQmZjbVZtTG5kcGJtNWxjanRjYmlBZ0lDQnlaWFIxY200Z2QybHVibVZ5TzF4dUlDQjlLUzV5WldSMVkyVW9ablZ1WTNScGIyNGdLR0VzSUdJcElIdGNiaUFnSUNCeVpYUjFjbTRnWVM1amIyNWpZWFFvWWlrN1hHNGdJSDBzSUZ0ZEtTNXlaV1IxWTJVb2JtVnRaWE5wYzBOdmRXNTBMQ0JiWFNrN1hHNWNiaUFnZG1GeUlHNWxiV1Z6YVdrZ1BTQmpiM1Z1ZEhNdWNtVmtkV05sS0c1bGJXVnphWE5RYVdOclpYSXNJRnRkS1R0Y2JseHVJQ0JwWmlBb2JtVnRaWE5wYVM1c1pXNW5kR2dnUFQwOUlEQXBJSHRjYmlBZ0lDQnlaWFIxY200Z1hDSlhiMjRnWlhabGNubDBhR2x1WjF3aU8xeHVJQ0I5WEc1Y2JpQWdjbVYwZFhKdUlHNWxiV1Z6YVdrdWJXRndLR1oxYm1OMGFXOXVJQ2h1WlcxbGMybHpLU0I3WEc0Z0lDQWdjbVYwZFhKdUlHNWxiV1Z6YVhNdWJtRnRaU0FySUNjZ0tDY2dLeUJ1WlcxbGMybHpMbU52ZFc1MElDc2dKeWtnSnp0Y2JpQWdmU2s3WEc1OVhHNWNibVoxYm1OMGFXOXVJRTVsYldWemFYTW9YM0psWmpJcElIdGNiaUFnZG1GeUlIVnpaWElnUFNCZmNtVm1NaTUxYzJWeU8xeHVYRzRnSUhKbGRIVnliaUJTWldGamRDNWpjbVZoZEdWRmJHVnRaVzUwS0Z3aVpHbDJYQ0lzSUhzZ1kyeGhjM05PWVcxbE9pQmNJbTVsYldWemFYTmNJaUI5TENCY0lrNWxiV1Z6YVhNNklGd2lMQ0JtYVc1a1RtVnRaWE5wY3loMWMyVnlLU2s3WEc1OVhHNWNibTF2WkhWc1pTNWxlSEJ2Y25SeklEMGdUbVZ0WlhOcGN6dGNiaTh2SXlCemIzVnlZMlZOWVhCd2FXNW5WVkpNUFdSaGRHRTZZWEJ3YkdsallYUnBiMjR2YW5OdmJqdGlZWE5sTmpRc1pYbEtNbHBZU25waFZ6bDFTV3B2ZWt4RFNtMWhWM2hzU1dwdmFVd3hWbnBhV0VwNlRETkNiMkZYZDNaa01qbDVZWGs1WmxreWFIWk1iVVowVERKa01XRlhlR3RNTTA1NVdYazVhbUl5TVhkaU1qVnNZbTVTZWt3eU5XeGlWMVo2WVZoTmRtRlhOV3RhV0dkMVlXNU9ORWxwZDJsak1qa3hZMjFPYkdONVNUWlhlVWwyVmxoT2JHTnVUWFpqUjJod1lrTTVNMkl6U25KTU1UbHFZVWM0ZFZsWE1IWmFNMVp3WWtkUmRtTXpTbXBNTWs1MllsaENkbUp0Vm5Wa1NFMTJZbTFXZEZwWVRuQmplVGx3WW0xU2JHVkROWEZqTTJkcFdGTjNhV0p0Um5SYVdFMXBUMngwWkV4RFNuUlpXRUozWVZjMWJtTjVTVFpKYTBaQ1VWVkZjMUZWUmtKWFUzaENVVlZHUkU5NmRFSlJWVlpwVEVWc1FsRlZhM05SVlVaQ1UzbDRVbEZWUmtoTVJVWkNVVlU0YzFWVlJrSlJlWGhDVVZWR1VFeEZSa0pSVlUxelVWVkdRbEY2ZEVKUlZVMHpVV2w0U2xGVlJrcE1SVVpDVVZaVmMxbFZSa0pTZVhoQ1VWVkdVRXhHUmtKUlZVMXpVVlZHUWxkVGVFSlJWVVpFVEVWR1FsRlZUVGRQTUVaQ1VsaGFSRXhHVGtKUlZrMXpVVlZHUWxaNWVGcFJWVVpFVEVWR1FsRlZhemRpVlVwQ1VUQTBjMUZWUmtKVGVYaFFVVlZHUmt4RlJrSlJNMUpEVHpGa1FsRlZPSE5STUVaQ1VYbDRRbEZWUmt4TVJURkNVVlZOYzFGVlJrSlVVM2hRVVZWR1JFeEZSa0pSVmtWelZUQkdRbEY1ZUVKUlZVWktURVYwUWxKc1ozTlJWVVpFWld0SmMxRlZSa0pVZVhoQ1VWVk5ORkZwZUVKUlZVWktURVZHUWxGVlRYTlJWVVpDVVhsNFFsRlZUWGhSZVhoQ1VWVkdSRXhGUmtKUk1HOXpVVlZHUWxGNmN6ZFBlblJDVVZWV1JVeEdUa0pSVmsxelVWVkdRbGRUZUdoUlZVWkVURVZHUWxGVk1ITlZWVVpDVWxONFFsRlZSa3BNUlRGQ1VWVlZjMUZWUmtSalJVMXpVVlZHUWxKVWRFNVJWVVpLVEVWR1FsRlZhM05VTUVaQ1VubDRRbEZWUmtSTVJWWkNVVlZOYzFGVlJrSlRVM2hNVVZWR1JFeEZSa0pSVlRCelZWVkdRbEpUZUVSUlZVWkVURVZHUWxGVk1ITlZWVVpDVWxONFFsRlZSa3BNUlVaQ1VWVk5jMUZWUmtKUmVYaENVVlZHUkV4RlJrSlNWRVpFVDNwMFRsRlZSa3BNUlVaQ1VWVnJjMVJWUmtKU1UzaENVVlZPVTB4RlJrSlJWV3MzVlRCR1FsRjVlRUpSVlVaTVRFWk9RbEZWYTNOUlZVWkNVWGw0UWxGVlJrUk1SVVpDVVRKb1EwOHhaRUpSVlRoelVWVkdRbFJUZUVKUlZVWkVURVZHUWxFeWVFTk1SVVpDVVZWamMxRlZSa1pTUkhNM1R6Rk9RbEZWT0hOUlZVWkNWRk40VUZGVlJrUk1SVVpDVVZVd2MxUXdSa0pSZVhoR1VWVkdSa3hGUmtKUlZXdHpWRlZHUWxKVGVFSlJWVVpLVEVVeFFsRlZWWE5SVlVaQ1UzbDRVRkZWUmtaTVJVWkNVVlZOYzFGVlJrSlNVM2hDVVZWR1JFeEZSa0pSVlUxelVWVkdSR0ZyVVhOUlZVWkNVWHB6TjA4d1JrSlNWVkZ6VlRCR1FsVjVlRUpSVlVab1RFZE9RbEZWVFhOUlZVWkNWSGw0VkZGVlJrWk1SVVpDVVZVNE4xUlZSa1JoYTAxelVWVkdRbFI1ZUZKUlZVWkVURVZHUWxGVk1ITldNRVpDVTNsNFFsRlZSa1JQTVd4Q1VUSlJjMUZWUmtKVFUzaE1VVlZTV2t4RlJrSlJNMmhEVEVWR1FsRlZPSE5SVlVaQ1ZGTjRRbEZWUmxCTVJVWkNVVlZOYzFGVlJrSlJlWGhDVVZWT01sRnFkR2hSVlVaV1RFVkdRbEZWT0hOVlZVWkNVWGw0UWxGVlJrUk1SVVpDVVZWTmMxSXdSa0pSZVhoQ1VWVkdURXhHUmtKUlZXTnpVVlZHUWxSNWVGSlJWVVpFVEVWR1FsRlZjemRaTUVaRVREQkpjMUV3UmtWVVEzaENVVlZHZWxGNWVFSlJWVTE2VVhsNFFsRlZSbEJNUlVaQ1VWVnJjMUZWUmtKVWVYaENVVlZHUkV4RlJrSlJWVTF6VVZWR1JHTnJTVGRaVlVaQ1ZsTjRRbEZWUmxCTVJrWkNVVlZOYzFGVlJrSlJlWGhDVVZWR1JFeEZaRUpSVlUxelVWVkdRbE41ZUZaUlZVWk1URVZHUWxGVk9ITlZWVVpDVVhsNFFsRlZSa3hQTVd4Q1VUSTFSRXhGUmtKUlZXdHpVekJHUlZWRGVFSlJWVVl6VVhsNFFsRlZUVE5SZVhoQ1VWVkdVRXhGUmtKUlZUQnpVVlZHUWxSNWVFSlJWVVpFVEVWR1FsRlZUWE5SVlVaRVRWVkpjMUZWUmtKU2VYaENVVlZXUlU5NmN6ZFZNRVpWWkZWTmMxRlZSa1JrYTAxelVWVkdVbFI1ZUVKUlZVWlFURVZHUWxGVlRYTlJWVVpFWVd0SmMxRlZSa0pSZVhoQ1VWVldSVXhGUmtKUlZHaEZURVZHUWxGNmJFVk1SVVpDVVZSYVEweEZSa0pSZW1SRFRFVkdRbEZVU2tOTVJVWkNVWHBPUTB4RlJrSlJWRnBFVEVWR1FsRjZaRVJNUlVaQ1VWUmFRMHhGUmtKUmVtUkRURVZHUWxGV1JYTlJWVVpFVldsNFFsRlZSbkpSYVhoQ1VWVk9jMUZwZUVKUlZVWmFURVZHUWxFeGIzTlJWVVpDVTFSek4wOTZjemRQZW5NM1QzcHpOMDk2ZEVKUlZWWkxURVpPUWxGV1RYTlJWVVpDVm5sNFdsRlZSa1JNUlVaQ1VWVnJOMVJWUmtSaWEwbHpVVlZHUWxSVGVHcFJWVVpTVEVWR1FsRlZNSE5VTUVaQ1VYbDRRbEZWUms1TVJUbENVVlZOYzFGVlJrSldlWGhhVVZWR1JFeEZSa0pSVld0elVWVkdRbEY1ZUVKUlZVWkVURVU1UWxGVlRYTlJWVVpDVW5sNGFsRlZSbGhNUlVaQ1VWVnJOMVZWUmtSTU1GRnpVVlZHUWxSVGVGUlJWVVpJVEVWR1FsRlZhM05UTUVaQ1VYbDRRbEZWUms1TVJVWkNVVlZOYzFGVlJrUmxhMGszVmpCR1IxWjVlRUpSVlVaS1RFVkdRbEZZVGtSTVJVWkNVVmRrUTB4RlJrSlJNMHBHVEVWR1FsRXdPSE5SVlVaQ1ZGTjRRbEZWUmtSTVJVWkNVVEpaYzFGVlJrSlJlblJNVVZWR1JFeEZSa0pSVlRCellWVktRbEZXWTNOUlZVWkNVWGw0U0ZGVlJrWk1SVVpDVVZWTk4xWXdSa1JhYVhoQ1VWVkdSRXhGVmtKUlZVMXpVVlZHUWxSVGVGQlJWVkpSVEVWR1FsRlhaRU5NUlVaQ1VUTm9RMHhGUmtKUlYyUkRURVZHUWxGVlRYTlJWVVpDVVhsNFFsRlZSa1JNUlVaQ1VUTmFRMHhGUmtKUlZXTTNVekJHUWxKVGVFSlJWVVpHVEVWR1FsRlZUWE5UVlVaQ1VYbDRRbEZWUms1TVJUbENVVlZOYzFGVlJrSlhVM2hxVVZWR1JreEZSa0pSVlZWelVWVkdRbEY1ZUVKUlZVWkVURVZHUWxKWGVFUk1SVVpDVVZWVk4wOHdNVUpSVld0elVWVkdRbFI1ZUZaUlZVWklURVZHUWxGVk1ITlVNRVpDVVhsNFFsRlZSazVNUlRsQ1VWVk5jMUZWUmtKWlUzaHNVVlZHUmt4RlJrSlJWVlZ6VVZWR1FsRjVlRUpSVlVaRVRFVkdRbEpUT1VSUGVuUk9VVlZHU2t4RlJrSlJWVGh6VlZWR1FsRjVlRUpSVlVaT1RFWmtRbEZWYzNOUlZVWkNVWGw0U0ZGVlJrWk1SVVpDVVROb1EwOHhaRUpSVlRoelVWVkdRbG93U1hOUlZVWkNVWGw0UWxGVlRURlJhWGhDVVZWR1NFeEZSa0pTVlZFM1QzcDBWRkZWUmxCTVJVWkNVVlU0YzFWVlJrSlJlWGhDVVZWR1NFeEhUa0pSVm1OelVWVkdRbFI1ZUZSUlZVWkdURVZHUWxFelFrUlBNV1JDVVZVNGMxRlZSa0pVZVhoU1VWVkdSRXhGUmtKUlZXdHpWREJHUWxKNWVFSlJWVVpLVEVVNVFsRlZZM05SVlVaQ1ZIbDRVbEZWUmtSTVJVWkNVVlZ6YzFWVlJtMWlhMGx6VVZWR1JHVnJTWE5SVlVab1lsVkpjMUZWUmtST1JVbHpVVlZHUWxOVGVFSlJWVVpFVEVWR1FsRXlOVVZNUlVaQ1VWVk5jMUZWUmtKUmVYaENVVlZPVFV4RlJrSlJWVTAzVDNwek4xRlZSa1pTUTNoVVVWVkdWRXhGUmtKUlZUaHpWVlZHUWxGNWVFSlJWVVpNVEVVNVFsRlZWWE5SVlVaRVpVVkpjMUZWUmtKU1ZIUk9VVlZHU2t4RlJrSlJWV3R6VkRCR1FsSjVlRUpSVlVaTVRFVXhRbEZWVFhOUlZVWkNVMU40UWxGVlJrUk1SVVpDVWxoU1EwOTZkRlJSVlVaUVRFVkdRbEZWYzNOVVZVWkNVWGw0UWxGVlJtaE1SMDVDVVZWTmMxRlZSa0pUZVhoUVVWVkdSa3hGVmtKUlZWVnpVVlZHUWxWNWVGaFJWVVpHVEVWR1FsRldUWE5SVlVaQ1VsTjRhRkZWUmtaTVJVWkNVVlpqYzFsVlJrSlNVM2hDVVZWR1dFeEdiRUpSVlUxelVWVkdRbE5UZUVKUlZVWkVURVZHUWxGVlRYTlJWVVpDVVhsNFFsRlZUVFZTYVhoQ1VWVkdSRTk2Y3pkUlZVWkdVa040UWxGVlJrNU1SVGxDVVZWTmMxRlZSa0pVZVhoV1VWVkdTRXhGUmtKUlZUaHpVVlZHUWxGNWVFSlJWVTQyVVdsSmMwbHVUblprV0VwcVdsaE9SR0l5TlRCYVZ6VXdTV3B3WWtsc2QybGtXRTVzU1VoT01HTnRiR3BrUm5kcFR6RjRkVmhITlRKWldFbG5WVzFXYUZrelVXZFFVMEo1V2xoR01XRllTbXhMUTJSNVdsZEdhbVJEWTNCUE1YaDFaRzFHZVVsSFRuTlpXRTU2VkcxR2RGcFlUV2RRVTBKNVdsaEdNV0ZZU214TFEyUnFZa2RHZW1NeU5XaGlWMVo2U25sck4xaEhOV05pYlZveFltMU9NR0ZYT1hWSlIyeDZWRzA1TUZZeWJIVmliVlo1UzBoV2VscFlTWEJKU0hSalltbEJaMk50VmpCa1dFcDFTVWRhTVdKdFRqQmhWemwxU1VOb2JHUnRWblZrUTJ0blpURjRkVWxEUVdkSlNFcHNaRWhXZVdKcFFXaGFXRnBzWW01UmRXUXliSFZpYlZaNVRHMXNkVmt5ZURGYVIxWjZTMGhXZWxwWVNYVmliVVowV2xOck4xaEhOR2RKU0RBM1dFYzFPVmhITldOaWJWb3hZbTFPTUdGWE9YVkpSelZzWWxkV2VtRllUa1JpTTFaMVpFTm9hbUl6Vm5Wa1NFMXpTVWhXZWxwWVNYQkpTSFJqWW1sQloyUnRSbmxKUjFwd1ltMVJaMUJUUW1aTWJWcHdZbTFSYjFreU9URmlibEo2VEVOQ1lrb3lOV2hpVjFWdVRFTkNNV015Vm5sWVUyczNXRWMxWTJKcFFXZGhWMWxuUzBkYWNHSnRVWEJKU0hSalltbEJaMGxEUW0xaFZ6VnJURzFPZG1SWE5UQkpRM001U1VSRk4xaEhOR2RKUTBGblkyMVdNR1JZU25WSlIwNTJaRmMxTUdONmRHTmlhVUZuWmxaNGRWaEhOR2RKU0Vwc1pFaFdlV0pwUW1waU0xWjFaRWhOZFZreU9YVlpNa1l3UzBoeloySnRSblJhVkc5blpGaE9iR05wZDJkWk1qa3hZbTVSTmtsRVJXZG1VMnMzV0VjMU9WaEhOV05pYlZveFltMU9NR0ZYT1hWSlJ6VnNZbGRXZW1GWVRsRmhWMDV5V2xoSmIySnRWblJhV0U1d1lWTjNaMkp0Vm5SYVdFNXdZM2xyWjJVeGVIVkpRMEp3V21sQmIySnRWblJhV0U1d1lWTTFjMXBYTlc1a1IyZG5VRlF3T1VsRVFYQkpTSFJqWW1sQlowbERRblZhVnpGc1l6SnNjRXh1UWpGak1tZHZZbTFXZEZwWVRuQmplV3MzV0VjMFowbElNR2RhVjNoNldsTkNjRnBwUVc5aWJWWjBXbGhPY0dGV2MzZFlVelZxWWpOV2RXUkRRVGhKUnpWc1lsZFdlbUZZVFhWWk1qa3hZbTVSY0VsSWRHTmlhVUZuU1VOQ2RWcFhNV3hqTW14d1NVUXdaMWN5Tld4aVYxWjZZVmhPWkU4eGVIVkpRMEk1U1VkV2MyTXlWV2RoVjFsblMwYzFiR0pYVm5waFYyeGlUVVl3ZFZreU9URmlibEZuVUZRd09VbEhOV3hpVjFaNllWaE5kVmt5T1RGaWJsRndTVWgwWTJKcFFXZEpRMEoxV2xjeGJHTXliSEJNYmtJeFl6Sm5iMkp0Vm5SYVdFNXdZM2xyTjFoSE5HZEpTREZqWW14NGRVbERRbmxhV0ZJeFkyMDBaMkp0Vm5SYVdFNXdZVlIwWTJKdU1XTmliSGgxVEhrNFoxSllhSGRhV0Vwd1lsZFdkV1JEUWpCaWVVSjBXbGhLYmxwVFFqQmhSMVZuV20xc2VXTXpVV2RhYld4elpFZFdlVWxIUm5WYVEwSjBXVmhCWjJJeVdXZGFiV3gxV2tVMWJHSlhWbnBoV0U1alltazRka2xIV2pGaWJVNHdZVmM1ZFVsSFduQmlTRkpzWTJzeGFHTkRhREZqTWxaNVMxTkNOMWhITkhaTWVVRm5TVWhLYkdSSVZubGlhVUZ2V1ZkT2FreERRbXBrV0Vsd1NVUXdLMGxJZEdOaWFUaDJTVU5CWjBsRFFuQmFhVUZ2U1ZkT01XTnBOVE5oVnpWMVdsaEpkV0ZYTldwaVNGWnJXbGhOYjJSWVRteGphVFYxV1ZjeGJFdFRhMmRsTVhoMVRIazRaMGxEUVdkSlEwRm5XVmRPYWt4dVFqRmpNbWR2V1ROV2VVeHVaSEJpYlRWc1kybHNZMkpwT0haSlEwRm5TVU5DT1ZoSE5IWk1lVUZuU1VOQloyTnRWakJrV0VwMVNVZEdhbGw2ZEdOaWFUaDJTVU5CWjJaVGQyZFhNVEJ3VHpGNGRVeDVPR2RtVm5oMVdFYzFiV1JYTldwa1IyeDJZbWxDYldGWE5XdFViVlowV2xoT2NHTjVhREZqTWxaNVMxTkNOMWhITkdkSlNGcG9ZMmxDYW1JelZuVmtTRTFuVUZOQ01XTXlWbmxNYlZZeVdsYzFNR041TlcxaFYzZ3dXbGhKYjJGWVRrOWlNMUpZWVZjMWRWcFlTVzlrV0U1c1kybHJjRXh0TVdoalEyaHRaRmMxYW1SSGJIWmlhVUZ2V0ROS2JGcHBhMmRsTVhoMVNVTkJaMGxJV21oamFVSXpZVmMxZFZwWVNXZFFVMEptWTIxV2JVeHVaSEJpYlRWc1kycDBZMkpwUVdkSlEwSjVXbGhTTVdOdE5HZGtNbXgxWW0xV2VVOHhlSFZKUTBJNVMxTTFlVnBYVWpGWk1sVnZXbTVXZFZrelVuQmlNalJuUzBkRmMwbEhTWEJKU0hSalltbEJaMGxEUW5sYVdGSXhZMjAwWjFsVE5XcGlNalZxV1ZoUmIxbHBhemRZUnpSblNVZ3djMGxHZEdSTFV6VjVXbGRTTVZreVZXOWliVlowV2xoT2NHTXdUblprVnpVd1RFTkNZbGhUYXpkWVJ6VmpZbWxCWjJSdFJubEpSelZzWWxkV2VtRlhhMmRRVTBKcVlqTldkV1JJVFhWamJWWnJaRmRPYkV0SE5XeGlWMVo2WVZoT1VXRlhUbkphV0VselNVWjBaRXRVZEdOaWJIaDFTVU5DY0ZwcFFXOWliVlowV2xoT2NHRlROWE5hVnpWdVpFZG5aMUJVTURsSlJFRndTVWgwWTJKcFFXZEpRMEo1V2xoU01XTnROR2RZUTBwWVlqSTBaMXBZV214amJtd3dZVWRzZFZveGQybFBNWGgxU1VOQ09WaEhOV05pYVVGblkyMVdNR1JZU25WSlJ6VnNZbGRXZW1GWGEzVmlWMFozUzBkYU1XSnRUakJoVnpsMVNVTm9kVnBYTVd4ak1teDZTMU5DTjFoSE5HZEpRMEZuWTIxV01HUllTblZKUnpWc1lsZFdlbUZZVFhWaWJVWjBXbE5CY2tsRFkyZExRMk5uUzNsQ2RWcFhNV3hqTW14NlRHMU9kbVJYTlRCSlEzTm5TbmxyWjBwNmRHTmlhVUZuWmxOck4xaEhOVGxZUnpWalltMWFNV0p0VGpCaFZ6bDFTVVUxYkdKWFZucGhXRTF2V0ROS2JGcHFTWEJKU0hSalltbEJaMlJ0Um5sSlNGWjZXbGhKWjFCVFFtWmpiVlp0VFdrMU1XTXlWbmxQTVhoMVdFYzBaMGxJU214a1NGWjVZbWxDVTFwWFJtcGtRelZxWTIxV2FHUkhWa1ppUjFaMFdsYzFNRXRHZDJsYVIyd3lXRU5KYzBsSWMyZFpNbmhvWXpOT1QxbFhNV3hQYVVKalNXMDFiR0pYVm5waFdFNWpTV2xDT1V4RFFtTkphelZzWWxkV2VtRllUVFpKUm5kcFRFTkNiV0ZYTld0VWJWWjBXbGhPY0dONWFERmpNbFo1UzFOck4xaEhOVGxZUnpWalltMHhkbHBJVm5OYVV6VnNaVWhDZG1OdVVucEpSREJuVkcxV2RGcFlUbkJqZW5SalltazRka2w1UW5waU0xWjVXVEpXVGxsWVFuZGhWelZ1VmxaS1RWQlhVbWhrUjBVMldWaENkMkpIYkdwWldGSndZakkwZG1GdVRuWmlhblJwV1ZoT2JFNXFVWE5hV0d4TFRXeHdXVk51Y0doV2Vtd3hVMWR3ZG1WcmVFUlRiVEZvVmpOb2MxTlhjSFpoVlhkNFZtNXdZVmRGY0RaVVJFNURZakpHV0dReldtdE5hbXcxV1Zock5WcHNhM2xoU0ZwTllsVmFNRlJFU210TlYwWllaVWQwVFUwd05UVlhXR3MxWVcxSmVVMVlaR2xOYWxaeldXMDFVMlZyZDNsT1YzaHBWakZhTmxsV2FFNWtiVVpZVGxkMFlWZEhaREZaVnpWUFRrVnNjR1F5YkdwTmFtdDRXVEl4VDJKSFRqVlRWRnBZWlZWc01sWnNhRTlpUjA1MVZGaGFhbEl5YUhkWmEwMDFUVEpKZWxOdVNrMU5WR3h4V1ZWak5HUldiRmhOU0ZwaFRURmFkMWxyWkZKa2JVMTZVMjF3VFUxck5USlpiR2hEWkcxS2RGWnVWbXRUUlRFeVdXMHhWMlJHY0ZsVWJrSnFaVlJzZDFsdE1WTmlSMVpFVGxoR2FrMHlaSEJYUms0ellWZEtkRkp1VW1GWFJURndWREo0TUZwRmVFUlRibEphVjBWS00xbFdZekZpYlU0MVUxUmFTbUV3V2tOVlZsWkdZekZHVmxKclNsaFZNMmhEVlZaV1IxSkZPVFprUlVwU1ZsWmFjRlJGVm5OUmJFWldZVE5PVWxaVldrTlZNMncwVld4R1ZsSnJhRTFTVlZwRFZWWlZOR014VmxaU2EwcFNaVmhvUTFWV1ZrZFZSWGhHVW10S1VsWlZNWHBWVmxaSFVXeEdObVJGU2xKV1ZUQjZWVmRzTkZOc1JsWlNhM0JOVWxWYVExVldXbFpqTVd4V1VtdEtVMlZZYUVOVlZsWkhWVVY0UjFKclNsSldWVEY2VlZaV1IxRnNaRlJsUlVwU1ZsVmFSVlJGVmtkUmJFWldWRlJrVUUxRldrTlZiR2hoVWtWNFIxUnJTbEpXYXpGNlZWWldSMUZzV2pWbFJuQlNWbFZhUlZSRlZrZFJiRVpXWVhwa2FWWlZjRU5WVkVFd1l6RkdWbEpyU2xSbFdHaFJWVlpXUjFKcmVFWlNhMHBTVFRGS1JGUjZSbXRSYkVaV1QwaE9VazFGV2tOVldHdzBVV3hHVmxKcmVFMVNWRVpEVlZaV1RtTXhSbFpTYTBwVlZUTm9VVlZXVmtkU1JYaEdVbXRLVWxaclZucFdWRUpIVVd4R05XVkZTbEpXVlZwTFZFVldNRkZzU25OYU0wNVNWbFZhUlZwWGRFcGpNVVpXVW10S1ZXVllhRU5WVmxaT1RrWkdjR1ZGU2xKV1ZWcExWRVZXUjFGc1JsWlVXRTVTVmxWYVExVlliRFJSYkVaV1ZGaG9VbVZZYUVOVlZsWkhVa1Y0UmxKclNsSk5Semw2VlZaV1IxRnNSalpqZW1SUVpXNVNRMVZXVmxkU1ZYaEhWR3RLVWxack1YcFZWbFpIVVd4a1ZHVkhhRkpXVlZwRlZFVldSMUZzUmxaTlNFNVdWbFZhUTFWc1RqUlJiRVpXVW10d1RWSlVSa05WVmxaV1l6RkdWbEpyVW1wU1ZURjZWVlpXUjFGc1NsVmtSVFZTVmxWYVMxUkZWa2RSYkVaV1lUTk9WVTFGV2tOVmJtdzBVV3hHVmxKclVrMVNWbHBEVlZaV1RtTXhSbFpTYTBwVVZUTm9UVlZXVmtkU1JYaEdVbXRLVWxaVVFucFdWbFpIVVd4S1ZHVkZVbEpXVlZwRlZFVldSMUZzUmxaTlNFNVdWbFZhUTFWc1RqUlJiRVpXVW10d1RWSlZXa05WVmxaT1l6RkdWbEpyU2xKbFdHaERWVlpXUjFKRmVFWlNhMHBUVmtWYVJWUXpjREJVYkVaV1VtdHdUVkpWV2tOVlZsWnlZekZTVmxKclNsTlZNMmhEVlZaV1QxVXdlRVpTYTBwU1ZsZHpNMVpVUWtkUmJFWTFaVVZLVWxaVldrMVVSVnBQVVd4R1ZtRXpUbEpXVlZwRFZWaHNORkZzUmxaU2ExSk5VbFZhUTFWVVNtOVJNRGg0V2tWS1VsWlVhSHBWVmxaSFVXeFNWR1ZGU2xKV1ZWcEZWRVZXUjFGc1JYbGxSVTVOVWxWYVExVldWbXBqTVVaV1VtdGFVMUpJVFROVWVrWlBVV3hHVms5SVRsSldWVnBEVmtaT05GVkdSbFpTYTFKTlVsVmFRMVZXVlhkak1WRjNVbXRLVW1WWWFFZFZWbFpIVW10NFJsSnJTbEpXVjNSNlZrWldSMUZzU2xSbFJVcFNWbFZhUzFSRlZYaFJiRVpXVmxoT1VsWlZXa05WTTJ3MFZVWkdWbEpyV2sxU1ZWcERWVlpXVG1NeFJsWlNhMHBUVlROb1ExVldWa2RTUlhoR1VtdEtVbFpWTVhwVlZsWkhVa2RHY2xWWVRsSldWVnBEVlZod2VrNHdPSGRTYTBwVFZsWkdlbFpVUWtkUmJGWTFaVVZLVWxaVldtOVVSV1JQVVd4R1ZsUllUbEpXVlZwRFZraHNORlpHUmxaU2ExcE5VbFZhUTFWV1ZUUk9NVkpXVW10U2FHRXdNWHBWVmxaSFVXeFNOV1ZHU2xKV1ZWcEZWRVZXUjFGc1JsWk5TRTVYVFVWYVExVXpiRFJSYkVaV1VtdFNVRTFYZUVOVlZFcFNZekZHVmxKclNsUlZNMmhOVlZaV1UxZHJlRVpTYTBwU1RUSm9SRlJGVmtkUmJFWldUMGhPVWxaVldrTldSazQwVVd4R1ZsSnNRazFTVlZwRFZWWldUbU14UmxaU2EwcFNaVmhvUTFWV1ZrOU5iRVp4WkVkb1VsWlZXbGRVUlZaSFVXeEdWazlJVGxaV1ZWcERWVmhzTkZGc1JsWlNhMUpOVWxWYVExVldWazVqTVVsM1VtdEtVbVZZYUVOVlZsWkhWRVY0UjFKclNsSldWMDU2VlZaV1IxRnNValZsUmtwU1ZsVmFSVlJGVmtkUmJFWldZM3BrV2sxRldrVlVSRUpLWXpGRmQxSnJWbFZSTTJoRFZWWldSMlZzUmpWbFJVcFNWbFV4TmxWWWJEUlJiRVpXVW14Q1RWSlZXa05WVmxaeVl6RkdWbEpyU2xWbFdHaERWVlpXUjFKRmVFWlNhMHBTVmxVeGVsVldWa2RTUjA1eVUxUmtXbFpWV2tOV2JFNDBVV3hHVmxKc1FrMVNhMXBEVlZaV1RtTXhSbFpTYTBwU1pWaG9RMVZXVmtkU1JYaEdXa1ZLVWxaVk1YcFZWbFpIVVd4T05XVkdXbEpXVlZwTlZFVldSMUZzUmxaUFNFNVdWbFZhUTFWWWJEUlJiRVpXVW10NFVFMVhlRU5WVkVreFVrVjRSbEpyU2xKV1YzUjZWWHBDUjFKV1ZrUmxSVXBTVmxWWmVsVlliRFJSYkVaV1ZGUk9VbVZZYUVOVlZsWkhWVVY0UmxKclNsSldWRUo2VlZaV1IxRnNValZsUlVwU1ZsVmFSVlJGVmtkUmJFWldWRmhPVWxaVldrVlVWbFpLWXpGR1ZsSnJTbE5sV0doRFZWWldWMUpWT1RaamVtUldUVVZhVmxwR1ZrNWpNVVpXVW10U2EyRXdNWHBWVmxaSFZXeFNOV1ZGU2xKV1ZWcFJWRVZXUjFGc1JsWlVXRTVTVmxWYVJWbFhkRXBqTVVaV1VtdEtVbVZZYUVOVlZsWlhVbFY0UmxKclNsSldSMmhHVkVWV1IxRnNSalppUlZaTlVsVmFRMVZXVW1GUk1IaEdVbXRLVW1WdFVrUlVSVlpIVVd4R1ZWTnJUazFTVlZwRFZWaHdUMUV3ZUVaU2EwcFNWa1p3UlZSRlZrZFJiRVkyV2tWU1RWSlZXa05WVmxKaFVUQjRSbEpyU2xKbGJWSkVWRVZXUjFGc1JsZFNXRTVTVmxWYVJWWlhiRFJSYkVaV1VtNUtVbUZZYUVOVlZsWlBZekZHY0dWRlNsSldWVnBoVkVWV1IxRnNSWGhpTTA1U1ZsVmFRMVV4VW5wT01EazJZM3BrVUdWdVRUTlVNM0I2VGpBNU5tUkZTbEpXVmxwTVZFVmFUMUZzUmxkVVdFNVNWbFZhUTFadWJEUlhiRVpXVW10U1RWSlZXa05WVmxaeVRqRlNWbEpyVW1saE1HeDZWVlpXUjFGc1VsUmxSM0JTVmxWYVUxUkZWa2RSYkVaV1RVaE9WVTFGV2tOVldHdzBVV3hHVmxKck5VMVNWR3hEVlZaV1RtTXhSbFpTYTBwWFpWaG9ZVlZXVmtkU1JYaEdVbXRLVWxaWGRIcFZWbFpIVVd4R05XVkZTbEpXVlZwRlZFVlZOVkZzUmxaVVdFNVNWbFZhUTFWdWJEUmhiRVpXVW14b1RWSlZXa05WVmxaeVRqRldWbEpyVWsxTlJrWjZWVlpXUjFGc1VsUmxSbEpTVmxWYVNWUkZWa2RSYkVaV1lUTk9WRTFGV2tOVldHdzBVV3hHVmxKck5VMVNWVnBEVlZaV1RtTXhSbFpTYTFKc1lUQnJNMVpxUWtkU01WbzFaVVZLVWxaVldrdFVSVlpIVVd4R1dWUnJVazFTVlZwRFZWWmthMUV3ZUVaU2EwcFNUVEJ3UjFSRlZrZFJiRVYzVDBoT1VsWlZXa05XUms0MFVXeEdWbEpyVWsxU1ZWcERWVlJLV21NeFJsWlNhMHBTWlc1U1RWVldWa2RTUlhoR1VtdEtVbFpVUW5wWlZsWkxVV3hHVjFrelRsSldWVnBEVlZoc05GTkdSbFpTYTFwTlVsVmFRMVZXVms1T01WbDNVbXRTWVdGWWFFTlZWbFpIVWtWNFJsWnJTbEpXVlRGNlZWWldSMUZzVWxSbFJrSlNWbFpLVWxSRlZrZFJiRVpZV2tWT1RWSlZXa05WVkU1dlVUQjRSbEpyU2xKV01sSkVWRVZXUjFGc1JsWlVXRTVTVmxWYVExVlliRFJSYkVaV1VtdFNUVkpWV2tOVlZFNWhVVEI0UmxKclNsSldWMDB6VlhwQ1IxRnNTbFJsUlVwU1ZsVmFSMVJGVmtkUmJFWldWRmhPVkZaVldrTlZXR3cwVVd4R1ZsSnJOVTFTVkd4RFZWWldUbU14UmxaU2EwcFlWVE5vY1ZWV1ZrZFNhM2hHVW10S1VsWldWbnBWVmxaSFVXeEdOV1ZGU2xKV1ZWcEZWRVZXUjFGc1NsaGxSVkpOVWxWYVExVldWbFpPTURoM1RWVktVbFpYZEhwVlZsWkhVV3hTTldWR1dsSldWVnBKVkVWV1IxRnNSbFpOU0U1VlRVVmFRMVZZYkRSUmJFWldVbXMxVFZKVWJFTlZWbFpPWXpGR1ZsSnJTbHBWTTJoelZWWldSMUpyZUVaU2EwcFNWbFpXZWxWV1ZrZFJiRVkxWlVWS1VsWlZXa1ZVUlZaSFVXeEtWRTlWVWxCbGJsSlBWVlpXUjFOcmVFWlNhMHBTVmxSb2VsWldWa2RSYkVZMVpVVktVbFpWV2s5VVJWcHJVV3hHVm1NelRsSldWVnBEVlZoc05GTkdSbFpTYTFwTlVsVmFRMVZVVG05Uk1EaDRXa1ZLVWxaVWFIcFZWbFpIVVd4dmQxTllUbEpXVlZwRFZWaHNORkZzUmxaVVZFWlNZVmhvUTFWV1ZrZFRSWGhHVW10S1UxWldSVE5VTTNBd1ZrWkdWbEpzUWsxU1ZWcERWVlpWTkdNeFZsWlNhMHBTWlZob1ExVldWa2RUUlhoSVZHdEtVbFp0VG5wVlZsWkhVV3hTTldWR1VsSldWVnBIVkVWV1IxRnNSWHBSYTFKUVRWZFNRMVZXVlRSak1VWldVbXRLVldWWWFGTlZWbFpIVWtWNFJsSnJTbEpXVjNSNlZrUkNSMUZzU2pWbFJVcFNWbFZhUzFSRlZUVlJiRVpXV1ROT1VsWlZXa05XU0d3MFZXeEdWbEpyVWsxU1ZWcERWVlpXZW1NeFZsWlNiVEZwWVRCc2VsVldWa2RTUjFaeVUxaE9VbFpWV205WmJGWktZekZHVmxKclVrOVNWV3g2VlZaV1IxRnNUbFJsUlVwU1ZsVmFSVlJGVmtkUmJFVjVUbFZXVFZKVldrTlZWbFpPWXpGR1ZsSnJTbEpsV0doRFZWWldUMVJWZUVaU2EwcFNWbFV3TTFRemNIcE9NVVpXVW10YVUxRXphRlZWVmxaSFZrVjRSbEpyU2xKV1ZHaDZWbFpXUjFGc1JqVmxSVXBTVmxWYVRWUkZWVFZSYkVaV1ZsaE9VbFpWV2tWYVZWWktZekZHVmxKclNsTldTRkpQVlZaV1IxTnJlRVpTYTBwU1ZsZDBlbFpFUWtkUmJFbzFaVVZLVWxaVldrMVVSVlY0VVd4R1ZsUllUbEpXVlZwRFZURk9ORkZzUmxaU2ExSk5VbFZhUTFWc2FGTlJNRGsyWkVaU1VsWlZXbEZVUlZaSFVXeEdWbU16VGxWV1ZWcERWVmhzTkZGc1JsWlNiV2hOVWpBMVExVldWazVqTVVaV1VtdEtWR1ZZYUZGVlZsWkhVbXQ0UmxaclNsSldWbFo2VlZaV1IxRnNWalZsUm1oU1ZsVmFSMVJGVmtkUmJFWlhWRmhPVWxaVldrTlZiRTQwWVVaR1ZsSnJXazFTVlZwRFZWWmFhbU14YkZaU2EwcFRWVE5vUTFWV1ZrZFhSWGhIWWtWS1VsWlZNWHBWVmxaSFVXeE9WR1ZGU2xKV1ZWcEZWRVZXUjFGc1JsWlVXRTVTVmxWYVExVlliRFJSYkVaV1ZGUldVMkZZYUVOVlZsWkhVa1U1Tm1ONlpGSldWVnBIVld0T05GRnNSbFpTYXpWTlVsUnNRMVZXVms1ak1VWldVbXRLVldWWWFGZFZWbFpIVTBWNFJsSnJTbEpXVkdoNlZWWldSMUZzUmpWbFJVcFNWbFUwTWxWWGJFcGpNR3gxVkc1YWExZEZjSEZYYkdoUFVrZEplVTVVUW1GV2VsVjNVMWR3ZDFscmJITmtNbXhyVjBVMWMxTlZhRTlOUjA1MFlrZHdhMUp1WkhCVWVrWTBaRlpvU0U1VVNscFhSV3h1VmxjeFYyRkdhM3BWVjJSUlZUQktOVmRzYUVkTlYwWlpVMjE0VEZFeVVqVlhiR1JIWVcxU1JGa3pRbEJOV0dneFdrY3hSMlZWYkVoVWJrNWFWMFUxTmxaSE1VZGtSbkJaVkZka1VWVXdTalZYYkdoSFRWZEdXVk50ZUV4Uk1sSnhXV3RrUjJWdFRYbE9WMmhwVmpGYU5sTnViSEpPTVdoSVRsZE9hV0pXYjNoWmJURlBUVWRHV0U5WVZrcFNNbmcyVmtjd05VMUdXWGxpU0ZacFlsWmFOVk13YUZkbGJIQlpVMWhDU2xOSVVtcFpiV3hDV2pKT2RGWnFRbXRYUlhBeFUxVmtZVTFYU25SVWFrSm9WbnBzTVZOVlRtOWlSMUowVm01V2ExRXlkRzVhVkVZMFpGVnNSRkZYWkVwVFJYQnpXa1ZvVjJWWFNuQlJWMmhoVjBad2MxbHROVkprVjFGNVlraFdhV0pXV2pWVVJ6RnpaRlpyZVdWRVJtRlNNVm8yVXpCb1YyVnNjRmxUV0ZacFlsVmFNRmRzVG5KT01XaElUa2RrU2xORVFUTlhSV014VDFab1NFNVhUbWxpVm05NFdXMHhUMDFIUmxoUFdGWktVbnBXYzFsc1pGZGxiVVpaVkd0U2FVMHhXakZhUlU1dllXMUplbFp1Vm10VFJURjZVMVZvVjJWc2NGbFRXRUpLVTBoU2FsbHRiRUphTWxKMFVtNXNTbEl4Y0hkWmJURlNXakZDVkZGdFdrMWlWbkIzV1cweFVtSXhhM2xQVkVacFlteEtObFJGVGtOWmEyOTVUbGRvYVZZeFZuVlVSVTVEVFZkTmVWWnViRmxWTW5NelYwVmpNVmt5U25CUlYyUm9WakZzYmxNd1pHRmpSMHAwVlZoQ1NsTklVbXBaYld4Q1dqQnNSRkZ0TVdoV2VsWnlWRWN4VDJSdFVsaE9WRUpLVVROTk5WTlZVa1pPTVdoSVRrZGtTbEV3Um01Wk1qRlhUVWRTV1ZOdVZrcFNNRFV5V2taak1VMUhUalprUjA1cFlWVkdibHBzV2pSa1ZtaElUa2RrU2xORmNITmFSV2hYWlZkS2NGRnRjR2xOTVZveFdrVm9UbVJXYTNsUFdGWmFUV3RaZDFNd2FIcGFNa3AwVW01U1lWWkhPVzVhUm1oUFlrZE9jR1F5WkZwTmFtdDRXVzAxVWs1cmJFVlNWMlJ0VlRKek0xZEZZekZQVm1oSVRsZE9hV0pXYjNoWmJURlBUVWRHV0U5WVZrcFNlbFp6V1d4a1YyVnRSbGxVYkVab1ZqQTFlVmRzYUVwaU1rcDBWbTVTWVZkRk5YZFpWazR6V2pKS2RGWnVVbUZYUlRWM1dUTnNjbG95VlhobFNGWktVVEJLZDFkdGJFSmlNa3AwVm01U1lWZEZOWGRaVmsweFl6RndXRTVYTld0U01tUnVWVVpSZDA5VmJFVlJXRUpLVTBoU2FsbHRiRUphTUd4RVVXNVdZVlo2Um5OWmVrcHpZMFY0ZFZGcVJtcE5iV1IyV1cweFYyUkdjRmxVYmtKcVpWZHpNMWRGWXpCYU1HeEpUVWRrWVZZemFEWlhiRTVEWTBad2NGRlhPV2xpVmxvd1YyeG9UMk5IUmxkak0yUlpWWHBXY1ZscVRsZGtWMUpFVVZSb1NsSjZWbk5aYkdSWFpXMUdXVlJZVmxwTmFtdDRXVzAxVW1ORmJFbGtSMDVwWVZWR2JsTlZUa05rVm5CWVRWZDRhazF0ZUhkVFZWRjNXakZqZVU1WGVHbFdNVm8yV1Zab1QxcEZPSGhsU0ZaS1VUQkpOVk5WWkZkak1rMTVWbGRrYUZZeGJHNVRNR014WWtkS1dGWnVjR2hXTW5ocFZGVlpkMlJXYTNsUFZFWnBZbXhHYmxWR1VYZFBWV3hJVGxkNGFWWXhXalpaVm1oT1pGWnJlVTlVUm1saWJFWjNVMVZvTUZreVNuQlJWMlJLVVRCS01WZHNZM2hpUjAxNVlraENUV0pyU1hoWmVrcHVZakpLZEZadVVtRlhSVFYzV1ROc2NrNHhhRWhPUjJSS1UwUkdhbGx0ZURSa1ZXeEVVVzVzWVZkR1NYaFpNakF3V2pKS2RGWnVVbUZYUlRWM1dWWlNNRmt5U25WTlYwNXBZa2hvTVZSSWF6UmFNVXBaWVVoa1lWZEZjSGRaYkdSWFpGZFNSRkZxUW1sbFZVb3dWMnhvUzJKc2NGUlJha0pvVWpGV2JsZHRNWE5sVjAxNlZWZGtZV0pYZUhwYVJXUlhaVlZzU0ZKdVZtRlJNRW93VjFab1Fsb3lTWGxYVjJSaFlsZDRNVmRyVlRGaVIwcFlWbTV3YUZkRk5XcFpiV3MwWkd0c1NGZHFSbWxpVlRSM1dWWmpOV1JWYkVoWGJrSnBVMFpLYzFreWMzaGhSMDVFWVVSR2FrMXNXalZUTVU1RFRqRm9TRTVJV2sxbFZVWnVVMVZvUzJKSFVrbFdibXhwWVZWR2RsZFdaRTloYTNoRVVXMXdhMWRGYkhkVFZWRjNTekJzU1dSSFRtbGhWR2d5VTFWT1Fsb3diRVJSYmtKaFlWVkdkbE5XWkU5TlYwNXdUbFJPYUZaNlZqRlhiR2hLWkZkR1dFNVhjR2xUUmxweVYyeG9UbUl5VWxsVWJYaHFZVlJXTVZkV1kzaGlSWFJVWVRKa2JFMVlhREZVU0dzMFdqQnNSRkZYWkVwUk1FWnVWMVprVDJGcmVIVlJha1pxVFcxa2RsZFVUbGRsVlhoMVdraENhV0pVVm5OWk1teHpXVEpLY0U5SVdrcFJNRVp1VTFWT1EwOVdhRWhPU0ZwTlpWVkdibE5WVGtKYU1rNTBWbXBDYTFkRmNERlRWV1JIWVd4c05tUkhUbWxoVkdneVUxVk9RbG95V2xSa01tUllUVlJDZDFSNlJqUmtWWGcxVDBka2JWWnVhREZYUldNeFlsZFNXRTVYY0d0U01uZ3lXVzFzUTJKWFJsaE9WM1JWWWxaYU1GZHNhRTlqUjA0MVlVUkdhazFzV2pWVE1VNURUakZvU0U1SFpFcFRSbkJ2V1RKc1EyRnRTWHBXYmxaclUwVXhibFZHVGtOTlYwMTVWbTVzVFdKV1dYbFhiR014VFVkT05VNVhNV2hXTTJkM1YyeG9TbUl5UmxsVWF6bHBUVEZLV1ZsV1l6RmtWbkJaVTFjNWExZEZOWE5aTW14eVkwVjRkRTFYYUdwUk1taDBXa1pqTVdGdFVraGlTRnBwWVZWR2RsZEVUa3RpUm5Cd1lUSmtiRTFZYURGVFZVNUNXakJzU1ZkdGFHcGhWVWw2V1Zaak1XUldjRmxUVjJSUlZUQktiVmt5TVZkaVZYaDFXa2hDYVdKVVZuTlpNbkF3V1RKS2NGRlhaRXBSTUVvMVYyeG9VMDFYVG5ST1IyUnJUVzE0TVZsdE1WZGxWVGg0WlVoV1NsRXdTVFZUTVUweFpWWndXRlZxUmxwTmJGWjJWMjAxVjJSV2EzcFZia0pwVFdwU2JsTXdaRVpqTUd4SVUxaENTbE5JVW1wWmJXeENXakJzUkZGdWJHRlhSa2w0V1RJd01Gb3hiRlJPVjNCcFRXcFdjVmRXYUZKaU1XeHdZWHBrV1ZKNlVtNVRWV2QzWXpCc1IyUkhVa3hWZWxZMVYyeGtVMDFXYTNsV1Z6bHBZbFphTUZkc2FFOWpSMDEzVkc1YWExWjZWWGRVUlU1RFdXeG9WR0Y2WkZsU2VsWnFXVzFzUWxveVVuUlNibXhLVW5wV2MxbHNaRmRsYlVaWVlUSmtVVlV3U25GWmFrNVhaRmRTU1ZSWVZtcGlWbHB5V2taa1QySkZkRWhPVjNocFZqRmFObGxXYUU5VlYwWllWRzVLWVZkRmJIcFRWVm93V2tWMFZXUkhUbWxpU0dneFUxVk9RMk5HY0hCUlZ6bHBZbFphTUZkc2FFOWpSMFpVVGxoT1lWWjZWblZhUldSdVdqRkNWVTFFYkVwU1JVWjNVMVZvTUZreVNuQlJWMlJLVVRCS05WZHNhRk5OVjA1MFRrZGtXVkV3Y0ZsWmFra3dXakZ3V1ZkdGVHcGliWGQzV1ZWa2MyUldiM2hrTW14UVRWaG9NVk5WVGtOUFZtaElUbGRPYVdGVlJtNVpNakZYVFVkU1dWTnVWa3BTZWxaeldXeGtWMlZ0UmxoaE0xWnBWakJhTTFNd1pHRk5WMHAwVkdwQ2FGWjZiREZUVlU1dlpGWndXRTFYZUdwTmJYZzJVekZPUTA0eGFFaE9SMlJLVVRCR2Jsa3lNVmROUjFKWlUyNVdTbEo2Vm5OWmJHUlhaVzFHV1ZSWVZtbGlWVm93VjJ4T1FtTnJiRVJaTW1STVVUSk9ibE16YkVOa1ZuQllUVmQ0YWsxdGVEWlVSekZQWkcxU1dFNVVRa3BSTTA1dVUyNXNjbG93Y0Raa1IwNXBZVlZHYmxwc1RuSk9NV2hJVGxSc1dWSjZWbXBaYlRGaFRWZEtkRlJxUW1oV2Vtd3hVMVZWTVdKSFNsaFdibkJvVjBVeGRsZEVUa3RpUm5CeFUxaENTbE5JVW1wWmJXeENXakpTZEZKdWJFcFRSbG8yVjJ4b1Nsb3hRbFJSYlZwcVlsWmFkRlJYYXpGTlYwMTVWbTVzVUUxWWFERlhSV013V2pCc1NWTnRlR3RUUmxvMVdXMXNRMVV4Y0ZoU2JYQnJVWHBXY1ZreU1WZGhSMUpJVm10YWFWSXhXakJYYkdNeFRVVjBSMlF5YkdGU01uZDVWMFZPU21Nd2JFbGpNbVJhVFc1b2IxbDZUazlVTVd4WVRWZDRVR0ZWU21wVFZ6QXhZa2RLV0ZadWNHaFhSVFZxVTFkc1EwOVZlRVJSYlU1S1lYcFdjMWxzWkZkbGJVWlpWRlJhU2xKdVpIQlVSVTVEWWxkR1dFNVhkRlZpVmxvd1YyeG9UMk5IVGpWaFJFWnFUV3hhTlZNeFRuSk9NV2hJVGxSc1dWSjZWbXBaYlRCNFpHeHdTVlp1VG1GVmVsWnpXbFZvUTJSdFRuVlZibkJLVWtSQ2JsWkhNVmRrUm5CWlZHNUNhbVZ1VW1wWmJXczBaR3RzTlZGdWNHbE5NVm8xVjFSS1YxUnNiRmxSYm1Sb1ZucFdkVlpzV2t0VVZrSllWVzFvYTFJd1ZUSlhWbWhEWkRKS1NHSkhjRnBYUmtwM1dXcEpNR1J0Um5WVWJscHBZVzVTY0ZkV2FFOWlSVFZ4VlZoT1lWZEhlRXhVVjNoM1YxWk9kV05IYUZkbGJYZDRWVEZrZDJSdFZuSmxSVkpVWWxSR2IxWnFUbTlqTVU1WVkwaGFhRlpZWkRSV2JUVjNXVlprUm1ORVdsVlNSVFZFV1dwS1IxZEhVWHBYYlhST1lXMTNNVmRXYUhKT1ZuQnpZVE5zYUZOR2NFNVpiRlpoVFVaU1JWTnRkRTVXTUZwWldsVmtNRlJWTUhkT1ZGWllWMGR6TVZsWE1VcGxWVEZaV2tkc1RtRnNXbnBYVnpBeFZUSldjbVF6YkU5V00yaHdWbXBHWVU1c2JGZGhSVFZyWWxWYVdWUnNaREJaVm1SSVdrUkdXbFo2VmxCVWExWnpZMGRSZVdKSGNFNWhiWFEwVjFSSmVGUXlTa2hVYWxaVVZrWndXVnBXVm5OTmJGcHpZVVU1YVZJd05URldSbWhoWVd4SmVXRklaRnBoTURBeFZGUktTbVZzVG5WVGF6Rk9Wa2Q0ZUZkV1ZtcE9SMUpYWWtab1RsTkdjR2hVVkVaaFpERnNjbHBHU210aVZURTJWVEl4ZDFSVk1YSk9WRXBhWWtkb1JGcEhNVXRrUmxwMVZtMTBWRkpVUlhsWFZ6QjRWakpTUjJOR2JGVmlhMHB4V2xaU2MyUXhiSFJOVms1cFVqRmFSVlJzYUVkaGF6QjVXa2hDV0ZKck5IcFpWbVJMWkVaS2RWVnRSbGhTVkVaM1ZrUktORTFHY0VabFJWSlVZbXhLWVZZd1ZrdE5NV3hYV1hwR2FXSlZOREZWTVZKaFUyMUZkMWRyVGxaV2JGcEhXWHBHUjFac1NuSlRiR2hXVFRKb1JGWldXbGRTTVVwR1QxUmFhMUpWY0ZOV2JGcGhZMFpTUmxadVRsSmlSVnBYV1ZST1QxVnNXbFpYYTA1V1RUSjNNRlpYZUVkV2JFcHlZVVV4VTFaV2NFUldWbHBXVGtkTmVGWnNXbE5oTUhCVFdsWm9iMUV4VmxkV2EyUldVbGhvUjFWdGRFdFZiRnBXVFZod1ZsWnNXa2hWVjNoSFRtMVNSbE5zU2xkV1ZFSTJWbFprYzA1R1RuTlNiRnBUWVROQ1RsVnNWbUZSTVZaWFYyeGFhazFYZUZkVmJYUkxWVEpXV1dGRlRsWldiRnBJVmxWV05GSXhTbkpUYkVwWFZsUkdObFpXV2xkU01VWnpXa1pTYkZKVmNGTldiRlpoVWxaU1JsWnJaRkppUlZwWFZrWlNhMVZGTVVaWGEwNVdZa2RvYUZWclZqUlNNVkp5VTJ4S1YyRjZSalpXVmxwWFVqRkdjMWRxVm14U2JrSlRWbXhXWVZKV1VrWldhMlJTWWtWYVYxbFljR3RoVmxwV1kwVk9WbFpGUlhkWmVrWkhWbXhLY2xOc1VteFhSMmhTVmxaYVYxSXhTbkpsUlZwVFlUQndVMVJVUmt0U1JsSTJVbTEwVW1KRldsZFVNR2hQVldzeFJsZHJUbFpYUjNjd1ZWZDRSMVpzU25KbFJURlRWa1ZhUkZaV1dsZFViVTE0VW14YVUyRXdjRlpXVkU1dlZWWldWMVpyWkZOU1dHaEhWVzEwUzFWc1duSldibkJYVmtWS1NGVlhlRWRPVjFaR1UyeEtWMVpXY0V4V1JWWlhUVVpHYzFOdVRtRk5NRFZUVm14V1lWSldjRmhrUlhCcVRWVmFWMVZ0ZEV0V1YxWlpZVVZPVmxac1drOVVhMXBIWTBkV1JsTnNTbGRXVm5CTVZrVldWMUl4Um5OU2JGcFZWMFUxVTFac1ZtRlJNVlpaWWtSU1VtSkZXbGRXUm1odlZXMVdXV0ZGVGxaV2JGcElWV3RXTkZKc1NuSlRiRXBPVW5wc05sWldXbGRTTVVaelVtcGFhbVZ0VWxGYVZ6VlRVVEZXVjFac1pGTldXR2hJVmtkMFMxVnNXbkpOV0hCV1ZteGFTRlZYZUd0V1IxWklZVVpLVjFaV2NFWldSVlpYVWpGR2MxSnNXazVUUlRWWFZteFdZVkV4Vm5OVWFsSlNZa1ZhVjFWdGRIZFVWa3BWVW10T1ZsWnNXbGRaZWtaSFZteEtjbFZ0Y0ZOV1ZFWTJWbFphVjFJeFJuTlRiRlpyVWxSV1UxWnNWbUZUTVZKR1ZtdGtVbUpGV2xkWlZFNVBWbFV4UmxkclRsWmliWGN3VlZkNFIxWnNTbkpWYXpGVFZteHdSRlpXV2xkVWJVMTRVbXhhVTJFd2NGVldWRTV2VkZaV1YxWnJaRk5TV0doSFZXMTBTMVZzV2xWUmJuQlhWbXhhU0ZWWGVFdFdSMVpHVld4S1YxWldjRVpXUlZaWFVqRkdjMUpzV2s1VFJUVlhWbXhXWVZFeFZuTlVhbEpTWWtWYVYxVnRkSGRVVmtwV1YydE9WbFpzV2s5WmVrWkhWbXhLY2xOc1NteFhSMmhFVmxaYVYxSXhTa1psUlZwVFlUQndWRlpyVm1GU1ZsRjZZMFJDVldKRldsZFZiWFIzVkZaS1ZsZHJUbFpXYkZwNVdYcEdVMVpzU25KVGJFNVdUVEpvUkZaV1dsZFVNVlYzWlVWYVUyRXdjRk5XYkdSNlRURmFWVkZyWkZKaVJWa3hXbFZXUzFWc1dsWlhhekZWVWxad1VGVlhlRWRXYlVWNlZHeEtWMVpXY0VSV1ZtaHpUa1pHYzFKc1dsTmhNVXBPVld4V1lWRXhWbFZUYlRsU1RVUm9ORmRyVmt0VmJGcFZZVWh3Vmxac1draFZWM2hUVmtkV1JsTnNTbGRXVm5CR1ZrVldWMUl4Um5OU1dHeHNVbFUxVGxWc1ZtRlJNVlpYVm0xd2FrMVZXbGRWYlhSaFZURktTVlJVVGxWbGExcFFWVmQ0UjFack9VbFViRXBYVmxad1JGWnJXazlPUmxaSFVteGFVMkV4U2s1VmJGWmhVVEZXVjFaWVpHcE5Wa1l6VlcxMFMxVnRWbGxoUldSV1ZteGFTRlZ0ZERSU2JFcHlVMnhLVjFZelVqWldhMXBYVWpGR2MxTnNVbXhTVlhCVFZteFdZVk14VWtaV1dHaFNZa1ZhVjFac2FFOVZiRnBXVjJ0T1ZrMHlkekJXVlZwSFZteEtjbGRyTVZOV1ZuQkVWbFphVjFSdFRYaFNiRnBUWVRCd1ZGWlVUbTlSTVZaWFZtdGtVMUpZYUVkVmJYUkxWV3hhVmsxWWNGWldiRnBJVld0a1IyTnNWbGxVYkVwWFZsWndSRlpXYUhkbGF6UjNUMGhrVTJFd2NGUldiRnBIWld4YVZWRnJaRkppUmxreFdsVldTMVZzV2xaWGJUbFZVbGRTVUZWWGVFZFdiRkpaVkd4S1YxWldjRVJXYTJoelRrWmFSMUpzV2xOaE1YQk9WV3hXWVZFeFZsZFdWRkpQVFZaS1YxVnRkRk5oUjBWM1RWaHdWbFpzV2toVlYzaFRUbGRXUjFOc1NsZFdWbkJHVmtWV1YxSXhSbk5TYkZwT1UwVTFXRlJWVm1GUk1WVjZZa1JTVW1KRldsZFZiWFJUVlVVeFdHVkZUbFpXUlhCVFdYcEdSMVpzU25KVGJGSldUVEpvVGxaV1dsZFZNV1J5WlVWYVUyRXdjRk5VVkVwdlVrWlNSbFpyWkZKaVJWcFhWREJvVDFWc1dsWlhhMDVYVW1zME1GVlhlRWRXYkVwelVXc3hVMVpXY0VSV1ZscFhWRzFOZUZKc1dsTmhNSEJUV2xab2IxRXhWbGRXYXpsT1lrVmFlRnBGWkc5VmJGcFdWMnhrVlZKV1draFZWM2hIVm1zNVNWUnNXbGRXVm5CRVZsWm9jMDVHUm5OU2JGcFRZVEZLVGxWc1ZtRlJNVlpYVm1zMWFrMVZiRE5WYlhSTFZXMVdXV0ZGVGxaV2JGcElWa1ZXTkZJeFNuSlRiRXBYVmpBMU5sWldXbGRTTVVaelZXcFdiRkpyY0ZOV2JGWmhVbFpTUmxaclpGSmlSVnBYV1ROd2ExZHJNVVpYYTFaVlVrVktTMWw2Umtaa01VcHlWbXhXVWsweWFFUldWbHBYVWpKV2MxSnFWbXhTVlhCVFZteFZlRTVzVmxsaVJGSlNZa1ZhVjFWdGVFTlVWa3BXVjJ0T1ZsWnNXbmxaZWtaSFZteEtjbE5zVm14WFIyaEVWbFphVjFJeFNrWmxSVnBUWVRCd1UxWnNWWGhsYkZaWFZtdGtVMUl3TlhsVk1WSnJWMnhhVmxkclRsZGlSVFF3VlZkNFIxWnNTbk5SYXpGVFlURndSRlpXV2xkVWJVMTRVbXhhVTJFd2NGTmFWbWh2VVRGV1YxWnJaRk5TV0doSFYydFdTMVZzV2xaTldIQldWbXhhU0ZWWGVFOU9WMVpIVjJ4S1YxWldjRTVXUlZaWFVqRkdjMUpzV2xCVFJUVlhWbXhXWVZFeFZsbGlSRkpTWWtWYVYxVnRkRFJWUlRGWVpVVk9WbFpGYTNoVmExWTBVbXhLY2xOc1NsZFdNMUkyVmxod1ExSXhTbGRXYTFKc1VsVndVMVpzVmxwbGJGWlpZa1JTVW1KRldsZFdSbEpQVlcxV1dXRkZUbFpXYkZwSVZsVldORkpzU25KVGJFcFhWa1ZLTmxaV1dsZFNNVVp6VldwV2JGSlZjRk5XYkZaaFVsWlNSbFpyWkZKaVJWcFhWa1pvVDFWc1dsWlhhMVpWVm14YVMxbDZSa2RXYkVweVUyeE9iRmRIYUVSV1ZscFhWakZLVms5VVdtcGxiVkpYVkZWV1lWWnNjRWRXYXpWcVRWVmFWMVZ0ZEZOaE1rVjNUVmh3Vmxac1draFdWM2hUVGxkV1JsTnNTbGRXVm5CU1ZrVldWMUl4Um5OU2JGcFZWMFUxVTFac1ZtRlNWbXhZWkVWd2FrMVZXbGRWYlhSTFZXMVdXV0ZGVGxaV2JGcFlWV3hXTkZKc1NuSlRiRXBYVWpKb1IxWkZWbGRTTVVaelVtcGFhVkpXV2s1VmJGWmhVVEZXVjFWdFJsSk5TR2hIVlcxMFMxVnRWblJWYTFKVlVsWmFTRlZYZUVkV1ZrNXlWR3N4VTFaV2NFUldWbWgzVkRGRmQyVkZXbE5oTUhCVFZtdGFkMUpXVWtaV2EyUlNZa1ZaTWxkclZsTlVWa3BXVjJ0T1ZsWnNTbWhWVkVJMFVteEtjbE5zU214aVZrcEZWa1ZXVjFJeFJuTlNiR1JUVjBVMVUxWnNWbUZTVmxwWVlrUlNVbUpGV2xkVmJUVkxWVzFHV1dGRlRsWldiRnBRV1hwR1IyTkhWa1pUYkVwWFZsWndhRlpGVmxkU01VWnpVbGhvYVUwd05WTldiRlpoVVRGVmVGVnVjRTlOUkdzeVdUTndhMVZIVm5WVVZFNVZUVE5DTmxScVFUVk9iVkpHVTJ4S1YxWnNjRTFXUlZaaFZERkdjMUpzWkZWWFJUVlRWbXhXWVZFeFduVmlSRkpZWWtWYVYxVnRkRk5VVmtwV1YydE9WbFpzV25sVWFrWlRWbXhLY2xWdGJHaE5SM2cyVmxaYVYxSXhSbk5WYkZKc1VqTkNVMVpzVm1GVk1WSkdWbXRrVW1KRldsZFVWV2hQVmxVeFJsZHJUbFpYUjNjd1ZWZDRSMVpzU25KT1ZURlRWa2Q0UkZaV1dsZFViVTE0VW14YVUyRXdjRmhhVm1odldWWldWMVpyWkZOU1dHaEhWVzEwUzFWc1dsaGtTSEJXVm14YVNGVlhlRWRPVjFaR1UyeEtWMVpXY0VaV1JWWldUbFpHYzFKc1dsVlhSVFZUVm14V1lWRXhWblZpUkZKb1lrVmFWMVZ0ZUc5VVZrcFdWMnRPVmxac1dubFVha1pYVm14S2NsVnJNVTVTYTFvMlZsWmFWMUl4Um5OVmJGSnNVbXhLVTFac1ZtRlRWbEpHVm10a1VtSkZXbGRaVkU1UFZrVXhSbGRyVGxaWFIzY3dWVmQ0UjFac1NuSk9WVEZUVmxad1JGWldXbGRVYlUxNFVteGFVMkV4U25OWlZFSnlUVEZhY1ZGclpGTk5WbTh4V2xWV1MxVnNXbFpYYTNSVlVsWmFTRlZYZUVkWFZsSnlWV3N4VTFaV2NFUldWbHByWVRGRmQyVkZXbE5oTUhCVFZGUkNkMUl4VWtaV2EyUlNZa1ZXTTFRd2FFOVZiRnBXVjJ0T1YxSnJOREJWVjNoSFZteEtjbFZyTVZOV1ZuQkVWbFpTUzFkdFRYaFNiRnBUWVRCd1UxcFhOVk5VVmxaWFZtdGtVMUpZYUVkVmJYUkxWV3hhVlZGdWNGcFdiRnBNVlZkNFIxWXhhM3BVYkVwWFZsWndSRlpXYUhOT1JrNUhVbXhhVTJFeGNFNVZiRlpoVVRGV1YxWnJOVTlOVm13elZXMTBVMWxYUmxsaFJVNVdWbXhhU0ZWclZqUlNiRnB5VTJ4S1YxWlVSalpXVmxwWFVqRkdjMVZzVW14U2EwcFRWbXhhUzFWc1VrWldhMlJTWWtWYVdWZHJWazlVVmtwV1YydE9WbFpGTlhaVlZFSTBVbXhLY2xOc1NsZE5iRXBGVmtWV1YxSXhSbk5TYkZwVlYwVTFVMVpzVm1GUk1WWlpZa1JTVW1KRldsZFZiWFJUVkZaS1ZsZHJUbFpXUlRWb1ZWUkNORkpzU25KVGJFcFhWakF3ZWxaWWNFTlNNVVp6VTJ4U2JGSlZjRk5XYkZaaFVqRlNSbFpyWkZKaVJWcFhWa1pvVDFaR1dsWlhhMDVXVjBkM01GVlhlRWRXYkVweVRsVXhVMVpIZUVSV1ZscFhWRzFOZUZKc1dsTmhNSEJaVmxST2IyTldWbGRXYTJSVFlUTm9SMVZ0ZEV0VmJGcFhWbTV3Vmxac1draFZWM2hIVGxkV1JsTnNTbGRXVm5CR1ZrVldWMUl4Um5OVGJHaHNVbFpLVGxWc1ZtRlJNVlpYVm14YVQwMUVhRE5VVmxaTFZXeGFXR1JJY0ZaV2JGcElWVmQ0VTA1WFZrZFhiRXBYVmxad1NsWkZWbGRTTVVaelVteGFUbE5GTlZaVVZWWmhVVEZXV1dKRVVsSmlSVnBYVlcxek1WUldTbFZpUlU1V1ZteGFUMWw2UmtkV2JFcHlVMnh3VmsweWFIcFdWbHBYVWpGS2NtVkZXbE5oTUhCVFZteGFWMlZzVmxkV2EyUlNZa1ZaTVZwVlZrdFZiRnBXVjJ0V1ZWSldXa2hWVjNoTFZrVTVWbFZzUW14aWJFcFFWbFphVjFJeFRuSmxSVnBUWVRCd1UxWnNVbTlsYkZwWFZtdGtVbUpGV1RGYVZWWkxWV3hhVmxkck9WVlNWbkJ5VlZkNFIxWnRUWHBVYkVwWFZsWndSRlpXYUhOT1JrNUhVbXhhVTJFeGNFNVZiRlpoVVRGV1ZWUnRPVkpOUkdnMFYydFdTMVZzV2xWaFNIQldWbXhhU0ZWWGVIWmtNVTVaVkd4S1YxWldjRVJXVm1oelRrWkdjMUpzV2xWV1JWcFRXVlpvYjFFeFZsZFdhMlJVVWxob1IxVnRkRXRWTVZwWFVsUk9WVTB6UVhkV2ExcEhWbXhLYzFGck1WTldWbkJFVmxaYVZrNUhUWGhXYkZwVFlUQndVMXBXYUc5Uk1WWlhWbXRrVkZKWWFFbFdSM1JMVld4YWRGUnVjRlpXYkZwSVZWZDRVMDVYVmtkVmJFcFhWbFp3U0ZaRlZsZFNNVVp6VWxod1VtRXhTbEZVVm1SVFVURldWMVpVVW1wTlZWcFhWVzEwUzFaWFZsbGhSazVXVm14YVNGVnJWalJTYkVweVUyeEtWMVl6VWpaV2ExSkRVakZHYzFOcVZteFNWWEJUVm14V1lWTXhVa1pXVkZaU1lrVmFWMWRVVGs5VmJGcFdWMnRPVjFOSGR6QldWM2hIVm14S2NsVnJNVk5XVm5CRVZsWmFWMlZ0VFhoV2JGcFRZbFJHY0ZsVVFuTmxiRlpYVm10a1UxSXhXbmxWTVdoUFZXeGFWbGR0T1ZwaVJscExXWHBHUjFac1NuSlZhemxUVmxkNE5sWldXbGRTTVVaelZHeFNiRkpWY0ZOV2JGWmhVbFpTUmxaclpGSmlSVlkxVkd4V1YxUldTbFpYYTA1V1ZteGFUMWw2UmtkV2JFcHlVMnhLYkZkSGFFUldWbHBYVkRGU1ZtVkZXbE5oTUhCVFZteFZkMDB4VVhwalNIQlBUVlZhVjFWdGRHRlZNVVY2WVVaV1ZsWnNXa2hXYTFZMFVteEtjbE5zU2xkV1IyZzJWbXhhVjFJeFJuTlNhbFpzVWxWd1UxWnNWbUZVVmxKR1ZsUldVbUpGV2xkV2JHaFBWV3hhVmxkclZtRldWbHBMV1hwR1IxWnNTbkpUYkU1WFUwWktVRlpXV2xkU01VNXlaVVZhVTJFd2NGTldiR1F3Wld4YVJWRnJaRkppUlc4eFdsVldTMVZzV2xaWGF6RlZVbFpXTkZWWGVFZFdiRkpaVkd4S1YxWldjRVJXVkVaUFRrWkdjMUpzV2xOaE1VcE9WV3hXWVZFeFZuTmhSazVTVFVSck1scEZXbE5WYkZwV1YyeEdWVkpXV2toVlYzaEhWbTFOZWxSc1ZsZFdWbkJFVmxab2MwNUdSbk5TYkZwVFlsZG9UbFZxUVRGUk1WWlhWbXMxYWsxVldsZFZiWFJMVmtkV1dXRkdSbFpXYkZwSVZXMTBORkpzV25KVGJFcFhWbXhhTmxaV1dsZFNNVVp6Vm1wV2JGSnRhRk5XYkZaaFVqRlNSbFpyWkZKaVJWcFlWa1pvVDFWc1dsWlhhMDVXWWtVME1GbFZXa2RXYkVweVYyc3hVMVpXY0VSV1ZscGhZVzFOZUdKR1dsTmhNSEJVVmxST2IxRXhWbGRXYTJSWVVsaG9TRmxyVmt0VmJGcFdUVmh3Vmxac1draFZWM2hQVmtkV1JsTnNTbGRXVm5CR1ZrVldWMUl4Um5OU2JGcFZWMFUxVTFac1ZtRlJNVlpaWWtSU1VtSkZXbGRXUmxKWFZUSkdXV0ZGVGxaV2JGcElWV3RWTlU1dFRqWmFSa3BYVmxad1NGWlhkRTlPUmtaelVteGFVMkY2Vms1VmJGSnpVVEZXVjFack5XcE5WVnBYVlcxMFMxWlhWbGxoUm1SV1ZteGFTRlV3VmpSU2JFcHlVMnhLVjFaSGFEWldWbHBYVWpGR2MxSnFWbXhTVlhCVFZteFZNRTFzVmxoaVJYQnFUVWQ0TVZaSE5XRmhNV1JHWTBoR1dHSkhhRkJWYTJSS1pWVTFWVkZ0UmxkbGJGWXpWVEZrZDJReGJISmlTRTVyVFcxNGNsWXdWVEZqTVU1V1lVVTVUbEl3TlRCWmEyUjNZVEZLZFZwSVFsVmxhMWt3V2taYWIxTkZOVlZUYkhCWVVsZDRkVlpzWTNoV01rWkhZVE53VmxZeVVsSldWRUpMVGxaa2MyRkZaRTVXTUZwYVZUSXhORlJHUlhsVmFsWllZa2RTU0ZsWE1WTlNSbXQ2VVd4Q1RsZEhaM2hYYTJONFVqSldWbUpGYUZWaWF6VmhWakJWTVU1c1draE5WV1JyVW01Q1dsWkdaR3RWVmxWM1UycFdXR0pIYUVoVVZtUkhWMVpPZEdWRmVGSk5iRXA0VjFkMGExSXlWblJVV0d4UFZqSm9jRlpxUm1GT2JFNTFZa2hLVDAxWGFFbFViR1JQWVZkS1YySXphRnBpVkVaUVZGVmtSMWRGT1ZsV2EzQlRUVzVuTWxaclkzZE9WVEZIVjFoc2FWTkdXbkJaYkZwaFRsWk5kMkZHWkd4aVNFSmFWVEZvUTFOc1RrbFZiWEJhWWxkNFExZHFTazlrUmxweFVXMTBXRkpZUVhoVk1WWnJXVlV4V0ZOdVVsVmhhMHB2Vm01d2MwMVdUbFpVYlRscFVqRktNRlp0TlZkaE1VVjVaRWMxWVZaRldUQmFSbFp6VWtaR1dGcEZjRlJTV0VKNlYydFdiMVl5VmxoVGJrSlNWakpvYUZZd1duZGpNV3gwVGxaS2ExWXhSalZaYTJoWFlWZEtWMWRxVmxWU2VrWjZXa1phY21WWFZrVlNiVVpUVFZadk1sVjZRbTlXTWxaelkwWnNWRmRHV25CWmJGWmhUVVprYzFSdVNrOU5WMmhKVkd0a2ExTnNUa1ZSVkU1WVVsZE5lRlF4V205VFJUVllWRzFzYVZadE9UUlhWekI0VkRBeFNGSnNhRkJYUmxwTFZXNXdWMk14YkhOYVJtUnNZbFZhV2xaSGRGTmhWVEI0VjJwR1lWSlZOWFpaVnpGS1pXeGFkVlp0ZEZSU1ZFWTJWVEZXYjFZeVZuTmpSbXhVVjBWS1MxVXdhRk5oYkd4MFlrVktZVTFzU2pCVmJUVnpVMnhKZUdOSVpGcGlWRVpUVjJwR1ExWkdSblJYYXpGcFZtNUNNMWRYTUhoVmJVbDRZVE5zVUZaRlduQlpiWGhMVG14U1JsUnJUbHBoTWprMVZHeGtiMkZXV1hoV2JsWlZVbFUxUkZSV1pFNWxWbHAxWWtac1ZrMXVUWHBXTUZacVRWWnJlVk51UWxKV01sSnZWbXBHYzJKc1RYZGFSMFpxVWpCd01GWldhRU5UYkU1SlZXMXdXbUpYZUVOWGFrSnpVa1pHZEUxWGFGZGxiRnA1VmtWamVGUXlVblJWYkdoUFZrVktTMVZVVGs1T1ZrNVdWV3RhVDAxWGFFbFVhMlJyVTJ4RmQxSnROVnBOYWtaWVZGVmtVMWRXVG5WV2EzQlRUVVJWZVZkcldtcE5WVEZJVkdwYWExSXdOWEJaVmxaSFlteHdjMWRxVW10V2JXaEpWR3RrYTFOc1RrWmpTRTVoVWxkb1dGcFdaRXRqUmtaMFkwZHNUazFXYjNoWGExWnZWRzFTVjJFemJGQlhSbHBoVkZkMFdtUXhUWGRoU0hCaFRXdHdNRlZ0TlZOWlZscElUMWMxWVZKdGFGQlphMlJQWTBkUmVWcEdjRTVoYlhRMFYxY3dNVlZyTlhKaVJWWlRWakpTZEZaVVNucE5NV1JHV1hwR1VGWnRhRWxVYkdSUFlWZEtWMkl6YUZwaVZFWlFWRlZrUjFkRk9WbFdhM0JUWld4YWVsZFhlR3RXTWxaMFVteHNWV0pGV205V2FrRXhaVlprYzJGRmNHbE5hM0F3Vm0wMVUxbFdaRVpPV0dSYVZtczBlbGRxU2t0a1JscDFWVzFHV0ZKVVZqTlhWRTV6WTJ4dmVWWllhR3hUUmxwTFZWUkNTMlF4WkhSaVJVcHBUV3R3TUZadE5WTlpWbVJHVGxoa1dsWnJNSGhaZWtaM1YwVTFXRTVYZEZOTmJWSjFWbFZhVW1Rd09WWmlSVlpTVjBWS1MxVXdhRk5oYkd4MFlrVktZVTFIZUVWVlZ6VlhXVlphTmxKdVRscGxhM0I2V1RCV05HUldSbkZTYlhCT1lsZFNNbGRYTUhoV01sSkhZMFpzVldKclNuRmFWbVI2VFRGa1JsbDZRbUZOUjNoS1ZGVmthMWxXV1hwaFJGcFlZa1UxUkZrd1duZGpSa1pZVDFkc2FWWnNiM2RXTW5odlZESk9TRkpzWkdwTk1sSmFWbGh3VjJOV2JIRlViR1JyVmpGS1JWVldVbTlUYkVvMlZtNU9XbUpIVWxoYVZ6RkhWMVpTV1Zac2NFNWhiWFEwVjFjd01WVnRUa1ppUld4clVqQTFjRmxXVmtkaWJFNVdWR3RPYTFadVFsbFVWbVEwWVdzeGRHVklaRlJXVmtZelYycEdhbVZWTlZobFIyeFhUVlp2TWxkV1dtOVVNWEJHVDBob2JGTkdXa3RWVkVKS1RsWk9WbHBHWkdwTmF6RTFWbXhrYTJGR1dYaGlSelZVVFVkTmVGbHJaRXRYUmxwMVkwZG9WMDF1YUhCV1JsWmFaREpTVjJFemJGQldSVnB3V1cxNFIySnNWa2RWV0dSUVZsZDRTVlJzWkRSaFZsbDRWMnBhV2xadGFFOWFSbHB5WlZVNVZWSnRiR2xpUlZvelZURldiMDFHYTNsVGJrSlNWakpTUzFWVVFrdE5WbVJ6V1ROb2FWSXdNVFZaYTJoRFZGZEtjbE5ZYUZwbGEzQjFXV3BLUzJSR1duVlZiVVpZVWxSV00xZFVUbk5qYXpSNFlVVm9UMUl5VWt0Vk1GSkhZV3hzZEdWRVVtdFdWM2hGVlZjMWMxbFdaRWRUV0doYVRXcEJkMWRxU2t0a1JscDFWVzFHV0ZKVVZqTlhWbHBUVFVacmVWTnVWazVXTURWd1dXdG9iMDFXVWtsaGVsSmhUVlZ3V2xsVmFHdFpWbVJHWTBoa1dtSkhVbGhhUm1SVFVrWkdjVkZ0Ykd4V1ZXOTNWako0YjFNeVNuTmpSbEpTWVd0S2IxVnFSbGRpYkdSMFRWaE9iRll3TVRaV1ZtUnJXVmRLV0dWSWNHRlNWMUpZV2xaV2MxTkdTblZXYlVaU1RVVnZkMVl4V205UmJHOTVVMWhzV0ZZeVVtaFpiR1EwVFZaa2NsWlVSbWxTTUhCWlZtMDFkMkZHWkVaT1YzQmFZbGR6TUZwSGRITlRSbVJ4VW0xc2FWWlVVak5YVmxwcVRsZFNWbUpGYUZoaWEwcHdWVEJhUzJNeGEzbGpNMmhvVWpBMVJWbFZVa2RoYXpGelYycFdWRTFWTlVSVWFrWnZVMFUxU1Zkck1XeFdWVnAxVlRGV2IxTXlTa2hWYTJ4WFltMTRjRmxXVmtka2JHUlhXa1U1YUdFemFFVlZWekYzWVRGa1JtSklaRlJXVmtZelUzcENjMU5YVWtoVWJXeG9Wa2RuZVZVeFZrOVJiRzkzWWtWU1VtSnJTbWhaVmxaSFpHeE9WMXBGT1U1V01EVjNWR3hTVDJGR1dqWldha1pZWWtkb1MxcEdaRWRYUlRWWVkwZHNWRkpzY0hsV01uaHZWRzFKZVZWc2JGVmlXR2h4V1ZaU1YwMVdaRmRaTTJocFVsaFNWVmxVU210aVJURlpZVVJHVlZOSGN6Qlhha0p6VWtaR1dGcEZjRkpOUlZwMVZqRmFhMVF5Um5KbFNGWlNZV3RhY1ZSWE1XdGtiR1JWVkd4a2JGWllhREZYYTJoRFlWZEtWVlp1VGxwTmJYaDZWMVJLUzJORk9VbFhhM0JTVFVWYWRWVXhWazlSTURsWFlVVm9UMU5HY0U1YVZsWkhZbXhPVmxSclNtRk5helV3Vm0xd1EyRXhaRVpqUkVaVVZsZFNTRmxYZUhOT2JWSklWRzFzYUZaSFozbFZNVlpQVVd4dmVWZHNVbXROYlZKWlZGWlNRMlF4VWpaU2FsSnJWbGhuTVZRd1pHdGlWbHAxWVVSR1dGSlhUWGhaYkdSVFYwVTFXR05IZEZOTmJtZDVWMWN4YzFFeVNsaFNiR2hQVmpOU1ZsbHNXbUZOUm1SellVVTVhbEl3TkRGWlZWSkhZV3N4YzFkcVZsUk5WVFZFVkdwR2IxTkZOVWhhUlhCVVVtNUNkbGRVU25OUk1rWjBVMWh3VjJKc1duSlZNRlY0WW14V1IxUnJUazVXTURFMVZtMDFjMVJYU2xkWFdHeFlZa2ROZUZSVlpFOU9WVFZZVFZkb1YwMHlaRE5XTW5odlUyMUplVkpzYkZWaGVteHdWRlJHUzFkV2JGZFpla1pyVm01Q1dsVXhZelZoTVdSR1RsaE9XazF0ZUhsWk1GWTBaRVV4V0dGSGNGSk5iV2d3VjJ0YWFrMVhSblJWYTJocFUwWndjRmxXVmtka2JHUkZWR3QwYVZKdVFuZFpWRXByWWtVeFdXRkVSbFJXVlRWRFYycENjMU5XWkhSaFIzQm9WbFZzTmxkV1dtcE5WMUpYWTBac1ZGWXlVbEpXVkVKTFlsWnJlVTFXWkdsV1dHZ3hWMnRvUTJGWFNsVldiazVhVFc1QmQxZFVTa3RqUmtaWVdrVndVazFGYnpGV01uaHZWVEF4V0ZSdVVrOVNNbEp5VkZjeE5FMVdiSFJOVm1Sc1ZsUm9ORnBWYUZkVGJFVjNVMVJXVkUxVk1IaGFWbHAzVjBaV2NWSnNjRTVpUmxveVZqSXdNVll5VWxkaE0zQldZbXRLY0ZSWGNGTmliRTEzV2tWYWFrMUhlRWxWTVdoRFUyeE9TVlZ0Y0ZwaVYzaERWMnBDYzFKR1JuVmlSMFpZVW10c05GZFVTWGROUm05NFlrWlNUMVl6UW5CVVYzQlhZMVprVjJGR1NtbE5WM2gzV1Zod2ExZFdTalpWYlRWVVZsZGtNMWw2UW5OU01sSklWV3Q0Vm1Wc1dURldNbmhyVlRBeFYyRXpiRmRXZW14d1dXeGFZVTFHWkhOaFJUbHFVakF4TTFaSE5XRmhNVm8yVmxoa1ZWSlZOVVJYVjNodlZrZEdObHBHYkZObGJGcHhWMWN4YzFGc2IzbFZibEpUWW0xNFMxVnVjRmRqTVd4eldrWmtiR0pWV2xsWlZFcHJWVlpWZDFOdVJscGhhelZZV2taa1UxTldVbGxXYlhCcFZteHdlVmRyV210VU1rcEdaRVZvVDFZemFIQldha1poVG14c1YyRkZPVlpXTUZwWlZrYzFTMWxXWkVaaVNIQlVWbFp2ZDFkclZqQldWMUpJVkcxc2FWTkhaM2hWTVZaUFVUSk9SMk5JUWxKV2VteHdXV3hhWVUxR1pITmhSVGxxVWpCYVZWUnNhRTlaVmxvMlZtNVdZVkpYVW5WWGFrWkRWbFV4UldKRmNGTlNWVm96VlRGV2IwMUdhM2xUYmtKU1ZqSlNTMVZVUWt0T1ZtUnpZVVpPVGxZd05UQlVhMlJyVjFaRmQyTkdiRnBoYTJ0M1YycEdkMWRXWkhSbFIzQnBZbGhrTTFkV1ZtdGpNbEpYWWpOb2EwMXRlRkZVVm1odlRWWk9WbFJyVGxCV2JXaEpWR3hrVDJGWFJsWlNiVFZhVFdwR1dGUlZaRk5YVms1MVZtdHdVMlZzV25wWFYzaHJWakpXZEZKc2FHaE5NVnB3Vm1wQ1lVMHhUWGRhUjBaT1ZqQndNRlpIY0VOaFJsbzJZa1JHVkZaVk5YWmFSbHAzVjBVeFdHVkhjRTVpV0djeVZYcEdUMUV3TkhoaFJXaFBVakpTUzFWVVFrZGliR3Q1VFZaa1RsSXhTbHBWTWpWWFUyeEtObFp1VGxwaVIxSllXbGN4UjFkV1VsbFdiV3hwVmxadmQxWXllRTlSYlU1eVlrVlNXazF0VWsxVlZFcFBZbXhOZW1KRlRtdFdia0paVkZaa05HRnJNWFJsUkZwVlVucEdVRnBITVZOWFJUVlZVV3R3VWswd05YVlZNalZ6WTJ4dmQyTkVXbXRTTURWd1dWWldSMkpzY0hOVWJrcFBUVmRvU1ZSc1VuTlhWa28yVm0xd1dtSlVSbWhVVm1STFpFWlNjVkZ0YUZkbGJYZDRWVEZXVmsxWFNraFRiR2hYWW01Q2IxWXdWWGhrYkdSRlZHdDBhVkp1UW5oVk1XaERVMnhPU1ZWdGNGcGlWM2hEVjJwS1UyUkdTblZpUlhCVVVteHZNbFl5ZUc5VGJHOTRVV3hTVW1KV2NIRlpiRnBoWkVaU1dHRjZSazVXTURFMVZtMDFjMVZGTVZsaFJFWllVbGROZDFkcVFuTlRWazUwWlVkMFZGSnNiekZYVnpGelVURlZlR05HYUZOaVdFSnlWVmh3VjJOV2EzbE5WbVJvVWpGS1NWWnRkR0ZoVmtsNFYycENXR0pIVFhoVVZWWXdVakpSZVdKSFJsTk5ibVExVmpCV1QxTnRUWGRpUld4cVRXMVNZVlJYTlc5aU1XdzJWR3M1VlUxWGVGbFVWbVEwVlVkR1ZsTnRjRlJXZWtGNFdXdGtTMWRHV25WalIyaFlVbFJXY1ZVeFpITlJNRGxXWlVWU1VtSlZOVXRaV0hCWFl6RnNjMXBHWkd4aVZWcGFWa1pTWVZOc1NuVmFTRUpWVWxVMVJGbHNaRWRYUlRWWVpFWldhVlpzYjNkV01uaHZWREpPU0ZScVZtaFNSVnB4VkZkNFlVNVdUWGhVYmtwUFRWZG9TVlJzVW5OWFZrbzJWbTF3V21KVVFqUmFSM2gzVTFaYWRWUnRSbFpsYkZwNlYyeFdiMUV5VW5SVWJsWldZbTVDUzFWclVrTmliRnBJVFZaa2ExSnVRbHBXUnpWRFlXMVdkVlZ0Y0ZwaVYzTXdXa2QwYzA1V1JuVmpSMnhPVFZadk1WWXhVa3RXTVZKellrWnNVbUp0VW05V2JuQlhaRlphYzFkcmRGVldhMHBaVmxjeGIyRXhTWGRXVkVwWVZtMW9SRnBFU2t0VFIwcElZMFp3V0ZKcmNETlhWM0JLVFVkU2RGSnVWbFZpYkhCd1dWYzFVMk5HWkZkaFJUbHBVbFJXZUZaV2FFOVpWbVJJWlVWNFZWWXphRE5XTVZwUFpGZE9TR0ZHWkd4aVdHUTBWbFJHYTJReVVuUldia3BzVWxaS1ZWbHNVa2RpTVZweFZHMDVhazFWTlZsWk1HaGhZVVphV1ZwRVVsZGlWRll6VjFaYWExSnRUa1ZYYkZaVFVsUldSVmRYY0V0U01XUklWVmh3V0dKWVVrOVpWekV6VFZaa1YyRklTazlXYmtKNldWUk9jMkZHVGtkalJUVmFZa1phYUZSVldsTlNWazUwWkVVMVYwMUdjRnBYYkZaclRVWlNWazFJWkU5V1JscFpWakJrZWsxV2JGaE5WWEJzVmxSR1dsZHJaSE5VYlVaelYyNXdXRlo2UVhoV1ZFcFhZMjFSZW1KRk9WZE5NbWgzVm0xd1IxbFZOWE5pUm1Sb1VsUldjbGxzVm1GWFZsSnpXa1JDV2xadFVrbFhhMUpIVjJ4YU5sWnNRbFZoTVZwNldUQmtVbVZYU2toalJUVm9ZbGhSTUZZeFVrcGxSbEY1VTJ0b1ZXRnNXbFZXYTFwM1YxWndWMVp1VGs1aVJuQjZXVlZWTldGV1NYZE9WRVpYVW0xb2FGbFhlRXBsVjBaSldrWndhRTFFUVhoV1JsSkxVMjFXYzFSdVZsUmhla1pQVm10a05HVkdaRmRXYlhCUFVqRktXRmxyV205VWJFNUhZMGRvVlZaRldtaGFSRVp6WTJ4d1IxTnRkR2xXVkVVeVZsUkplR1F4VWxaTldFcFBWa1Z3WVZsclpHOVNSbkJJVFZWMGExSnNjREZXYlRFd1ZrWktWVkpZYkZoV2VrSTBWbXBLVTFJeVRrZGlSbFpwWVRCd2VGZHNXbE5qTWxGNFlraFNUbFpyTlhCVmFrWmhVbFpTYzJGRlpHaGhla0kxVjJ0b1ExZEdTbkpPU0hCYVZtMVNURnBGV2t0a1ZsWjBVbXhvVTFaRldqTldhMUpMVGtVeFIyTkZXbXhTVmtwVldXMTRTMWxXV1hkV2EzUk9UVmQ0V0ZkWWNFZGhWMHBXVGtSR1ZrMVdTbWhWTWpGR1pERmtjbFJzV2xkaVJuQklWMWh3UjFJeFduTlRia3BVWWtkb1YxUlVTbTlTUmxwWFYyeGtVMDFWY0VkVU1WSmhZVEZLVm1OR1RsZGlSbkJvV1RCYVUxSnNXblZVYkVwcFVsWndXRmRXVWs5VU1WWnpWMnhhV0dFd05WZFVWRW96VFVaYVdHVkZaRmRpUlhCNVdWVlZlRlV4V2xkalJWSlhWbXh3VjFSclpFNWxSbHB6VjJ4T2FFMUlRbFJYYkZwdllqRkZlRlpzWkZkaE1sSlhWV3hvYjFJeFZuUmtSWFJXWWtad1YxUldhSGRXYkZwelYydG9WbFl6YUVoVWJURlRVbXhPYzFOc1pGZFdSVWt5Vm14YWEyTXdOVWRVYms1VFlrWndWRmxVVGtOVWJGWnpWbTFHVWsxV1dsaFdNbmhoWVdzeFdHVkdaRlppV0ZKTVZsUktWMWRYUmtaVWJGcFhZa1p3U1Zac1ZsZE9Sa2w0VTI1S1ZHSkZjRmhXYkZKSFRteGFWMWRzWkZOTlZWcDZWMnRhVTJKR1NsWmpSazVYWWtaYWFGVnNXbE5TYkZweVdrWkthVkpXY0ZoV2ExcFRZVEZXUmsxVldsaGhNRFZYV1d0a2IyRkdWbkpXYWxKVFRWWktlVlV5ZUV0V01rWTJVbXBhVjFac2NGaFZha1pIWXpGa2NWWnRlRk5pYTBwVVZtMTRWMWxXU2xkVmExcFhZVEpTVTFsclZtRldNV3haWTBkMGFGWnNjRmRaTUZaUFZteGFSbEpZWkZwbGExcElWbTE0UzJOc1RuTlZiWGhZVWpKb1UxWnNXbUZXTVVsNFUyNUtiRkpXY0ZSWlZFSjNWVEZTVlZKcmRGTlNiRWt5VlcweE1GVnRTa1pYYkdSVlRVZG9VRlpYYzNoU2JHUnlWR3hhV0ZJelkzZFdWbVEwVWpGYWMxTnVTbXhTVkVaVVZtdFdZVkpHV2xkWGJHUlZZbFV4TkZWdGVHRlZNa1YzWTBaYVYxWkZOWFpXVmxwWFZqRmFjbHBHVGxOWFIyaElWbGN4TUZNeFZuTlhia3BYWW01Q1dGWnJWa3RUUmxaWVpVVmtUMVl4V2tkVk1uaExWakZhVjJORmVGZFNWbHBZVkZWYVIyTXhUblZVYlVaT1RVUldWRlp0ZUZkWlZrcFhZMFpvYTFKWVFuRlVWbFpoVmpGV2RHUkZkRmRXTVZwYVdWVldUMVpzV25OWGF6bFZZVEZ3U0Zrd1pGZFNiRTV6VTJ4a1YxWnVRazFXYTFaWFZqRkplRkp1VGxOaVJuQldWakJWTVZVeFduTldiVVpTVFZaYVdsbHJVbE5WYlVwR1YyeGtWMUp0YUhaV1Z6RlhWMWRHUmxSc1dsZGlSbkJKVmxkMFYwNUdTbk5UYmtwVVlrVndUMVZ1Y0hOT2JGcFhWMnhrVTAxVlducFZiWEJoWVcxV2RGVnNSbUZXZWxaVVZWUkdWMVl4V25OYVJrNVhWMGRvU1ZaclpEQlRNVlp6VjI1S1RsZElRbGRXYlhoaFUwWldXR1ZIZEZkU01WcEpXVlZhUzFZeFdsZGpSVnBYVWxaYVdGVnFSa2RqTVVwelYyczFWRkpVVmxoV2JYaFhXVlpGZUZadVRsVmhiRXBUV1d0V1lWWXhWblJrU0dSVlZtdHdWbFZ0ZEU5V2JGcHpWMnhrV21WcldraFdiWGhMWTJ4V2RHTkdUbGRXUlZreVZteGFZVll4U1hoU2JrNVVZa1phY2xWc1VsZFZNVnB6Vm0xR1ZFMVdTa2RXYlhSclZXMUtSbGRzWkZwV1JUVlFWbXhWZUZKc1pISlViRnBwWWxoamQxWldaRFJTTVZwelUyNUtWbUY2UmxSV2JYaDNVa1phVjFkc1pGVmlWVEUwVlcxNFlWVXlSWGRqUmxaWFZrVTFkbFpHV2xkV01WcHlXa1pPVTFkSGFFaFdWekV3VXpGV2MxZHNWbEppYmtKWVZtMTRZVk5HVmxobFJYUlhVakZhUjFaWGVFdFdNVnBYWTBWYVYxSldXbGhWYWtaSFl6RktjMWRyTlZSU1ZGWllWbTE0VjFsV1JYaFdiazVWWVd4S1UxbHJWbUZXTVZaMFpFaGtWVlpyY0ZkV01uUlBWbXhhYzFkck9WcGxhMXBJVm0xNFMyTnNUbk5UYlhoWVVqSm9SVlpzV21GV01VbDRVMnRhYkZKV2NGUlpWRUozVmtaYWNsWnRSbE5XYkVZMldUQlNRMVpYU2taWGJHUldZbGhTTTFaR1drdFdiR1J5Vkd4YVYySkdjRFZYV0hCSFZURmFjMU51U2xSaVJUVlhWRlJLYjFKR1dsZFhiR1JWVFZaV00xcFZWbUZWTWtWM1kwWk9WMkpIVWpaVVZFWmhWbFpHY2xwR1NtbFNWbXQ0VjJ4V1YxTXhWbk5YYkZwWVlYcEdWbFZzV25kVlJsWllaVVZrVjJKVlZqWldSM2hMVmpGYVYyTkZVbGRXYldoNlZHdGFSMk14U25OWGJFNW9UVlZ3VDFaWGVGZFpWa1Y0Vm14V1ZHSlViRk5VVlZKdlRrWmtjbFpyZEZaaVJuQldXVlZvZDFac1duTlhhMmhXVmpOb1ZGWnJaRmRTYkU1elUyeGtWMVp1UWtkV2ExWlhWakZKZUZKdVRsTlhSM2h6Vld4Vk1WUnNWbk5XYlVaU1RWWmFXRlp0TVhkaGF6RldWMnhrVm1KWVVtaFdWRVpMVTFaU1ZWUnNWbXhoTVhCUlZsWmtORkl4V25KUFZXeFZZa1Z3V0Zac1duZFNSbHB5VjJzNVQxSnNXa2hWYlhoaFZUSkZlRk5yTlZaaVJscG9WVlJHVjFZeFdsbGFSM0JPVm10WmVsWlhNVEJUTVZaMFZteHNhRkpYVWxkV2JYaGhVMFpXZEdSRVVsTmlSWEI1VlRKNFMxWXhXWHBWYWxwWFlURndXRlZxUmtkak1VNXpWVzE0VTFaWVFsUldiWGhYV1ZaTmVGVnJXbGRYUjJoVFdXdFdZVll4V25OaFJUbFdZa1p3VjFZeWRFOVdhekI1WkhwQ1YxWldjRWhXYlhoTFkyeGtjazFXVGxkV2JrSkZWbXhhWVZZeFVuUlVXR2hUWWtad1ZGbFVRbmRXUmxwVlZHMDVVazFXV2xoV2JYUnJWVEZLV1dGRlpGWmlXRkpNVmxkNFlWWnJNVmxqUmxwWFlrWndTVlpYZEd0U01rNXpWbXhzVldKRmNGaFdiRnAzVWtaYVYyRklaR3hoZWxJelZEQm9hMVV5UlhkalJsSlhZa1p3U0ZwWGVHRldWa1p5V2taS2FWSnNhM2hYYkZaWFV6RldjMWRzV2xoaVZHeFdWV3hrVTFWR1ZsaGxSV1JYWWtaS1dsWkhlRXRXTVZwWFkwVlNWMkV5YUhwVWExcGhVakZLYzFkc1RtaE5XRUpQVmxkNFYxbFdSWGhXYkdSWFZrWktVRlJXV2t0V01WWjBaRVpPYUZJd1ZqTlVWbWgzVm14YWMxZHJhRlpXTTJoVVZHeGtWMUl4VG5OVGJHUlhWbTVDUjFaclZsZFdNVWw0VW01T1UySkdjRTlWTUZVeFYwWlNWbFp0UmxKTlZsWTJXV3RTVTFWdFNrWlhiR1JXWWxoU1ZGWlZWWGhYUjFaR1ZHeGFWMUpZUWxSWFdIQkhVakZhYzFOdVNsUmlSa3BYVkZSS2IxUnNXbGRYYkdSV1RWZFNlVnBWVm1GVk1rVjNZMFpPVlZaRmNIWlZhMXBUVW14YWNscEdTbWxTVm5CWVZrUkNiMVF4Vm5OWGJGcFlZVEExV0ZWdGN6Qk5SbFpZWlVWa1YySkZjSHBWVjNONFZURmFWMk5GVWxkV2JIQllWa2N4VG1WR1NuTlhiRTVvVFVoQ1ZGZHNXbTlpTVVWNFZteGtWMkY2YkU5WmExWmhaVVp3UmxwSE9WWmlSbkJYVmpKNGExWldTbGRYYTJoV1ZqTm9TRlp0Y3pWVFZsSnpWMnhrVjFadVFrVldiRnB2WXpBMVIxSnVUbE5pUm5CVVdWUkdTMVJzVm5OV2JVWlNUVlphV0ZadGN6RmhhekZXWWtST1ZtSllVa3hXVnpGWFYxZEdSbFJzV2xkaVJuQkpWbXRXVjA1R1NYaFRia3BVWWtWd1dGWnFRVEZPYkZwWFYyeGtVMDFWV25wV1YzQlhZa1pLY21OR1RsZGlSbHBvVld4YVUxSnNXbkphUmtwcFVsWndXRmRVVG5kaE1XUnlUVlZhV0dFeFdsWlZhMVpMVXpGc05sSnJXbXROVlhCNVZtMTRWMVZyTUhsaFJWSlhWbXh3V0ZWcVNsZGpNVXB4Vm0xNFUxWllRbFJXYlhoV1pVVTFjMVpzYkdsU1JrcFRXV3RXWVZZeFZuUmxSVTVWVm10d1YxWXlkRTlXYkZwelYyNXNXbVZyV2toV2JYaExZMnhPYzFadGVGaFNNbWhGVm14YVlWWXhTWGhUYTFwc1VsWndWRmxVUW5kVk1WcHpWbGhvYkdKR1dsaFdiWFJyVlRGSmQwNVliRlpOVmtweVZqSjRZVlpzWkhKVWJHUnBVbFJSZDFaV1pEUlNNVnB6VTI1T1VtRjZSbFJaVkVaM1VrWmFWMWRzWkZWaVZURTBWVzE0WVZVeVJYZGpSazVoVm0xb2RsVlVSbGRXTVZweVdrWk9VMWRIYUVoV01uUlhVekZXYzFkc1drNVhTRUpYVm0xNFlWTkdWbGhsUlRsUFZqRmFTRll5ZUV0V01WcFhZMFUxVjFKV1dsaFZha1pIWXpGS2MxZHNRbFJTVkZaWVZtMTRWMWxXUlhoV2JHeHBVa1pLVTFsclZtRldNVlowWkVSU1ZsSlVSbGxhVlZaUFZteGFSbUV6YUZaaE1Wa3dWVzE0UzJOc1RuTlRiR1JYVFRGSk1sWnNhSGRSTVVsNFUyeGtWMkV4U25OVmJGWjNWVEZhYzFac2NHeGlSbHBhV1d0U1UxVnRTa1pYYkdSWFVteEtVRlpYTVZkWFYwWkdWR3hhVjJKR2NFbFdiRlpYVGtaS2MxTnVTbFJpUlhCWVZtdFdTMDVzV2xkWGJHUlRUVlZhZWxaWGNGZGlSa3BXWTBaT1YySkdXbWhWYkZwVFVteGFjbHBHU21sU1ZuQllWbXRhYjFReFZuTlhiRnBZWVRGYVZsWnRlR0ZUTVd3MlVtdGtWMkpGY0hsVk1uaFBZa1prU0dGRlVsZFdiSEJZVm1wR1MxWnJPVlZYYlhCc1lsWktXRlpHVmxkWlZscHpZMFZrVjJGNlZuRlVWbFpoVmpGV2RHUkdUbWhOYTFZelZGWm9kMVpzV25OWGEyaFhWak5vVkZSc1pGZFNiRTV6VTJ4a1YxWnVRbE5XYTFaWFZqRkplRkp1VGxOaVJuQldWakJWTVZVeFduTldiVVpUVm0xNFdWcEZWbmRoYXpGV1YyeGtWbUpZVWt4V1Z6RlhWMWRHUmxSc1dsZGlSbkJaVmxkNFYwNUdTbk5UYmtwVVlrVndXRlZxU205U01WcEdWbXhrVTAxVlducFZiWEJoWVZaS1YxZHJOVlppUmxwb1ZWUkdWMVl4Vm5SU2JFcE9VMGRvU0ZaWE1UQlRNVlowVm01U1ZtRXhTbFpWYkZwaFUwWldXR1ZGWkZkV2F6VjVWa2R6ZUZVeFdsZGpSVkpYVm0xb00xWkVSa1prTWxaR1YyeE9hRTFJUWxSV2JYUmhaREZLVjFWcldsZGhNbEpUV1d0V1drMXNaSEpXYkU1VlZtdHdWMVl5ZEU5V2JGcHpVMjFvVmxaRlNUQlZiWGhMWTJ4T2MxTnRlR2xXYTNCR1ZtdFdWMVl4U1hoU2JrNVRZa2RTVkZZd1ZURlZNVnB6Vm0xR1UxWnNjRmxaYTFKVFZXMUtSbGRzWkZaaVZGWk1WbGN4UjFkWFJrWlViRnBYWWtad1VWZFljRWRTTWs1SVZtdGFWR0pGY0ZoV2JGcDNZVVphUmxac1pGTk5WVnA2Vld4b2IyRlZNSGRPVms1WFlrWmFhRlZVUmxabFJsWjFZMFU1VGxKSGMzbFhWRTUzWVRGV1NGWnVWbFZXUlRWV1ZGUk9RMDVzVW5GUlZGWlBZbFpLUjFVeWVFdFdNVnB6WTBVeFYxSldXbWhXUkVaSFl6RktjMXBHVmxoU1ZGWlVWbTE0VjFsV1JYaFhibFpwVWtaS1dWbHJWbUZXTVZaMFpFWk9WVlpyY0ZkV01uUlBWbXhhYzFkdWJGVmhhMXBVVm0xNFMyTnNWblJpUjJoT1VqTm5NbFpzV21GV01VbDRVbTVPVm1KR1NuTlZhazVEVlRGYWMxWnRSbFpOVmtwSFZtMTBhMVZ0U2taWGJHUlZWbGRvVUZac1ZYaFNiR1J5Vkd4YVdGSXpZM2RXVm1RMFVqRmFjMU51U2s5V1ZFWlVWbXRrTkZKR1dsZFhiR1JWWWxVeE5GVnRlR0ZWTWtWM1kwWm9ZVlp0YUhaWFZscFhWakZhY2xwR1RsTlhSMmhJVmxjeE1GTXhWbk5YYkdoclUwaENWMVp0ZUdGVFJsWllaVVZrVDFZeFdrZFZNbmhMVmpGYVYyTkZXbGRTVmxwWFZHeGFSMk14U25OWGJGWllVbFJXVkZadGVGZFpWa1Y0Vm01V2FWSkdTbTlaYTFaaFZqRldkR1ZIT1ZWV2EzQlhWakowVDFac1duTlhibXhWWVd0YVdGWnRlRXRqYkZaeVRWVTFVMkV4YnpKV2JGcGhWakZKZUZKdVRsWmlSa3B6VlcxNFMxVXhXbk5XYlVaVVZteEtSMVp0ZEd0VmJVcEdWMnhrV2xaRk5WQldhMVY0VW14a2NsUnNXbGhTTTJOM1ZsWmtORkl4V25OVGJrcFBWbFJHVkZac1duZFNSbHBYVjJ4a1ZXSlZNVFJWYlhoaFZUSkZlRk51VGxwV1JVcDVWRlJHWVdOV1JuSmFSazVPVm0wNGVGZHNWbGRUTVZaelYyeGFXR0V6VWxaVmJGcGhVMFpXV0dWRlpGaFdiRXA1VmxkemVGVXhXbGRqUlZKWFZteHdjbGxVUmtaa01sWkdWMnhPYUUxSVFsUldSbEpEWkRGSmVGVnJXbGRoTWxKVFdXdFdWMDB4VVhkaFJUbFdZa1p3VjFZeWRFOVdNVXB5VGtSQ1ZsWXphRWhXYlhoTFkyeFdjazFXVGxkV2JrSkZWbXhhVTFNeFpIUlVXR2hUWWtad1ZGbFVRbmRWTVhCWVRsWk9WVlpzV2xoV2JYUnJWVEZLV1dGRlpGWmlXRkpNVmxkNFlWWldSblZqUm5CWFlrWndUVlpXWkRSU01WbDRZVE53VldKRmNGaFdiRnAzVWtaYVYyRklUazlTYXpWSVZXMTRZVlV5UlhoalJUVldZa1phYUZWVVJsZFdNVnB5VGxVNVRsWnRkM3BXVnpFd1ZURnNXRkpzYkdoU1ZUVlhWbTE0WVZOR1ZuSldhbEpUWWtad2VWVXllRXRXTVZwVlVtcGFWMVpzY0ZoVmFrWkhZekZXYzFWdGVGTmhNSEJVVm0xNFlWTXhWbk5WYTFwWFlUSlNVMWxyVm1GWFZtUnlWbXM1VlZacmNGZFdNblJQVm14YVJrNVlXbFpXUlVrd1ZXMTRTMk5zVG5OVGJHUk9Za1Z3UmxaclZsZFdNVWw0VW01T1UySkdjRlpXTUZVeFZURmFjMVp0UmxKTlZscGFXV3RTVTFWdFNrWlhiR1JXWWxoU1ZGWkdXa3RXYkdSeVZHeGFWMUpVVm05V1ZsSkRUa1pLYzFOdVNsUmlSWEJZVm1wQmQyVnNXbGxqUlU1VFRWVmFlbFV5ZUZOaVJrcFdZMFpPVjJKR1dtaFZha1pUVW14YWNscEdTbWxTVm5CWVZtdGFiMVF4V2tkWGJGcFlZVEExVjFZd1pETk5SbFpZWlVWa1YySkZjSGxVYkZWNFZURmFTR1ZGVWxkV2JIQllWa2N4VG1WR1NuTlhiRTVvVFVoQ1dsWnNVazlpTWs1WFZteGtWMkV5VWxSWlZFNXZVakZXZEdSRmRGWmlSbkJZVm0wMWQxWnNXbk5YYTJoV1ZqTm9TRlJzWkZkU2JFNXpVMnhrVjFadVFrZFdhMVpYVmpGSmVGSnVUbFJpUjJoelZXeGFTMVJzVm5OV2JVWlNUVlphV0ZadGVHRlVNREZGWVVST1ZWWnNXa3hXVjNoaFYwZFNTV05HV2xkaVJuQkpWbFprTkZVd05WaFdhMlJZWWtWd1dGWnNXbmRUYkZwR1ZteGtVMDFWV25wVmJYaGhWR3hPUms1V1dsVldWbHBvVlZSR1YxZFhTa1ZWYkVwcFVsWndXRlpYTVhwTlZsSlhVMnhXYVZKVk5WZFdiWGhoVkRGc05sSnJaRmRpUlhCNVZUSjRkMVpyTUhsaFNIQlhWbXh3V0ZWcVJrdGpiVlpHVjJ4T2FFMUlRbFJXYlhoaFZqSldjMVpzWkZkaE1sSlRXV3RXV2sxV2NGWldhM1JXWWtad1YxWXlkRmRXVmtwWFYydG9WbFl6YUV4V2ExVTFWbXhXYzFGdGVHbGlSWEJSVm14YVlWWXhTWGhVYmtwc1VsWndWRmxVUW5kVk1WcHpWVzA1YkdKR2NGaFdiWFJyVlcxS1JsZFVSbUZXVmxwTVZsZDRZVlpzWkhKUFZsWlRWbTVDZVZaV1pEUlNNVnAwVkZod1ZXSkZjRmhXYkZwM1VrWmFWMkZJVGs5U2F6VklWVzE0WVZVeVJYaGpSVFZXWWtaYWFGVlVSbGRXVmxKMFQxWktUbEpIWnpCV01uUlhVekZXYzFkc1ZtaFRTRUpYVm0xNFlWTkdWbGhsU0ZwclRWVTFXbFpIZUV0V01WcFhZMFZTVjFadGFIcFVhMXBIWXpGS2MxZHNWbGRTVm5CVVYxWmFiMkl4UlhoV2JHUlhZVEpTVlZWc2FHOVNNVlowWkVWMFZrMVdjRmhWYkZKUFZsVXdlbEZZWkZkaE1YQklWbTE0UzJNeFJuSk5WazVYVm01Q1JWWnNXbUZXYXpWSVZGaG9WMkpHY0ZSWlZFSjNWVEZ3VjJGSE9WSk5WbHBZVm0xMGExWkdTbGxoUld4WFVqTlNURlpYZUdGa1JsSjFZMFphVjJKR2NFbFdWbVEwVlRBMVdGWnJaRlppUlhCWVZteGFkMU5HV2taV2JHUlRUVlZhZWxWc2FIZFZiVVY0VTJ4R1ZWWnRVbFJWVkVaWFZqRmFWVlZ0Y0U1V1ZuQllWbGN4TUZNeFdsaFdiR3hvVW1zMVYxWnRlR0ZUUmxaeVZtcFNVMkpGY0hsVk1uaExWakZaZWxWcVdsZGhNVXBFVldwR1IyTXhUbkZXYlhoVFZsaENWRlp0ZUZkWlZrMTRWV3RhVjFaR1dsTlphMVpoVmpGa1ZWUnJPVlppUm5CWFZqSjBUMVl4VGtoa2VrSlhWak5vU0ZadGVFdGpiRlp5VFZaT1YxWnVRa1ZXYkZwaFZqSldkRlJZYUZkaVJuQlVXV3hTUjJOR2JGVlJiazVzWWtaYVdGWnRkR3RWTVVsNFYyNXNWazFYYUZCV1YzaGhWbXhrZEU5V2NHbFNiSEJNVjFod1IxSXhXbk5UYmtwV1lYcHNWRlpzWkRST2JGcFhWMnhrVTAxVlducFdSM2hUWWtaS1ZtTkdUbGRpUmxwb1ZXeGFVMUpzV25KYVJrcHBVbFpaTVZaSGVGZFdNVkpYVTJ4YVdHRXdOVmRXYlhoaFZERnNObEpyWkZkaVJYQjVWVEo0UzJKR1pFaGhSVkpYVm14d1dGWkVSbE5XYlZaR1YyeE9hRTFJUWxSV2JYaFdaREF3ZUZWWWNHcFRTRUpRVkZaV1lWWXhWblJrUjBaV1RWVldObGxWV2xkV2JGcHpWMnRvVjJFeFdUQlZiWGhMWTJ4T2MxTnNaRmRTTW1jeVZtMTRZVll4U1hoU2JrNVRZV3hhYzFWc1ZuZFZNVnB6Vm0xR1ZWWnNTa2RXYkZKWFZXMUtSbGRzWkZkaVIyaFFWbGQ0WVZac1pISldiVVpYVm14d1RGZFljRWRTTVZwelUyNUtWR0pGTlZoVk1GcExWVVphVjFkc1pGTk5WVFY1V2xWV1lWVXlSWGRqUms1WFlrZFJkMXBYZUdGU1ZrWnlXa1pLYVZKWE9IaFhiRlpYVXpGV2MxZHNXbGhoZWtaV1ZXeGFWMDVHVmxobFJXUlhZa1pLV2xaSGVFdFdNVnBYWTBWU1YxWkZXbEJVYTFwSFl6RktjMWRzVG1oTlZYQlBWbGQ0VjFsV1JYaFdiazVvVW1zMVUxUlZVbkpOYkhCR1YyeE9WbUpHY0ZkV01uaEhWbFpLVjFkcmFGWldNMmhJVm0weFRtVnNVbk5XYkdSWFZtNUNSVlpzV205ak1EVkhVbTVPVTJKR2NGUlpiR1J2Vkd4V2NWRlVSbEpOVmxwWVZtMXpNV0ZyTVZaWGJHUldZbGhTVEZaclpGZFhWMFpIVW14YVYySkdjRWxXVnpFd1RrWktjMWR1U2xSaVJYQllWbTE0WVU1c1dsZFhiR1JUVFZWYWVsWnRjRmRpUmtwMFlVWk9WMkpHV21oVmFrWlRVbXhhY2xwR1NtbFNWbkJaVm10YWIxUXhWbk5YYkZwWVlUQTFWMWxyVlRCTlJteFdWMnRrVjJKRmNIbFdNbk40VlRGYVYyTkZVbGRXYkhCb1dWY3hUbVZIU2tkWGJFNW9UVWhDVlZac1VrOWlNVVY0Vm14a1YyRXlVbGxWYkdodlUwWnNjbFpyZEZaaVJuQlhWRlpvZDFac1duTlhhMmhXVmpOb1VGWnJaRmRTYkU1elUyeGtWMVp1UWtkV2ExWlhWakZKZUZKdVRsTmlSbkJXVmpCVk1WVXhXbk5XYlVaU1RWWmFXbGxyVWxOVmJVcEdWMnhrVjFKc1NsaFdWRXBIVjFkR1JsUnNXbGRpUm5CSlZsZDBWazVWTlhSVWFscGhVbXR3V0Zac1duZFRSbHBZWkVVNVQxSnJXbnBWYlhoaFZUSkdObFpyTlZaaVJrcDZWVlJHVjFZeFduSk9WM0JPVmxad1dGWlhNVEJUTVZwWVZteHNhRkp0VWxkV2JYaGhVMFpWZDFacVVsTmlSWEI1VlRKNFMxWXhXa2hoUkZwWFZteHdXRlZxUmtkak1VcHhWbTE0VTFaWVFsUldiWGhXVFVVeGMxWnNhR2xTV0VKeFZGVmtORTFXV2toT1YwWm9UVmRTUjFrd2FFZFhSMHBJWVVaQ1ZtRXlVa3RhVmxVeFZsWkdkRkpzWkd4aVJsbDZWbFJHYTJReVVYaGlTRXBwVTBVMWNsUlhNVFJqYkZsM1ZsUkdhazFWTlZkWlZWVTFWR3hKZDA1VVFscGhNbEl6V1ZSR1MyUldjRWxSYkZac1lURnJkMWRyV21GaU1VNUdUbFpXVkdKSVFsbFZiR1EwWkZaYWMxa3phRmROYTFwSVdWUk9kMVpzV1hsVmJFcFhWa1ZLVEZSc1dtdGpNa1pHV2tVMVYwMUdjR0ZXVkVsNFRrWlNSMUpZYkZaaGJGcFpXV3RrVTFOR2JGaE5WazVUVW0xME5sVlhlRU5VYkdSSVdqTm9XR0V5VGpSVmFrcFhWbTFLUm1GR1ZtbGhlbFpvVm1wQ1ZrMVZOWE5YYTJoT1ZsZFNjbFZ0TlVOWGJGcEhXa2QwVmxac1ZqTlZNbkJYVjBkS1NHRkZhRlZXYlZKSVZqRmFUMlJIVmtabFJrcE9Za1Z3TkZZeFpEQmhNVWw1Vm01U1ZWZEhlRkJXYWtwdlkwWmFjVkp0Ums5aVJUVXhXV3RvUzFRd01WaGhSV3hWWWtkU1VGbFdaRXRXTWtsNllVWndhVlpGV2xGV1JsWnJVakZrUms5V2JGZGhNMEpVVkZjMWJrMXNXbkpaTTJSUFZsUkdTRll4YUhOaFZrNUhWMjVDV21KR2NHaFViRnBPWkRKR1IxcEhlR2xUUlVwaFZsUkdiMUV4VG5OVWEyeFdZbGhDWVZsc1pEUlJNV1J4VTJzNWExSnNjSGhWVnpFd1YwWktXVkZZYUZaTlZscHlWMVpWZUZkR1RuVlZiRlpvWVRCd2RsWnROWGRqTURGWFZHeGFWV0pVYkhCVmFrWkxUVVphZEU1V1pHaE5WVlkxV2tWak1WbFdXa1pYVkVKaFVteGFlbFZyV2tkWFJuQkdZMFpTVTFkRlNqWldNblJYWWpGWmVWWnNhRlJpYTBwVFZtcEtiMkZHV1hkWGJtUnFUVmQ0TUZSc1drdGhNVmw0VW1wV1dtRXlhRmhaVm1STFZqRmtjVlpzVmxObGExbzJWMnRhWVdOdFZsaFdhMVpUWWxWYVZGUldXblpOYkZZMlVXMDVWMDFzV25wWk1GcHpWa1prUjFkdVFscGlSbHBvVkZWYWEyTXhVblZUYXpsT1ZqSm9TbFpIZEd0aE1VNXpWR3RXVWxaRk5WbFZiR1JPWlVaUmVGZHRPVlJTVkZaWlZrY3hjMkZXV25SUFZGSllWbnBDTkZaRVFYaFRSa3B6WVVaQ1dGSnNjRXhXVnpWM1ZqSk5lR0pJVG1GU2JWSnpXV3hXWVZkc1draGtSazVvVmxSQ05GWXljRWRaVmtwV1RsaGFXbFo2Umt0YVYzaGhaRlphZEdSR1VsTldSVmt5VmxSR1YySXhXWGxXYms1cVVtMTRWVll3Vmt0VE1WVjNZVVpPYUdKSGVEQlphMVpMV1ZVeGMxTnFRbFppVkZaNlZUSjRTbVZIVGtsYVJuQnBWa1ZhVkZZeWNFZFJNVnBIVW01U1dHRjZSbkJXYlRWRFRURmtXRTFJYUZaaVZXdzBXVlJPYzFWR1drWlhia0phWWxob1RGUnRlRk5TYkZKeVZHeHdhRTFxYXpGV1IzaHJZakpHVjFkWWFGZGliRnBXVld4Vk1WSkdVbGRhUlRWc1ZteHdNVmxyV25OV2F6RjFWRmh3VjAxR1duRlVWbHB5WlZaT2RWRnNTbGROYkVwMlZtMXdSMk15U25OVVdHUmhVakJhY1ZWcVFuZE5SbHBYWVVWT1ZHSkZOVXBXVnpGM1YyMUtXR1ZGVGxoaGEwcDZWV3RhUjJSRk1WaGhSbVJzWWtad05WWnJWbXBsUmxGNVZXNVNWbUpIYUZCV2ExWkxVekZXVlZSck5VOVdhelZYVmxkMFlWUXdNVmhoUld4VllUSlNjbFV5ZUVaa01VcDBUbFp3VG1GcldsbFdSbFpyVlRGa1YxUnVWbGRoTTBKVVZGVlNWbVZXWkhKWGJYQk9WbFJHU1ZaSGNHRmhNVWwzVGxoQ1dsWnNXa2haYlhoM1l6RmtjVlZ0ZEZkaVYyaEtWa2QwYTJFeFRuTlVhMXBxVTBVMWFGVnNaRzlYUm5CWFdrVjBhbEpyV2pCWk1HUnpWR3N4VjJJemFGaGhNVnAyVmtjeFUxWXlSWHBpUmtKWVVteHdhRlpHWkRCWGJWRjRWRmhrYUZOSVFtaFVWM1IzVFVaV2RFNVdUbHBXYkhCSlZERmpNVmxXU25SaFJrSmFZVEpTVUZrd1pGSmxWbkJIWTBVMWFHSllVVEJXTVdOM1RWWldjazVZU21sU1ZscFVWbXBLVTJSR1dsVlRibkJPVFZkU1IxZFljRWRWUmxwMFlVVnNWV0pIVWxCWlZtUkxWakpKZW1GR2NHbFdSVnBSVmtaV2ExSXhaRVpQVm14WFlUTkNWRnBYZUdGbGJHUllaVWQwVjAxc1dqQlZiWGh6VmxkS1JsZHRPVmRoYTBWNFdsWmFhMk15UmtaalIyeE9ZVE5CZDFadE1ERlZNV3hYV2tWYVQxZEhVbUZXYlhNd1pXeGtjVk5yZEd0U2JIQXhWbGN4UjFkR1NsVldhazVZVmtVMWVsa3llSFpsVmxwWllVZDRWRkpzY0V4V1ZsSkRVekpSZUZwSVVtbFNWWEJ3VkZkMGQwMUdXblJPVms1YVZtMVNSMVJzYUd0WGJGcHlUVWhvV21WcldqTldNRlV4VjBVMVdHUkdUazVpVmtveFZteFdZVlZ0VVhkUFZscHBVbFphVTFZd1ZrdFRNVlYzWVVaT2FHSkhlREJaYTFaTFdWVXhTR1ZGVmxaV2VsWllWMVphWVU1c1NuVlViSEJzWVROQ05sZFVRbGRPUjFKWFVtNUdVMkpZUWs5WmJHUlRUV3hrV0UxSWFGZE5iRXBJV1RCYWMxWlhTbkpUYmtaaFZtMVNObFJVUm10U2JHdzJVVzFHVGxJemFFdFdSbFpyWVRGc1YxZFljR2hTUm5CWldXdFZNVkpHYTNkWGJtUnFVbXRhV1ZReFpITmhWbHB6WWpOa1YwMXVhSFpXUkVwUFUwWktjMXBIY0U1TmJFcGhWbXhvZDFZeVRsZGlTRVpWWWtkU2NsWnFSa3RTVmxaWFZXMDVWR0pGYnpKV2JUVlBWMjFLU0ZWc2FHRldla1pJVmpGYVUxZFdXbk5qUlRWb1lsaFJNRll4WTNkTlZsWjBWR3RhYVZKWGVISlZha0V4WTBac1YxWnJaR2xpUlRWWFZrZDBUMkV4V25WUmJHeFZWbTFSTUZsWGMzaGtSMVpKV2taU1YxWnJXWHBXTW5CSFlXMVdWazVXYUd4U01uaFlWRlphZGsxc1pGZFhiVGxWVFZoQ1IxUXdhRzlpUms1SFYydDBWbFpGU2t0VWJGcFBWbXh3UjFwSGNFNWhla1V4Vm0xNGEyRXlSa2RYV0docFVucFdWVlJWWkU1bFJteHlXa1YwV0ZKc2NERlpNR1J2VmpBeGRXRklRbGRTYkZwaFdrUktVMVl5UlhwaVJrSlhVbFp3ZDFkWE1UUlNNa3B6Vm10a1ZsZEhVbEZXYkdRMFUxWlNjMXBFVW1oV2JHdzBWakp3WVZkc1duUmhSVGxoVW14d2VWcFdWVFZXVmtwMFlrZHNhVkpXYjNwV1ZFWlhZakF4UjJFemJGUmlhMHBUVm1wS1UxTXhWbFZSYTNST1ZtMVNlbGRVVG05aFZrbDNUVlJXV21FeWFFUldSbVJMWTJ4T1dXRkdjR3hoTTBJeFYxZHdTMU15VWtkWGJsWldZbFZhV1ZWc1VsZE5NV1JWVkc1T2FtRjZValJaVlZadlZERkplVlZyZEZaTlJrcElXVmQ0YzJSSFZrVlZiWFJYVmpOb1JsWldZekZqTVd4WFdrVmtWRmRIYUdGVVYzQkNaREZrY1ZOcmRHdFNiSEF4VmxjeFIxZEdTbFZXYWs1WVZteHdWRlJWV25KbFZrNTFWbXMxVjAxRVZuZFhWM1J2WWpBeFYxVnJiR2hsYkVwb1ZGWldkMWRzYkZaaFIzUmFWbTFTUjFrd2FHdFhiVXBJVld4b1lWSnRVbFJWYTFwSFkxWkdkR0pIZUZkV1Z6a3pWbXBLTkdJeFRYbFRiazVxVW14S1UxbFhkRXRpTVZaeFVteGthV0pIVWpCVVZtaFBZa1paZDAxVVdsZFdiVkp5VjFaa1MxZEhWa2xqUjBaVFZqRktXVmRzV2xkak1VNUhVMjVXVjJKVldsTlVWVloyWkRGWmVGZHRPVkppUnprMVZURm9jMWRHV1hsVmJXaGFZa2RSTUZSV1dtdGpiRnBWVW0xc1UwMUlRbHBXYlRBeFpESkdSMXBGV2s5V00wSmhXV3hrZWsxR2NFaGtTRTVVVW0xU2VGVnRNWE5oVmxwVlZXcE9XRlpzY0hGVWJHUlRWbTFLUm1GR2FHbGhNSEIzVmxSQ1lWTXlUWGhoTTJ4cVRUSm9iMVZxUVRGU1ZteFdWV3RrYUdGNlJucFdNbkJYVmtVeFZrNVZVbFZoYTFwMlZUQlZNVk5XWkhKTlYzaFhWbFp3TVZaVVJsZGlNVTE1VTJ0b1ZtRXllRmhaYlRFMFkwWnNWMVpyWkd0aVIxSllWMnRWTldGSFJYcGhSVlpXVm5wR00xbFVSbXRTYlVwSldrWlNWMVpyV1hwVk0zQkRZekZPV0ZWcmFGVmlWM2h2Vm10a2JtVldWWGhXYXpsU1lrYzVNMWxyVmxOVmJVcHlVMjFvV2xac1draGFSM2hQVmpGd1JrOVZOVmROUkZZelZrZDRVMVF5UmtkWGFscFhZV3RhV1ZsclpHOVRNWEJIV2tWa1dGSlVWbGxaTUdSelZrWktjMk5JYkZkTmJtaDJWa2N4U21WV1ZuTmlSbFpwVjBkb2VGZFdXbE5XTURGWFdrWmtXazB5YUhCVmJHaFRWbFpzVlZOdGRHbFNWRVphV1ZWU1IxWldUa2hqZWtKWVlXdEtlbFZyV2tkWFJuQkdZMFpLVGxKV2NERldha1poWVRGUmVWSnVTbXhUUmxwVFdWZDBZV05XVWxoTlYzUnJZa2RTVmxaSGVHdGlSbHBaWVVSR1dHRXlhRVJaVm1STFZsWmFkVlJzY0U1aVdHZzJWakZTUzFNeVRrWlBWV3hZWVROQ1UxUlZWbUZrVmxWNFZtczVVazFFYkZoWlZWWnZWREZPUjJORk5XRldiRnBJV1cxNFQxWnNVbkpUYlVaT1lYcFZkMVp0TVhkUk1rVjRXa1ZhYWxKRldsVldiR1JUVTBac1dHVklUazlpVmtwSlZrY3hjMkZHV2toYU0yeFdUVlphVUZWWGVIWmxWbVJ6VlcxMFRtSldTbHBXUmxwVFVUSlJlRlZxV2xOaGJFcHlWbXhvYmsxV1VYZGFSM1JwVm14d01WbFZVa2RYUmtwWVZGaG9XbUpIVWxSV01GVXhWMGRPU0dSR1RrNWliV1ExVmpGamVHTXhSWGxUYkdoVFlrZG9VRlpxVGxOV2JHeHpWMjFHVGxKdFVucFpWVlUxWVd4SmQwNUVSbHBXVmtwSVdWZHplR014WkhGV2JGSk9WbFJXUlZaSGNFZGlNVTVHVGxWb1lWSllRbFZWYlRWRFpHeGtWVk51VGxKTmExb3dWVEZvZDFZeVNuTlhia3BXVFVaV05GbHRlRmRTTVZKeVZHczFWMDFFUlRGV2JUQXhZekZTV0ZOc1pGaFhSM2haV1d0a1RtVkdVbFphUlRsUFZsUldXVlJXWkc5V01EQjVXa1JPVjAxdWFIWlZNakZLWlZaS2MySkdWbWhsYlhoM1ZrWlNSMU14WkZkaVJtUmFaV3RhY2xadE5VTlhiRlY0V1hwV2FFMVhVa2RVYkdoUFYyc3hkR1ZJYkZwTlJsa3dXa1ZWZUZkSFJraGpSa3BPWWxkbmQxWXlkR0ZoYXpGWVVtNVNWbUV5YUhCVk1GcDNZMFpzVjFaclpHdGlSMUpHVmtkME1HRldTblZSYm1SYVZrVndjbGxyVlhoWFYwWkZVbXhTVjFaVVZrUldNbkJEWXpGT1YxcElVbWhTTTBKdlZteFdjMDVzWkZkWGJYQk9WakZLV0Zrd1duTldSbGw1Vld4S1YxWkZTa3haYkZweVpWVXhWMXBIYkZkWFIyZDRWakowYjFFeVJsaFRiRlpYWW1zMVlWUlhOVUprTVdSVlUydDBhbEpyV2xsWGExWjNWV3N4Um1KNlJsZE5ibWgyVmxSQmVGZEdVblZWYXpsVFRXeEtlVlpHWTNoT1JURlhZa2hTVGxadFVuTldiRkp2VGtad1ZtRkdaRlJpUlZZelZURlNWMVpGTVZaTlNHaGhWbXh3TTFZd1dsZGpWa3B6WTBVMWFWSnNiM2xXYWtsM1RWWlplVlZzWkdoTk0wSlhXVzEwUzJOR1VsaGpSazVwWWtVeE0xZHJWbUZoYXpGSVpVVnNWazFYYUVSVk1uaFBVMVpXZEdOR2NHbFdNMmhFVmpKd1EyTXhTa2RTYmxacFVqQmFXVlZ0ZEhOT1JtUlZVMWhrVGxKdE9UUlphMXBUVkRGWmVsRnVRbFZXTTBKWVdURmFhMVl5UmtkVGJXeE9Wak5vTTFkV2FIZGhNV1JYVTJwYVZtSlVWbFZXYkdSclRURnNObEZ1VGxOTmJFcEpWbGQwTkZadFZuTlhWRVpYVFc1b2NsWlVRWGhXTWtWNllrWmtWMlZ0ZUhkWFYzaGhXVlV4UjFwSVRtaFNWR3h4VldwQmVFMHhXa2hPVjBab1RWWnZNbFpzYUd0V1ZrcFdUbFZTV0ZZemFIWldhMlJIVG14d1IySkdUbXhpUm5CNFZqRmplR014Um5OaU0yeFdZbXhLVkZsdE1UUlRNVloxWTBaa2FrMVhlSHBYYTFwcllrZEtWbGRzYkZwV1JYQnlWbFphVm1ReFRuVlNiSEJvWVhwV1dWZHJXbXRWTVU1WFZXeHNWMkpZUW5CV2JYaDNaVlprY2xkdGRGVk5hM0JIV2tWV2IxUXhXWHBoU0VKWFlXdGFhRlJ0ZUhOV01rWkdUMVphVjAxR2NGcFdhMk14VXpGc1YxcEZXbWxUU0VKVlZteGFkbVF4WkhKV2FrSlhWakZLU1ZaSE1YTmhWazVJV2pOb1ZrMVdXbEJWVkVwUFVqSk9TVkZzU2xkbGJYaDNWMWQ0WVZsVk1VZGFTRTVvVWxSc2NWVnFRbUZXVmxKellVVTVXbFpzYnpKV2JUVlhXVlpLV0ZWdVZsaGhhMXBFVm14VmVGSlhTa1pqUms1VFZsWnZlbFpVUmxkaU1ERkhZVE5zVkdKclNsTldha3BUVXpGV1ZWRnJkRTlXYlZKNldWVmFUMVJzV1hkT1ZFSlZZVEpTY2xZeFdrWmtNazVIWWtad2FHRXlkRE5XTW5CSFpERmtWMXBJVW14U00wSndXV3hvYTAweFpGZFdiWFJxVFd4S1dGbHFUbTloTURGMFpVWkdWVlp0YUhaVVZscFBWbXhTY2xSc1FsZGlWMmhLVmtkNGExUXlSbGhTYkZwVFlsUldZVlJYY0VkWFJsSldXa1pPV0Zack5URldiWFIzVlRKV2MxZHVjRmhXTTJoeVZtcEtWMlJHU25OaFIyaE9UVlp3ZDFadGNFTlpWVEI0VkZoa1lWSXdXazlXYWtKM1RVWmFTR05GVG1oU2JHOHlXV3RTUjFaR1dsWk9XRnBoVW14d00xWXdWWGhYUjFaSVkwVTFhVmRIWTNsV1dIQkhWREZGZDA1SWFHaFNWMmhRVldwS1UxTXhWbFZSYTJScFlrZDBOVlJXV210VWJFbDRVMnh3VmsxcVZsaFZNbmhMVG14YWRWUnNjR2xTTVVwWlYyeGplRkl4WkZkVmJHeFhZbGQ0Y0Zac1duWmtNVmw1WlVVNVVtSlZOWGxaYTFaVFYyc3hkRlZyTVZaV1JYQlFXVzE0VG1WdFNrWlViWFJYWW10S1dsWkdXbXRPUjBaeVRWaFNiRkpHY0ZaVmJuQkhWVVp3U0UxV1RsaFNWRlpXVlZkMGQxVnJNSGRPV0ZaV1RXcFdlbGt5ZUhaa01rNUZWMjEwVTAxRVZuZFhWbHBYVWpKS2MyTklUbFZpYTNCUVZGWmtiMU5XVW5OVmJrNVlWbXR2TWxadE1YZFhiVXBWVW0xb1ZWWnRVa3hhUlZwVFkxWkdkR0ZHWkd4aVdHUTBWbFJHVjFack1WaFRhMmhVWWtkb1dGbHROVU5pTVZsM1ZsaG9hMkpIVWtaV1IzUXdZVlpLZFZGdWFGWk5WMmhFVlRKNFQxTldWblJqUm5CcFZqTm9SRll5Y0V0Vk1sSkhVMjVXYVZKWVFsVlZiWGgyVFd4WmVXVkhPVlJpUnprMFZWZDRVMVZ0U2xkalNFWmFZa1p3YUZwRldsTlhSMFkyVW1zMVYwMUVSVEZXYlRBeFl6RldSazFXYkdoU1JWcFpWV3hrVG1ReFpIRlJiazVVVm1zMU1GcFZaREJXUmtwellucEdXRlo2Um5wVlZFWldaVWRPUjJGR1RtbFhSVXA1Vmxab2QxWXlUbGRoTTJ4T1ZtMVNiMVZxUmt0VFZscDBaRWRHYUZacmJEUldNbkJEVjBkS1NGUllhRlZXVmxsM1ZXcEtVbVZYU2toU2JFNU9ZbTFSTVZacVFsZFVNVTUwVkZoa2FWSlhlSEZVVnpGVFdWWlNXRTVYT1dsTlYzY3lWa2R6TlZaVk1WaGxSbXhWVm0xUk1GWlZaRWRXYkU1MFkwWlNWMlZyUmpSWFYzUnJVekZrUjFkdVZtcFNNbWhaVld4U1YyTldWWGhhU0U1U1RVUnNWMXBWVmxOVmJVcFdUbFYwV2xkSVFsaFpla1p6WXpGd1IxcEhlR2xXVm5CaFZtdGFVMWxXVG5OVGJsWmhVMFZLVmxWc1ZURlNSbXh6V2tWa1dGSlVWbGxhUlZwWFlWWmFjMkl6WkZkTmJtaDJWa1JLVDFOR1VuRldiV2hUVWxad2VGWkdaRFJaVlRWWFZGaG9WV0pyY0ZCVVZtUnZVMVpTYzFWdVRsaFdhMjh5Vm0weGQxZHRTbFZSYWxKaFVqTm9NMVV4V21Ga1ZsSjBVbXhhYkdKR2NEWldNbmhYWWpGRmVWVnVVbFZpYkZwWFdXMDFRMU14Vm5KVmEwNXBZa1p3U1ZSV1dtdGhNVXAxVVd4d1YxSjZWa1JaVnpGWFpGWldkR05HY0dsV00wMTNWMnRrTUdNd05WZFNibFpxVWpKNFQxUldXblpOVmxsNFZXdDBWMDFXU25wWmExcHpWVzFLZEZWdE9WZGlia0pZV2taYVlXTXhaSEprUmxaWFlUQndXbFpzWTNoaU1rVjRVMWhrVjFaRmNGbFdiVEZ2VWtad1JWTnJkRlJTTUhCSldUQmFkMWRHU25KalJFNVlWak5DUzFSVlpGTmtSa3AxVm14V2FXSklRbmRYVm1NeFZUSk9SMXBHWkdoU1ZHeHdWV3hTVjJWR1dsZGhSVGxhVm0xU1NWcFZWalJXVmxsNllVUk9WMDFXY0ZCYVJtUlBVMGRHUjFwSGVHbFhSMUV3Vm14U1IyRXlVWGxWYmxKWFltdHdjMVZzV2t0V1ZteHpWV3RrYVUxV2NIaFdSekExWVdzeFZrNVdiRnBOUjJob1dWVmFZVmRXY0VWVmJHUnBWa1paZWxZeFdtRmhNVXAwVkd0V1dHSkdXbFJWYkZKWFVsWmtXR05GZEZOTlYxSkpWbFpvZDFkSFNsbFZhemxhVm5wRmVsUldXbXRXTWtaSlUyczVWMkpyU2paWFZsSlBZekpHUjFSclpHcFNWRlpoV1d0YVlXRkdVbFpYYkU1VFZtczFNRnBGVlRGV01ERkhZMFp3V0dKR1duSlVWVnBUVm1zeFNWcEZPVmRTYkhCYVZtcENhMlZyTVZkaVJtaE9WbGhDYzFac1VrZFhiR1J5V2toT1ZXSlZXbnBXTWpWM1YwWmFObEZZYUZkV1JYQllXVEl4VW1WdFNrWlBWbVJPVFcxb00xWnRNWGRTTVd4V1RsaE9hVkp0VW05VmJGSlhZMnhzYzFadFJsaFdiRXA2VjJ0U1ExZHNXblJWYTJ4WVlURktTRll5ZUdGT2JGcHpVV3hXYUUxV2NEWlhWRUpyVlcxV1dGTnJhR3BTVkZadldXeG9VazFHV1hoVmEzQnNVbXhHTlZVeWRHOVdWMFp6VjJ4V1YyRXhjRE5XTVZwM1ZqRmFkVlJyTldsU2JrSTJWMVpXVms1WFJsZFRXR1JQVmtWYVdGVnRNVzloUm14WVpVVndiRll3V2twWGExcDNZVVV4UlZGWWFGZFNiRXBNVlRJeFYyTXhVblZXYkZKb1pXdGFVRlp0ZEd0T1IxWkhXa1prVjJKWVFsQlZha1pMVjBac2NsZHRPVlZpUlRWSVdUQmtiMVpXV2taWGJXaGhVa1ZhZWxreWVIZFNNVTUwWkVkc1YxWkZWWGxXYkZKS1pVZFJlRlZzV2s1WFJYQlFWbXRXZDFsV2JISmFSemxUVW01Q1NWUldWakJoTVVwelkwUkdWMkpVUlhkV2ExcExWbFpLV1dKR2FGZGxhMGt3Vm0xd1MxVXhTWGxVYTJScFVteGFjRmxVUW5kbFJtUnpWMnhPYWsxc1JqUlphMmhUVkd4YWNrNVlRbFpoYTFwb1ZXeGFVMk15UmtaYVIyaG9aV3RKTVZZeWRHOVJNV1JIVTI1S1QxTklRbUZXYlRGVFZFWndSbGRyZEd0V2JGb3dWVzE0YjFVeFdrWlhhazVYWVRGS1RGUnJWWGhTTWs1R1YyMTRVMVpyY0ZaWFZ6RTBVekZzVjFkWVpGZGhNMUpQVkZaa05GZEdaRmxqUldSb1ZqQndWMVJyVWtkV2F6RlhVMjFvVmsxcVJrZGFSRVpyWTJ4U2MxZHNaR2xTYmtKSlZqRm9kMUl4U1hoWGJrNVVZbXR3VlZsclpHOVdNVkpWVTIwNVUxSnNjRmhXTW5oclZUQXhWbU5GWkZWTlZrcG9XVlJHUzFadFRrZFViR1JwVW01Q2IxZFVRbUZWTVVwelYyNVdWV0pGY0hCVmJGcDNWMFprVjFWck9WVk5WbHA2VmpKNFlWZEhSWGRPVm1SVlZrVnZlbFJWV21GWFIxWkdXa1prYVZKWVFqVlhWbFpXWlVaVmVGZHNaR3BTVmtwWVZtMTRkMVl4VW5KYVJUVnNVbXh3ZWxZeWVFOWhSVEZKVVd4U1dHSkdjSFpaYWtaR1pVWmFjMXBHWkdoTmJFcFlWbGQ0YjJJeFNYaFdibEpyVWxoU1YxbHJXbmRXTVZKWFlVaGtWMkpHY0hwV01uUnZWbXhaZW1GRmFGVmlWRVpVVlcxNFQyTXhUbk5hUm1SWFVsVnJlVlp0ZUdGaE1rMTNUbFZrVldKck5WUlphMXAzVmtac1ZWUnJUbFZpUmxwNlZtMHhSMVZyTVZkWGJHaFhUVzVvYUZsWGMzaFhSMVpIV2taYWFWZEdTazFXYkZKTFZqRmtXRkpyV2xWaVJuQllXV3RhZDFOV1duTldiR1JQVW10c05GVXlOVXRXUjBwR1kwWm9WMkpHU2toVWJYaGhWakZrYzFwR1RrNVdWbkEyVmpKMFlWVXlTa2RUYkZwcVVtczFXRmxyV21GaFJsWnpWMnhPVTJKR2NIbFhhMXBMWVZaS1YyTkdhRmRoTVhCVVdWUkdWMUpyTVZaWGJHaG9UVVJXV0ZkWGRHdGlNa1pIVm01S1YyRnNTbFJVVmxwTFpWWlZlV1ZGZEZkTmExa3lWVzF3WVZZeFduTmpSbWhXWVd0YVNGbDZSbXRqVmxwMFpVWk9hV0V3Y0ZWV2JURTBWakZzVjFOc1pGWmhNWEJZV1ZSS1UxVXhiSEpXYlVaWFRWZDRXbGt3WkRCaFJscHpZMFprV2sxR1dsQldiWGhoVW14S1dWcEdjR3hoTVhCSlZtMHhORk15VG5OVWJrNVdZbGhvV1ZWcVNtOVZNVnB6VjIxR1YwMVZiRFJWTWpWTFlrWktWMk5HVWxwV1JVb3pWbFJHVTFaV1NuSmtSazVUWWtWcmVWWlhNSGhOUmxaMFUydGFXR0pIVWxaVVZXUnZWVVphV0dNemFGTmlSMUo1VmtkNFlWZEdTWHBaTTJSWFZtMVJNRlZxUm1Gak1VNTFVMjE0VTFaRldsVldiWFJYV1ZaS1IxZHNaRmhpUjFKV1dXeFZlRTVHVm5SbFIwWldUV3RXTTFrd1dtRldNVnBHVGxoYVYxWnNjRmhXYWtaaFkyeHdSMVJzVGxoU01taEpWbXhqZUUxR1RYaFdiazVZWW10d1dGbHROVU5YUmxweVZtdDBWRkpzV2xsYVZWWnJWREZaZUZkclpGWk5ibWhNVm1wR1lWWXlUa1psUm1SVFZteHdXVlpHVm1GU01rMTRWRzVXVldKVldrOVVWVkpYVmtaYWRHVkdaRnBXYTNCWVdUQmFiMkV4U2xsUmJrWlZWbXhhYUZacVJsZGtSMUpHWkVaa1YwMVdjR0ZYVmxaWFZERmFjMWR1VGxoaGVteFdXVlJHZDFOR2EzZGFSbVJUWWtVMWVsVXllR3RXTVZwMVVXc3hWMkV4V2xoV2FrWktaVVpLZFZSc1RtbFNia0pYVm1wQ1ZrMVdWWGhYYms1WFlsVmFVMVJXV21GWGJHeHlWV3hPVm1KVmNFZFdNbmhyVmpGS2RHRklXbGRXZWtaWVZqRmtSMUpzVW5OWGJHUnBVbTVDU2xac1pEQldNRFZIVTI1T1ZHSnJjRlZaYTFaM1ZERldkV05JVGs5aVJuQllWako0YTFVd01WWlhibkJXWWxoQ2FGbFhNVmRrUmxaelVtMUdWMlZzV2xWV1ZsSkhWakZaZUZkdVRtRlNhelZZVmpCa2IxTldXbkphUkVKVVRWWmFlbFl5TlV0VWJHUkpVV3hrVjJKWWFHaFZNRnBYVjBkV1NHUkdaRk5OVm5CS1YxWldZVk14V1hoWGJHUnFVbFp3V0ZWc1dtRlhSbFp4VW10a2FrMVZjSHBXTW5NeFZrWktWVlpzYUZkaVdHaFlWMVphUm1WR1duVlViRlpvWWtWd1ZGZFhkRmRaVmxsNFZtNVNhMU5IVWxaV2JYUjNWbXhXZEdSRk9WZGlSbkI2VmpKNGExZHRWbkpYYTJoWFlsaG9URmt5ZUZka1IwNUhWR3hrVjFKV2EzbFdiWGhoV1ZaWmVGTllhRk5pYXpWVldXdGFZV05zVm5OVmJHUldUVlp3ZWxadE1VZFdSVEZYVTJ0a1YySllVbkpXVnpGTFVteGtjMXBHY0ZkU1ZGWlJWbTE0Vm1WR1NuTmFTRXBWWWtad2NGbHNhR3BrTVZwWFdrUlNVMDFXY0hwVk1qVkxWbTFHTmxKc1VsZGlXR2d6Vld0YVlWWXhaSE5hUmxacFZsUkZNRlpYTVRSWlZsVjVVbGhrYWxKc1dsaFdhMVV4Wkd4YVIxZHNaRmROVm5CNVYydGFUMVV4WkVoaFJXaFhWbnBGZDFWNlJsZGpNV1J6Vm14S2FXSnJTbGxXYlRFMFdWWk9SMVpzYUd4U1dGSllWV3BHWVZJeFdsaGxSWFJYVFZad1dGa3dWbUZXTVVwWFYyeG9WbUZyV2toWmVrWkxZekZrY2s1V1VsTldSbHBaVm0weE5GWXhiRmRTV0doWFltczFWbGxYZUV0Vk1XeHlWbTFHVjAxV1dqQmFSV2hyVmxaYWNtTkdaRmROYmxKUVZtMTRZV014WkhKUFZuQnNZVEZ3U1ZadE1UUlRNazV6Vkc1T1ZHSllhRmxWYWtwdlVsWmFjMWR0UmxkTlZXdzBWVEowWVdKR1NsZGpSbEphVmtWS00xWnJXbUZqYkZwMFVteE9WMkpGV1RKWFZFSlRVVEZhV0ZOcldsaGlSMUpYV1d4b1UwMHhXa2RYYTNSWFlrZFNlVlpIZUdGV01rcEhZMFJXV0ZkSVFraFdWRVpoWXpGT2RWTnNVbWxTVkZaWVZrWlNTMkl4U2tkWGJHUllZa2RTVmxSV1dsZE5NWEJXVm0xR1ZrMXJWak5aTUZwUFZqSktTRlZxV2xWV1JWcG9WbXhhUjJOc2NFZFRiV3hUVm0xME5GWXllRmRXTVUxNFZtNU9XR0pHY0ZsWldIQkhWbXhXYzFkdVpGWlNiRnBaV2xWV2ExWXlTbFpXYWxwWFVqTm9URlpxUm1GV01rNUdWV3hrVjJKWGFEWldSM1JoVWpKTmVGTnVUbGhpUlRWdlZGWldkMVF4V2xobFJtUmFWbXRXTkZadGVGZFdSMHBWWWtaT1ZWWldTblpVYTFwclkyeGFjbVJHV21sU2JrSlhWMVpXYjJReFduTlhiazVZWVRKb1YxWnFUbTlXUmxweVdrWmtVMkpGTlhwVk1uaHJWakZhZFZGclpGZGhNVnBZVm1wR1NtVkdTblZVYkU1WVVqTm9lbFpYZUZaTlZsSnpWbTVPVjJKVldsTlVWbHBoVjBaYWRFMVlaR2hoZWtaWFZqSjRhMVp0U2xsVmJXaFhWa1ZhVEZVeFdsTldWbEp6Vm0xNGFFMVlRbEpXYkZwclRrWkplRmR1U2xCV1YzaFdXV3RXZDFkR1duTlhibVJUVW14d2VWWXljelZVTVVwelYydG9WbUpZYUdoV1ZFcEdaVVpPY2s1V1dtbFNiSEJ2VmxaU1IxWXhXWGhYYkd4aFVqTkNUMVp0ZEZwbGJGcFlUVlJDVkUxV1dqQldiWGh6WVVaS1dGVnNaRmRpV0dob1ZUQmFWMlJIVWtWVmJFNXBVbGhDTlZaVVNqUlRNVmw0VjFod1ZtRnNjRmhaVkVaM1YwWldjVkpyWkdwTlZUVjZWbGN4TkZVeFdsbFJiRkpYWWxob1dGZFdXazVsUmxaeVYyeGtXRkl5YUZSWFYzUlhXVlpaZUZkdVRtaFNWR3hYV1d0YWQxWXhXWGxrUlRsWFlYcENOVnBJY0VOV01WcFhZMFZvVjJKWWFFeFpNbmhyWTJzeFYxUnNaRmRpYTBwR1ZtMTRZVmxXV1hoVmJsSlZWMGRvVkZsclduZFdSbXhWVVc1a1YxSnNjRlpXUnpBMVZXc3hWMWRzYUZkaVdGSnlWbFJHUzFkWFJrWmFSbHBwVjBaS1RWWnNaRFJaVmxweVRWWnNhbEpzY0ZoWmExcDNVMVphV0dSSGRGTk5helY2Vm0xNGMxWlhTa1pqUm1oWFlrWndNMVZyV21GV01rWkpXa2Q0YUdWc1NYcFdSRUp2WVRGVmVWSllaR3BTYkVwWVdXdGFkMU5HY0ZobFIwWlhWbXRhZVZkcldrdGhWa3B6WVROb1dHSkdXbGhWZWtaWFl6RmtjMWRzYUdsV1IzaFhWbGQ0YTFVeFZrZFdiR2hzVWxkU1dGbHJXa3RYYkZwSVpVVjBWMDFXY0ZoWk1GWlRWakpGZVdGSWNGVmhNWEJvVldwR1MyTXhaSE5VYldoT1YwVktVRlpzWkRSV01XeFhVbGhvVjJKSFVsaFdhMXBMVlVaU1YxZHJkRmROVmxvd1drVmFUMkZHU1hkV2FrNVZWbTFvTTFadGVHRmpNV1J5WVVaYVYwMHlhRlZXUjNoclZqRkplRlJ1VGxSaVIxSllWbTAxUTFJeFduSldiR1JYVFZWc05GVnROVTlWTWtwSFkwVTVWazFHVlhoV01GcFRWbXhhZEZKc1NrNVdiRmt5VjFkMFUxVXhWblJUYTFwWVlrZFNWMWxzYUZOV1JscFdWbGhvV0ZJeFdrZFdSM2hoVmpGS1dWRnNVbGhYU0VKSVZXcEdZV014VG5WVGJGSnBVbXR3V0ZaR1VrdGlNVkp6VjJ4a1dHSkhVbGRVVm1SVFpWWndWbFp0UmxaTmExWXpXVEJhVDFaV1drWmpTRnBXWVRGd1ZGVnRlR0ZqYkhCSFUyMXNVMVp1UWxsV2ExSkRZakZSZUZadVRsaGlSbkJaV1ZSQk1WZEdWblJqZWtKT1VteGFXVnBWVm10V01rcEdZMGh3VmxZelRqUldWRVpoVmpKT1JsVnNaRmRpU0VKWlZtdGplRlJ0VmtkVGJrNVlZa1UxYjFSVmFFTldSbVJ6VjIwNWFVMVZWalJXYlhoclZqSkdObUpGT1ZwaE1WcG9XbFZhZDFKc2NFaFBWbHBwVW01Q1dGWnFTalJoTVZwWFUyeGtXR0V5YUZkV2FrNXZVMFphZEdONlZsUldiRXA2VmpKNGExWXhXblZSYTFaWFlrWndkbGw2UVRGU01VcDFWR3hPYVZKdVFsVlhWbEpIVXpGU2MxWnVUbGRpVlZwVFZGWmFZVmRHV25SamVrWm9ZWHBHVjFsclVrOVdiVXBaVld0NFYxWjZSbGhXTVdSSFVteFNjMWRzWkdsU2JrSktWbTEwVjFZd05VZFRXR2hVWW10d1ZWbHJWbmRYUmxweFVWUkdUMkpHY0ZoV01uaHJWVEF4VmxkdWNGZFdNMEpZV1d0YVMyTnRUa2RVYkdScFVteHdiMVpYZUdGVk1VcHpWMjVLWVZKcmNIQlZiRnAzVjBaa1ZWUnVaR2hOVjFKNVZGWldZVmRIUlhoWGJGcFdZVEZhVEZWNlJuTk9iRXB5VjIxMFRsWllRalZXYlRFMFZqRldjazFJYkdoU1ZrcFlWbTE0ZDFkR1ZuRlRiR1JxVFZWd2VGWnRNVFJWTVZwWlVXeFNWMkpZYUZkYVZWVXhZekZhYzJKSGJGTlNhM0JVVjFkMFYxbFdXWGhXYmxKc1VsVTFWbFp0ZEhkV01WbDVaRVU1VjJKR2NIcFdNalZ6VjIxV2NsZHJhRmRpV0doTVdUSjRUMk14V25SbFJtaFRUVzFvUmxadGVHRlpWbGw0VTFob1ZHRXhjSE5WYkZwM1ZrWnNWVkZ1WkZaTlZuQjZWbXhvYjJKSFNrZFhiR2hYWWxoU2NsWlVSa3BrTURWWllrWmFUbFpyY0hsV2FrbzBXVlphYzFwSVNsVmlSMUp3Vld4U1VtUXhXbGRhUkZKVFRWWndlbFV5TlU5VmJVWTJVbXhTV2xaRldqTlZhMXBoVmpGa2MxcEdWbWxXVkVVd1ZsY3hORmxXVlhsU1dHUnFVbXMxYUZadE1XOWtiRlpWVW14a1YwMVdjSGxYYTFwUFZURmtTR0ZGYUZkTmJsSllWWHBHVjJNeFpITlhhelZZVTBWS1dGWnRNVFJaVms1SFZteG9iRkpVYkZCV2FrWmhVMFpaZVdWRmRGZE5WbkJZV1RCVk1WWXhTbGRYYkdoV1lXdGFTRmw2Umt0ak1XUnpVV3hTVTFaR1dsbFdiVEUwVmpGc1YxSllhRmRpUjNod1ZXdGFTMVV4YkhKV2JVWlhUVlphTUZwRlVsTldiRXBWVW14c1lWWldXbEJXYlhoaFVtMUZlbUZHV21oTlZtdDNWbGN4TkZNeVRuTlViazVVWWtkU1dGUlVSa3BOYkZwellVaGtVazFWYkRSVk1uaHJWakpGZUZOdVRsWmlSbG96VmxSR1lXTXhXbk5qUjNocFVteHdZVmRYZEZOVk1WWjBVMnRhV0dKSFVsaFZiWGhMVlVaYVdFMVdaRmhXTUZwSFZrZDRZVll5U2tkalJXeFhZa1phV0ZScldrdGpNVTUxVTJ4U2FWSllRbGxXYlhSWFV6QTFjMWRzWkZoaVIxSlVWRlpXWVdWc1dsaGpSbVJwVW10d1Yxa3dXazlXTWtwSFYyMW9WbUpHY0ZSVmJYaGhZMnh3UjFOdGJGTldia0paVm0xMFlXSXhVWGhXYms1WVlrWndXVmxVUm1GV2JGcDBaVWRHVkUxWGR6SlZiWFJyVmpKS1JtTkliRlpOYm1oUVdXdGFhMU5IUmtaVmJHUlhZa2hDV1ZadGNFZFRNVnB5VDFaV1dHSllRbk5aYkZwTFYwWmFSMVpzWkZwV2JIQjZXVEJXYTFZeVJqWldia1pWVm14YWFGWnFSbGRrUjFKSFZHMW9UbUV4V1hwV1JscHZaREZhYzFkdVRsaGhNbWhZVm1wT2IxWkdVbk5hUm1SVFlrVTFlbFV5ZUd0V01WcDFVV3hPVjJFeFdsaFdha1pLWlVaS2RWUnNUbWxTYmtKWFZtcENWazFXVlhoWGJrNVhZbFZhVkZadE1UUlhWbkJHVm01a2FHRjZSbGRXTW5oclZtMUtXVlZyZUZkV2VrWllWakZrUjFKc1VuTlhiR1JwVW01Q1dsWnNaRFJXTURWSFUyNU9WR0pyY0ZWWmExWjNWMFpXY1ZOdE9WTk5WbkJIVm0xNGExVXdNVlpYYm5CV1lsaENhRmxXV2t0V01XUnlUbFphYVZKc2NHOVdWbEpIVmpGWmVGWnVVbE5pUlhCUFZUQmtiMU5HV2xoTlZFSlVUVlphTUZadE5WTldiVVY0VTJ4YVZtSkdjR2hWTUZwWFYwZFdSbHBHWkZkaGVsWTFWbXRrZW1WR1ZYaFhiR1JxVWxaS1dGWnRNVzlOTVZwRlVtdGFhMDFzV2tkV01uaFBZVVV4U1ZGc1VsZGlXRkpvV2tSR1MxWXhWbkpYYkdSb1RXeEtWRmRYZEZkWGF6RnpXa2hLVjJKRk5WWldiWFIzVmpGWmVXUkZPVmRpUm5CNlZUSXhiMVpzV2taVFZFSldZbGhvVEZreWVFOWpNVTUwWlVkc1YyRXpRa2RXYlhSWFZqRlplRk5ZYUZOaWF6VlVXV3RrVTFaR1dYZFdWRVpXVFZad2VsWnRNVWRWTVZwelkwWnNXbUV4U2xSV1Z6RkxVbXhrYzFwR1dtbFdSbHBOVm14amVGSXhaRmhTYTFwVllrWndXRmxyV25kVlZtUlpZMFZrVTAxck5VbFdiWFJoVmtkS1JtTkdhRmRpUm5BeldWVmFZVkpzV25OYVJrNU9WbFp3TmxaWGVHOWlNa1pXVFVoa1QxWnJOVmhaYTFwaFlVWldWVkpzV214U2JGb3hXVEJWTlZSc1NraGpNMnhZVmtVMU0xbFVSbGRUUmxwMVZteFdWMUpVVmxkV1JsSlBVVEExYzFWdVJsSldSbHBRV1d4YVMxSXhWWGxsUlhSWFRWWndlbGt3VlhoV01VcFhWMjFvVjFKRldraFpla1pMWXpGd1IxWnNhRk5XUmxwVlZtMHhORll4YkZkU1dHaFlZbXhhY0ZWcldrdFhWbXh5Vm0xR1YwMVdXakJhUlZwUFZsWmFjbU5HWkZkTmJsSlFWbTE0WVdNeFpIVmlSbFpvWVRGd1ZWWnRNVFJUTWs1elZtNVNhVkl5YUU5VmFrNXVUV3hhYzFkdFJsZE5WV3cwVlcwMVQxWnRTa2RUYms1V1lXczFSRlpVUm1Gak1WcDBVbXhhVGxacmNFaFdiVEV3WVRGV2RGTnJXbGhpUjFKV1ZteGtiMVZHV25OV1dHaFRZa2RTZVZaSGVHRlhSa2w2V1ROa1YxWnRVVEJWYWtaaFl6Rk9kVk5yT1ZkV1JWcFZWbTEwYTA1R1NrZFhiR1JZWWtkU1ZsbHNWWGhPUmxaMFpVZEdWazFyVmpOWk1GcHZXVlphZEdGSVdsaFdiSEJZVm1wR1lXTnNjRWRVYkU1WVVqSm9TVlpzWTNoTlJrMTRWbTVPV0dKSGFISlZNR2hEVmpGYWRHVkhSbFJTYkZwWldsVldhMVF4V1hoWGEyUldUVzVvVEZacVJtRldNazVHVjJ4a1UxWnNjRmhXUjNoaFVqSk5lRk51VGxoaVJscFpWV3hTVjFaR1duUmxSbVJhVm10V05GWnROVmRoVmtwSFUyMDVXbUV4V21oV2FrWlhaRWRXU0U5V1ZsZGhNMEpZVm1wS01GUXhXbk5YYms1WVltMTRWbGxYZEdGWFJscDBaVVYwYW1KR1dubFVWbFV4VlRKRmVHSjZTbGRpUm5Cb1ZtcEdTbVZHU25WVWJGcHBVbXR3ZWxaWE1UUlRNVlY0VjI1T1YySlZXbFZXYlhoTFVqRmFkR1JIZEZaaVZYQkhWako0YTFkc1drWk9Wa0pYWVRGV05GVnRlR3RqYkZKelYyeG9VMDB5VGpOV2JGcHJUa1pKZUZkdVRsUmlhM0JRVm14U1IxWkdXbk5YYm1SVFVteHdXRll5ZUd0V1YwcFdUVlJTVm1KWWFHaFdWRXBHWlVaT2RWUnNjRmRTVlhBMVZrWlNSMWxYVGxkU2JrcGhVbXMxVDFadE1EUmxSbVJ6Vm14a1ZFMVdXbnBXTW5oaFYwZEZlbFZzV2xaaVJuQm9WVEJhVjFkSFZrWmFSbWhYWWtWd05WWnNaSHBsUmxWNFYyeGthbEpXU2xoV2JYaDNZMnhzVlZKcldtdE5iRnBIVmpKNFQyRkZNVWxSYkZKWFVteEtSRnBFUmtwbFJsWnlWMnhrYUUxc1NsUlhWM1JYVmpBd2VGVllaR2hTVkd4WFdXdGFkMVl4V1hsa1JUbFhUVlZ3ZVZSclVrTldiRmw2WVVWb1YySllhRXhaTW5oWFkyc3hWMVJzWkZkaWEwcEdWbTE0WVZVeFRYaGFTRkpWVjBkb1ZGbHJXbmRXUm14VlVXNWtWazFZUWxsVWJGcFBWbFphYzFkc2FGZGlXRkp5VmxSR1MxZFhSa1phUmxwcFYwWktUVlpzWkRSWlZscFhVbTVXYWxKdVFsaFphMXAzVkZaYVYxcEVVbE5OVm13MFdWUk9kMVpYU2taalJtaFhZa1p3TTFWcldtRldNa1pKVkdzNVUyRjZWa2xXVnpFMFdWWlZlVkpZYUdwU1ZGWlhXV3RhWVdGR1ZsVlNiR1JYVFZad2VWUnNWVFZVYkZwMFpETndWMVo2UlhkV1ZFWnpWMFpLYzJKSGFGTldWRlpZVm0weE5GbFdUa2RXYmtwWFlXeEtWRmxyV25kbFZsVjVaVVYwVjAxV2NGWlZiWEJoVmpGYWMyTkdhRlpoYTFwSVdYcEdWMk14Vm5SbFJrNW9UVWhDVlZadE1UUlpWazE0Vm01T1ZtRXhjRmhaVkVwVFZURnNjbFp0UmxoV2JWSjVWbTF6TlZaV1duSmpSbVJYVFc1U1VGWnRlR0ZTYXpWWlYyeGFWMUpWYTNkV1Z6RTBVekpPYzFSdVRsUmlSMUpQV1d0V2QxSnNXbkpXYkdSWFRWVnNORlZ0TlU5Vk1rcEhZMFphVjAxR1ZYaFdWRVpoWXpGYWRGSnNTazVXYkhCaFYxZDBVMVV4Vm5SVGExcFlZa2RTVjFsc2FGTldSbHBIVjJ0MFYySkhVbmxXUjNoaFZqRktWVlp0T1ZkV2JFcEVWR3RhUzJNeFRuVlRiRkpwVWxoQ1dWWnRjRUprTWxaelYyeHNhbEpWTlZSVVZsWmhaV3hWZVdWR1RtbFNhM0JYV1RCYVQxWXlTa2RYYldoV1lXdGFWRlZ0ZUdGamJIQkhVMjFzVTFadVFsbFdiWFJoWWpGUmVGZHJaRmhpUm5CWldWUkJNVll4V1hkYVJFNU9VbXhhV1ZwVlZtdFdNa3BHWTBoc1ZXSkdWalJXVkVaaFUwZFdSbFZzWkZkaVNFSlpWbXRqZUZSdFZrZFRiazVZWWtVMWIxUlZhRU5YYkZwelZXczVhVTFyTlZoV2JYaHJWakpGZVZWc1VscFdSVFYyVldwR1YyUkhVa1prUmxwcFVtNUNXVlp0TURGa01WcHpWMjVPV0dFeWFGZFdhazV2VTBaU2MxcEdaRk5pUlRWNlZUSjRhMVl4V25WUmEyUlhZVEZhV0ZacVJrcGxSa3AxVkd4U2FWSXlhSHBXVjNoaFV6RlNjMVp1VGxkaVZWcFRWRlphWVZkR1duUmxSMFpWVFVSR1JsbFZVazlXVmxwelYydDRWMVl6YUdoV01HUlRVMWRPUjFkc1pHbFNia0pLVm14YWEwNUdWWGRPVm1oWFlUSlNXVmxyVm5kWFJscHpWMjVrVkdKR2NFZFdiWGhyVlRBeFZsZHVjRlppV0dob1ZrZDRUMUpyTlZkWGJGWlhWbXh3YjFaV1VrZFdNV1JZVTJ0V1ZtSkZjSEJWYkZwM1YwWmFXRTFZY0U1V2JFcFlWVEo0VjJGV1NsWk9WbVJYWWxob2FGWkVSbk5PYkVweVdrWmthVkpZUWpWV1ZFbzBaREZhY2sxSWJHaFRTRUpZVm0xNGQxZEdWbkZTYTNScVlsWmFSMVl5ZUU5aFJURkpVV3hTVjJKWWFHaFdha3BYWXpGYWMxcEdaR2hOYkVwVVYxZDBWMWRyTVZkalJscFhZVE5TVjFsclduZFdNVmw1WkVaa1YxWnJjRmhXTW5SdlZteFplbUZGZUZkaE1WVXhWbTE0VjJNeFJuUmxSMnhwVWxoQ1VsWnRlR0ZaVmxsNFUxaG9WV0pyY0hOVmJGcDNWa1pzVlZGdVpGWk5WbkI2Vmxjd05XSkhTa2RqUm1oWFlsaFNjbFpYTVV0U2JHUlZVbTFHVjFac2NFMVdiR1EwV1ZaYWMxcElTbEJXYkZwVVZtMDFRMlZXV2xkYVJGSlRUVlp3TUZaR2FIZFdWMHBHWTBab1YySkdjRE5WYTFwaFZqSkdTVlJyT1ZOaGVsWkpWbGN4TkZsV1ZYbFNXR2hxVWxSV1YxbHJXbUZoUmxaVlVteGtWMVpzU2pCVU1WcExWR3hLU0ZwNlFsZE5ibEpZVlhwR1YyTXhaSE5XYldoVVUwVktXRlp0TVRSWlZrNUhWbXhvYkZOR2NISlVWbFV4VjJ4YVNHVkZkRmROVm5CWVdUQldVMVl4V25SaFNIQlZZVEZ3U0ZsNlJrdGpNV1J6Vm14a1UxWnVRbFZXTVZwaFlqSkplRkpZYUZkaVIxSllXVlJLVTFaV1ZuTmhSemxUVFZaYU1GcEZWakJXYXpGWFkwWm9WbUpHU2xCV2JGVjNaV3hHV1ZwR1pHaE5XRUpKVm0weE5GTXlUWGhTYmtwT1ZtczFXRlp0TlVOU1ZscHpWMjFHVjJGNlZrbFdSbWh2VmpKS1IyTkdVbHBXUlVvelZsUkdkMVl5UmtoUFZrcE9WbXh3V1ZadE1UQmhNVnBIVTJ4c2FGSlhlRmhWYWs1VFZFWmFXR1ZIUm10U2JFb3hXVEJhWVZZeVNrZGpSV3hYVm0xUk1GWlVRVEZYUmxweVdrWmFhVkpZUWxsV2JYaGhaREZPUjFkcldsZGlSMUpVVkZaV1lXVnNWbk5oU0dSV1lsVldORlV5ZUVkV1ZscDBWV3hTVmxaRldsaFdha1poVmxaV2RHTkZOVmRXYmtKWlZteGplRTFHVFhoWGJHaFhZa2Q0YjFWdGN6RldNVnAwWlVkR1ZGSnNXbmxXYlhCVFZUSktSbU5JYkZaTmJtaE1WbXBHV21Wc1ZuRlhiR1JvVFZWd1JWWlhjRWRTTWsxNFZHNUdWMkpZYUZSV2JHaERWa1phZEdWR1pGcFdhekUwVmxkMFlWWXhXa2RYYkU1YVlURmFhRlpxUm10V1ZsSnlUMVphYVZKdVFsaFdha293VkRGWmVGUnJhR3RsYTBwWVZtcE9iMU5HV25SbFJYUnFZa1phZVZSV1drOVdNVnAxVVd0V1YySkdjR2hXYWtwWFpFWlNXV0ZHWkdsU2JrSlZWMWQ0VTFJeVRrZGlSbFpTWW1zMWMxbHJXbUZYUmxwMFpFZDBWazFWYkRSV01qVnpWbXN4V0dGR1FsZFdNMmhvVm0xNGEyUkZPVmRqUjJ4VFlraENUVll4YUhkU01VbDRWMjVPVkdKcmNGZFpXSEJ6VmtaYWMxcEVVazlpUm5CWVZqSjRhMVV3TVZaWGJuQlhVak5vVkZscldrdFdiVTVIVkd4a2FWSnNjRzlXVjNoaFZURktjMWR1U21GU2EzQndWV3hhV2sxV1draGxSbVJYVFZaS1dGVXllR0ZYUjBWM1RsWmtWMkpZYUdoV1JFWnpUbXhLY2xwR1pHbFNXRUkxVmxSS05GTXlTa2RhUldob1VsWktXRlp0ZUhkWFJscEZVbXhPVjJKV1drZFdNbmhQWVVVeFNWRnNVbGRpV0doWFdrUkJkMlZHVmxsalIzQlVVMFZLVVZaR1dsZFpWbGw0Vm01U2ExSXdXbGRVVmxaWFRteHNWbGRzWkZkaVJuQjZWakowYjFZeVJYaFhWRUpXWWxob1RGa3llRTlqTVU1eldrWmtVMDF0WTNsV2JURTBXVlpaZUZOWWFGTmlhelZVV1ZkNFlXTXhWbk5XYm1SV1RWWndlbFp0TVVkV1ZscHpVMnRrVjJKR1NsaFdWekZMVW14a2MxcEdaR2xTTW1oUlZteGtORmxXV25OYVNFcFhZbFZhV0ZadGVIZFVSbVJaWTBWa1UwMVdjSHBWTWpWTFZrZEtSazVXYUZaTlJuQk1WbFZhWVZZeFpITmFSazVPVmxSV05WZHNWbGRaVmxWNVVsaGthbEpyTlZoWmEyUlNaREZ3V0dWSFJsTldhMXA1VjJ0YVMyRldTbGhQU0doWVlrWmFXRlY2Umxkak1XUnpWMnhvYUdWcldsZFdWM2hoVmpBMVIxWnNhR3hTVjFKWVdXdGFTMWRzV2tobFJYUlhUVlp3V0Zrd1ZsTldNVnBHVjJ4Q1ZXRXhjRWhaZWtaTFl6RmtjMVJ0YUU1V1dFSlFWbXhrTkZZeGJGZFNXR2hYWW1zMWIxVnRjekZWTVZKV1ZXNUtUbUpJUWtkV01uaFBWbTFLUjJOR1pGZE5ibWhJVm14YVMxWXhaSEpoUmxwWFRUSm9TVlp0TUhoVWJWWnpWVzVPVjJKSFVsaFdiVFZEVWxaYWMxZHRPV3BOUkZaSVZXMDFUMVV5U2tkalJsSmFZa2RTZGxaSGVGZGpWa1pWVW14S1RsWnNjRmxXYlRGNlRWZEdjazFXV2xoaVIxSlhXV3hvVTFSR1duSmFSbVJZVmpCYVNGVnRlR0ZXTWtwSFkwVnNWMVo2UlhkVWExcExZekZrZFZOc1VtbFNXRUpaVm0weE5GbFZOWE5YYkdSWVlrZFNWRlJXVm1GbGJGcDBZMFprYVZKcmNEQlpWVnBQVmpKS1IxZHRhRlpoYTFwVVZXMTRZV05zY0VkVGJXeFRWbTVDV2xadGRHRmlNVkY0Vm01T1dHSkdjRmxaVkVFeFZqRnNjbFpVUWs1U2JYaFhWakowYTFZeVNrWmpTR3hYVFc1T05GWlVSbUZXTWs1R1ZXeGtWMkpJUW05WFZtTjRWRzFXU0ZOclpGaGlSVFZ2VkZWb1ExWldXbk5WYXpscFRWVldORlp0ZUd0V01rVjVWV3hzVm1KSGFIWlZNRnB6WTJ4YWNtUkdXbWxTYmtKWVZrWmFiMlF4V25OWGJrNVlZVEpvVjFacVRtOVZSbHB5V2taa1UySkZOWHBWTW5oclZqRmFkVkZyWkZkaE1WcFlWbXBHU21WR1NuVlViRTVwVW01Q1YxWnFRbFpOVmxWNFYyNU9WMkpWV2xOVVZscGhWMnhzY2xWc1RsWmlWWEJIVmpKNGExWXhTbk5UYkdoWFZrVndTRll4WkVkU2JGSnpWMnhrYVZKdVFrcFdiR1F3Vm1zMVZrNVlVbFZoYkhCb1ZXMTBkMWRHV25OWGJtUlVVbXh3V1ZwRlZUVlVNVXB5VjI1d1ZtSllhR2hXVkVwSFRteGFjazVXV21sU2EzQTJWbFpTUjFZeFdYaFhia3BQVmpOQ1QxWnNXbmRYUmxwWVRWUkNWRTFXY0ZsV2JYaHpZVVpLZEZWc1pGZGlXR2hvVlRCYVZtUXhXbkZWYkU1cFVsaENOVlpVU2pSVE1WbDRWMnRvYUZKR2NGaFdiWGgzVjBaV2NWSnJaR3BOVlhCNFZtMHhORlV4V2xsUmJGSlhZbGhvVjFSVlZYaGpNVnB6WVVkc1UxZEZTbmhXUmxaclRrVXhWMWRyYUU5V01GcHZWRlprVTFJeGEzZGhSV1JZVWpCd1NWbFZXa05XYlVWNVZXdDBZVlpzVlhoV2JGcEhaRVpLYzFwSGVHbFNiR3cyVm14U1IyRXlVWGxWV0docFUwVndjRlV3VlRGamJGSllUVlJTYW1KR2JETldiRkpIWVdzeFZrNVdaRnBXVmxVeFZrZDRTbVF3TlZWUmJIQm9UV3hKZWxkV1VrZFRNbEpYWTBWc1VtSkdXbk5aVkVaeVpERmtjbGR0Um1sTlZUVkhWR3hhVjFaSFNrbFJiR3hXWWtkUk1GcEdXbUZqTVd0NllVWmtUbUV4Y0VsWFZsSlBaREZhYzFkWWJGWmlSWEJZVm10V1MxUkdVbk5YYlhScVRXdGFSMWRyVlRGV01ERkhZMGRHVjFaRmJEUlVhMXBUVWpGS1dXSkdXbWhpUm5CYVYxZDBhMVV4VGtkaVJtaE9WbXMxVkZWdE1UQk9iRlpZWlVWT1ZXSkhVa2xYYWs1dlYwZEZlVlJxVWxaaGEzQllWbTB4UzFKdFJrZFdiV3hvWld4YWIxWnRjRU5XYXpGV1RsaE9XR0V5YUU5V2JHUlRZMnhXZEU1VlRsaGlSbkJJVjJ0a01GWnNXbk5XYWs1V1RXNUNXRll3WkV0VFIwWkdZVVpXVjJKV1NrbFdha1poVkRKU1NGWnJXbXhTYTNCUFdXdFdkMDVHV1hoYVJFSm9UVlZzTlZadE5WTldWbVJJWlVaQ1YyRnJjSFpaTUZwaFkxWktkRkpyT1dsU1ZGVjRWMWQwYjFNeFVYZE5WbWhvVWxkNFZsbHJaRk5WUm14WFdrVjBWMDFyYkRaWlZWcDNZVlphUmxkc1JsZFNiRnB5VldwR2ExSnJPVmRpUm1Sb1RUQktWVlpHWXpGaWF6RnpWMjVLV2sweVVsQldiRkpIVTBaWmVHRklUbWhXYXpWSVZqSTFRMWR0U2tkalIyaFZZa1p3VDFwRVNrZFNNWEJJWlVkc1ZGSlZjR2hXYkZKSFlqRkZlRlJ1VGxWaE1uaFhXV3hvUTFsV2JITmFSRkpTVFZkU2VGVXljelZoTVVwelkwaG9WbFo2UlhkV01GcExWMVpHV1dGR1drNVdiSEI1VmpGYVZtVkdaRWRVYmxaV1lrWmFiMWxVUW5ka2JGcDBUbGhrYWsxRVJsaFdSM2hoVmxkS1ZXSklRbFpoYTFwTVZGVmFZV1JGTlZkYVIyaE9WbFpaTVZkclZtcE5WbXhYVjJ0YVdGWkZTbWhWYlhoaFpXeFdjbGRyWkZoU2JrSkhXVEJhVTFVeFpFWlRhbHBYVFc1U1dGbHFSbHBsVmxwellVWlNhV0V3Y0ZSV2JYQkxZakpHUjFkWVpGaGliVkp4VkZaa05FMUdVbk5YYTNSb1RWWnNORlZ0Y0ZkWGJVVjVZVVpvV2xadFVreFdha1pyWTFaYWMxWnNUbXhoTVc4eVZqSjBZVmxYVG5SV2JHaFhZVEZhVkZsc1ZtRldSbEpYVjI1YVRtSkdXVEpWVnpBMVZqQXhjMWR1Y0ZwTlJuQjZWbXRhYTFJeFpIVlJiSEJwVW14d2IxWkdWbUZoTWsxNFZXNVdWR0Y2YkU5V2FrcHZVMnhhU0dSSGRHaE5WVFY2VmtkMFYxVnNXa1pPVm14V1lrZFNUMXBWV2xKbFJtUjBUMVpTVTFaR1dscFdhMk40WXpKR1YxZHVVbEJXUmtwWlZtNXdRMDVHV2tWUldHaFVVbXR3ZWxsVldrTlhSa3B6WTBWNFYxWjZWak5XYWtwT1pVZEtTVlJ0UmxOaVZrcDZWMWQ0VjFsV1pITlhhMmhyVW1zMWIxWnNVa05PUmxsNVkwVmtXbFpyY0ZkVWJHaGhWMnhhTmxKcmRHRldNMmhvV2taYVlXUkhVa2RWYkU1WFVsWnJlVlpzVWtkV01rbDRWMWhzVjJKck5YRlZiVEUwVmxaWmQxWnJkRlJOVmxZeldWVmFUMkZIU2tobFJFSmFZVEZhVEZkV1ZYaGpNVTV4VVd4YWFWWkdXalpXVkVvMFUyMVdTRlJyYkdGU2JrSndWbXRXWVZaR1dYbGpSV1JTVFZad1NGVnROVk5YUjBZMlVtNUNWMkpVVmtSVVZFWnJWMFV4U1dGR1dtbFdWM2N3VjFaU1QyTXhWa2RYYTFwWVltdEtZVmxzYUc5VVJsSjBaVVpPVTJKR1NubFdSM2gzWVVVeGNXRjZSbGRTTTJoeVdXcEtSMVl4WkZsaFJtUnBZa1p3VjFaWGVGWk5Wa3BIVld4a1lWSlVWbk5XYlhoM1RWWnNjbGR1VGxkaGVrWXhWa1pvZDFZd01VZFhia1pWVm14d2VWcFdXazlrVmtaelUyeGtUbUpGY0RKV2JURjNVakpOZVZOdVRsVlhSMUpvVldwQ1lXTldWbkZSYm1ST1VteHdXRmxWVms5V1IwcEdUbFZ3VjFaNlJqTldNakZMVjBkV1JsUnNhR2hoTUhBMlZsZDBZVkl5VWtaTlZtaG9VbTFTYzFsclduZE9WbHB5Vm0xd2JGSnNSalZXVnpWVFZtMUtTR0ZHUWxkaE1WcE1WWHBHVjFaV1VuSk9WVGxYWVhwV1dGWnNaREJaVmxGM1RWWm9hRkpYZUZaWlZFcFRZMnhWZVdWRldtdE5WWEF3Vkd4YWQxUnRSbkpYYkd4WFVteGFjbFpVUm10V01WSjFWbXhrYUUwd1NsVldSbFpUVm0xV1YxcElTbGhpV0VKUFZteFNSMU5XV2toalIwWm9UVlZzTTFSc2FFTlhiRnB6VjJ0b1dtSllhRE5aZWtaclkxWldkR1JHWkdsV01taExWbXRrTUdFeVJYaFViazVWWVRGd2NWVXdWVEZoUmxaeldrYzVXRkp1UWxoWGExWXdZV3hLY2xkcVFscE5SMUo2VmtkemVGWXlTWHBoUm1ob1RWWndNbFpyWTNoVk1WbDVVbGh3YVZKclNsbFZiWGgzWVVaYVIxcEVRbGhpVmtZMFZrWm9hMkZHVGtsUmJXaFZWak5TTTFSVldsZGtSVFZYVkd4d1YySklRa3BXUkVacVRWWnNWMU51VW1oU2EwcGhXVlJLVTFWR2EzZGFSa3BzVm01Q1NGa3dWVEZoUjBwWlZWUkNWMDFYVGpOVVZscFhZMnMxV1ZOdGJGTldiSEJWVm0xd1MxVXlVa2RYYkZaVVltNUNUMVJXWkZOU01XUlpZMFZrVmxKc2NEQlpWVlp6VmxkS1NGVnNRbHBXYlZKTVZtcEtTbVZ0UmtkalIyeFhVbFp3VWxacldsZGhNVWw0V2tWYVVGWnRlRmhaVkU1RFZrWndXR1ZIUm14aVIxSlpXbFZrTUZZd01YTlhha0pXWWxob2VsWnNaRXRTYkdSMFQxWmthR0V3VmpSWGJGcGhZVEpOZVZKcldtcFNNbmhQV1ZST1FtUXhXblJOUkVaV1RWZDRXRmRyVm1GVU1XUklWVzFHVjJKWVRYZGFWM2hyWTFaT2NtUkhkRk5pU0VGNFZteGplRkl4WkVkVGJGWlhZV3MxV1ZaclZURmxiR3Q1WlVoYWJGWnNjRnBaVldRMFZrWktjMk5GZUZkV2JFcEVWWHBLVW1WR2NFbFZiV3hUVmxoQ2QxWkdaREJrTURGSFYyNVNUMVpyTldGV2JURlRVakZTYzJGSGRGaGlSbkI1VkZWb2IxZHRWbkpYYWs1WFRVWlZlRll3VlRGWFIxSkhWR3MxYVZacmIzaFdiWGhYV1ZaV2RGVllaRkJXYkhCd1ZXeGFZVlV4V1hkV2EzUlVUVlpXTTFsVldrOWhSMHBJWlVSQ1dtRXhXa3hYVmxWNFUwZFdSbFpzV2xkbGJGcFpWakZhWVZsVk5YTlRibFpWWWtoQ2MxbFVUa05PYkdSVlVXeGtUMUl4U2xoVmJUVkhWVEpLV1ZGck9WcGlSMUpVVkZkNGExZEZNVWxoUm1ST1lrVndTVmRVUW1Gak1WcFlVMjVLVkdKcldtaFdiVEZUVG14U1ZWSnRkRk5pUjNjeVZWY3hSMVJzU1hwaFJYUlhVbXhhY2xsVVJuTldNV1JaWTBkb1UxSnVRbHBYVjNSV1RWWktSMkV6WkZoaWJWSnhWVzEwWVZkV1VYaGFTRTVvVm14d2VsbHFUbXRXTURGMVlVaGFWMUpGY0ZCVk1GcExZekZ3U0dORk5VNWlSWEJvVm0xNGIyUXhXWGxVYkdScFUwVmFWbGxyWkZOamJGcHhVbXQwVTFac1dsaFdWekExVmtkS1JtSjZTbGRpVkZaUVZqSXhTMU5HVm5OaFIwWlhaV3RhU1ZacVJtRlZNV1JYVjI1T2FsSlVWbTlaYkdoU1RVWlplRmt6WkU1V2JGb3dWa2QwWVdGV1NsaGxTRXBXWVd0RmVGa3dXbk5XTVZweVdrZHNhVkpVVmxoV2EyUXdWREpGZUZkdVZsSmlSM2hXVm0weFVrMUdiRmhqTTJoclVqRmFTbGRyV2xOV01WcHlWMWh3VjAxdVFraFpWekZYVm1zMVYyRkhlRk5OYm1oWlZrWmFZV1JyTVhOYVJtUllZbFJzVmxSV2FFTlNNVkYzWVVjNWFWSnJOVWhXTW5Rd1ZteGFSbE5yZEZWaVJuQlFWbTE0ZDFJeGNFaGpSVFZvWld0VmVGWnRNVFJoTWtWNVVtdGtXRmRIYUhCVmJuQlhWbFpTVmxwRk5XeFNiWGg1VjJ0V01GZEdTbk5qUkVaYVRVZFNkbFpxUVhoa1YwWkpVV3hrVTJKR2NHaFhhMUpMVlRGWmVWSlljR2xTYTBwWVZXeGFkMlF4WkZoTlZGSlRUV3R3ZWxadGRHdFdiR1JJVld4R1YySkhVVEJWTVZwVFl6RndSVlZ0YUZkaVIzY3dWbXBLZDFsV1pITlhibEpvVWxSc2FGVnRlSGRsVm5CWFZsUldWMVpyY0RCWmEyUnpZVlpLVjJJemNGZFdSVnBZV1dwQmVGSXlSWHBpUmxKcFlUQndWRlp0Y0V0Vk1VMTRWbXhXVW1FelVrOVdiVEZUWld4a1ZWUnRPV2hXYTJ3elZGWlNWMWR0UlhsaFJWSlhVbTFTVEZreWVFOVhWMFpIWTBkNGFFMHdTWGhXTVdSM1V6Rk5lVlZyWkZoaWJGcFhXV3hXWVZkV1ZuTlZiR1JPVFZkU1ZsWkhOVTloYlVZMlZXcFNXbFpXV25aV1JFWktaVlpXY21SR1drNVNhM0JKVjFaa05HTXlVa2hXYTFaV1lsaFNXRlpxVG05U2JGcFhXWHBHYWsxWGVGaFhhMVpyVmtaa1NHRkhSbFZXTTBKRFdrUkdhMk5XVG5Ka1IzUlRZa2hCZUZac1kzaFNNV1JIVTJ4V1YyRnJOVmxXYlhoM1ZrWlNWbGR1U214V2F6VXhWbTF6TVZZd01VVldibVJZVmpOU2RsbHFRWGhXTVZaeVlrZG9iR0pGY0c5V1JscFhaREZrYzJKR1dtaFNNMUpoVm0weFUxSXhhM2RoUjNSWVlsVndTVlpYZUc5WlZrcDBWV3hTVm1FeGNFaFpNVnBIWkVkS1NHVkdaRmRXZW10NlZtMXdTMDVIU1hoVVdHeFVZbXMxY1ZWdGVFdFZNV3hZWkVWMGFVMVdXbmhWYlhocllWZEtTRlZxUWxWV2JXaFFXV3RhV21Rd01WVlhiR1JYWWxaS2VWWXhXbXRUTVdSSVZtdHNhbEl3V2xSV2FrWkxWMVprYzFkc1pHcE5WVFZJVlRJMVYxWXlTbFpYYkU1VlZsWmFNbHBFUmxwbFJtUjBUMVpLYVZKNmF6RldWRVp2WXpGa1IxZFliRlppVjJoaFdXdGtVazFHVWxkWGJYUnFZa1p3VmxWdE1YTlZNREZKVVd4d1YySlVRWGhhUkVwSFVqRndSbGRyT1ZkTk1FcG9WMWQ0YTJWck1VZGpSV2hyVTBVMVZWVnRNVk5sUmxaMFRWaE9hRlpzY0ZaV1YzQlBWMFphYzJOSVJsVmlSMUpVVm0weFMxSnRSa2RoUjJ4b1RVaENNMVpzVWtOWlZrMTVWRmhvYUUweWVIRlVWRXB2WWpGV2NWRlVSbE5XYlhoWFZsZDBhMkZIUmpaU2JuQlhUVzVDV0ZaclZYaFdhelZXVld4V2FHRXhjREpXVkVKV1RWWk9WMXBJU2s1V00yaFlWbXhhZDAxV1dsVlNiR1JwVFZVeE5WVXlkRzlXYlVWNVpVWm9XbUpVUlRCWk1GcHpWakZhY2xwSGRHbFNNVXBaVmpKMFZrNVhSa2hTV0hCb1VsWmFWMVp1Y0VkTk1XeFZVbTEwVTJKVmNFcFhhMXBUVmpGYWNsZFljRlpOTTBKRVdYcEdUMWRHVm5KaFJsWnBWak5vZGxadGRHdGliVlpYVmxob1YyRjZiRk5aYTJNMVRURnNjbFpzVGxaaVZYQjVWVEl4YjFkc1duTlhhMmhoVWpOb1VGWnFSbmRTYXpsV1RsWmtUbEpHV1hwV2EyUTBWVEZSZVZKclpGaGhiSEJZV1ZkMFlWZFdiSEphUnpsVVRWaENTRmRyVm10WFJrcFZWbXhzV2sxSFVucFdhMXBMWXpKT1NXSkdaRTVpYldneVZtdGplRk50VmxkV2JrNXBVbXhhY0ZZd1pHOWxSbVJYVjJ4T1YwMUVSbGhYYTFwclYyc3dlV0ZJUWxaaVIyaFVWbXhhYzFaV1RuUmtSMnhUVmtWYVlWZFdWbE5TTVZwWFZHdG9hbVZyU2xsWlYzUkxaV3hXY2xkclpGaFNia0pIV1RCYVMxUnNTbGRqUkVaWFlXdGFhRmxVUmxKbFZrcDFVMjE0VkZKc2NGUlhWbVF3V1ZkT1YxVnNhRTVXTTFKeVdXdGtVMVpzV2tobFIzUnBVbXh3V2xsVlVrZFhSMFY1WVVWU1dsWnRVa3hXYkZwaFpGWlNjMk5GTldsWFIyY3lWbXBHVTFNeFRYbFVhMXBRVmxkNFdWbFVUa05WTVZKV1ZtMUdhMVpzVmpSV2JYTTFWV3N4UldKR2FGcFdWbHAyVmtSR1QxSXlUa1pPVjBaWFlrWndTVmRYTVRSVU1WcHpWVzVLVkdKVldrOVpXSEJXWkRGYWRFMVlaRkpOYTFZMFYydFdZV0ZzU2taWGJGWlhZa2RTVkZVd1duTlhSMVpKVkdzNWFWWnJjRXBXYTJONFl6SkdSMWRyYUdGTk1uaFhWRlphWVZWR1ZsaGxTRnBzVm0xU2VsWlhNVEJVYlVwWFUyeHdWMUpzY0ZSVlZFcFNaVVpXY1Zkc1RtaGlSWEI1Vm0xNGIySnJNVmRWV0dSaFVqTlNjRlp0ZUhkTlZteFdWV3RrV0ZKcmNGbFdSbWh2VjIxS1NGVnNVbGROUmxWNFZqQmtUMU5IVWtkVWF6VnBZbGRSTVZacVJtcGxSMDE0VWxoc1ZHSkhhRlJaYTJSdlZVWmFjVlJzVGxkaVIzaDZWakl4UjFSc1NuUlZibkJhVmxaVk1WbFhlRXBrTURWRlVteHdWMVpyY0VsWFZtUjZaVWROZUZwSVJsZGlSa3BQVm14U1YxSldXa2hqUldScFRWVTFSMVJzVm05WlZrcFpVV3hXVm1KVVZrUmFSM2hyVmxaT2RWUnNTazVoTVc5M1ZsUkdiMlF4V1hsVGJrNVlZbXR3VjFSVldsZE9SbXgwWlVaa1UwMVdTbmxXUjNNeFZqQXhSVkpVUmxkaVZFRjRXWHBHVTFkR1RuTmFSbWhZVWpOb1dsZFhkR3RVYlZaSFZXeGFZVkpVYkZCV2JGSlhWMVpTVjFwSE9WZE5SRUkxVjJ0U1QxWXdNWFZoU0ZwV1RXcEdTMXBXV2t0ak1rcEhWbTFvYkdKWWFETldhMXBUVWpGTmVGcEdaR2xTYlZKaFdsZDBZV05zV25ST1ZVNVlZa1pXTkZkWWNGZGhSVEZZVld0a1ZXSkhhRkJXTW5ONFpFZFdTV0pHY0U1U2JHdDNWMnRXVm1WR1pFaFNhMmhxVW10d1QxbHNaRzVrTVZsNVpFZEdhR0Y2UmxsVmJUVlRWbTFGZVdGSVFsWk5SbkF6V1RCYWMxWXhXbkphUjNScFVqRktSMVpyWkRCTlIwWlhVMjVXVW1KdFVtRldhMVozWTJ4c2NsWllhRmhXTUZwR1ZXMTRVMVl4V2xWV2ExSlhUVzVDUkZsNlJrOVdNWEJKVlcxb1UwMHdTblpXYlhoWFl6QTFjMXBHWkZoaVdFSlBWbXBHUzFkR2EzZFhiazVYVW14c05WWlhlRXRXTVZwR1UydDRXbUpHY0hsYVZsVjRWakZ3U0dKR1pGaFNNbVEwVm1wS01HSXhSWGxTYkdoVVlrWmFXRmx0Y3pGWlZsSllUbFZLYTAxWFVsWlZNblF3WVd4S2NsZHNiRmhoTVZvelZsZHplRkp0U2paU2JHUk9ZbTFvTWxac1VrSmxSbVJIVlc1V1ZtRjZiRlJVVjNoTFpWWmFSMWt6YUU5U1ZFWllXV3RvVTFSc1duUlZiazVYWWtaS2RsUnJXbmRXYlVaSFdrWlNhVkpXV1hwV1ZFWlRWakZhUmsxV1drNVRSMmhvVm0xNGQwMHhXWGRYYkdScVZtdHdlbGt3VlRGaFZrcHpZak5zVjJGcmJETlVWbHBhWlZaV2MxcEhhRTVOTUVwWVYxY3hNRk15VGtkVmJHaHFVbXMxY0ZsclZYaE5NV1J5Vm0xR2FHRjZSa2xhVlZaelZtc3hXR0ZGVWxaTmJtaFFWVEZhVjJSSFRrZGpSMnhYVFRKb1JWWnFTbmRSTWsxNFUydGtVMkpzV25CVmFrSmhWMVpXZEdSSVRrOVNiVkpXVlRGb2ExUnNTblJQVkZKYVlURndWRlpFUmxwbGJFWjFVV3hXVjAwd1NsbFhWRVpoWVRGWmVWSnJaRlJpVjNoUFZtcE9iMDB4WkZkaFNHUm9UVmRTV0ZVeWNHRldiVXBWVm14V1YySkhVbkpVVkVaelRteEdkVlJzVGs1aVJYQktWbXhrTUU1R1duUldiazVZVmtWYVdGUlhOVzlqYkZwVlVWaG9WMDFyVmpaWmExcHJWakpXZEdWSVpGaFdNMmhvVjFaVmVGSXhjRWxVYldoVFZrZDRlRlpYY0VKbFJUQjRWMnRvVDFZd1dtOVVWbHAyVFd4YWMyRkhkRmRXYTNCWFZHeFdVMWRHV1hwaFNGcFhZVEpTU0ZSdGVIZFNNa3BIVkcxNGFWSnVRalJXYWtacVpVZE5lRkp1VG1sTk1uaFhXVzE0UzFaR2JIUk5WRkpVVFZaYU1Wa3dXbXRoYXpGWVpVaHdXR0V4Y0hKWmEyUkxWbXhrYzJKR2NGZFNXRUo1Vm14YVlWWnRVWGhVYmxaVFlraENiMWxZY0ZkWFZtUnlWMjEwVmsxVk5WaFdWM2h6VmpKS1dWRnVRbGRpV0dneldsWmFhMk5zWkhSa1JsWk9ZVE5DU0ZkclZsZGlNVkY0VjFod2FGTkZTbGhaVjNSaFlVWlNkR1ZJVGxkTmExcEhWREZhWVZZd01VZGpSbkJYWVRKTmVGVjZSbk5XTVhCR1YyMXNWRk5GU2xaV2JYaGhaRzFSZUZwSVNsZGhhMHBZVm1wR1MxTldXa2hOV0U1b1ZtczFTVmRxVG05V2F6RlhWMnhDVmxaRmNGQlZha3BQVTFaR2MxTnNaR3hpV0dnelZqRmtORmxXYkZaTlZXUmhVMFUxYjFWc1VuTmpWbFp4VVcxR1YxWnNTbnBaVlZVMVYyeGFjMko2U2xkaVZGWllWMVphUzFkR1ZuVldiR2hvWVRGd1JWWnRlRlpsUmtwWVUydGFhbEpyTlZSV2JGcDJaV3hhVlZKc1pHbE5SRVpJV1ZST2MxWkhTbkpUYkU1WFlXdHdWRlY2UmxkV1ZrWnlaRVU1VjJKV1NqWlhWbFpoVkRGU2MxZFlaRTlXUlVwV1dWUktVMk5zV1hoWGExcHJUV3MxU0ZsclduZGhSMFY1WkVST1YwMXVRa2hhUkVaclZqRndTVlZ0ZUZOTk1FcDNWMWQ0YjJFd01IaGFSbVJYWWxoU2NWUlhlRXRYUm14eFZHMDVhRTFFUmpCYVZWcEhWbFphZEdGSVdsVldiSEJRVm0xNFUyTnNVbk5SYkdScFZqSm9TMVpyWkRSaE1WRjVVbXhvVTJKR2NGUlpiRkpYV1ZaU1dHTkZaRmhTYkVwWFYydGFUMWRHV25KT1ZFWlhZbGhTTTFaVVNsZGpNV1IxWTBab1YwMHlhSGxXYlhCTFZqSlNSMU51VG1oU01taFBWRlphZDJReFduUmpSVTVhVmxSQ05GWkdhR3RaVmtsM1YyczVWMkZyU2pOVVZWcGhVMGRPUmxSdGFGTmlSemg1VjFkMFUxSXhXa2RYYkZwUFYwWndhRlZ0ZUhkTk1WbDNWbGhvV0ZJeFdrbFpNRlV4WVZaa1NGa3piRmRYU0VKSVZrUkdSbVF3TlVsaFIyaFRWakpvVVZaWGNFdFZNVTE0Vm14V1VtRXlVbkJaYTJRd1RsWlNWMWR0ZEZWaVJXdzBWVEo0ZDFack1YRldiR2hXVFc1b1RGUnRlR0ZrVmxKelkwZHNVMDFWY0ZwV01uaHFaVVpKZUZwR1pGWmlSM2hZV1d4a05HTkdXbk5YYmxwclRWWnNOVnBWVlRWVmJVcFdUbGhzV21FeFdsUldNbk40WkVaV2NrMVdXbGRTV0VKUlYxY3hORlJ0Vm5SVGExcFZZbGhTV0ZsdGRFdFhiRnBIVjIxMFQxSXdXbmxVVm1oVFlrWktSMk5HV2xaaWJrSklWbFZhZDFORk1WZFViR2hUVmtaYVYxWldaREJrTVZaeVRVaGtUMWRHV2xkVVYzQlhaV3hyZVdWSVdtdE5helZHVmpJeE1GVXdNVVZXYm1SWVZteHdXRlZxU2t0ak1rNUpWR3hXYVdFelFsRldSbHByWWpGT1YxVnVUbFppYXpWWlZtMTBkazFzV25STldHUllZbFZ3VmxWdE1XOVdWbHAwVld0NFlWSldjRlJaTVZwSFpFZEdSMXBIZUdsWFIxRXdWbXhTUjFZeFduSk5WbWhVWVRKb1ZWbHJaRzlYUm14MFRsVk9hVTFXYkROV2JHaHZZVEpLU0ZWcldsZFNNMUYzV1ZaYVMyUldSblZoUmxwT1ZqSm9SVlpVU2pSVU1VNVhWbTVTYWxKdVFuQldhazV2VWtaWmVXTkZkRlpOYkVwSVZUSTFWMkZXU2xsUmJGWldZbGhvTWxSWGVGcGxWMVpJVDFaU2FWSjZhekJXVm1RMFZURldkRk5zWkdwVFJWcGhXV3RhZDJGR2NFWlhiRTVZVWpCWk1sVnRjekZXTURGRlVsUkdWMkpVUVhoWmVrWlhVbXN4VjJKSGFGTlNWbkJhVmxkNGExUnRVWGhhU0VaU1ltczFWVlp0Y3pGTlJuQldXa1JDVjFKcmNIcFpibkJIVjBaYU5sSnVjRlpXUlZwWFdsVmtUMUl5UmtkVWJXeFlVbFZ3TlZac1dtOWtNVmw1Vkd4a2FFMHllRTlXYlRGVFlqRldjVkpyZEZSV2JIQXdXa1ZrUjJGR1duSmlSRkpYVFc1Q1JGWXdaRXRUUmxKWllVWldWMVpzYkROV1YzQkxWVzFXV0ZOcmFGTmlSVFZQV1cweFVrMVdXbkZSYkdSVlRWVTFNRlpHYUd0aFZrcFlaVWhHVlZaNlJsUlhWbHBUVjBVMVdFOVhiRTVXTTJONVZtdGtlazVXV2xaTlZtaHNVbTE0VmxadE1WSk5SbHBXV2tWa1YySkZOVEJaTUZwVFZqSldjbEpxVWxoV00xSnlWWHBHYTFJeFpIVldiWEJUVFcxb1dsWlhlRk5XTWs1WFZsaG9ZVk5GTlZOVVZWSnpWakZ3Vmxac1RsWmlWWEJYVkd4V01GZHNaRWxSYkdoYVpXdGFlbGw2Um5kU01YQklaVWRzVjFadVFtaFdiWFJoVlRGc1YxUnVUbFJpYkZwb1ZUQldTMVpzVm5OV1ZFWlRVbTE0ZWxkclZtdFhSa3BWVm14c1lWSldjRmhaVmxwaFl6SkplbHBHWkU1aWJXZ3lWbXRTUzFReFRrZFZia1pYWWxkb1ZGVnNXbmRsUmxwSFdrUlNXbFpVVmxoV1JtaHZWbGRLY21OR1FsVldiVkoyVlRGYVUyTXhWblZVYkdoWFlUSTRlVlp0TUhoa01XUjBVMnhXVW1Gc1NtaFZhazV2VFRGVmVGZHRSbXRXYkVvd1ZXMTRZV0pIU2tkalJGcFhUVzVvV0ZscVJrWmxWbFoxVld4V2FXSkdjRmhYVnpBeFVURk5lRlp1U2xaaE1EVndXV3RhZDFOV1VsZFhiWFJvVFZWd01WVlhlSGRXTVVvMlZtdFNXbFo2UmxoYVJscFhaRWRPUjJOSGJGZE5NREV6VmpKMGEwMUhUWGRPVm1SVFlteGFjVlZxU2pSVU1WSlhWMjVhVGxac2JEUldWM1F3VmpBeFYxTnVjRnBoTVhCNlZsY3hTMlJHVm5SUFZtUnBZbXRLV1ZkcldtRlpWMDE0V2toS2ExSnNXbGhaVkVKM1YyeGFjMWt6YUdsTmExWTBWVEZvYTFZeFdrWmpSbXhYWWxSR2RsVnJXbmRTVms1eVpFWlNVMDFJUWtwWFZFSmhaREZrUjFOdVNtcFNSVFZaVm1wT1ExTXhVbFphUms1clVtdHdNVlp0ZUZkaFYwcEpVVzVrV0ZadFRYaFdWRXBQVWpGd1IxcEhhRk5XUjNoM1ZsZDRVMVl5VmtkWGJHUm9VbFJzWVZadE1WTlRWbkJXVm1wU1YxWnNiRFpaVlZKUFZqQXhWMk5HUW1GU2JWSlFWVEJrUjFJeGNFaGxSMnhZVWpGRmQxWnRlRk5TTWtWNVZWaHNWbUpzU2xoWmJYUjNZekZXYzFkcmRGZFdiWGg2VmxkMGEyRlZNVmRqU0doWFVucEJNVmxYYzNoV2F6VlhZa1p3VGxJeWFHOVhWbFpoV1Zaa1YyTkZWbFppUjFKd1ZtdGFXbVZzV1hoWGJVWm9UVlZ3TUZaSGRGZFhSMHBIVjJ4U1ZtSkdTbGhWYkZwclYwZE9SbVJHVGs1V01VcEtWbXhhYjJReFpFaFRiR3hXWVhwc1lWWnVjRVpsYkZKWFYyMTBWMDFyV2twVk1uTTFWakpLY2xOcVdsaFdiRXBRV1hwS1IxSXhVbkphUjNCVFZrWmFhRmRYZEdGWlYwWkhWV3hhV0dKRk5WUldiWE14VFVad1JsWlVSbGROUkVaSVdUQmFkMWRIU2tkWGJrcFZWbFp3VkZadGMzaFRWbkJHVDFaa1UySklRbUZXYlhCRFlUSldjazFXWkdsU2JXaFBWbXhvUTJNeFduTlZhMlJZWWtkU2VWZHJhRTlXVjBwV1YyNXdWMDFxVmpOV01GcGhUbXhHV1dGR1pGZFNXRUpaVjFSSmVGVnRWblJUYTFwUVZtMVNUMVJYTVc5Tk1WcDBUVmhrVTAxWGVGZFViR2hQWVZaS2RGVnRPVlppUmtwWVdUSjRjMk14V25SU2JHaFhZa1Z3TmxZeWRGTlJNV1J6VjI1U1ZtRXllRmxaVkVaTFUwWlplV1ZIUms5aVJuQjZWVmQ0VjJGRk1WZGpSRnBZVmtWS2NsWlhNVmRYUms1eVlVZHdVMVpHV25aWFYzaHZWV3N4UjFkWWFGWmhNMEp6VlcxNFIwNVdWWGxrUnpsWFZqQmFlbFl5ZUZkV01rVjRZMFJPVjAxV2NETldha1poWkZaU2NrNVhiRk5pYTBreVZqRmFWMVpyTlZoU2JHUlVWMGRTVUZaclZtRlhSbFowVFZjNWFGSnRlRmxhVlZaM1lrWlpkMWRyY0ZoaE1YQXpXVlZWZUZKV1JsbGhSbVJUWWtWd1RWWlVTWGhXTWsxNFZXNVdWMkpHU205YVYzUmhWVVphZEdSSGRFOVNNVnBJVjJ0YWExWXlTbGxSYkVKV1lXdGFURll3V25OamJHUjBUMVpXYVZKVVZrbFhWRUpyWWpGYVYxZHJXbGhpVjJob1ZXdFdZV1ZzYTNsbFNHUlRUVlUxTUZwRlpITldNVnBHVmxoc1YySkdTa3RhVldSU1pVWldjMWRyTlZoU1dFSlJWbTEwVjJReGJGZGlTRXBoVW5wc1ZGVnROVU5UVmxKWFZtcENhRTFWY0hwWk1GSkhWakpLVlZKWVpGZGhNWEJNVm14YVMxZFhTa2RoUm1Sc1lUQnJkMVp0TVhkVE1WVjRVMWhzVldFeVVuQlZiWGhoWTBac1ZWRnVaR3hTYlZKNlZqSjRUMkZyTVhOU2FsSmFZVEpvVkZaSGVHRmphelZaVVd4YWFHRXhjRzlXVjNoaFZUSk5lVkpyV21GU01taHZXbGQwU2sxV1dYbGtSemxTVFZkU1NGVXlOVXRVTVU1SlVXMUdWMkpVUmxSV1JWcDNVbXhrY21SSGRGZGlSbTkzVmxjeE5HSXhWWGhYYTFwWVlXczFXRmxVUmt0VVJsSnlWbGhvVTAxck5VZFdNakUwVlRGYWNtTkdXbGhXZWtVd1ZYcEdjMVl4WkZsYVJtUm9UVEZLVUZaR1dtdE9SbVJIV2tac2FsSlhVbTlXYWtKM1ZqRlNjbFZyWkZkaGVrWllWVEl4YjFack1YRlNhMlJoVWtWYWNsa3llRk5qTVdSeldrZHNVMkpyU2twV2FrWnZaREZKZUZOWWFGaGlhelZWV1cxMGQxWldiSEphUnpsWFRWWktWbFV5TURWVk1VcHpZMFpvVjAxdWFISldWRUY0Vm0xT1JscEdWazVXYTNCdlYxWlNSMU14V25SVWEyUlZZa2RTY0ZWdE5VTmlNV1JWVVcxR1ZrMVZjSHBXTWpWWFZsZEtSbU5JUWxaaVJuQXpWakJhYTFZeFZuSlBWbFpPVm14d05sWnFTalJaVm1SSVVsaGtUMVp0VWxaV2ExWjJaV3hTVmxkdFJsaFNNVnBIVjJ0YWEyRldTbGxSYWxaWVZteGFWMXBWV2xabFJtUnpXa2R3VTFacmNGbFdiVEUwWkRGWmVGVnVTbUZTVkZaelZXMTRkMlZzV1hsbFJUbG9VbFJHU2xWWGVGTlhSMHBIWTBoYVdtRnJXa2RhVlZwaFl6RndSMXBIYUU1aVJYQlpWbXhrTkdJeVNYaFRXR2hYWW14S2NsVnNhRk5XTVd4eVYyNWtWMDFXU2xoWlZXaHJWakpLUjJOSWNGZE5ibEoyVm0xNFdtVnRSa1poUmxacFZrVmFWVlpYTVRSVU1rMTRWRzVPWVZKdFVsaFZiRlp5WlZaYWRHVkhSbWhOYXpFelZHeFdhMVpYU25KT1ZsSmFZVEZ3TTFaclduTldWbEp5Vkd4V2FWSnNjRFpXYlRCNFVqRldjazFXWkZoaVIyaFlWRmMxYjJGR2JGaGpNMmhZVWpGYVNGZHJXbUZoVm1SSFUyc3hWMkpHU2t4V2FrWnJWMFpLY2xkc1ZtbFNia0paVjFkMFlXUXhUbGRYYms1WFlrZFNVRlZ0ZEhOT1JsVjVUbFYwVjFJd2NFZFpNRnB2VmpKS1IxTnJhRlZpV0dob1ZtcEdhMk14Y0VkVWF6VlhWbTVCTWxacVNqQlpWbFY1VTJ0a1ZHSkdjSEZWYlhNeFYwWnNjbGR0Um1oU2JGcDZWako0VDFVeVNrZGpTR3hZWVRGd1RGbFdXa3RXTWs1SFlVWmthRTFZUWxWWFZsSkhWakZLY2sxV1dsaGlSMmh2VkZWU1YxZEdaRmhrUjNScFRXdGFTRlp0TlV0V01rWnpVMnhTVlZac2NFeGFWbHBXWlZkV1JtUkdaRTVoTVd0NVZsY3hkMWxXV1hoWGJrNXFVbTFvVjFsWGRHRlRSbXcyVW0xMGFsWnNjREJhVlZwUFlWZEZkMk5HVmxkaVZFVXdWbXBHYzFZeFRuTmFSbHBvVFZoQ1dWZFdVa3RWTVZWNFlraEtWMkpWV2xoVVZtUTBWMnhyZDFwRVFtaFNiSEI2V1RCYWExZHJNVWRYYkVKWFlsaG9hRlZ0ZUV0WFZuQkhZMGQ0YUUxWVFrcFdiVEI0VGtaTmVWUnVUbFZpYXpWWFdXeG9iMWRXVm5GVGJUbFdUVlp3ZWxZeU1VZFdNREZXWWtSU1ZrMXFWa3haYTFwTFZqSk9SMVZzY0ZkU1ZXOTZWbXhTUjFVeFdsZFRia3ByVW1zMVZGbHJWbkpsVmxwWVRVaG9UbEpzV2pCVk1uUmhWMGRLU0ZWc1dsVldWMUoyVmxWYVlWZEhUWHBoUms1cFVqRktOVlpyWkRSWlZtUkhVMWh3V2sweVVsaFdiVEZTVFVaV2NWSnRSbXBOVlRVeFZUSXhORlV4V2taWGJGWlhZbGhTV0ZkV1drdFNNV1J6V2tab2FWSXhTbGRYVjNoV1pVVTFSMVp1VW14U01GcFhWRmQwVjAweGEzZFhiVVpYVFZad1IxUnNhR0ZXTVZwelkwWm9WMkZyV21oWk1uaDNVakZTYzFSc2FGTk5iV2hLVm0xNGFtVkZNVWRVV0doWFltczFXVmx0ZEhkWFJteDBUbFZPV0ZKc2NIbFdiWFF3VmtaS2MxZHNiR0ZXVmxweVZrUkdXbVZHWkhKYVJscE9ZbTFvVFZadGNFZFpWbGw1Vkd0YWJGSnRVbFJXYlhoM1YxWmFSMVp0UmxOTmF6RTBWa2MxVjFaWFNsWlhhemxWVmxaS1dGWnJXbUZrUjFaSFdrWndWMkV6UWxsWFZFSmhZakpGZUZOc2JGSmlhMXBXVm0xNFlXRkdXbkZTYkdSclVqRktSMXBGV210V01ERlhZMGRHV0Zac1dsaFdSRVpoWXpGa2RWUnNhR2hsYlhoWFYxWlNSMlF4VGtkaE0yUmhVbTFTVkZsclZURmxiRlY1WlVkMFYwMVdjREZWVjNONFZqSkZlRmRzYUZkaGExcExXbFZhUzJSV1VuTlViV3hUWW10S1dGWnRjRU5XYXpGWFZsaG9XR0pyTlZoWmJGWmhWVEZTVjFkdFJsaGlSM2g1VmxkNFQxWnRTbFpqUldSWFRXNW9jbFpxUmt0a1IwWkpWMnhrVjJWcldsbFdha1pyVWpGS2MxVnVUbGhpUjFKd1ZXMDFRMU5zV25OYVJFSlhUVVJXU0ZVeU5VOVdSMHB5WTBaV1dtRXhXak5XUkVaWFpGZE9TVlJyT1dsU2JrSlpWbXBLTkdFeFZYZE5WbHBZWW01Q1YxbHNhRU5oUm14WVRWWmthMUpzV25wVmJURkhWakpXYzFkc1ZsZFdiRXBJVm1wR1dtVkdaSFZVYlVaVFlYcFdXVlpxUW10aU1VNVhWMjVLWVZKRlNsVlVWbHBoWld4WmVVNVZkRlZpUjFKS1ZWZDRhMVl5U2xsaFIyaFdUVVp3V0ZZd1pGZFRSMUpIV2taT1RsWnVRa3RXTVZwWFdWWk5lRmRZYUZoaVIxSnhWV3hhZDFkR1ZuTlhiVVpZVW14YWVGVnRkR3RoYXpGV1kwaHdWMDF1VFhoV2ExcExWbFphYzJGR1pHbFhSMmhaVmpGYVlWSnRWa2RYYmxaVllrWmFiMWxyVm5kV1JtUllaRVprV2xac2JEUldiVFZUWVRGT1NGVnNXbGRpV0ZJelZtMTRWMlJIVWtaUFZtUnBVbTVDTmxacVNqUmhNV1IwVm01S1dHRXlhRmhaYkdodlZFWnJlV1ZHWkd0U01EVklWa2Q0YTFZeFNsZGhNMnhYWWxob2FGZFdXbHBsUms1WllVWk9hV0Y2VmxaWFYzUmhXVmRPYzFadVRsWmlSMUpYVkZaYWQyVnNXblJOVldSWFVsUkdXRlV5ZEd0V01rcFpWVzVLVjFaNlJreFZiWGhyWXpGd1IyTkdaRk5XUmxwU1ZtMHhORlp0VmtkVGJrNWhVMFZ3VmxsclduZGpSbXh6WVVkd2EwMVdjRmhYYTFKVFZUQXhWMk5JY0ZaTmFsWk1WbTB4UjA1c1NuTlZiR1JwVjBkbmVsWlhkR0ZaVmxsNFdraE9ZVkpzV25CV2JGSkdUVVphV0UxVVVscFdiRlkxVld4b2EyRnNTbk5YYkdoWFlURlZlRnBIZUdGU01XUnpXa1prVGxadVFqVldNblJoVkRGVmVGcEZhR2hTVjJoWVZtNXdSbVF4VmpaU2JHUnFUVmRTZWxadGVFdGhWMHB5VTJ4c1YySlVSVEJYVmxwUFVqRmFjMkZIZUZOWFJrcFpWbGR3UjFsV1NYaFhiR2hzVWxoU1dGUldXbmRYUm10M1ZtMUdWMDFWY0ZoV01uaHZWbTFHY2xkcmFGcGxhMXBNV1hwR2EyTnJOVmRWYkU1WFVteHdXbFp0TUhoT1JsbDRZa1prVTFkSGFGaFpiWE14Vm14c1dHVkZkRlpOVjNoNVZtMHhSMVl3TVZkWGFrSmhVbGRvY2xac1dtRmpiVTVIV2taa1RtSnNTbEZXYlRFMFdWZE5lRnBJU2xCV2JrSnpXVlJHZDFOV1duUk5WRkpVVFdzMWVsWkhOVTlXUjBwWllVWnNWbUZyY0haVmJGcGhZekZrZEZKc1pFNVdWM2N3VmxSS01GbFhTa2RUYkdScVVteEtZVlpyVmt0Tk1WcHlWMjFHYW1KR2NEQlZiWGhQVmpKS1JsZFVTbGhXUlVwVVZWUkdZVmRHVG5KWGJHaHBVakZLV0ZkWGVHOVZNREI0VjJ0a1dHRXpVbGhaYTJSVFpWWmFTR1ZIUmxkTmEzQklXVEJTVjFkR1pFbFJhMmhYVmtWYWFGbDZSazlrVms1elZXMXNVMVpHV2xsV2ExcFRVekpKZUZOclpGaGlSMUpaV1d0a1UxWnNVbGRYYkdST1RWaENWMVp0TVVkV2F6RnlWbXBPV2sxR2NGQldha3BMVTBaV2NWZHNWbGRTVm5CdlZtMTRZVkl5VG5OalJXUlVZbGQ0VkZadE1UQk9SbGw1WlVaa1YwMVZNVFJXYlRWUFYwZEtSMk5HYkZwWFNFSklWbTE0VjJNeFpIVmFSbHBUWWtad1dsZHNWbGRoTVZsNVUyeGFWMkZzY0ZoVmFrNXZWRVphY1ZKdFJsZE5helZIVmxkNGExWXlTbGhoUkZwWFVqTlNhRlZxU2s1bFJrNTFWR3hvYVZKVVZuWldSbHBYWkRGUmVGZHNhR3hTYlZKaFZtMTBWMDVHV25SbFJtUlhVakJ3VmxscldrOVdWbHBYVTI1YVZXRXhjSEpaTW5oaFkyMVNSMWR0YkZOaWEwcFlWakZhVjJJeVVYaFhiazVZWW1zMVdWbFVTbTlXTVZweFZHMDVWMUpzY0hsWGExcHJWVEpLUms1WWNGWk5ibWh5Vm1wR1lXUldSbkphUm1Sb1RWWndXVlp0Y0VkVGJWWkhVMjVXVldKRk5WbFZhazV2Wld4YVdHVkdXazVXYkVwNlZtMDFUMVl5U2xaWGJFNVZWbXh3YUZZd1dtRmtSVEZaV2tkb2FHVnJXbGhXYWtvMFlURmFkRk5zYkZaaVYyaFlWbXRXWVZSR1ZYaFhiRTVYVm14S2VsWnRNVFJoUlRGWlVXeEtWMkpHY0hKVWExcEtaVVprZFZOc1FsZFdNMmhYVjFkMFYyUXhaRWRYYms1WVltMVNWRlZ0ZUhkbFZsbDVZM3BXVlUxVmNIcFdNblJ2Vm0xS1dXRkhhRmRXUlhCSFdsVmFUMk5yTlZkWGJXeFRZa2hDZGxac1dsTlNNVmw0VjFob1dHSkhlR2hWYWs1RFZERmFkR1JHY0d4aVJuQlpWRlpTUTFaRk1WZFhha0pYWWxob2VsbFZXa3RYUmxaeldrWmthVmRIYUc5V1ZFSmhWakpTU0ZWclZsWmlSVFZ3Vld4b1EwNVdXbFZUYWxKVVRWWnNORll4YUhkV2JVWnpZMFpvV2xaRldqTldNRnBYWTFaS2NscEhjRTVXVkZZMlZteGplRTVHVlhoWGJHeFNZa1pLV0Zsc2FHOVhSbVJYVjJzMWJGSnNXbmxXTW5oclYwWkplV0ZHVWxoV00xSllWMVphV21WR1pIVlViV2hUVmtkNFdGZFhkR0ZrTVZsNFYxaHNhMUpVYkZoWldIQkRUbFp3U1dORlRsZE5WbkJZV1RCV2IxWXlTbGxoUlhoYVRXNW9jbGt5YzNoV01WSnpXa1prYVdFd2NFZFdiVEUwV1Zac1YxZFlhRlppYkVwV1ZqQmtiMVpHYkhKWGJtUlhVbTE0VmxWWE5XdFdNVXB6WTBaYVYxSjZRVEZXVjNONFZqRmtjMkZHWkdsWFJrcDVWbXhTUjFNeFpGaFNhMXBoVW14d2NGWXdXa3RVVmxweldrUlNXbFpzY0hsVVZscHpZV3hLYzJOR2FGcGhNWEF6VlRGYVlWZEhVa2hrUms1T1lYcFdObFp0TVRSak1WcFlVMnRhYWxKdGFGaFphMXAzVFRGV2NsZHRSbGROYTFwS1YydGtOR0ZIVm5OVFdIQlhVa1ZLZGxsVVJsWmxWa3BaV2tkd1UySkZjRmxYVjNSaFpERk9SMk5HYUd4U01GcFlWbTEwWVdWV1pISlhhM1JvVm10d2VsbFVUbTlYUjBwSFYyeG9WbVZyV2xoWmVrWnJZekZrYzJGSGJGZFNNMmhZVm14a05HRXhWWGhXYTJSWFlrZG9jMVZzWkZOWFJteHlWMnQwV0dKR2NFbGFWVll3VmpBeFYyTkdhRnBOUmxwVVZtcEtSbVZYUmtsalJsWm9UVmhDYjFaWGNFZFRNazE0V2toT1ZXSlhhRTlXTUZaTFZVWmFjMXBFVWxkTlYzaFlWV3hvYjFZeVNraFZiR2hYWVRGd1RGWlZXbE5XTVdSeVpFWmtUbFpzYjNkWGExWmhWREpHUjFOWVpGZGhhelZXVm0weGIwMHhXblJsUjBacVRWZFNlVmxWV21GV01EQjVZVVpXVjFJemFISldha1pLWlVaU2RWUnNVbWxTTVVwWlZtMHdNVkV4U1hoWGJrcFhZa2RTV0ZSV1ZuTk9SbFowVGxVNVZrMXJjRWhaTUZVMVZtc3hSMVpZYUZkTlJuQlVWbTE0WVdSR1NuTlRhelZYWWtacmVWWXhaREJWTVZWNFZtNVNWR0V4Y0ZsWmEyUlRWakZzYzJGR1RsZFNiSEJYVm14b2IxZEdTWGhYYTJSWFVqTm9hRlpxUmt0WFZrWnpWV3hvV0ZORlNrbFdWM0JIV1ZkTmVGUnVWbFJpUmtwd1ZXMTBkMWRHV2tkVmEzUnBUVlpLZWxZeWVHdFhSMHBJVld4a1ZWWnRVbFJhVmxwM1ZteGFkRkpzV2s1aE1WbDZWMVJDWVZReFdsZFhhMXBxVTBad1YxbFVSbmRXUmxaMFpVZEdhbUpJUWtoVk1qRnpWVEZhZFZGc2JGZGhNVXBFV1dwR1VtVkdXblZVYkdocFVtNUNXbGRXVWtKTlZtUkhWbTVTYW1WclNrOVZiWGhoVjFad1ZsWnRkRmROYTNCSFdUQm9kMVpzV1hwVWFsSlhWa1ZhYUZacVNrOVNiRlp6V2taa2FWTkZTbHBXYlhScVpVWlNkRlpyWkZSaWF6VlpXV3RWTVdJeFVsWmhSVTVYVW0xU2VsWXlNRFZoVlRGV1ZtcFNWMkpZYUhKV2FrcEhUbTFLUms5V2NHaE5WbkJ2VjJ4V1lXUXhTbk5qUldoUVZteHdjRlZ0TlVOWFJscHhVMnBTYUUxV2NGaFZNbmhyVjBkRmVXRkdaRmRoYXpWMlZUQmFZV1JIVGpaV2JGSlhZa1Z3TmxacVNqUmhNVmw0VjI1V1VtRXhXbGhaYTFwM1pHeHNObEZVUmxOTlZYQXhWa2Q0VDJGV1NuVlJiRlpZVm14S1NGVjZSbE5qTVZwMVZHeGthVlpXY0ZSV1JscGhXVlprUjFkdVVtcGxhMXB2V1Zod1IxWXhiSEpWYXpsWFlsVndXbFpYZERSV01WbzJVbXhvVjAxWFVraFZiWGhUWXpGa2MxcEhiRk5pYTBwTFZtMHhNRll4V1hkT1ZXUlVWMGRvVlZsdGRIZFdWbXh5Vm01a1dGSnNjSGhWVmxKSFZESktSMk5HYUZkTmJtaHlWbFJCZUZac1pIVmpSbVJYVFRCS1dWZFhkR0ZUTWs1MFZHdGtWV0pIVW5CVmJYaDNZakZhV0dWSFJsWk5WWEI2VmpJMVMxbFdTbkpqU0VKV1lrWndNMVl3V210V1ZsSjFXa2RvVGxZeFNqVldSbHBYV1Zaa1NGSllhRmhpUm5CWFdWUkdZVlJHVmpaU2JrNVBZa1Z3ZVZZeU1UQlViRnBaVVdwV1YySlVSVEJXYWtaWFkyc3hTV0pIYUZOV2EzQlpWbTB4TkdReFpFZFdia1pVWWtkU2NWUldWbmRsUmxwMFRWUlNWazFXY0ZwVlYzaFRWakpLV1dGR1pHRldWbFY0V1hwR1lXTXlTa2hpUms1VFlUTkNWVll4WkRCV01XeFhWMWhvVjJKc1NuTlZiRlV4Vm14YWRHUklaRmROVm13MVdrVlZOVll5U2tkalNIQlhUV3BXZWxZeU1WZGpiR1J5WVVaa2FWZEhhRTFYVkVvMFZESk5lRmR1VW14U2JXaFVWRmN4YjFKc1duUmxSMFphVm14c05GVXhhRzlXUjBWNFkwaE9WbUpHY0ROV2ExcHpWbFpHZFZwR1drNVdia0kyVm0xNGIySXlTa2hUYTJSWVlrZG9XRmxzYUZOamJGcFZVbXR3YTAxRVZscFphMXBoVkd4YWNtTkliRmRoYTI4d1YxWmFZV014Y0VsVGJGWnBVakZLZDFaWGVGTlZiVkY0VjJ4a1lWSkdTbFJVVmxwM1pXeFZlVTVWT1ZaaVZWa3lWVzE0VTFkc1drWlhhazVXWVRGd2FGWnFSbXRqTVhCSFZtMXNWMVpGVlhkV2JHTjRUa1pzVjFaWWJGTlhSMUp4Vlcxek1XRkdXblJOVnpscllrWmFWbFZ0ZUd0V01ERlhZMGhzV0dFeGNGQldWRVpyVTBkR1JtRkdaRTVpYkVwWlZsaHdSMVl5VFhoYVNFNVlZWHBXV1ZVd1ZrdFhSbHAwVFZSU1dsWnJOVWhXYlhodllrWktWV0pHUWxkaGExcG9WVEJhV21WWFZrWmtSbVJPVm01Q1dWZFVRbFpOVmxsNFUyeGtXR0pIYUZkWlYzUmhVMFpzTmxKcmRHcE5WMUo2VlZkNFUxVXhXa2RYYkd4WFlsUkZNRlpxUm5OV01VcFpZVVprYVZJemFIZFdWM1JoVXpGVmVHSklTbGRpVlZwWVZGWmFZVTFHY0VaVmJFNVhZa1Z3VmxWdGVITlpWbHBYVjJ4Q1YySllhR2hWYlRGR1pXMUdSMWR0YUU1V2JYUXpWbXhqZUU1R1RYbFViazVWWW1zMVZWbHJaRk5YUmxKVlVtdHdUbUpHY0hwWlZXaHJWV3N4Vm1KRVVsWk5ibWh5Vm1wS1JtVkdUblZVYkZwcFVteHZlbFpzVWtkWlYwMTRWMjVPYWxJemFIQlZiWGgzV1Zaa1dHUkdUbFpOVmxvd1ZUSjBZVmRIU2toVmJHaFdZbGhvVEZaVldtRlhSVEZYV2tab1YwMUdjRWhXYTJRMFdWWlplVk5yWkdwU1YzaFlXV3RhWVZkR1VuSlhhM1JxVFZVMU1WVXllRk5oVmtwWlVXeHNWMkpZVWxoVmVrRXhZekZrYzFwR2FHbFNNVXBWVmtaYVYxbFhWbk5YYkdocVVtMVNjRlZ0ZEhkV01XdDNWMnM1VjAxcmNFaFdNakZ2Vm0xS1IyTkdVbFppV0dob1dUSjRkMUl4VG5SaVJrNVhZbXRLV2xadE1UQlpWMGw0VlZob1YySnJOVmxaYTFwM1YxWnNWVkp0UmxkaVJuQXdXbFZrUjFaRk1WaGtla3BXWWxoU2NsWnFTa3RTYlU1SllrWmFUbUp0YUZGWFYzUmhZVEZPU0ZKcldsWmlSMUpZV1d0b1ExZFdXblJqUldSVVRWWndlVlF4V2xkWFIwcFpVVzVPV21KR2NFeFdNRnBoVWpGYWMxcEdjRmRpU0VJMlYxUkNWMkV4V1hsU2FscFhZbXRhVmxadGVHRmhSbHB4VW14a2ExSXhTa2hXUnpGdlZHMUZlRmRZY0ZkU2JIQjJXa1JHWVdNeFpIVlViR2hvVFcxb1dWWnRjRTlpTVZwSFZXNU9ZVkp0VWxSWmExVXhaV3hWZVdWSGRGZE5WbkF4VlZkNFQxWXlSWGhYYkdoWFlXdGFTMXBWV2t0a1ZsSnpWRzFzVTJKclNsaFdiWEJEVm1zeFYxWllhRmhpYXpWWVdXeFdZVlpHV25STlZGSllWbTVDUjFadE5XdGhSMFkyVW14a1YwMXVhSEpXYlRGTFYxWldjbVZHWkZkbGExcFpWbXBHYTFJeFNuTlZiazVZWWtkU2NGVnROVU5YYkZweldrUlNWMDFFVmtoVk1qVlBWa2RLY21OR1ZscGhNVm96VmpCYVYyTldUblJQVms1T1ZtNUNTRlp0TVRSaE1WVjNUVlphV0dKdVFsZFpiR2hEWVVac1YxZHJkRmROVjFKNVZHeGFZV0ZXU25OalJ6bFhWbXhLU0ZacVJscGxSbHAxVld4T2FWSllRbEJXVkVKcllqRk9SMWRzYUU1V1JVcFZWRlphWVUxR1duUk9WazVYWWxWV05GVXllR0ZXYlVwSFkwZG9WazFHY0ZoV01HUlhVbXh3UjFwR1pHaGxiRmt4Vm0xMGEyVnRWa2RXV0doWVlrZFNjVlZzV2t0WFJscDBUVmM1VGsxV2NFWlZiWFJoWVRBeGMxZHJaRmROYm1oUVdWVlZlRk5XUm5OVmJHUnBWMFpLYjFkclVrZFRNVmw0Vm01S1dHSkhVbTlVVjNoTFZrWmtXR1JHWkZoaGVrWjZWMnRvUzFZeVNrWk9WbHBYWWxoU00xWnFSbHBsVjFKR1QxWmthVkp1UWpaV1ZFbDRZakZhYzFkcldsUldSVXBYV1d4b2IxUkdhM2xsUlRscVRWVTFNRnBWWkhOV01rVjZVV3RrVjJKWVVsaFdha1phWlVaT1dXRkdUbWxoZWxaVlYxZDBhMVV4V2tkWFdHUlhWa1ZhVjFSV1duZGxiRnAwVFZWa1ZrMVdjSHBaTUZwelYyMUZlRk5zVWxkV2VrWk1WVzE0YTJNeGNFZFhiV3hYVW14d1RsWnRlR3BsUmtsNFdrWm9VMkV4Y0ZaWmExcDNWMFpzY2xkdVpGWldiVkphV1RCV2ExVXdNWEpPVld4WFlsaFNhRlpyWkV0U2JVNUhZVVprYVZKdVFYcFhWbFpoV1ZaS2MxZHVUbUZTYXpWUFZteGFkMDVzV2xobFJ6bHBUV3RhVjFSVmFHdFVNVnB5VGxab1dtRXhjR2haVlZwWFZsWktjMWR0ZUZOaVJtOTRWMVJDVms1V1VuTlRhMmhxVFRKNFdWWnJWVEZOTVd4VlVteGtWRkpzY0RGV2JYaFhWakZLVlZac1pGZFNiRXBRVlZSQk1XTXhWblZTYkVwWFVteHdVVmRYZUdGVE1VbDRWbGhzYkZKWVVsaFVWbHAzWld4cmQxWllhRmROVlhCWVZqSXhiMVl4U2taWGEyaGFaV3RhVEZsNlJuZFNNVnB6WVVaT1YxSnNjRlpXYlRCNFRrWlplR0pHWkZOWFIyaFpXVzE0WVdOR1ZuSlhhM1JZVm0xNGVWWnRNVWRXTURGWFYycENZVkpXY0ZCV2JGcGhZMjFPUjFwR1pFNWliRXBSVm0weE5GbFhUWGhhU0ZacFVteGFiMWxVUm5kV1ZscDBUVlJTVkUxck5YcFdiVFZUWVZaSmVXRkZPVlpoYXpWMVZGZDRZV014WkhSU2JHUk9WbGQzTUZaWE1ERlVNVnAwVTJ0a1ZHSnJOVmRaVjNNeFVrWmFWVkp0Um1wTlZuQXdWVzE0WVZSc1duSmpSV2hYWWxSRmQxbFVSbGRrUms1eVYyeG9hVkl4U2xkV2JYaHJZakZXUjFkdVRsZFhSMmhVV1d0a1UyVldXa2hsUjBaWVVtdHNObGRVVG10V01WcDBWVlJDVm1GcldtaFpla1pQWkZaT2NrOVdaRmRTVm5CV1ZtMHhNR0V3TlVkVGEyUllZa2RTV1ZsclpGTldiR3h6Vmxob1QxSnNXakJhVldSSFZtc3hjbFpxVGxwTlJuQjJWMVphWVdSSFJrbFhiR2hYWWtoQ1dWWnRjRWRaVjA1elkwVmtWV0pGTlZsVmFrcHZVMVphYzFremFFNVNhekUwVm0wMVQxZEhTa2hoU0VwV1RVZG9SRlpxUm1Ga1IxWklVbXhTVTJKR2NGcFhiRlpYWVRGUmVGZFlhRmhoTWxKWFZGYzFiMVJHV25GU2JVWlhUV3MxUjFZeWVHdFZNVnB6WTBab1YxSXphR2hWYWtwT1pVWk9kVlJzYUdsU2JIQmFWbGQ0VTFZeFdrZFhibEpzVW0xU1lWWnRkRmRPUmxwMFRsWmthRlpyY0VoVk1qQTFWMjFGZUZkdGFGZGhhMXBZV2tWa1YxTkZPVmRXYkdSb1RUQktXVlp0Y0V0TlJsRjRWMjVPV0dKck5WbFpiVEUwVm14c1dHUkhSbGhTYkhBd1dsVldNR0Z0U2tkWGJteFZWbXhWZUZaVVNrWmxSMG8yVTJ4a2FWSnVRbTlXYlhCSFUyMVdSMU51VmxWaVJuQndWVzEwZDJWc1dsaE5WRkpVVFZaV05GWXlOVTlXTWtwV1YyeFdWMkpZYUV4VmFrWmhaRWRTU0dSR1dtbFdXRUpJVm1wS05HRXhaSE5YYTFwUFZtdEtXRmxVUmxkT1JsWjBaVWQwYW1KR1NucFdNbmh2VlRBd2VWUnFUbGRpUm5CeVZHdGFTbVZHWkhWVWJGSnBZVE5DVVZadGVGTlNNVnBIVjI1T1dHSnRVbFJWYlhoM1YwWlplV1ZIZEZkV01IQlhWRlpTVTFadFNsbGhSMmhYVmtWd1IxcFZXazlrVmxKelkwWmtVMVpZUVRGV2ExcFRVakZzV0ZSc1pGTmlhM0JvVlcxek1WUXhXblJOUkZKc1VtMVNlbFp0ZUd0V1JURlhWMjV3VjAxdWFHaFdNR1JHWld4V2MxZHNXbWxTYmtKdlZsUkNZVll4WkVoV2ExcGhVbTFvV0ZsclZuZE9WbHB6V2tod2JGSnNWalJXTW5ocllXeEtWMU5zYUZkaVdHZ3pXVEo0YzFaV1NuSlhiWFJPWWtad1NGWnFTalJVTWtaR1RWVnNVbUpHU2xoVmJYaExVa1p3UlZKcmNHeFNiRnA1VmpKNGEyRkZNWE5UYkZKWVZqTlNXRlpxUVhkbFJsWlpXa2RvVTFaSGVGaFhWM1JoWkRGWmVGZFliR3RTVkd4WVZGWldkMlZXVW5KVmEwNVhZa1pzTmxsVlZtOVdNa3BaWVVWNFdrMXVhRmhaTW5ONFZqRlNjMXBHWkdsaE1IQkhWbTB4TkZsV1ZYaFVXR2hoVTBaS1ZsWXdaRzlXUm14eVYyNWtWMUp0ZUZaVlZ6VnJWbXN4V1ZGc2JGVmlSbkJRVm14YVlXTXhaSE5oUm1ScFYwWktlVlpzVWtkVE1XUllVbXRhWVZKc2NIQldNRnBMVkZaYWMxcEVVbHBXYkhCWVZXMDFWMkZzU25WUmJHaGFZVEZ3TTFaR1dtRldNWEJGVld4T1RsWnRkekJYVmxKUFpERmFXRk5yV21wU2JXaFlXV3RhZDAweFZuSlhiVVpYVFd0YVNsWkhjelZWTWtZMlZtdHNWMVo2UlRCWFZscFdaVlpLV1dGSGNGTldSbHBZVjFkMFlWbFhSa2RXYkZaVFlrZFNXRlJXV25kbFZsSnpWbFJXVldKR2NEQmFSRTUzVmpGYU5sSllaRmRXUlZwNlZqQmFTMk15U2toaFJrNVhWa1phV1ZadE1IaE9SbXhYVkd0a1YySnJjRmhaVjNoTFZrWnNjbGR1Wkd4V2JGWTFXbFZXTUZZd01WZGpSbHBXWWxoQ2FGWnFSbUZqTWs1SFlVWmFhR0V4Y0VsWFdIQkhWakpOZUZadVVteFNhelZ2VkZWb1ExWldXblJOVkZKYVZtc3hORlp0TlU5V2JVVjRZMFpvV2xaRmNGUldWRVp6WTJ4YWRGSnNhRmRpVmtvMVZtMHhlazVXV2xkWGJrcHFVbTFTV0ZSWE5WTlZSbHAwWlVkR1UyRjZWbHBXTW5oaFZqRktWbUV6WkZkV2VrVXdWWHBLVDJNeFVuVlViRkpwVWpGS1VGZFhkRmRrTVVwelYyNUtWMkpIVWxoVVZsWnpUa1pXZEU1Vk9WWk5hM0JJV1RCYVlWWXdNVWRXV0doWFZrVmFhRmw2Um1Ga1JrcHpVMnMxVjJKSVFtaFdNV1F3VlRGVmVGWnVVbFJoTVhCWldXdGtVMVl4YkhOaFJrNVhVbXh3U0ZZeWREQldNa3BJVlc1c1YxSXphR2hXYWtaTFZsWmFkRTlXWkZkaVJYQkZWa2QwWVZNeVRYaFVibFpVWWtaS2NGVnNhRU5YVmxwMFkwVkthMDFzV25wV01uaHpZV3hLVms1V1VsVldiRnBvV2xkNFZtVlhWa2RVYld4VFlUTkNXRmRVUW1GVU1WbDVVMnRrV0dKWGFGZFpWM1JoVmtaV2RHVkhSbXBpU0VKSVZUSXhjMVV4V25WUmJHeFhZbGhTYUZscVJsSmxSbVJ5V2tab2FWSnVRbHBYVmxKQ1RWWlplRmRZWkdGU1JUVlBWVzE0WVZkV2NGWldiWFJYVFd0d1Ixa3dhSE5XVjBwSFZtcFNWMVpGV21oVk1HUlhVbXhXYzFwR1pHbFRSVXBhVm0xMGFtVkdVblJXYTJSVVltczFXVmxyVlRGaU1WSldZVVZPV0dKR2NIcFdWM00xWVZVeGNrNVdhRmRpV0doeVZtcEtSbVZXVm5OVmJIQlhVbFJXTWxaWGNFZFdNbEpJVld0YWExSnNjSEJWYlRWRFYxWmFkRTFFUm10TlZuQjZWakkxVDFkSFJYbGhSbVJYWVdzMWRsVXdXbE5qTVhCSFdrWk9hVkpVVmpaV1ZFbzBZVEZaZUZkdVZsSmhNbEpZV1ZSR1lWZEdXbkZTYTNCc1VtdHdNVlpIZUZOaFZrbDVZVWh3VjFZemFHaFZla1pUWXpGYWRWUnNaR2xXVm5CVVZrWmFZVmxXWkVkWGJsSnNVakJhVmxSVlVrZFNiR3hXVldzNVYxWnNjSHBXTW5RMFZqRlplbUZIYUZkTlIxSlVWVEZrVDFJeFpITmFSMnhUWW10S1MxWnRlR0ZoTURWSFZsaGtUMVp0YUZoWlZFcFRWMVpzY2xadVpGaFNiSEI2VmpJMWExWkhTa2RqUldSWFlsaG9jbFpVUVhoV2JHUjFZMFphYVZkSGFHOVdhMlEwVkRGS2NrNVdaRmhpUmxwWVZtMTRkMkl4V2xkVmEyUlhUVmRTV1ZVeWRGZFdiVXBHWTBoQ1ZtSkdjRE5XTUZwaFYwVXhXV05GTlZkaVJYQlpWbFJLTkZZeVJsZFRiRnBQVm0xU1dGbHNhRzloUmxwRlVtNU9UMkpGY0hsWGExcHJZVlpLV1ZGcVZsZFdSVzh3V2tSR1lXTnJNVWxpUjJoVVUwVktXVlp0TVRSa01XUkhWbTVHVTJFelVuRlpiRnBoVWpGWmVXVkZPV2hTVkVaS1ZWZDRVMVl5U2xsaFIyaFhZV3R3V0ZsNlJtRmpNWEJIV2tkb1RtSkZjRlZXTVdRd1ZqRmtjazFXWkdwU2JIQllXVlJPVTFZeGJISlhibVJYVFZac05WcEZXbXRXTVZweVkwWm9WMDF1VW5aV2JYaGFaVzFHUm1WR1pHaE5WbFY0Vm0weE5GWXlUWGhTYmxKc1VqSjRjRlZzYUVOVmJGcDBaVWRHV2xac2JEUlZNV2h2VmxkS2NtTklUbFppUm5BelZtdGFjMVpXUm5WYVJscE9WbTVDTmxac1kzZE9WMHBJVTJ0a2FsSnRhRmhaYkdoVFkyeGFXRTFWZEZOaVIxSldWVzB4UjFZeFduTmpSVEZYWWtkUk1GZFdXbUZqTVhCSlUyeENWMkpHY0ZWV2JUQXhVVEpXVjFkc1pHRlNSa3BVVkZaYWQwMUdXa2RoU0dSWFZqQndSMWt3V205V01rcEhZMFJPVm1FeGNHaFdha3BIVTFaU2NrOVdUbWhsYkZwS1ZteGplRTVHYkZkV1dHeFRWMGRvY1ZWc1VsZFdNV3h5VjIxR2FGSnNXbFpWYlhoclZqRmFjMU5xUWxWTlZuQk1Wa2Q0UzFOR2NEWlJiR1JPWW14S1dWWlljRWRXTWsxNFdraE9WMkpYYUZWVk1GWkxWMFphZEUxVVVscFdhelZJVm0xNGIySkdUa2RqU0VwVlZteFZlRll5ZUdGVFIxWkdaRVprVGxadVFsbFhWRUpYVlRGWmVGZHVVbWhUU0VKV1dWUkdkMU5HYkRaU2EzUnFUVmRTZWxadGVHdFZNVnAxVVd4V1YwMVdjR2haYWtwS1pVWktXV0ZHWkdsU01VcFpWMVpTUzFVeFdsZFdiazVvVW5wc1ZGUldXbUZOUm5CR1ZtcENWMkY2UmxoWk1GcHZWbTFLUjFOc1FsZGlSbFl6V2xkNFIxZFdjRWRhUjJoT1YwVktTbFp0TUhoT1JrMTVWRmhvVTJKcmNFOVdiWE14VjBaYWRFNVZUbE5XYkhCNlZqSXhSMVl5UmpaV2EyeFhVbTFvZGxacVNrdFNNazVIVld4d1YxSlZiM3BXYkZKSFpERlplVkpyYUZCV2EzQlBWbTE0ZDFkV1duUk5WRUpvVFZad1NGVXllSE5oUmtwWVpVWm9WbUZyTlZSV1JWcGhWMGRXU0ZKdGRGTmlSVzk0VjFSQ1lWbFdXWGxUYTJScVVsZDRXRlp0TVZKTlJscFZVVlJHV0ZKc2NIbFhhMXBoWVZaS1dWRnNiRmRpV0dob1drUkdUMUl4WkhKWGJHUnBVakZLVlZaR1dsZFpWMVp6Vm01T2FGTkhVbGRaYkZaWFRrWlZlV1ZGWkZkV2JIQXdWbGQ0VTFac1drWlhiR2hYWVd0YWFGWnNXbGRrUjA1R1RsWmtWMkpyU2xwV2JYaHFaVVV4UjFSWWFGaGlSMmhZV1d0a05HSXhWblJqZWtaWFRWWndNRnBWWkVkV1JrcHpWMjVzVjJKWVFsUldWRXBMVW0xT1NXSkdXazVpYldoTlZtMXdSMWR0Vm5OV2JrWllZa2RTYjFSV1ZuZFNWbHBZWTBWa1UwMXJNVFJXUnpWSFZqSktXV0ZHVWxkaVIyaEVWbXRhWVdSSFZrZGFSbkJYWVhwRk1GWnNaREJaVmxsNFYydGtXR0pGTldGWlZFWmhZVVphY1ZKdGRGZFdiRXA1VkRGYVlXRldTblZSYkdoWFlXdHZkMVpFUmxwbFJsSnlZVWQwYkdFd2NGbFdiWEJQWWpGT1IxZHVVbXhTV0ZKeFdXdGFZV1ZXVWxkWGF6bFhUVlp3TVZWWGRGZFdNa3BIWTBkb1YyRnJjRmhhUlZwVFYxZEdSMXBIYkZOaWEwcFdWakZrTkZVeFNYbFVhMlJwVW14YVUxbHRjekZqTVd4eVYyMUdXRkpzY0RCYVJXUXdWbXN4Vm1KRVVsZE5hbFo2Vm0xemVGZEhSa2RSYkdSWFRUSm9iMVp0TVRSaE1sSkdUMVprYWxJeWVGUlphMmhEVkZaWmVHRklaRk5OVld3MFZqSTFUMVpIU25KalJtUmFWMGhDZWxacldtRmpNWEJGVldzNWFWSnVRbGxXYWtvMFlURlZkMDFXV2xoaWJrSllWV3BPYjFaR2JISlhhM1JYWWxVMVNGWkhlR3RoVmtwelkwYzVWMVl6YUdoV1ZFWkxZekZrZFZOdFJsTmhNMEozVmxkNFlWZHJNVmRYYTJoc1VtMVNXRlJXV2t0WFJsVjVaVWRHV0ZJd1ZqTlViRnByVmpKS1dXRkhhRmRTUlZwNlZHMTRTMk5zY0VkYVIyeFRWMFZKTVZac1VrdE9SazE1VTJ0a1lWSlhhRzlWYkZwTFYwWmFkR1ZJWkZoU2JIQkdWVzE0VDFZeVNsZFhhMlJYVFc1b1VGbFZWWGhUVmtaelZXeGthVmRIYUZoWGExSkNaREpXUjFac2JHcFNNMEpWVlRCV1MxVldXa2RYYkdSYVZteHNORlp0TlZOaE1VbDNWMnhrVlZac1dsaFViWGh6Vm14a2MxcEdaR2xTYmtJMlZtcEtNR0l4V1hsU1dHaFlWa1ZLVjFsc2FHOVVSbXQ1WlVVNWFrMVZOWHBYYTFwclZUQXhkRmt6YkZkaVZFVXdWMVphV21WR1RsbGhSazVwWVhwV1ZWZFdaRFJaVjAxNFZtNU9WMkp0VWxkVVZscDNaV3hhZEUxVlpGZFdiSEI2VlRKMGExWXlTa2RUYkdoWFZucEdURlZ0ZUd0ak1YQkhXa2RzVTAxdGFGSldiWGhyVGtac1YxZHVUbUZUUlhCWVdXeFdZVmRHV25SbFNHUlZVbTFTV2xrd1ZtdFZNREZYWTBod1ZrMXFWa3hXYTJSTFVtczFWMkZHV2s1U2JrSk5WbXhXWVZsV1dYaGFTRTVoVW1zMVQxWnNVbGRPVm1SelZteGtXbFpzVmpWVmJHaHJZV3hLY2s1V2FGcGhNbEpUV2tSR2QxZEhWa2hTYkU1WFlURndOVll5ZEdGVE1rWlhVMnhvVUZOSGFGbFphMXBoVjBaV05sSnNaR3BOVjFKNlZqSjRiMkZIVm5KWGJHUlhWak5vYUZacVFURlNNVnB6WVVkNFUxWXhTbGxYVjNSaFV6RmtjMWRyYUd4U1dGSllWRlphZDFkR2EzZFdiRTVYVFZad1IxWXllRU5XVjBWNFkwVm9XbVZyV2t4WmVrWnJZekZTZEdGRk5WZFhSVXBSVm0xNGEwNUdXWGhpUm1SVFYwZG9XRmx0Y3pGaU1WWjBZM3BHVmsxV1NsZFdWelZMVkcxS1NWRnJaRmROYm1oUVZtMHhTMUl5VGtkYVJtUk9ZbTFvU1ZadGVHRlRNVmw0V2toS2FGSnNjRmhVVkVwdlUxWmFkRTFJYUZWaVZscDZWbGMxVDFZeVNraFZiR2hYWWxSV1JGVnNXbUZqTVdSMFQxZHdUbEpHV2tsV1Z6QXhWREZWZVZOclpHcFNiRXBoV1d0a1UyUnNXa2hsUm1ScVZtdGFWbFZ0ZUV0VWJGcHpZMFpzVjJKVVJqWlVWbVJIWTJzeFYxZHNhR2xTTVVwWVYxZDRiMVV4VWtkWGJrcGhVbTFTV1ZacVFtRlRSbFowWlVkR1YwMXJjRWhaTUZaelZqRmFObEpZWkZWaE1YQk1XWHBHYTJSV1RuTlZiV3hUVjBWS1dsWnRNSGhPUm14V1RsaE9XR0pIVWxsWmEyUlRWa1pTVjFadFJteGlSbkF3V1RCYWEyRldTbkpqUkVKYVZsWndVRlpxU2t0U01XUjBZVVphYUdFeGNGVldWekUwV1ZkT2MyTkZaRlJpVjNoVVZtMDFRMWRzV25Sa1IwWnBUVlpHTkZadE5VOVhSMHBIWTBac1dsWkZSWGhXYWtaelkyeGFWVkZyTlZOaVdHaFlWbXBLTUdFeFdYbFRhMXBxVTBkNFdGUlhOVTlPUmxwVlVtMUdWMDFyTlVkV1YzaHJWakpLU1ZGdE9WaFdiVTQwVmtjeFYxTkdUbkphUm1ocFVsUldkbFpHVm05Uk1WcFhWMjVPVm1GNmJIQlVWbFpYVGtaYWRHVkhkRmROYTFZMVZsZDRjMVp0U2toaFNGcFdUVVp3ZWxreWVHRmpiVkpIVjIxc1UySnJTbGxXYTFwaFlqSlJlRmR1VGxoaWF6VlpXVlJLYjFZeFduRlViVGxXVW14d2VWZHJXbXRWTWtwR1RsaHdWazF1YUhKV2FrWmhaRlpHY2xwR1pHaE5WbkJaVm0xd1IxTnRWa2RUYmxaVllrVTFjRlZ0TlVOV01WcHhVV3hhVGxac1ZqUldNalZQVmpKS1ZsZHNUbFZXYkhCb1ZqSjRjMk5zVm5OVWJGcHBWbGhDU0ZacVNqUmhNVmw0VTI1T1ZHSkhhRmhXYTFaM1UwWlplRnBGWkZOaVJrcDZWako0YTJGV1NuVlJhM0JYWWtkUmQxWnRjekZXYXpWWlZXeFdhR0pJUW05V1Z6RXdaREZrUjFkdVRsaGliVkpWVlcxNGQxZFdjRVpXVkZaVlRWVndlVll5TlhkV2JVcFpZVWRvVjFaRmNFaFViWGhoWTJzMVYxZHRiRk5oTTBFeVZteGFVMUl4V1hoWFdHaFlZbXR3VUZacVRrTlVNVnB6VjI1a1dGSnNjRmxVVmxKRFZrVXhWMk5HYkZkaVdHaDZXVlZhUzJSR1ZuTmFSbVJwVjBkb2IxWlVRbUZXYlZGNFYyNUdWbUpGTlhCVmJHaERUbFphVlZOcVVsUk5WbXcwVmpKMGIyRkdTa2RqUm1oWFlsaG9NMVl3V2xkalZrcHlXa2R3VGxaWVFqUldiVEI0VGtaVmVGZHNiRkppUmtwWVdXeG9iMVl4VWxaV1dHaHFUVlp3ZWxsVlpITlZNV1JHVTI1b1YxSnNXbkpVYTFWNFZqRmtjbUZGT1ZkTlJuQjJWa1phYTFVeFNYaGhNMlJvVWxkU1dWVnFRbmRUVm14V1YydE9WMkpWVmpWV1YzUXdXVlphYzFaWWFGZGlSbkJJV2tWYVMyTXhjRWhsUjJ4VFlrZDNNbFp0ZUZOU01rVjVWVmhzVmxkSGFIQlZNRlozWTBaVmQxWlVSbXBpUmtwWlZGWlNVMkZ0U2tkaVJFNVhZa1pLU0ZsWGMzaFdhelZYV2tad1YxWnNWWGhXYTJRMFUyMVJkMDVXVmxKaVNFSnZWRmQ0U21Wc1pGZFZhMlJVVFd4S1dGa3dWbk5WYlVwSFYyNU9XbFpGV25sYVJFWnJZMnhrZEZKdGJFNVdWRlpJVmtkNFlWWXhXa2hUYTJ4U1lrZDRWMWxyWkZKTlJuQkhWMjFHYWsxWGREWlpWVnByVkcxRmVHTkZiRmhXYkVwUVdrUkdZV014WkZsaVJscHBVbGhDV1ZadGRGZFRNVkpIVlc1T1dHSllVbkZVVjNSaFVqRmtjbFpVUmxkTlJFWklXVEJrUjFZeFdrWmlSRkpWWVRGd1ZGVnFSa3RYVjBwSFYyMW9hVkp1UW1GV01XUXdZVEZWZUZSclpHbFNiV2hQVm0xek1WWkdWblJOVkVKUFlrWmFXVnBWVms5V1YwcElWV3RzV0dGck5YWldNR1JHWlZaU2NWVnNXbWhoTTBKWlZtMHdlRk14U25SU2EyUlhZbGQ0YjFwWGVHRmlNVnAwWTBWT1YyRjZSbGRVYkdoUFYwZEZlV0ZGT1ZkaVIxSlVXVEo0VjJSRk5WWlViR2hwVW01Q1NWWXlkR3ROUmxwelYyNU9WMkZyTlZkVVZ6VkRWMFpaZDFwRmRGUlNNRnBIV1ZWYVYxWXlTbGRUYTJ4WFlXdGFhRlpFU2xOVFJscHlWMjE0VTJFelFsQlhWM1JYWkRBMVIxZFlhR0ZTUlVwdlZGWldjMDVXV25ST1ZrNVhWbTFTU1ZwVldrTldNa1p5WTBoYVdrMUdjR2haTVZwTFpFWktjazlYYkZOV1JsWTBWakZrTUdJeFRYaFZXR1JPVm0xb2IxVnNaRFJXYkd4eVdrWk9WbEp0ZUZoWGExWXdWakF4Y21KRVdscFdWbkF6V1ZaYVlWSnNaSE5TYkdSVFlrWndlVlpYY0VkaE1VcHlUMVprYVZKdFVtOVVWRUpMVmxaYVIxbDZSbWxoZWtaNlZqSTFTMWRyTUhsVmJFSlhZa1pLU0ZVd1dscGxSMFpKVkcxb1YyRjZWa2xXYWtreFVURmtkRk5yWkdwU01taFdXV3RhZDFReGNFVlRhMlJUVFZoQ1NWcFZaSE5XUmtwV1kwZG9WMkpHU2toWmFrWkdaVVpTZFZSc1ZtaE5ibWhZVjFkNGIxRXhiRmRpU0U1aFVrWktVMVJXWkZObFJsVjVZM3BXYUUxVmNIcFpNR2h2Vm14YU5sSllaRmROUm5CTVZqRmFSMWRYUmtkWGF6VlhZa2hDTlZacVJtRldiVlpIV2tWa1ZXSnNXbGRaYTFwaFlqRnNWVkZ1Wkd0aVJuQXdWR3hvYTJGck1VVlNiR2hYVWpOb2FGWnNaRXRXVjBwSlVXeGFhR0V4Y0UxV1JsWmhXVmRTUms1V1pHRlNNbWhQVm14YVdrMVdaSEpXYlhCT1ZtMTRXRll5ZEdGWFJscEdVMjFvVm1KWWFHaGFWM2hYWTJ4a2NscEdhRk5pYTBwSVYxUkNZVlV4VlhoYVJWcFVZV3h3V0ZSWE5WTlhSbXh4VW14d2JGWnNjSHBaVlZwVFlWZEZkMk5HVWxkaVdFSk1XV3BLUjFJeFpGbGFSbWhwWWxaS2VGWkdXbXRPUlRGSFZXNU9XR0V6VW05VVZscHpUa1pXZEdOR1pGaGlWVlkxV1ZWYWIxZHNXblJWYTNoWFlXdGFjbGt4V21Gak1WcHpWRzE0YUUxWE9IbFdha293V1Zac1dGUnVVbGRpUjJoWVdWUkdZVlpHYkhOV2JVWlhVbXhLV0ZZeU5XRlViVXBIVjFSS1ZsWjZRVEZXYWtGNFl6RmtkV05HY0U1U2JrSTJWbTEwWVdFeFNYaGFTRlpTWWtoQ2NGVnRlSGRpTVZwSFZtMUdhRTFyTVRSV1Z6VlhWa2RHTm1KRk9WZGhhM0IyVlRKNFlWTkhVa2hrUjJoT1ZsUldObFpyWkRCV01WWnpWMnRhVDFadGVGZFphMlJUVkRGd1ZsZHNTbXhTYlZJd1ZERmFVMVV4V2tkWGJIQlhZVEpPTkZsNlNrZFdNV1IxVld4Q1YxSnJjRnBXYlRWM1VUQTFSMWRyVmxKWFIyaFZWVzEwZDJWc2JGWlhhMDVZVW10d2Vsa3dWalJXTVZvMlZtcE9WMkZyY0U5YVZXUkxVMVpTZEZKc1RtbFdhM0EyVmpGa05GWXhiRmRhU0U1WVlUSm9jbFZ0Y3pGaU1WcHpWV3RPVDFKc2JEVlpNRlpyVjJ4YWNtTkdaRlZpUjJob1ZqSjRZVTVzU25Ka1IwWlhUVEpvYjFkcldtRlpWMUpJVld0a1ZtSkZOVmhWYkZweVpWWmFjMVZyWkZkTmEydzBWakZvYzFZeVNuSk9XRVpXWWxSRk1GWnNXbHBrTVZweVpFWlNUbFpzV1hwWFZsWmhWREpHU0ZOcmFHeFNSVXBoV1ZSR1lWUkdaRmRXV0docVRWVTFlRlZYZUdGaFZscEhWMnBhVjFaRmJ6QlZNakZYVTBaU2NtSkhSbE5pYTBwM1ZtMTBWMWxXV2tkWFdHeHFVbGRTVTFSV1duZFRSbFowVGxaT1dGSXdXVEpWYlRWRFZqSktWVlpyVWxWV1JWcHlWakJWZUZOWFJrZFhiV3hYVmpOamQxWXhXbE5VTWsxNFZtdGtXR0V4Y0ZsWmJYUkxXVlpzYzJGSE9WVlNiRW93V2xWYVQxVXlTa2RUYm14WFVqTm9NMWxWVlhoalYwWTJVbXhrVTAweWFIbFhWM0JMVWpGWmVGcEdiR2hTYlZKd1dXdGFkMVl4V2xobFJscE9WbXR3U0ZaWGVHdFpWa3BWVm01T1YySllhRE5VVmxwelkyeGtkVlJzWkdobGExbDRWbXRhYjJReFdYZE5WV1JZWW10YVZsWnRlSGRsVm5CWFYyczVhMVpyV25wVk1uaHJWRzFLUm1ORVNsZGlWRVl6VldwS1RtVldUblZVYkZaWVVqRktiMVpYY0VOWlYwNVhWbTVHVW1KdFVrOVZiWGgzVjBac1ZsWnJPVmRTTUhCSFZHeFdkMVl4V2paU2FrNVhUV3BHVEZZd1pGZFNiRkp6WVVkb2FFMUlRVEpXYkdRd1dWWkplVlZyV2s1V2JXaHZWVzB4VTJNeGJISlhibVJQVm14d2VWWnRNWGRpUmtwelVtcFdWMVo2VmxSV2JURkxVMGRHUjFGc1pHaE5WbkJOVmxod1IxWXhXbGRWYmtwUFZsUnNXRmxZY0ZkWFJscHpXa1JDV2xac1JqTlVWbHB2WVVaS1dHVkdXbHBXUlhCVVdUSjRWbVZYVmtaWGJYUk9WbGhCZDFaSGVHRmtNVkowVW01S1dHSkhlRmhWYlhoaFkyeGFWVkp0ZEZkTlZrb3hWbTE0YTJGRk1IZFRiRlpYVW14YVZGWnRNVmRXTVhCSlUyeG9hVmRGU2xCV2JYaFRVakZPVjFkcmFHcFNNRnB2VkZaV2MwMHhVbk5oUlU1WVlrWndlbFl5ZEc5WGJVcFpZVVJPV21WclduSlpNVnBYWkVkU1IxcEhiRmROYldoTVZtMTBhMDFIUlhsU1dHaFZZbXMxVmxsVVJuZGpWbFYzVmxSR2FGSnNXbnBYYTJNMVYwWktkVkZzYUZoaE1WbDNXVmQ0UzJOc1pIRlJiSEJPVWpGS05sWnJaSHBsUmxsNVUxaHdhRkp0YUc5VVZscDNUV3hhY2xremFGWk5WbXcxVld4b2QyRldTbkpUYkd4V1lsaG9NMWxWV21GU01YQkZVV3hvYVZacldUQldhMXB2WVRKR1IxUnJiRkppVjJoV1ZtcE9VMDB4VWxaWGJHUnJVbFJXV0ZaSGVIZFdNa3BKVVd0d1YxSkZXbkZVVmxwelZqRk9kVlZ0YUZOaE1IQm9WMVpTUzFVeFZrZGhNMlJoVW10d2MxWnROVU5UUm10M1ZsUkdhRkl3Y0ZwV1ZsSkRWakF4V0ZScVRsVldiSEJZV1RKek1WZFdUblJpUms1WFlraENWbFp0TVhkVE1WVjVWV3RrV0dKR1dsVlpiVFZEVkRGU1YxcEdUbE5OVjFKYVdUQldhMVpzU25OalJFSmFWbFphZWxac1pFdFRSbFp6VVd4d1YySldTazFXYlhCTFUyMVdkRkpyWkdwU01uaFlWV3hhZDFWc1duSlhiR1JvVFZWc05GZHJWbUZWUmxwMFpVWm9XbFpGTlVSV2ExcDNWMGRXU0ZKdGVHbFNNVXBhVjJ4V2EwMUdXWGROV0U1WVlXdEtWMWxzYUc5bGJGcHpXa1YwVTJKSFVqQlVNVnByWVVkRmQxWnFVbGhpUm5Cb1dWUktUbVZXU25KWGJYQlRUVzVvVUZkV1VrOVJiVkY0VjI1U1RsSkZXbGRVVm1RMFYwWmtjbFp0UmxWTlYxSkpWbGN4UjFZeVNsbFVXR1JoVmpOb2Nsa3hXazlqYlZKSVpFWk9hVk5GUmpSV2JYaHFaVVpKZUZwRlpGUmlSbHBZV1Zkek1WZFdXbkpXVkVac1lrZDBOVnBWYUdGaVJscHpZMFp3V2xaWFVUQldhMXBMWXpKT1JtVkdaRmRpUlhCRlZsaHdTMVZ0VmtkalJXeFdZbGQ0VkZac2FFTmtNVnBIV2tSQ2EwMUVSa2hXTWpWVFZERmFjazVYUmxkaVZFWlVWV3BHVTJNeVJraGtSbWhwVW01Q05WWkdWbTlpTVdSMFZtNUtXR0ZyTlZoVVZWcFdaVVpaZDFaVVJsaFNNVXBJVmtkek1XRldXbkppTTJoWFlsaG9XRmRXV2xka1JsWlpXa1pDVjJKSVFuZFdWM2hoV1ZaVmVGZFlaRmRoTTFKVlZGWmFWMDB4YkZaWGF6bG9VakJ3U1ZwVlVrTlhiVVY0VjJ0NFdGWnNWalJWTUdSWFVteGFjMWRzWkd4aVJuQmFWbXBHWVZsV2JGWk9XRTVVWW14YVZsbHJhRU5qTVd4VlZHdE9UMkpIVWxaVlYzaHJWREZKZUZOc2FGWmlWRlpJVmxSS1MxZFdSbkpQVm5CcFVqRktWVlpHWkRSaE1XUkdUVlZzYUZKdFVrOVphMVozVTFaa1ZWRnRSbXBOVm5CWlZUSTFTMVpIU25KWGJXaFhZbFJHVkZSdGVGTldWa3AwWkVaT2FWSXpZM2xXVm1ONFVqRlNjMU5ZY0doU1dGSllWVzE0WVdOc2JGVlNiazVYVFZkU1dsa3daRzlWTVVwMVVXeHdXRll6VWxkVVZscExVakpGZWxwR2FHbGlWa3A0VmxjeE1GbFdaRmRWV0doaFUwVTFiMVp0ZUhkbGJHeHhWRzEwVjAxRVJqRlpWV2hoVmpGS1JtTkdRbFpOUm5CTVdYcEdkMU5IVGtaT1ZUVnBVbGhDYjFadE1UUmlNbEY0VjFoc1ZXSkhVbkJWTUZaaFZteHNjbHBHVG1waVJuQjRWVzEwTUZVeFduTlhiR2hYVm5wQk1WWnJaRXRTYlVvMlUyeGthVlpHV2xGV2FrbDRVekZPUjFadVRtaFNNRnBZV2xkMFlWTldXbkZTYlVaV1RWZFNXRll5TlU5aGJFcFZWbTA1V21KSGFGTlVWVnBhWlVacmVscEZOVmRpUm05M1ZtdGtNRmxYUmxkVGJHaHNVMFZ3VjFsWGRFWmxSbXQzVjI1T1YwMVdjSGxYYTJSellWWktWVlpzYUZkaE1sRjNWa1JLUm1WR1pIVldiRXBwVWpOb1YxWnRNSGhWYXpGSFlrWm9hazB5YUhKVmFrWmhVMnhrY2xkc1RsZE5WbkI1VmpGb2QxWXdNWFZSYTJoYVZucEdXRlp0Y3pGV01rWklaVVpPVG1KdGFGcFdhMXBoV1ZkU2NrMVlUbUZTYlZKWldXeFNjMVpzVWxkaFJVNVRUVlpHTTFsVll6VmhWa3B5VGxWb1YwMXVVWGRXYlhoaFVteE9jbVJHVm1sU2JrSlJWbTB4TkdReFNYaGpSV2hxVWxSV2IxcFhkRlpsUmxwMFRWUlNhRTFyVmpWVmJYUnJWMFprU0dGSVFsWmlia0pZVm14YVUxWnNjRVpPVjNoVFlsaG9OVll5ZEZkTlJtUkhVMjVPYWxKRldtRlVWV1JUWkd4YWNWRllhR3RXTUZwS1ZWZDRhMVV5U2tkalIyaFlZVEZLVEZaVVJscGxWa3BaWTBkc1UyRXdjRmxXVjNoaFpESlJlRnBHYUU1V1JrcFVWRmQwZDJWc1duUmtSM1JYWWtkU1NWWlhlRWRXTWtwSVZWUkNWazFXY0ZSWmVrWjNVbFpXZEdGR1pHbFNNMk4zVm0xd1MyUXhiRmRhU0U1WVlteEtiMVZzVW5OaFJsWjBaVWhrYkZadVFsaFdiRkpYVmpGYWNtTkVRbHBoTWxKNldWWmFTMVl5U1hwalJtUlhVbFp3V1ZkWGNFSmxSa2w1VWxod2FWSnNTbkJaVkVKM1ZrWmFkR05GZEZaTlZURTBWbTE0VjFWdFJYcFZhemxYWWxSR1ZGcFhlR3RXVmxKMFQxZG9WMkV5ZDNwV1JscFRWakZrZEZKWWJHaFNWa3BZVlcweFUxUkdhM2xsUlRsWVZqQmFTRmt3WkRSaFJUQjNVMWhvVjAxWFVqTlZla1pPWlZaV2NscEdhR2xpUm5CWVYxZDRWMWxXWkZkV2JrNVdZa2RTVDFSV1pGTldiRnBJVGxVNWFHSlZXVEpXVjNCVFYyeGFWMWR1V2xkU1JWcExXbFphVjJOdFVrZFhhelZUWVROQ1NsWXhXbXRPUjAxNVZXdG9WMkV4V2xkWmJHaFRWMFphY1ZSdE9WTmlSbkJZVjFod1IyRnJNVmhsUm1oWVlURmFjbFpyV210VFIwWklVbXhXVjAwd1NrUlhhMUpIWVRKT1YxUnVTbXRTTTFKVVdXdG9RbVZHV25OWk0yaFRUVmRTU0ZVeWVGZFdNa1p5VGxac1YySllhRE5XYTFwVFZteGtkVk50ZUZkaGVsVjRWbTB4ZWsxV1dYZE5WVlpYWW0xU1dWWnFUbE5rYkd4eFVWaG9WMDFXV25sWmEyUnZZa2RLUm1OSE9WZFNiSEJZV2tSR2EyTXlTa2RYYldoVFRURkthRlp0TUhoVk1VbDRZVE5rYUZJelVsbFpiRlozVTFaYVdHVkhPVnBXYTNBd1ZsZDRVMVp0UlhoalJXaGFUVlp3U0ZwRlpFdFRSMVpIV2taa1YyVnRkRFpXYlRGM1V6QTFTRk5ZYUZWWFIzaFZXVzF6TVdOV1ZuUmxSWFJXVFZkNFdWcEZWakJoVlRGWFYyNW9WbUpZYUhKWlZtUkxVMFpXY1ZGc1ZsZGlWMmhSVjFkMFlWZHRVWGROVmxaWVlrZFNXRmxzV2t0bFZsbDRWMjEwVkUxWFVrbFdiWFJ6WVd4SmQxZHNVbGRoYTFwTVZqRmFhMk14WkhOYVIzQk9WbFJXU1ZaVVNURldNVmw1VTJ4YVdHSkZOVlpXYkZwaFRXeHdSVkpzY0d4U2JWSXdWREZhUzJGV1NqWmhla1pYVmtWYWRsbDZSbXRTTVdSWllrWmFhVll5YUdoWFYzUnJWV3N4UjFWc1pGaGlXRkp4V1d0YWQxWnNWblJOV0U1V1RVUkdTbFZYZUhkV01rcFZVVmhvWVZKRmNFaFZha1ozVW14a2NrOVdaRTVOUlhCdlZqRmtOR0V5Vm5KTlZXUnFVbGRvY2xVd1ZURldWbFowVFZaT2JGSnNXakJVVm1oUFlVWmFjMk5HV2xkV00wSlFWakJhWVdNeVRrbFNiRlpwVWpGS1ZWWnRNSGhUTVVwMFVtdGthRkl5ZUc5VVZXaERUVEZhYzFWclRscFdhekUxVmtab2IyRkZNSGxsU0VaVlZrVndkbGxxUmxkalZrWlZVbXhPVjJKWWFGaFdiR1F3WVRKR1NGSnFXbE5pYmtKWVZGYzFRMWRHV25KV1dHaFhZWHBXVjFaWGVGZGhSMFY0WTBSS1YxWkZTbGRVVmxwUFZqRndTVk5yTlZkTk1taFpWbTE0WVdRd01WZFhiRlpUWWtkU2NGUldWWGhPVmxWNVpFYzVWMkpWVmpWYVZWcHZWMjFLVlZKVVFscE5SbkI2Vm1wR1lXTnNjRWhrUjJ4VFRWVndXbFpxU2pCV2F6VllVbXRvVTFkSVFtOVZiRnBoVmpGYWRXTkZaRTVOVjNoV1ZXMHhNRlV5U2xaalJYQllZVEZ3VkZacVJtRmpiR1JaWTBaYVRrMHdTa1ZYV0hCSFZERmtSMVp1U21oU2JGcHdWbXBPYjJSc1duUmtSM1JwWWxaYVdGWnNhRzlXTWtZMllrWk9XbUV5VFRGVVZFWnpZMnhhYzFSc1dtbFdXRUkxVmxSSmVHSXhaSE5YYms1WVlUSm9hRlZxVG05VlJscHhVbTVrVTJGNmJGZFViRnByVkd4S1IxZFljRmRoTWxFd1ZsUkdVbVZXU25KYVJtaG9Za2hDV1ZkV1pEQlpWbVJYWWtoS1lWSjZiRlZVVm1oRFUwWmtjbFp0ZEZoU2EzQldWbTE0YzFkck1VaFZibkJYWVRGd1RGbDZTazlUVjBwSFdrVTFhV0pYWjNsV2JYUnFaVVpPZEZac1pGZGlhelZ3VlcxNFlXTkdXWGRhUnpsc1VtMVNXRll5ZUU5V01ERkZVbXhvV0dFeGNISldNbk4zWlZkR1NWRnNXbWxTTW1oVlZtMTRZV014V2xkVWJsSnJVako0VkZaclZtRlpWbVJYVm14T1UwMVdjRmhXUjNSdllXMVdjbE5zYkZwV00xSk1XbGQ0VjJOc1pISmFSbWhUWW10S1NGZFVRbUZUTVZKelUyeGthbEpGV2xoWlYzUmhZVVpzVlZKc1NteFdhM0F4VlRJeE5GWkdTbk5qUmxKWVZtMVJkMWRXWkU5V01WWnpZVVUxVjAweFNubFhWM1JyVlRGYWMxZHJhR3hTTTFKd1ZXMTRkMWRzYkZaVmEyUllVakJXTlZsVlZsTlhiRnAwVld0NFYySkdjR2hhUmxwVFl6Sk9SazVYYkZoU01tTjVWbTF3UjFVeFRYaFVXR3hWWVRGd1VWWnNaRFJYVm14VlZHdE9WazFXU2xkV2JURkhZVEZhYzFacVVsZGlXRTB4VmxkemVGSlhTa2RoUm5CWFZteHdNbFpyVWtkVU1VbDVWR3RhVDFZd1dsaFphMXAzVTFaa1dFMVVVbFZOVm5CNlZsYzFTMVpIU2xaWGF6bGFWMGhDVjFwRVJtRmtSVEZaV2taS1RtRXhXVEJXTW5SWFdWZEdjMU5yV2xoaVJscFlXV3RrVTFaR1ZYZFhiazVZVWpGYVNsWkhjelZoVmxweVkwVndWMkV5VGpSWmVrcEhVakZrY21GSFJrNU5ibWhZVmtaYVlWbFdWa2RXYkdoc1UwWndjMVp0TVZObGJGcFlUVlJDVldKVmNGaFZNbmgzVmpGS2MyTkdVbFpXUlhCVFdsVmFWMk5XWkhOVWJXaHBVbGhDTlZadE1UUmlNa3B5VFZaa1ZsZEhVbWhWYWs1VFkwWmFkR1ZJWkU1V2JYaFhWbGQwYTFkR1NuSmpSbXhYVW0xb2RsWXlNVXRUUmxaelZXeGtUbEpzVmpSV2FrSnJWREZPU0ZWclpGVmhlbFp3V1d4a1VrMVdXbkZTYlhCc1VqQXhORlZzYUhOV1IwcElZVVpTV21FeVVuWldWVnBoWTFaU2MxUnNaR2xTTTJnMlZtcEplRkl4VW5OVGJsSldZbTVDWVZac1dsWk5WbXhZWlVWd2EwMUVWa1pWYlhoM1ZqRmFjbU5GYkZoV2JWSTJXbFZrVG1WR2NFbFNiR1JwVW10d1VGWnRlRk5XTVVwWFYydG9hbEpYVW5CVVZsVXhVakZTYzFadE9WcFdhM0JhVlZkNFYxWnRTbFZXYTFKaFVqTm9jbFpzV2s5a1ZsSnpVMnMxYUUxWE9UTldiRkpIWWpKUmVGZFliRlJpYXpWWldXMTBkMVl4VWxaWGJHUlBVbTE0TUZwVldtdFZNREZYVTI1c1YxSXpUWGhXYWtGNFVsWktWVkpzWkdsV1JVWTBWMWh3UjFVeFpFZFViazVoVW0xb1dWVnFUbTlYYkdSWVpFZDBWV0pXV2toV1YzaGhXVlpLVldKR1FsZGlSa3BZVmpGYVUxWXhjRWhQVm1ST1VrVkpNVll5ZEZOVU1WbDNUVmhXYUZOR2NGZFVWM0JIVXpGd1YxZHJkR3BOYTNCSVZtMHhiMkpIU2xsaFJFNVhZVEZ3VkZWcVJrNWxSbkJIV2tkc1UySldTbWhYYkdRd1dWZE9jMWR1VWs5V1ZUVlpXV3RhVjA1R1pGbGpSbVJvVWxSR1dWWlhkR3RXVjBwSVlVWkNWMDF1VGpSYVJXUlhVMWRLUjJORk5WTmlSM1F6VmpKMFYxWnRWa2RhUldoVFlUSm9jVlZ0ZEhkVU1XeHpXa2MxYTAxV2JEVmFSV1JIWVVkR05sSnNiRlppVkZaVVZtMHhSbVZYUmtsUmJGcE9VbTVCZWxkVVFtRmpNVmw0VjI1S1lWSXpVbkJWYWtaTFVqRmFjbHBFUWs1U01GcFlWVEkxVjFWdFNuUlZiVVpYWVRGYU0xa3llSE5qYkZwWllVWm9WMDFHY0VkV1Z6RTBWVEZaZUZkc1ZsZGhNVXBZVkZjMVExSkdiRFpTYXpsWFRWaENTbFpYTVc5Vk1EQjNVMjVhVjJKWWFGaFpla0V4WXpGd1IxcEdhR2xYUlVwUVZtMXdSMU14WkVkaE0yUllZbXMxV0ZWdGVITk9WbHBZWlVWMFYwMVdjRWRWTW5RMFYyMUtSMk5JYkdGV2JGWTBWbXBHZDFOSFNrZGFSbWhUVFcxUk1GWnRjRXROUjBsNFVsaHNVMkpIYUZWWmExcGhWMFpzZEdONlJscFdiRXBaVkd4V1MyRXdNVmhWYkZwV1RXNVJkMWxYZUV0amJHUnpZa1pvYUUxV2IzcFdiR1I2WlVaS2RGTnFXbE5pUjFKUFdXMHhiMDFzV25OVmEwcHNVbTFTU0ZaWE5WZFdiVVkyWWtaU1ZWWXphRXhhVmxwaFVqRnJlbUZGT1ZOV1JWcFpWMWQwYjFVeFVuTlhibEpXWW1zMVdGbHJXa3RrYkZKeVYyNWtWMkpWV2toWGExcFRZVlpLVjFkWWNGZFdSVnBVVm1wR1lWSnJNVmRYYXpWVVVqSm9iMVp0TVRSa01EQjRWMWhrV0dKSFVuRldiWFIzWld4cmQxWlVSbWhXYTNCNldXcE9jMVl5Um5KaVJFNVZWbXh3WVZwV1dsZGpNWEJJWVVVMVRrMUZjRmxXTVdONFRVWk5lVlJyWkZaaVIyaHhWVzF6TVdOR2JISldXR2hPVFZkU2VWWnRNVWRoUjBZMlVtdHNZVlpXV25wV2JYTjRWMGRHUmxWc1drNWliV2hSVmxSR1lWWXlVa2hVYTJScVVqSjRXRlJVU205U1ZscHhVMjVrVWsxck1UUlZNblJyVlRKS2MxZHVRbFpoYTBwb1ZqRmFWMlJIVWtsVWF6bFRZbFpLVjFaVVJtOWhNVkp6VTI1U1VGWkdTbUZaVkVaM1ZrWmFSVkpzY0d4aVJWb3hWVmQ0VjFZd01IZFRiR3hZVmtWYWFGbFVSbHBsVmtweVdrWlNhVll6YUZCV2JYQlBZakF3ZUZwR1pHaFRSMUp2VkZaa1UxZEdWWGxqUjBaWFlsVndWbFp0ZUZkV01rcElWVzVLVlZaRlducFViWGhIWkZaU2MxUnJOV2xTV0VKTFZtMTRhMDFGTlVkWGJsSlhZbXMxV1ZaclZtRlhSbEpZVGxjNWFtSkdjRlpWVm1odlZqQXhjbFpxV2xwaE1YQnlWbXBLVjJSSFZrbGFSbWhYVFRKb2IxWXhXbFpsUmtsNFkwVnNWV0pYYUZSV2EyUTBaVVphV0dORlNteFNWRUkwVmpKMGIxUXhXWGRYYlRsVlZteHdNbFJYZUdGak1rWklaRVprVjJFelFsaFdSM2hYVlRGa1IxZFljR2hUUm5CWVdWUktVMU5HVW5SbFNHUlRUV3R3U0ZaSE1UUmhWa3AxVVdwU1YyRnJXbkZhVldST1pVWktkVlJ0YkU1TmJtaFlWMWN4TkZNeFdrZGlTRkpPVmtaS1ZWUldXbUZOVm10M1YyMTBhR0Y2UmxsYVZXaDNWMGRGZUdOSVNscGhNbEpNVm0xNGEyTXlTa2RqUm1SVFYwVktOVlp0ZUdGWlZscDBWVmhvVldKc1dsUlphMmhEWWpGc1dXTkdaRmhXYlZKNVZqSXhNRlpyTVZaT1ZtaFhWak5vZWxacVNrdFhWa1oxVVd4a2FWZEhaM3BYYkZwaFlUSk9jMXBJVW10U2JGcFBXVlJPUTFOR1pISldiR1JwVFZaR05GWXhhSGRoUms1R1UyeG9XbFl6VW1oWlZWcFRaRWRXU1ZSc1pFNWhNWEJJVmtSR1lWbFdXWGROVldScVVtNUNXRmxVU2s1bFJsWTJVbTVPVjAxWVFrZFdNakZ6VmtaT1JsTnNXbGRpV0dob1drY3hVbVZHY0VsVGJHUm9ZVEJ3V1ZadGNFZFRNVTVYVjJ0b1RsZEZOVzlXYlhNeFUxWmtjVlJ0T1ZkaGVrWllWako0UTFac1drWmpSa0pXWVd0d1VGVXhXa2RqTVU1eldrZDRhVmRIWjNwV2FrWnJUa1pzVjJKR1drNVdWMUpvVlRCVk1XSXhWbk5WYms1cVZteGFlRlZYTVVkV01WcHpVMjV3V2xaV1ZURldNbmhoWXpKS05sTnNaR2xXUmxwWlZqRmFZVk14WkVkV2JsWlhZa2RvYjFsVVJuZFNWbHAwWlVaYWJGSnJjRmxWTW5SaFlXeEtjazVXVWxkaVJuQXlXbGQ0WVZaV1NuTmFSMnhPVWtWYVNWZFdVazlqTVZwSVUyNUtWR0pGTlZoWlYzUjNWa1pXTmxKc1pGZFdhMXA1V2tWVk5WWXlTbGRUYWxwWVZteGFhRlpFUmxOak1XUlpXa1U1VjFKVmNGZFhWbEpMVlRKT2MxZFlhRmhoTVhCeVZGZHpNVk5HYkhKWGJtUm9VakJXTlZwRlVrOVdNREYxVVd0b1lWSkZXbkpXYWtaM1UxWldkR1ZHVGs1TlJYQXpWakZrTkdJeVJYZE5TR2hoVW0xU1dGbHNhRk5qVmxKWVpVVjBXRkp0ZUhoV1J6QTFZVVV4UlZKcVFtRldWbkJJVm14YVlXUkhSa2xYYkZaWFlraENVVlp0TVRSVk1rNXpWVzVPVW1KSFVuQldha3B2VXpGYWNscEVVbWhOVmtZMVZXMTRiMVV5U2tkalJsSmFZa1pLV0ZkV1dsTlhSMDVHV2tab1UySkZjRmhXTW5SaFZERmtSMWR1U2s5V1JWcFlXV3hvVTAweFdsVlRiR1JxVFZkU01Wa3dXbTlXTURCNVlVaHNWMkpZUWt4V2FrcFRVakZPZFZSdGFGTk5iV2hRVmtaYVlXUXlVWGhYYmxKcVVsVTFZVlpzVWtOT1JscEhZVWQwV2xacmJETldNbk0xVmpKR2NsTnFUbFZXVm5Cb1ZUQmtUMUpzVW5SaFJrNXBVbnBvTlZZeFpEQlZNVWw0VjJ0a1dHSkdjRkJXTUZwM1lVWldkR1ZJWkU1TlZtd3pWbXhvYjFkR1NYaFhhMnhhVFVaVmVGbFdXbXRUUm10NllrWmtXRk5GU2tsV2ExSkhVbTFSZDA1VmJHaFNNbWhVVm1wS2IxVldXbGhqUlhSV1RWVXhORlp0ZUZkVmJVVjVWVzVDV21FeVVYZFViRnBUVmpGa2RHUkdWbWxTVjNjd1ZsUktOR1F4V25KTldFWlhZa2RvVjFSWE5XOVVSbEowWlVkR2ExWnNTbnBaTUdSelZUQXhWbU5HY0ZkTmJtaHhXbFZhU21WR2NFZGFSbHBwVWpOb1dWZFhlR3RPUjA1SFYyNU9XR0pzY0hKVVZscHpUbFp3VmxaVVZsWmlWWEJYVkd4b2MxZHRSWGhYYkZKWFRXNU9ORnBGV2xkamF6RlhWMnhrVTFkRlNsSldNV040VGtaU2RGWnVVbFJoTVhCV1dXeG9VMWRHYkhSa1JYUllZa1p3U0ZZeU1UQlVNVWwzVjI1c1ZWWnRhRlJaYTFwTFVqSk9SMWRzV21saWEwcEpWbXhXWVdReFRrWk5WbVJWWWtkb1ZGWnJXbUZXTVZwWFdrUkNhMDFXV25sVVZXaHJWREZrUjFkc1pGVldNMEpZV2xkNGNtVlhWa2xYYlhST1lYcFdSMVpxU1hoTlJsVjNUVlZXVjJKdFVsbFdiWGgzVjBaV2NWTnJkR3BOYXpWS1ZrZDRWMkZYUlhwUmJFWlhVbXh3Y2xscVJrOVdNVloxVkd4YWFXRjZWbHBXYlRFd1pHc3hjMWR1VWs1WFIxSlpXV3hXZDFac1ZuUk5WemxYVm14d01GWlhkRFJaVmtwWFkwWlNXazFXY0VoYVJXUkhVakZ3U0dWSGJGaFNNVVYzVm0xNFUxSXhXWGhYYmtwT1ZtMW9WVmxVU205V1ZteHlXa2M1V0ZKdGVEQlViRlpQWVZVeFYySkVUbGRpUjJoMldWUktTMU5HVm5KWGJHUlRUVEZHTTFkV1dtRlRNbEpYVW01V2FGSnNjRTlXYWtwdlVsWmFWVk5xVWxWTlZUVllWbTAxVTJGc1NuVlJia0pYWVdzMWRsVnJXbHBsVjA1R1pFWmFUbUpGY0VsV1ZFa3hWakpHVjFOc2JGSmlSbHBYV1d4b2IwMXNVbGhsUm5Cc1ZqRmFTVlF4V2xOaFZrbzJZWHBDVjFadFVUQldWRVpYWkVaT2MxcEhjRlJTVm5Cb1YxZDBZV1F5UmtkalJWcFlZa1UxV1ZWcVFscE5iRlowWTNwR1YwMUVSa1pWYkZKSFZqSktWVkZZYUZwbGExcFlWVzF6ZUZZeVNraGhSazVUVm01Q1lWWnNaRFJoTVZKMFZWaG9ZVk5GV2xOWmJYTXhWbFphZEdONlJrNVNia0pYVjJ0U1ExWXhTbkpqU0hCYVltNUNTRll3V21GT2JFcDFZMFphVjFKV2NGaFhiRlpyVkRGSmVWSnJaRlZpVjNoWlZXeFdkMDVXV25OWGJUbHJUVlpzTlZaSGVHdGhSVEI1WlVVNVYySlVSbFJaYWtaWFkxWktjbVJHVWxkaVNFRjNWMnRXYTFJeVJrZFhia3BwVWtaS1dGUlhOVU5TUmxsM1drVjBWRkpzU2xwWlZWcFhWakZhYzJKRVRsZFdNMEpNVmxjeFYxZEdUbkpoUms1cFVsUldVRmRYTUhoVmF6RlhWMjVHVW1KSFVsWlVWbFV4VFVaYVIyRkhkR2hXYTNCWldsVm9SMVpXV2paU2JGSllWbXh3VkZZd1ZURlhSVGxZWWtVMVYwMHlUalZXYlhSclpXczFWMWRzV2s1V2JXaHpWVzB4TkZac1duUk5Wa3BPVW14d1YxZHJWbXRXTWtwR1RsUkNXazFHY0ZSV2FrcFhZMnhLY1ZWc2FGZE5NVXA1Vmxod1IyRXhTWGhhU0ZaWFlsaENWRlJYTVc5WGJGcFlaVVpPVjAxck5WaFdiR2h2V1ZaT1JrNVdUbFZXVmtwNlZtcEdkMVpzV25OVWJGcHBWbGhDV0ZaSGVGZE5SbVJ6V2tWc1VtSkhhR0ZhVjNSaFpXeHNObEp1WkZOTldFSkpXbFZrYzFZeFduVlJiV2hYWWxoU2FGWlVSbk5XTVZKMVZHeFNhV0pHY0c5V1ZFSlhVekZhYzFadVRsZFdSVnBVVlcweE5HVnNaSEpXYlhSWVVtdHdWbFp0ZUhOWlZrcFhZMFpvV2xac2NHaFpla3BLWld4d1IxcEZOV2xpVjJkNVZtMTBVMU14VVhoVWEyUldZbXRhV0Zsc1pHOVdSbFp6VjI1a2JGSnNjRWhYYTFKVFYyeGFWVlpzYUZkU2JXaDJWbXhrUzJOdFRrZFJiRlpYWWxaS01sWlVSbUZWTWsxNFZtNVdWV0pIYUZoWlZFazBaVlphZEUxSWFHdE5WMUl3VlRKNFYxVnRSbk5UYldoV1lXczFkbFJVUmxabFJtUjBVbTEwVjJKRmIzZFdWekUwV1ZkS1NGTnJaR3BTUm5CWVZGYzFiMWRHYkhGU2ExcHNWbXhhTVZaWGVGZGhWMHBIWTBab1dGWjZRWGhWVkVaT1pVWmFkVk5zV21oTlJGWjNWMWQwWVdReFRsZFZiR1JZWWxoU2IxUldWbmROVmxaWVpVaGtWMDFWYnpKV2JYUlRWMnhhTmxKc2FHRlNiSEJZV2tWa1QxSXlUa2hpUm1ST1RVUkZlbFpxU2pCaE1ERklWRmhrVDFadFVsUlpiWGhoWTFaV2NWTnFVbFZOVmtwWVZqSTFZVlJzV25OaVJGSlhWak5SZDFacVFYaFdNVTUxWTBad2FFMVlRalpXYkdONFV6SlNSMVp1VWxCV2JWSndXVzEwUzFkV1pISlhiVVphVmpBeE5GZHJhRXRoTVVwelYyeG9XbFpGU2pOV01uaGhZekZyZW1GSGJFNWhNVmt3VmxSR2IyRXhXWGhYYTFwcVVtMTRXRmxzVWtka2JGWnlWMjVrVTFack5YbGFSVnBUVlRBeFNWRnJjRmhXUlVwb1drUkdhMUl4VG5WVGJYQlRVbFJXV2xadGNFOVJNVTE0Vld4YVlWSnJOWEpWYlhSM1RWWmFkR1ZHWkdoV01IQktWVmMxYTFkR1duUlVXR2hYVmtWd1VGVnFSbmRTTVhCSVlVWk9WMUl6YUROV2JHUTBWVEZaZVZaclpGaGlSMUp2Vld4U2MxbFdXblJOVms1VVZtNUNWMVp0Y0ZOV01WcHpZa1JhV2xaV1NsQldha0Y0VmpKT1IxRnRSbE5pVmtwUlZsUkNhMUl4U1hoalJXaHNVako0V1ZWcVJrWmtNVnAwWlVaT1UwMXJWalZXVm1oelZtMUtjMU5zYUZwaVdGSXpXWHBHVjJNeFpISmtSbVJYWWxob05sWnNaREJoTWtaV1RWWmthbE5IYUZoVmJuQkNUVlpzV0dNemFGZGhlbFpZV1d0YWQxUnNTWGxoUnpsWVZteGFhRmRXV210V01rNUdWbXhhYVZJeFNuZFdiWFJoVjIxV2MxZFlhRmhpVlZwdlZGWldkMDFHV2toa1JtUllVakJ3U0ZZeWVGTldiVXBIVTJ4b1ZtSkdjSEpXTUdSUFVtMVNSMVJyTlZkTlZYQkxWbTE0WVdJeVVYaGFSV2hVWWtkNFYxbFljSE5aVmxwMVkwVmFiR0pHU2xoV01qRXdWakF4Y2xkcmNGWk5iazB4Vm1wS1MyTnNUbkZYYkdoWFlrVndVVmRZY0V0U01VbDRWVzVLWVZJelFsUldhMXBoWVVaa1dHUkhSbHBXTUZwSVZsZDRZVmRIU2taT1ZsSlhZbGhOZUZSVlduZFNiRnBWVW14a1RsSkZXa2xYVkVKaFpERmtTRk5yWkZoaWEzQldWbXhhZDFaR1duUmpNMmhVVm01Q1IxUXhXbXRWTWtwSlVXMUdWMkpZUWtSWlZFcFhZMnN4VjFwSGJGTmlWMmhRVm0xNGIxRXlUWGhYYms1V1lUSlNXVmxyWkZObFZtUnlZVVU1VjFZd2NGZFdNalYzVmpBeGNWWnFUbGROUm5Cb1ZHMTRSMWRYUmtkYVJtUlRWMFZLV2xZeFVrcGxSbFowVm01U1ZHRXhjRkZXYlRGVFZERlNXRTFYT1U1TlZuQXdWRlpvYTFVd01WaGxSbVJWWWtkb1VGbFdXa3RrUmxaMFQxWmFhVkpyY0ZsWFZFbzBZekpOZUZkdVVsTmlSMmhZV1d0V2QwNXNXWGxrUms1U1RWZFNlbFl5TlZOV2JVVjVaVVpzV2xaRldreFZNRnBhWlZkV1NGSnJPV2xTYmtJMlZsWmtORll5UmtaTlZtUnFVa1p3V1ZaclZrdGpiRnBZVFZaa1dGSnJOWGxaVldSM1ZURmFSMWR1V2xoV00yaDJWbGR6ZUZJeFpGbGhSbHBvVFRCS2VsWlhNVFJTTURWWFZsaHNhMUo2YkZoV2FrSmhaV3haZVdWR1pGZE5hMVkwV1RCU1QxWXdNVmRqUkU1WFlXdGFhRnBHV2xOamF6VllZa1pPYVdFd2EzbFdha1poVmpGYWNrNVdhRk5pUjFKVlZqQmtVMVZHV25KV2JVWllVbXhhTUZSV1l6VmhSa3AwWlVac1lWWldXak5aYTFwYVpERmtjbU5HYUdoTldFRjZWMVpXVm1WR1NsZFNiR3hvVW0xU1ZGbHJWbmRVVmxwVlUxaG9WMDFyTVRSV1Z6VlhWakpLUjFOdE9XRldNMUpvVmxWYVlXUkhVa2hrUlRsVFRWWndTVll5ZEdGaE1WbDVVMnhzVW1KRlNsZFpWM1JoVkVaWmQxZHVUbXBpUjFJd1ZERmFWMkZXU2xWV2EyeFlWa1ZLY2xscVJtRldNV1J5VjJ4b2FWWXlhRzlXVjNSWFdWZFdjMkV6Ykd4VFIxSlVWRlpWTVUxR2NFWmFTRTVYVFZad1IxWnNhSE5XTWtwSFUydDBZVlpYVWxOYVZWcFhZekZrY2s1V2FGTlhSVXBTVm0weE1GWXlVWGhpUm1ScFUwVndhRlZ1Y0hOV1JsWjBUbFZPVkZac1NsaFdiWEJEWVVVeFZtTkljRnBOUmtwSVZtcEtTMVpXU2xsYVJtUm9UVmhDVFZadGVHRlRNV1JZVTJ0a2FGSnRVbk5aVkVKeVpERmFkRTFZWkZSTlZsWTBWVEZvYzFaWFJYbFZia0pXWWxob2FGa3dXbk5XVmtaMVdrZDRVMkpXU2paV2FrbzBWREpHY2sxWVRsTmhiRXBoV1ZSS2IxWkdXa2hsUjBacVlYcFdXbFZYZUdGaFIwVjRZMGM1VjFZemFHaFdWRXBPWlZaS2NsZHRSbE5OYldoMlYyeGtNRk5yTVZkWFdHeHJVbnBzVTFSV1pGTlRSbFY1VGxWMFZVMVZOVXBWVnpGSFZqSktWVkpzVWxkU1ZuQXpWVzE0YTJOdFVraGtSbVJwVW0wNU0xWnNZM2hPUjBsNFZsaG9XR0V4Y0ZsWlYzTXhWMFpzVlZKcmRGVlNiRXA1Vm14b2IxVXdNWEpPVldSWFRXcEZNRlpVUm1GamJVNUhWMnhvVjJWclZYZFdXSEJIWXpGWmVGcEdiR0ZTYlZKdlZGUkdTMVZHV2tkWGJYUlBVbTFTU0ZkclduTmhiRXBZVlcwNVYyRnJTak5XYWtaVFkyeFdjbHBHWkdobGExcFpWbFJKZUdJeFduSk5XRVpUWVRKU2FGVnJWbUZqYkd0NVpVWk9hazFYVW5wWGEyUnpWVEpLY2xOcmNGZGhhMXAyV2tSR1NtVkdUbGxoUm1ocFlYcFdWbGRYTVRCa01WcFhZa2hLWVZKNmJGaFVWbHBMVm14VmVVMUVWbFpOVlhCNldUQmFiMVl3TVhWaFNFcFhWa1ZHTkZadE1VOVNiSEJIVm1zMVYyRXpRblpXTVZwVFVqRk5lRmR1VWxWaE1sSldXV3RrVTJOR1ZuUk9WVTVwVFZkU1ZsVlhNVWRXYXpGV1kwaHdWMDFxVmxoV2JHUkxVbTFPU1ZGc1dtbFNia0Y2Vm1wQ1lXRXhXWGhXYmtwUVZteGFUMVp0ZUhkT2JGcHhVMnBTV2xadFVrbFZiR2hyVkRGYWRGVnNXbGRoTVZveVdsZDRVMVpzWkhSU2JHaFRUVlp3U0ZZeWRHRmhNa1pYVTJ4c1VtRnNXbGxXYlhoaFZqRndWbGRzV214U2JWSjZWMnRrZDFVeFduSmpSbXhYWWxSRk1GcEVSbHBsUmxaMVUyMUdVMVpHV25wV1Z6RTBaREpXYzFkWWJHeFNWR3h2Vld4U1IxTnNWbGhsUms1WVVqQndTRmt3YUdGWGJVWnlWMnRrWVZaV2NHaFpla1ozVWpGd1NHRkZOV2xTV0VKYVZtMTRhMDVIU1hsVFdHaFVWMGRvV0ZsdGVFdGpiRlp6WVVaT1YwMVhlSGxXTWpWclZqQXhWMU5zYUZwV1YyaHlWbXBLUzFJeVRrbGpSbVJPWW14S01sWnRNVFJYYlZaMFVtdGFhRkpzV25CV2ExWmhWbFphV0UxVVVsVk5hekUwVmtjMVQxbFdTblJWYkdoV1lrWmFlVnBXV21Ga1IxWklVbTFvVG1GNlJYcFdSM2hYWVRGYVdGTnVTazlXYkVwaFdWUkdkMDB4V25KWGJrNVhWbXhLZVZaSGVGZGhWa3B6WTBSYVYySlVRalJWYWtaWFkyc3hWMXBHYUdsU01taFpWa1pqTVdJeVJrZGlSbWhxVFRKb1dWVnFSbUZUUm1SeVYyMUdhRlp0VWtoVk1uTjRWakpLUjFOcmVGZGhhMXB5VmpCYVMyTnNaSE5XYld4VFltdEtXbFl4WkRCWlYxRjRWR3hrV0dKck5WaFphMlJUVlVaV2RHUklUazlTYkZZMVZHeFdNRll4U1hkalJXUmFUVVp3ZGxacVNrdFNNVTV5WVVaV2FWZEhhRzlXYlhCSFlUSk5lR05GWkZWaGVsWllWbTAxUWsxc1duRlRha0phVm14V05WVXlkR3RXUjBwSFkwaEdWbUpZVFhoV01GcHpZMnhrZEZKdGFGTmlSbkEyVm1wS05GUXhWWGxUYTJScVUwZDRXVmxVUm5kVVJteFhWMnQwVjAxck5VaFpWVnByWVVVeFdWRnNWbGhXYkVwSVZtcEdTMk5yTVZkWGJHaHBVakpvZGxaR1ZsTldNV1JIV2tab2ExSXpVbkJVVjNSaFUwWmFkRTVWZEZkTmExcDZWVEo0VTFaV1duTmpSWGhoVm14d1YxcFdaRmRTYlZKSFdrVTFhRTFYZERWV2JHTjRaREZzVjFkWWFGaGlhelZ4VlcweGIxWXhiRmhrUjBaVVVtMTNNbFZ0TVRCaGJGcHpZMFJDWVZaV2NGQlpWbVJHWkRKT1IxWnNaR2xXUlZWM1ZtMXdSMk14V1hoVWJrNWhVbXh3YjFSV2FFTlhWbVJYVld0MFZrMVdWalJaYTJoTFZqSktWbGRzYUZWV2JWRXdWako0Y21ReGNFVlJiV2hUWWtoQ05sZFVRbUZoTVdSeVRWVmtXR0pGU2xoWmJHaHZZVVpXZEdWRmRGaFdia0pJV1RCa05HRkZNVmxSYTNCWFlsUkNORlJyV2s1bFZsSjFWR3hXYVdGNlZsaFhWM2h2WWpGa1YxWnVSbFJpVkd4WFZGWmFkMlZzV1hsTlZXUlhUVVJHVjFsclVsTldhekZ4Vm10NFdtRXhjRXhXYWtwUFVqRldjMk5HWkZOV1Z6azJWbTE0VTFJeFZYaFhiR1JVWW10d2NsVnRjekZXUm14eVZtNUtiRlpzY0ZsVVZXaHZWR3hLYzFkcVFsWk5ibEpvVmpCa1MxTkdWbk5YYkZaWFZqRktNbFpzVm1GWlZtUklWRmh3YUZKck5YQlZha1pMVGxaYWNscEVVbHBXYlZKSVZURm9kMWRyTUhsVmJHaFhZbFJHVTFSVldsZGpWa3AwVW0xd1RsWlVWWGhXVkVsNFRrWlZlRmRyV2xoaVJscFlXV3hvVTFkR1pGZFhhM1JUVFZkU2VsZHJXbTloVmtsNFUyeGtXRll6YUZkYVZWVXhVakZhZFZWdGVGTk5SbkJZVmtaa01GWXdNSGhoTTJSWVlsVmFXRlJXV25kU01WSnpZVWRHVjAxV2NIcFpNRnB2VmpKR2NsZHRhRnBOYm1nelZXcEdVMk14VW5OaFJrNU9ZbGRvUzFadE1UUmhiVlpHVFZWa1ZWZEhhRmhaYlhNeFYxWnNkR1JJWkZoU2JYZ3dWR3hXVDFkR1NuTmpTR3hYWWxoUmQxWnJXa3RqTVdSellrZEdWMVpzY0hsV2ExSkhWMjFXUjFwSVNtRlNiSEJQV1cweGIxUldXblJqUldSYVZteHNOVlpIZEdGaVJrcDBWV3hTVjJKWWFETldNVnBoVWpGYWRGSnNUazVoZWtVd1ZtdGpNVll4V2xoVGJGcFlZWHBzVmxac1drdFhSbHB5VjIxR2ExSXhXa2hYYTFwM1ZqSkZlbEZzYkZoV1JVcG9XV3BLUm1WR1RuTmlSa3BwWVRGd1YxWnRNVFJaVjBaSFYyNUdVMkpIVW5KVmFrWkxVakZ3UmxkdGRGZE5SRVpZV1RCa1IxZEdXbk5YYkdoWFVrVmFhRmw2Um10a1ZsSnpZVWRvYkdKWWFGaFdNVnBUVWpKUmVGUnJaR2hOTWxKb1ZXMHhVMVpHYkhKV1ZFWnNZa1pXTlZwVlpEQldNREZYWTBSR1ZsWXpUalJXYWtwR1pVWmtjMkZHWkdoaE1YQk1WMnhXWVZNeVVsZFZiazVWWWxkNFZGbHRkRXRYUmxwMFkwVk9WMkY2UmxoV2JHaHZWMGRLY2s1V2FGcGlSbHBvVmxSR1UxWXhaSFJTYkdocFVqTm9OVlpzWkRSVU1WcDBVMnhhYWxKWFVsaFVWelZ2WTJ4YWNWSnJkR3RTTUZwS1ZqSjRhMVl5Vm5KWGJHeFhZV3RhY2xWcVJrdGpNVloxVkd4b2FWSXhTbmRXVnpBeFVURk9jMWR1VG1GU1JVcFlWRlZTVjFOR1ZYbE9WVGxYVWpCd2VWa3dXbGRYYlVWNFYycE9WMUpGV2xoYVJtUlBVMVpTY2s5WGJGTmlhMHBhVm0xd1MwNUhSWGhXV0dST1ZteHdXVmx0TlVOV01XeHpZVVZPYUZKdGVGbFVWbHByWVRGS2MxZHVjRlppVkVaSVZtcEtWMk14WkhOV2JHUlhZa1Z3U1ZadGNFZFhiVlpIV2toV1ZXSlZXbFJaV0hCWFYxWmFjVkZ0ZEdsTlZUVllWakkxUzFsV1NrWlRiRlpWVm14d2FGcFhlRnBsVlRWV1pFWldhVkl4U2t0V1ZtUTBZVEZaZVZOc2JHaFNNbWhYVkZWYWQxZEdXWGRhUm1SVVVqRktTRmRyV2s5VWJGcDFVV3QwVjAxV2NGaFhWbHBPWlVaa1dXRkdhR2xTTVVwNFZsZDRZV1F4WkVkV2JrNVlZbFZhV1ZWdGVHRmxSbFowWkVkMGFHRjZSbGRaTUdoM1ZqQXhkVlJZYUZkaE1YQk1WbXhhWVdNeVJrZGFSMnhZVWpKb1dsWnFSbUZaVmtwMFZtdGtXR0pzV2xaWmExcGhZakZzY2xadVpGZFNiVkpaV2tWYWExZHNXbk5pUkZKWFlsUldWRmxVUms5VFJsWnpWMnhrYVZkR1NYcFdiVEUwVmpKU1NGVnJXbEJXYlZKd1ZXMDFRMDVzV25GVGFsSm9UVmRTTUZadE5VdFhSMFY1WVVab1dtSkhhSFpXUlZweVpWZFdSMXBIZEZOTlJGWkpWbXRrTkdFeFdYaFRiR1JvVFRKNFdGbHNhRzloUm1SWFYyeHdiRkpyTlZwWlZWcFBZVmRHTmxac1dsaFdNMUpvVjFaa1QyTXhXblZVYkZwcFVqRktXRlpHV21Ga01sWnpWMjVTVGxaWFVsaFZiRkpIVjBaVmVXUkhkRmROYTNCYVZsYzFTMVl4V2paU2EzaFdZbGhvY2xsNlJuZFNNazVIV2taT1YxSnNjRk5XYlRCNFRrWmFkRlpyWkZSaWF6Vm9WVEJXZDFac2JISlhibVJxVW0xNGVsbFZaSGRoTURGWFkwWm9XR0V4U2xSV1ZFRjRWakpPU1dOR1drNWhiRnBOVm0wd2VGSXdOWE5UYms1V1lrZFNjRll3Wkc1bGJGcFlaRWRHV2xac2JEUlhhMmhQV1ZaS2MxZHVRbGRpUmtwSFZGVmFZVmRGTVZWVmJIQlhZa1paTVZaWGVHOWhNa1p6VTI1T1dHSkhhRmhaVkVaV1pVWndTR1ZIUmxOTlYxSjZWMnRhYTFSc1duVlJhbFpYVFc1U2FGWkVSbFpsUm5CR1lVZG9VMVl5YUZsV2JUVjNVbTFSZUZacVdsTmlSMUp4VkZaa1UyVnNXblJsUlhSb1ZqQndlVlV5ZUhOV01rcFZVbFJDV0Zac2NGQlZha1poWXpKR1NHVkdUbGhTYTNCYVZteGtkMUl4YkZkVFdHaFlZa2RvYzFWc2FGTlhSbEpYVjI1a1dGSnRkRE5XYlRGSFZqQXhWbU5HYUZkTmJtaDJWbTB4UjJOc1pISmhSbkJzWVRGd1RWZFljRWRoTWs1eVRsWmtWbUpGTlZoVmJYaDNWMnhhZEUxSWFFOVNiR3cwV1d0YWExVXhaRWhoUm1oYVlsaE5lRlp0ZUhOWFIxWkdaRVphVGxZemFEVldiVEI0VWpGWmQwMVdaRmhoYTBwb1ZXeGtiMk5zV25OWGJVWnFZbFUxU0ZkcldtdFViVXB6VTJ4R1YySlVSVEJYVm1ST1pVWndTVk5zUWxkaWEwcDZWMVpTUjJReFRsZFhibEpPVmtaS1ZWUlhjekZsYkZwSVRsVTVWMUl3Y0ZwWlZWcHpWbTFHY21OSVdsWmlSbkJvV1hwR2EyUkdTbk5hUlRWWFZqTmpkMVpzVWt0TlJteFlVMnRrVkdKSFVuRlZiWGhMV1ZaYWNsWnJkRTVOVm5CNVZqSXhSMkZ0U2tkalJFSldZbGhvVUZacVNrdFNiR1JWVTJ4b1YxSlZjRlZXVmxKSFdWWmtSMVJ1U2xoaVIyaHdWV3BHUzFkR1pGaGxSemxXVFVSQ05GWXlkR3RYUjBWNlZXeG9XbUV5VWxSYVZscGhVMGRXU0ZKc1pFNWhNMEpKVjFSQ1UxWXhaRWRhUld4U1lUSm9XRlpyVm1GaFJtdzJVbXM1YTFack5YcFdWekZ6VlRGYVIxZHNiRmRoTVhCVVZYcEtTbVZHVG5KYVJtaHBVakZLV2xkWGRHdFZNVnB6Vld4a1dHSkhVazlVVm1oRFZqRmFkRTFWWkZkaGVrWjVWbTF3VDFkck1VZGpSa0pYWVd0d1RGVXdXbGRqVm1SelZteGtVMVp1UW5aV2JURTBXVlpKZVZSdVRtcFNWMUpWV1d4a05GWkdXblJOVkVKUFVteHNOVnBWV210V01ERldUVlJTVjJKVVZsQldNR1JMVWpKT1IySkdjRmhUUlVwSlZtMHhORll5VFhoYVNGWmhVbXh3VkZsclduZFhiR1J6Vm14a2FFMVdiRFZWTW5oaFZqSkdjMk5HYUZaaGF6VjJWa1ZhWVdOV1NuUlNiR1JPWVhwV1NGWnNaRFJoTVZsNVUyeG9hRkpHY0ZoVmFrNVRZVVpXY1ZOck5XeFNhelV4VmtkNGIyRldTbFZXYmxwWFVteHdXRnBFUmxKbFJtUnpZVWQ0VTJKV1NtaFdiVEV3VmpBMVIxZHVVbXhTYlZKWVZXcENkMVpzYkhKWGF6bFhWbXh3V0ZVeU5XRldWMFY0WTBoS1drMXVhR2haTWpGVFVqRmtkR0pHVG1saE1IQlpWbXBHWVZZeVNYbFZXR2hZWW1zMVdWbHRjekZYVm14VlUyMDVWMDFXY0hoV1J6QTFWakZLYzJOSWJGaGhNWEJ5VmxSS1MxSnJOVmxqUmxwT1ltMW9lVlp0Y0VkWlYxSlhVbTVLWVZKdFVtOVVWbHAzVjFaYWRHTkZaRlJpVmxwSVZUSTFWMVpYU2taT1ZteFdZV3MxZGxwWGVHRlhSMVpIVjJzMVYySkZjRFpXYlRBeFZERlplVk5zV2xoaVJUVldWbTE0ZDJGR1dYZFhiVVpyVWxSR1dsZHJaRzloUjFaeVYyeG9WMkZyYnpCWlZFWmhaRVpPYzJKR1dtbFdNbWhaVm0xMFYxbFdVa2RXV0doWVlrVTFXRlp0ZUV0bGJGcDBUVlJTYUZKVVJscFZWM2hMVmpKS1IyTklTbFZoTVhCTFdsVmFhMlJXVG5OUmJHUlhUVEpvV0ZZeFpEQldNbEY0V2tWa1dHSnJOVmxaYlRGVFZrWldkR1ZJWkd4V2JHdzFXVE53VjFaVk1WWmpTSEJYVFc1U2RsWnRNVXRYVjBaSVlVWmtWMUpZUWtoWGJGWmhWREpPY2s1V1pGaGlWM2hVV1d0b1EyUnNXbk5YYkU1VFRWWnNORll4YUc5WFIwcElaVWRvVm1Gck5VUldSRVpoWkVkU1IyTkhlR2xTYmtKYVZrWmFVMUV4V2taTlZtUllZV3RLV0Zsc2FHOWxiR3hXVjJ0MFdGSnNXbnBYYTFwcllWWmtTR0ZIT1ZkV1JVcG9WbXBLVTFOR1ZuSldiRnBwVWxSV2QxWlhlRzlSTURWWFYyeFdWR0ZzU2xWVVZscHpUa1paZUdGSVpGZGlWVnA2V1RCYWIxZHNXa1pYYWs1WFRVWndXRmt4V2t0amJIQklZMFUxVjFaR1dUSldiWGhxWlVVMVIxWllhRmhpUjNoVFdXdGFTMWRHYkhOaFJ6bFlVbTFTV0ZZeWN6RmlSa3B6VjI1c1YwMXVhSEpXTUZwS1pWZEdSMVZzYUZkTk1VcFpWakZhWVZkdFZrZGFTRlpWWWxkb1ZGWnJaRFJYUm1SWVpFZEdhMDFXYkRSV01XaHpZVEZLVldKR2FGcFhTRUpFVkd4YWQxTlhUa1pVYkdST1ZtNUNXVmRVUWxkaU1WbDVVMnhzYUZKWWFHRlVWelZ2WTJ4cmVXTXphRmROVmtwNlYydGFhMkZYUlhkalJXUlhZbFJGTUZkV1duTldNV1JaWVVaYWFXSkZjRmRXYWtKcllqRmFSMkpJU2xoaWJWSllWVzB4TkZac1ZsaE9WM1JYVFZWd2Vsa3dXbUZXTVVvMlVWUkdWMVl6VGpSV2FrWnJZekpHUjFwSGJGaFNhM0ExVm0xNFUxSXhUWGhhUm1oVFlURndhRlZ0ZUhkalJsbDNWMnQwVlZac2NIcFhhMUpUVjJ4YWMyTkliRlZXYkhCNldWZDRTMk15VGtkaFJuQm9UVmhCZWxaVVJtRlpWbVJJVld0b2ExSnJOVTlaV0hCWFRteGFkRTFVVW1wTlZuQlpWVEowWVdGc1NuUmhSbWhhWVRGd00xUlVSbGRqYkdSMFVteGtUbUV4Y0V0V01uUnJUa2RHU0ZadVRsUlhTRUpZVld0V1MyUnNiRlZTYkZwc1ZtdHdXbGRyWkhkVk1rcEdZMFpzV0ZZelVtaGFSRVpQVWpKT1IyRkhlRk5OUm5CWlZtMHhNRmxYVmxkYVNFcFlZVE5TYjFadGRIZGxiR3hWVkcwNVdGSXdjRWhXTW5odlZtMVdjbGRzYUZwbGExcHlXWHBHYTJNeVJraGlSbVJUVFRKb1dWWnRlR3RPUjBWNFZsaG9WMkV5VWxoWmEyUnZZekZXYzFwR1RsaFNiWGg1VmpKME1GZEhTa2RqUld4aFZsWlpkMVpxUVhoV01rNUhZVVp3VGxKc2NGVldiWEJMVW0xV1dGSnJiR3BTYkZwdlZGWm9RMkl4V2xoalJXUlVUV3N4TkZkcmFFOVdWMHBZWVVVNVYwMUdXa3hXVlZwaFl6RndSVlZzWkU1V00yaFpWbGQ0YjJJeFdYbFRhMmhXWWtkb1dGbFVSbmRVUmxwV1YyeE9WMDFYVW5sYVJWcHJWR3hhYzJJelpGaGhNVnBvVmtSS1IxSXhUbGxhUm1Sb1lYcFdWMVp0TUhoaU1EQjRWMjVTYkZJd1duRlVWbVJUWlZac1ZsZHRSbGROUkVJMVdWVmFWMVl4U1hwaFNFcFhZV3RhUzFwVldsTmtWbEp6Vlcxc1UwMVZjRnBXYlRCM1RWWkZlRk5ZYUZoaWEzQllXV3RrVTFkR1VsZFdiazVQVW14YU1GUnNWVFZXYXpGeVkwVm9XazFHVlRGV2JYTjRVakZhV1dGR1pFNVNia0pWVm0weE5GbFhVa2RUYms1VVlYcFdXRmxyV25KbFZsbDRXa1JDVmsxV1ZqUldiVFZUVmtkRmVHTkdiRnBoTWxKVVZtcEdjMk15UmtkVWJHUlRZa2hDV0ZadGVHOWlNV1JIVTFob1dHRXlVbGhWYWs1dllVWmFjVkpyZEZoV2ExcDZWbGQ0YjFkR1RrWlRhMnhYVmpOQ1NGZFdaRTVsUmxKMVZteFNhVkpyY0hkV1Z6RXdaREZrUjFkclpGWmhNMUp3VkZaYVMyVnNXWGxsUjNSWVVqQndTVlpYZUd0V1ZscDBWV3hTWVZac2NETldiWGhoWkVaS2MxZHJOV2hOVm13MlZqRlNRMWxXVVhoWGJHUllZVEZ3Y1ZVd1duZFdNV3hWVW01a1YxSnNXakJhVldSSFlXMUtTVkZyYUZaTmFrWjZWbFJHWVdSV1JuTmlSbVJvVFZWd1JWZFhjRWRWYlZaSFYyNVdWV0pIYUhCVmJUVkRWMnhrVjFWclNrNVdiVkpJVm0wMVUyRnRWbkpUYXpsV1lsaG9hRll4V25kV2JGcDBaRVprVG1FelFraFhWRUp2WkRGYWMxZFljRlZoYkVwWVZtdFdZV0ZHV25GVGF6bFRZa1phZWxkcldtdGhWazVHVTJ4d1YySllVbkZhVlZwVFpFWmFjbHBHVW1saGVsWmFWMWQwVmsxWFNYaFZiRnBvVWxVMVdGVnRNVk5sYkZsNVRVUldhRlpVUmxkV2JYQlRWakpLV1dGSVNsZGhhM0JJVkcweFMxSnJPVmRqUjJoT1ZtNUNkbFl5ZUZkWlYxRjRVMjVPYWxKWGFGRldiWGgzWTBaV2RFNVZUbGhTYkhCNFZUSndVMkZGTVZkalJtaFdUVzVvY2xZd1pFWmxWMFpIV2taa2FHRjZWakpXVkVKaFdWZFNTRlJxV2xkaVJrcFlXV3RXZDA1c1duRlRhbEpvVFZac05GWXlOVmRWYlVWNFYyeG9XbUV4Y0ROYVIzaHpUbXhHVlZKc1RrNVdXRUY0Vm10a05GUXlSbGRUYmxaU1lrWmFXVlp0ZUV0VFJsWTJVbXhPYWsxV2NERldSM2hyWVZaYVYyTkdVbGRTYkhCb1YxWmFhMUl4WkhWVmJYQnNZVEZ3ZGxkV2FIZFNNVmw0WWtoS1ZtRjZiRmhaYkZaM1YyeGFXR1JFVWxkTlZtOHlWVzE0YjFZd01WaFZhMmhXWWxob1ZGbDZSbXRqTVhCSVlrWk9hV0V3Y0V4V2JUQjRUVVpaZUZkWVpFOVdWMUpWVmpCa2IxWldiSFJrU0dSWFZtMTRlVlp0Tld0WFJrcHpZMGhvVmxac1NraFdSRXBMVWpKT1IyRkdaRTVpYldoNVZteFNRbVZHV25OYVNGWnFVbTFTV0ZSVVFrdFhWbVJZWkVkR1ZFMXJOVEJXUjNSclZsZEtTRlZ1UWxaaVdHZ3pXV3BHWVZkSFZraFNiRnBPVmxoQ05sWnFTVEZUTVd4WFUyNUthbE5GU2xkWmExcDNUVEZaZDFkdGRGZFdiRW94VjJ0a2IxUnNXWGhUYWxaWFVteHdXRmRXV210VFJrcFpZVVpvYVZKdVFsaFhWbEpIV1ZaU1IxWnFXbE5pYXpWUVdXdFdkMlZXV1hsTlZFSlZZa1p3V2xWWGNGZFdNa3BWVWxSQ1YyRnJXbGhaTW5ONFUxZEtTR0ZHVGxkaE0wSmFWbTB3ZUU1SFVYaGFSV1JYWW10YVZWbHJaRk5qVmxKWFZtNWtiRkpzY0RCVVZsSlRWbXN4VjJOR2NGWldNMmhVVm1wS1MxZFhSa2RhUjBaWFZteFdORmRZY0VkWlYwMTVVMnRvYVZKck5WUlpWRTVEVmxaWmVGcEVRbGROVjNoWVZqRm9iMVl5U25OVGJrNVdZa1pWZUZadGVHRmtSMUpKV2taa1RsWnRkekZYYTFaV1RsWlplVk5yWkdwVFNFSllWRmR3VjJWc1dYbE5WbVJxWWtkU2VWbFZXbXRoVm1SSVlVVXhXRlpGYnpCV1JFcE9aVVprZFZWdGVGTmlWMmhWVmtaamVHSXhTbk5YYmxKc1VqQmFZVlp0ZUhOT1JsVjRZVWM1VjFJd1ZqUlpNR2hQVm0xS1IyTkVUbGRoTVhCNlZteGFSMlJXY0VkWGF6VlhZbXRKTWxadE1UUmlNa2w1VTJ0b1ZHRXlVbGxaYTJSdlYwWnNjMkZHVG1waVJuQldWVzEwZDJFd01VVldiSEJhWVRGd2FGWkhlR0ZqYlU1SllrWmthR0V5T0hkV01WcGhXVmROZUdORmJGUmlSbHB3VldwR1MyUXhXbGhsUms1V1lsWkdORll5ZUd0WlZrcEhVMnhTVlZac2NETmFWM2hXWlZVMVZrOVdXbWxXVm10NVZsY3hORlV4WkhOWGExcFlZV3MxVjFsVVJuZGhSbHB4VW0xMGFrMVlRa2hXYlRGelZqRmFSbFpZWkZkaVIwNDBWR3RhYzFZeFdsbGlSazVZVWpGS2VGWlhNWHBOVjBaSFYyNVNUbFo2YkhKWmExcGhWbXhXZEdWSGRGZE5SRVpZV1RCb2MxZEhSWGhqUmtKWFZrVmFjbFV3WkVkU2JVWkhXa1UxYVdKRmNGcFdiR2gzVWpGWmVWUllhR0ZUUlRWWldWaHdWMWRXVlhkV2EzUllVbXh3TUZSV1VsTlhiRnB5VGxWb1YySllhSFpaYTFwTFZsZEtSMUZzWkdoaE1YQnZWbFJDWVZkdFZsaFdhMXByVW0xU1QxWnROVU5YVm1SVlVXeGFUbFpzYkRSVk1uaHJWMGRLU0dGR1pGcFdNMUpvVlRCYWMwNXNTbkprUjNCT1ZqRktObFpXWkRSVk1WVjRWMnRrV0dKSGVGaFpiRkpHVFVaYWNWSnVUbGROVlhCYVdWVmFhMkZXU1hwaFNHUlhWak5TYUZWNlJsWmxSMHBKVTJ4a2FWWldjRmxXUmxwaFdWVXhSMk5GV2xaaVJUVllXV3RXZDFac1ZuUmxTRTVhVm14d1dGWXllRU5XTWtwWllVZG9WbUpVUmtkYVZ6RkhVakZrZEdGRk5WZGlXRkY2Vm0xNGFtVkZOVWRVV0d4VlltczFWbGx0Y3pGV1ZteHlXa1pPV0ZKc1NsWlZiWFIzVkcxS1IyTkljRnBXVjJoeVZsZHplRlp0U2tWVmJGcE9ZbTFvZVZadGNFdFNiVlpIVkc1V1ZXSkdjSEJWYlhoMlpXeGFjMVZyWkZwV01ERTBWakkxVDJGc1NYcGhTRUpXWWxob00xZFdXbXRYUjFKSFZHeGFUbFpzYjNkV1ZFb3dXVlprU0ZOcmFGWmlSMmhYV1d4b2IxUkdXbFpYYlVaWVVsUkdXRmRyV205V01ERkhZMFZvVjJFeVVUQlhWbHBhWlZaT2NscEhjRk5XTTJoWlYxZDBZVmxXWkVkVmJrcFlZVE5TY1ZSV1ZURk5WbFY1WlVaT2FGWnJjRnBWVjNoelZqSktXVlZzYUZabGEwVjRXWHBHYTJNeGNFZGhSMnhUVFZWd1ZsWnJXbUZXTVd4WVZtNU9XR0pIYUhGVmJURlRZMFpXZEdSSVpGZE5WM1F6VmpKek5WWXdNWEpqUldoWFRXcEdkbFp0TVV0U01rNUhWV3hhYVZkSGFHOVhWRW8wWkRGSmVGUnVVbWxTYXpWWVdXMTBTMWRzV25STlZFSmFWakJzTkZaV2FHOVdNa3B5VGxac1dtRXhjRE5XTVZwelZsWktkRkpzWkdsU2JrRjNWMnhXYTFJeFdrWk5WbWhyWld0d1YxbHNhRk5qYkZweFUydDBVMkpWTlVwWmExcGhWRzFLZEdGR1JsaFdNMUpvV1ZSR1QxTkdTbkpYYkZwcFVqRktXVmRYZEc5Uk1XUlhWMjVTYWxKWFVsVlVWbHAzWlZaUmVGZHNaRmhTTUhCYVZWYzFUMWR0U2tkalJYaFhUVVp3YUZWcVJtRmpNWEJIWTBaa2FWTkZTVEpXTVZKRFZqSkZlRmRZYkZOaGJIQllXVzEwWVZac1duUmxSMFpvVW14d2VGVnRlR3RoTVVsNFUydG9WMUo2Um5aV1J6RkdaVVprV1dOR1pGTmlTRUl5VjJ0U1IxbFhUWGhhU0ZaVllrZG9iMVJYTVc5WFZscDBZMFU1YVUxV2NFaFdWelZQV1ZaS2RGVnNVbHBoTVZWNFdsZDRWbVZYVmtoa1JtUk9WbTVCZUZaV1pEUlVNVmw1VWxob1dHSkhhRmhaVjNSaFV6RndWbGRyZEd0V2JFcDZWa2N4YzFVeVNuSlRiR2hYWWxoQ1JGWnRjM2hXTVZwWllVWm9hV0Y2VmxsWFYzaFhXVlphUjFkdVVrNVdSa3BaVm0wMVExSXhXblJPVjNSb1VqQlpNbFZ0ZUd0V01ERjFZVWhLVjJKVVJreFdNVnBYWTIxV1IxcEdaR3hoTVhCYVZtMXdSMkV4U1hoVGJrNVdZbXMxV1ZsclpGTmpSbFowVGxWT1dHSkdjSHBYYTFKVFZqQXhSVlpyYUZaTmFsWlFWbXRrUzJOdFRrZFdiSEJvVFZadmVsWnFRbUZXTWs1WFZHNVNVRlpyTlU5V2JUVkRVMFphZEUxVVVtaE5WbFl6VkZaYVlWZEhTblZSYkdSYVlrZG9SRmxWV25OV01XUnlaRVprVGxZeFNqVldSM2hoV1ZkR1YxTnVUbXBTZW14WVZtMTRTMU5HV25GU2JIQnNVbXh3TVZaWGVFOWhWa3BaVVd4Q1YxWkZTbkpaYWtaUFVqRmtjMkZGTlZkU1ZYQldWa1phWVZsVk1VZFhibEpQVm1zMVdGbHNWbGRPUmxWNVpVZEdWMkpWY0VoWk1HUnZWbXN4UjJOR2FGZE5SMUpZVlcxNGQxSXhjRWRhUjJoc1lrWnJlRlp0TVRCaE1sWjBWbXRrVjFkSGFGbFphMlJUWTFaV2MxZHJkRmhTYkhBd1ZGWmpOVlJyTVZkalJWcFdZbGhTYUZsVVFYaGpNV1J5V2taa1RtSnRhRkZYVmxaV1pVWk9WMUp1VGxaaVIxSndWakJhUzJJeFpISlZhMlJVVFZac05GWnROVXRYUjBwSVZXMDVWVll6YUV4V2ExcHJWMGRTUjFwR2FHaGxhMW8yVmpKMGIxTXhXWGxUYTFwUFZteHdXRmxzYUZOTk1WcHhVbXh3YkZZeFNrZFVNVnByWVZaS2RWRnFXbGRXUld3MFdXcEdZV014WkhKWGJGSlhVbFZ3V0ZkWGVHOWlNVkpIWVROc2JGSlViSEZVVmxVeFRVWndWbHBJVGxkTmExWTJWVmQwYTFZeVNsbFZiR2hYWVd0YVlWcFZXazlYVjBaSFZHMXNhR1ZzV2xaV01XUXdZVEZWZUZkclpGaFhSMUpZVm10V1lWWXhVbGRYYm1Sc1lrWndNRlJXVm10V2F6RlhZMGh3V2sxR2NIcFdNakZHWlVaT2MxVnNaRmRsYTFwTlZsY3hOR0V5VFhoalJXUllZbGQ0V0ZWdGVIZFViRnAwWlVkd2JGSnJiRFJYYTFwdlZUSkZlR05HV2xwaE1YQXpWakJhYzJOc1pIVmFSbHBYWWxaS1lWZFVRbGRoTVZWM1RWaEtUMVpYZUZoWmJHaFRZVVphY2xwRmRGTmlWVFZJV1ZWYWEyRldTblZSV0hCWVZteGFhRmRXV2t0ak1XUjFWRzFHVTJGNlZsQldiWGhoWkRBMWMxZHNhR3hTZW14d1ZGZDBZVll4VWxaaFIzUlZUVlp3ZVZSc1dtOVhiVVY0WTBkb1dsWldjRmhXYkZwTFl6RmtkR1ZHVG1sU2JUazBWakZTUTFack5WZFZiazVVWVRKb2NWUlVTalJYVmxweVZsUkdUazFYZUZaVmJYaHJWa1pLYzJORVJsZGlXR2hZVm1wR1MxWldXbk5hUm1SVFlrVndVVlpXVWtKTlYwMTRWbTVXVTJKRmNGaFZiWGgzVlZaa1dHVkhSbFJOVld3MFZteG9jMkpHU2xsVmJHaFZWbXh3TTFwWGVISmtNVnBaWVVaa1RsWllRbGxXYWtsNFlqRlplRk5yV2xoaE1taGhXbGQwWVZSR2JEWlNibVJUVFZad2VsbFZXazlXTVVwelkwWmFWMkpVUWpSVWExcGFaVWRLUjFwR1RsaFNNbWhhVjFjeE5GbFhUa2RXYmtwWVlUTlNXVlp0TVRSbFZscDBUVlZrVjAxRVJsaFdNbkJEV1ZaS1YyTkdRbGRpUm5Cb1dUSXhUMUl4Y0VkYVJUVnBZa1Z3VWxadE1IaE9SbXhZVkZob1lWTkdXbkJWYlhoaFlqRnNWVkp1WkZkV2JIQXdWRlpTVTFaRk1YSk9XSEJYWWxSV1ZGbFdXa3BsVjBaR1QxWmFhR0Y2VmpGV1JtUTBXVmROZUZwSVVsTmlSMUpQVm14a00wMUdXbGhOUkVaVlRWWndNRlV5ZEd0V1IwcHlUbFprV2xZelRYaFZhMXBoVmxaS2RGSnRjRTVXYmtGM1ZsY3hORmxXVW5OWGJrcHFVbGRvV0Zsc1VrWmtNV3hWVW14a2ExSnJOWGxXTW5odllWWkplRk5zWkZkaVdHaHlXV3BHVjFJeFpIVlViR1JZVWpKb1ZWZFhkR3RWTWxaWFYydG9iRkl3V2xsVmJYUnpUbXhrVlZSdGRGZE5WbkF3VmxaU1ExWnRSbkpYYldoYVpXdGFVRnBHV2s5amF6bFhXa1prVTFadVFsZFdiVEI0VFVkRmQwNVZaRlJoTWxKWldXdGtVMWRXYkhKYVJrNVhZa2Q0ZWxac2FHOVVNVXB6VjJwQ1lWWlhVa2hXYlhONFkyeGFjVlJzY0U1U2JrSXlWakZhWVZsWFVraFNhMnhZWWtkb1dGbHJhRU5YVmxwMFkwVmtXbFl3TlhwWk1GWnJWbGRLUms1V2JGWmhhM0IyVlRGYVlXTXhhM3BoUlRWVFlYcEZNRlp0TURGVU1XUklVMnRvYUZORmNGZFVWV1J2VWtaYWNWSnRSbXRTTVZwSlZXMTRVMVV5U2tkalJuQllZa1phV0ZsVVJsSmxSbVJaWVVab2FFMXNTbGhXUm1NeFlqRlNSMWR1UmxOaVZWcFlWRmR6TVZJeFdYbGxSM1JXVFZad2Vsa3dXbTlXTVVsNllVZG9WbUZyY0U5YVZWcFBaRlpTYzJGSGJGTmlTRUpoVm14a05GVXhXWGhYYTJSWVlteEtjMVZ0TVZOWlZscDBaRVprVDFKc2NEQlViRnByWVVaYWNtTkZhRlpOYWtFeFZqSXhSbVZHWkhSaFJtUm9ZVEZ3V1ZkclZtdFdNVTVHVDFaa1YySkhVbTlVVkVKTFYxWmFkR05GZEU1U2JFWTBWakkxVDFkSFNuSk9WbXhhWWxSRk1GWnRlSE5YUjFKSVVteG9VMkpJUVhkWGJGWlhUVWRHZEZOclpGaGliWGhXVm0xNFZtVkdXbFZUYTFwc1VqQnZNbFV5ZUd0aFZrcDFVVzA1VjJKWVFraFZNakZYVWpGT2RWWnNWbWxTYmtKM1ZsY3hNR1F5Vm5OWGJHaE9Wa1pLVlZSV1dsZE9SbGw1VGxVNVYwMXJjRmRXTW5oWFZqSktXV0ZGZUZaaGExcG9Xa1ZrVTFOSFVrZFhiV3hYVjBWS1NWWnRjRXRPUjBWNFdraE9XR0V4Y0ZCV2JYUkxWMFpzVlZKc1pFOVNiRm93V2xWa01HRnRTa2RUYm5CWFRXNW9kbFpVUVhkbFZsSnhWR3hrYVZKdVFubFdSM1JoVTIxV1IxcElWbFZpUmtwd1dWUk9RMVZXV25SbFJrNVRUVlp3U0ZZeU5VOVhSMHAwVld4U1ZtSllhRE5XTUZwYVpWZFdTR1JHWkZkTlNFSllWa1phVTFVeFduUlRiR3hvVWpKb1dGWnJWbmRTTVhCV1YyczVhMVpzU25wWk1GcHJWVEZhV1ZGVVJsZGhNWEJVVldwR2MxZEdVbk5hUms1cFlUTkNiMVpYTVhwTlZsRjRWMjVTVGxKR1NuTlZiVEZUWld4YWRHVkhkRmRTVkVaWVZqSTFkMVl3TVhWaFIyaFhUVWRTUjFwWGVGZGpNV1J6VjIxc1UySnJTblpXYkZKRFdWWlplRnBGYUZkaE1YQm9WVzB4YjFkR2JISldibVJQVm14d2VsZHJhSGRpUmtwelZtcFNWMDF1YUhKWlYzaExWakZPYzJGR1pHbFhSMmQ2VjFSS05HTXhXbGRUYmtwWVlsaFNUMWxyV25kVFJscHhVMnBTVlUxcldrZFVWbFp6VlcxS1IxTnNhRlppV0doTVZXdGFkMUpXU25KalIzaFRZa1p3TlZacVNqUmhNa1pHVFZoT1ZHSkdTbGxXYWs1VFYwWmFjVkZZWkd4U2JGcGFWMnRrYjFVeFdraGxSbWhZVmpOU2FGcEVSbHBsUm1SWllrZDBVMVpIZUZsV1JscFhaREpXVjFWdVNsWmhNRFZZV1d0YWMwNXNiRlpXYlRsWFRXdHdXbGxWVmpSWGF6RjFZVVpvV2sxdVRqUldha1pUWXpGd1IxcEhiR2hOU0VKSVZtMHdlRTVHYkZkV1dHaFZWMGRvYUZVd1drdFdiRmwzV2tjNVYxSnRlSGxXTWpWclZqRktkR1ZHV2xaV2VsWnlWbTF6ZUZkV1JuTmlSbFpwVW01Q1VWWnRlR0ZaVjAxNFdraE9hRkp0VW5CV01GcExaVlphYzFWclpGUk5WMUpaVlcxMFlWbFdTbk5qU0VKWFRVWndURlpHV21Gak1YQkZWV3h3VjJKSVFsbFdWekF4VmpKR2MxTnVWbEppUjJoaFdWUkdkMDB4V2tkWGJVWlhUVmhDUmxaWGVFOVViRnAwWkhwQ1dGWnNTbEJhUkVaaFYwWk9jbGR0Y0ZOaVYyaFpWMWQwWVdRd01IaFdia3BZWWxWYVdGUlhkR0ZUYkZwSVkzcFdWazFyV1RKV2JYUnpWakZhTmxKVVFsaFdiSEJYV2xaYVMxZFhSa2hqUms1WFVteHdXVll4WkRCWlZteFlVbXRrVjJKR1dsUlphMlJUVjBaU1YxZHVaR3hXYkVwNlZteFNWMVpYU2tkalJFSmhVa1UxTTFacVJtRk9iRXBaV2taa1YxSldjRFpXYWtKaFV6Sk5lVk5yYUdoU2F6VllWbXRhWVZkV1duUk5TR2hQVW0xNFdGWkhkR3RXTWtweVkwWm9XbFl6YUV4V2ExcHpZMnhrZFZwSGVGZGlSbGt4VjJ4V1YwMUdXWGROVm1ScVVteHdWMWxzYUVOaFJscHhVbTFHYWsxck5VaFpWVnBoWVVkRmVHTkZiRmhYU0VKSVZtcEtUbVZHV25WVmJYaFRZWHBXZGxaR1ZtOVJNVnBYVjI1U1RsWkdTbUZXYlhONFRrWmFkRTVWT1ZkaVZWWTBXVEJhYjFkc1drWmpSbEpYVmtWYWVsa3llR0ZrUmtwellVWmthVlpyYnpGV2JUQjRaV3MxVjFkc1pGaGlhM0J4VlcweFUxZEdVbGhPVms1V1VteHdNRnBWWkVkVk1rWTJWbXh3VjAxdWFHaFdha1pMVm0xRmVscEdaRmRsYTFWM1ZsaHdTMVF5VFhoVmJsWlZZa1pLY0ZWcVJrdFZSbVJZWkVaa2EwMVZjSHBXTWpWTFZqSktTRlZzYUZWV2JGcDZWR3RhVjJSRk5WWlBWbHBPWVROQ1NWZFVRbUZaVmxsM1RWVmtWMWRIYUZoV2ExWmhZVVpzTmxKdFJtdFNhM0I2VlRKek1WWXlTa2xSYldoWFRWZFJkMVpVUmxabFJscDFWV3hTYUUxWVFscFhWM1JyVlRGWmVHSklUbWhTYXpWWVZXMTRkMU5HV1hsa1JFSlhUV3R3U1ZaWE5YTldNVWw2WVVkb1YyRnJXa3hXYkZwaFpFVTVWMXBHWkdsU1dFSkdWbXRrTUZsV1RYbFVXR2hWWW14YVZWbHJXa3RqUmxaellVVk9XRlpzY0RCWk1GWkxZVEF4YzFkdWNGZE5ibWg2V1ZkNFMxWnJOVmRWYkZaWFlrWndiMWRzWkRSV2JWWllWbXRrVldKWGVGUlpWRTVEVjBaa1ZWRnRSbFZOVm13MVZUSjBhMWRIU2xoaFJtUmFWak5TYUZacldsZGtSMVpJVW0xd2FWTkZTa2xXVkVsNFl6RlZlRmR1VmxKaVIzaFlXV3hvVTJGR2JIRlNiRXBzVW0xU2VWZHJXbTloVmtwMVVXeHdXRlpzU2tOVVZscGFaVVprV1ZwSFJsTlNWRlpRVmxjeE5GbFdaRmRqUmxwWFlsaFNXRlJYZEhkU01XdDNZVWhPVjFZd2NFaFdiWEJUVmpGYVJsZHRhRlpOUjFKWVZXMTRWMk14Y0VkYVIyeFVVbFZ3WVZadE1UQmhiVlpIVlc1U1YyRXlVbFZaYlhNeFYxWnNjbFpVUm1sTlZrcFhXVlZXVDFkSFNrZGpTSEJYVmpOTk1WbFdWWGhqYXpWWFlVWmthVmRIYUhsV2JYQkxVbTFXVjFadVRsWmlTRUpZVld4U1YwMXNXbGhqUldSWFRXeEtTVlpYZEdGaE1VcHpZMGhDVm1KVVZrUldNVnBoWkVVeFJWSnRkRTVXYmtJMlZtcEpNVlF4WkVoU1dHeG9VbTFTV0ZsWGN6RmtiRlYzVjJ4T2FrMVlRa2hYYTFwUFlWWktWVlpxV2xkV1JXOHdXVlJHV21WR1pIVldiRXBvVFd4S1dWZFdVa2RaVm1SSFYyNUdVMkV6UW5OVmJYUjNUVlphU0dWR1RtaFdhMncxV1ZWb2QxWXhXWHBoUjJoV1pXdGFWRmw2Um1Ga1ZsSnpXa2RzVjFadVFsVldhMXBoV1Zac1YxcEZaRmhpYkVwelZXcENZVlpzVWxaVmEyUlRZa2Q0VjFaWGN6VldNVnB6WTBod1YwMXVVVEJXYWtaYVpXMUdTR0ZHWkU1U01VcFZWbFJHYTFReFNYaGFTRTVoVWpKNFZGbHRkRXRUTVZwMFpVZEdhRTFFVmtoV2JHaHJWREZhZEdGR2FGcFdSWEJVVmpGYWMyTnNXblZhUm1oVFlraENObFpxU1RGaE1WcElVMnRrYWxKWFVsaFpiR2h2WTJ4YVZWRllhRmRpUjFJeFdUQmFZV0ZXWkVoaFJ6bFhZVEpSTUZaRVJrdGphelZYV2tab2FWSnNjRmxXYlRFMFpESkplRmRzWkZaaE1sSllWRlprVTFkV1ZYbGtSbVJYWWxWd1Ixa3dhRU5XYlVwSFkwUk9WMDFHY0doV01GVjRWMWRPUms1V1pHbFNXRUphVm14U1MwNUdXWGxTYkdSVVlrWndVRlp0TVZOWFJteHpZVWM1YUZKc2NFWlZiVFZQVkRKS1JtTkliRmhoTVhCeVdWWmFTMWRXUm5GV2JHUlhVbGM0ZDFkclVrZFpWMDV5VFZWc2FWSXlhRlZWTUZaTFYxWmFkRTFVVW10TlYxSklWbTAxUjFVeVJYcFZia1phWWtad2FGVnFSbHBsVjFaR1QxZG9VMVpGV2t0V1ZtUTBWVEZaZVZOc2JHaFNNbWhZV1ZkMGQxZEdiRFpTYlVacVRWaENTRmRyWkc5VWJVcEdZMFpXVjAxWFVYZFdha1pyWTJzeFYxcEhjRk5pU0VKWlYxWlNUMVV4V1hoaVNFcFlZbTFTV0ZSV1duTk9WbkJHVjIxMFYwMVdjSGxaTUZwdlZqQXhkVlZ1V2xkaVdHaGhXbGN4UjFKdFZrZGFSMmhPVm14V05GWnRNSGhPUmxsNVZGaG9VMkpzU25OVmFrbzBZMFpXYzJGRlRsWmlSbkF3V2xWa1IxZHNXbk5pUkZKV1RWZG9kbFpzWkV0amJVNUpWR3hhYVZKdVFYcFdiWFJoWXpGYVYxSnVWbUZTYkhCUFZtMDFRMDVzV25OWk0yUlBWakJ3U1ZVeWRHdGhiRXAwWVVab1dtSkhhRlJaTW5oaFYwVXhWbVJHVG1sU01VcFhWbGN3ZUZJeFdYaFhiazVxVWxSR1dGbHJaRkpOUm1SWFYyMUdhazFZUWtwVk1uaERWakpLUjJOR1ZsZGlWRUY0VlZSS1YxWXhaSE5hUjBaVFVtdHdWVlpHV21Ga01ERkhWMnRrYUZOSFVsaFdha0ozVWpGcmQxZHRPVmROYTNCSVdUQlNUMVp0UlhoalIyaFhZV3R3U0ZVeFdsTmphemxYVkcxb2JHSkdjRXRXYlhocVpVVTFSMkpHWkZkWFIzaFVWakJrYjJOV1ZuTlZiR1JYVFZkNGVWWXlNVWRoUmtwelYyeGFWbUpZYUhKV2FrWmhZekZPY1ZGc1ZrNVdia0pOVm10a05GTXhUa2RqUkZwU1lrZFNUMWx0ZUV0WFZscFpZMFZrVjAxck1UUlhhMmhQVmpKS1dHRkdWbFpOUmxwTVZqQmFZV1JGTVZWVmJIQlhZWHBXU1ZadE1UUmlNa3BIVkd0a2FsTkZjRlpXYlhoV1pVWlplV1ZIUmxSU01WcEhXa1ZhYTFSc1duVlJiR3hZVmtWS1dGWlVSbHBsUm1SMVZXMW9WRk5GU2xkWFZsSkhaREZPUjJKRVdsTmhNMUp4VkZaa1UyVnNXblJsUjNSV1RWWndNVlZYZUZkV01ERlhZMGRvV21GcmNFdGFWVnBMVjFkR1IxcEhiRk5OVlhCYVZqRmFVMU14VlhoWGJHUlhZbXMxYjFWdWNITldSbEpYVjIxR1RsSnVRa2RXYlhCRFZqSkdObEpzYUZwTlJuQjJWbTB4UzFJeFRuTlJiR1JwVW14WmVsZHNaRFJTTVdSWFkwVmtZVkl5YUU5V01GWkxVMnhhZEUxSWFFOVNhekUxVmtab2IxVXlTbkpqUlRsWFlsaE5lRll3V21Ga1JUVldWR3hPVjJKSVFqWldha2w0VWpGWmVWSnFXbGRoTW5oWVZXMHhiMlJzV25GVGEzUlRUV3MxU0ZaWGVIZFdNVXBXWWpOd1YySkdTa2hhUkVaYVpWWktjbUZHUWxkaE0wSlFWbTB4TkdReFpGZFhibEpPVmtWS2IxUldXbmRUUmxWNVpVaE9hRkpyY0ZsYVZWcHZWbTFHY2s1V1VsZFNWbkJvVmpCa1YxTkdTblJrUms1cFVsYzVORll4VWtOWlZteFhWMWhzVkdFeVVuRlZiR1EwVjBaYWRFMVdTazVTYkhCV1ZWWlNSMWRHU25OalNHeFlZVEZ3YUZsV1drdFhWa1p6WWtaa2FWZEhhRzlYYTFKSFZERkplRnBJU2xoaVIxSndWV3BHUzFaV1drZFhiR1JhVmpGYWVsWnROVTloUms1SVZXeGtXbUpHV2xoVWExcFdaVmRXUmxwR1pGZGlTRUYzVm14a05GVXhXbk5YYTFwWVlrZG9XRmxYZEdGaFJscHpWMnhrYTFJd05VZFViRnByVmpKS2NsTnNjRmRpV0doeFdsVlZlRkl4VWxsaFJtaHBVakpvV1ZkWGRHdE9SMGw0Vm01U2FtVnJXbGhVVmxwM1RVWndWbHBGWkZkU2EzQjZWakkxYzFZeVNsbFJiRkpYVmtWd1RGVnRNVTlUVjBwSFYyczFhV0pYYUU1V2JURjNVakZrZEZadVRsZGlhMXBaV1d0a1UySXhVbGRXYm1SVFZteHdXVmt3Vm10Vk1ERnlUVlJTVjFKNlZraFdha3BMVjFkR1IxVnNaR2xTTW1oRlZtMTBZVmxYVWtoV2EyUmhVbTVDV0ZsWWNFWk5SbHB6V2tSQ1dsWnNiRFJXTW5SclYwZEtSazVYUmxwV1JWcG9XVlZhWVdOV1NuUmtSbVJYWWtWd05WWkVSbUZaVjBaWFUyNVdVbUpIYUZoWlYzUjJaREZhUlZKc2NHeFNiRXA1V1ZWa01HSkhSWGRqUm14WFlsaENVRmxxUms5U01XUjFWVzE0VTFkR1NuaFhWM1JoV1ZkV1YxVnNaRmhoZW14WVZGWmFkMDFXVmxoa1JtUlhUV3R3U0Zrd1pHOVdNa1p5WTBab1lWSldjRlJXTVdSSFVqRndTR0pHVG1saE1IQlhWbXBHYTA1R1ZYaFRXR3hWWVRKU2NGVnRlR0ZWTVd4MFkzcEdhazFYZUhsV01qRkhWMFpLYzJORVFtRlNWMUYzVm0xemVGWnRTa1ZWYkdST1lXeGFObFp0TVhwbFJtUklVbXRrVW1KSFVsaFVWRXB2WWpGYWRFMVVVbWhOYkVwSFZERmFhMkZzU1hsbFJsSmFZVEpvUkZaR1dscGxSMFpKV2taT1RsWlhkekJXYWtreFZERmFTRk51U21wU2JWSmhWakJvUTJWc1duSlhiVVpxVFZoQ1JsWlhjelZoVmtwMVVXeHNWMkZyYnpCWlZFWldaREF4VjFkc2FHbGlhMHBaVmxkd1QySXhXa2RpU0VwWVlUTlNXRmxzVlRGVFJscElaVWQwYUZacmNIcFpNR00xVmpGWmVtRkhhRmRXUlZwTVdYcEdhMlJXVG5SU2JFNW9UVEJLTTFac1pEUlpWbVJ5VFZaa1dHRXlhSE5WYlRGVFYwWlNWMWRyZEZoU2JGWTFXbFZrUjFkR1NYZFdhazVWWWtad2NsWnFTa3RYVjBaSVlVWmtVMUpXY0RaV1J6RTBVekpPYzJORlpHRlNNbmhVVmpCV1NrMVdXbk5WYTNSUFVtc3hOVlV5ZEd0WlZrcFlZVWM1Vm1KR2NFeFdNRnBoWkVkV1NWcEdhRk5pU0VKSFZsY3hORlF4V1hsVGJHUllZVEpTV0ZSWE5XOVZSbXhXVmxob1ZGWnJXbnBXVjNocllWWmtTR0ZHYUZoaE1VcERXa1JLVjFJeFduTmlSM0JUVFRCS1ZsWlVRbGRUTVZaWFYydGtXR0pIVW1GV2JYaHpUa1phZEU1V1RtaE5WV3d6VmpKNGExWldXbk5YYkdoVllsaG9lbFp0ZUd0ak1YQkhXa2RzVTJKclNUSldiWEJMVFVkSmVGZFliRk5YUjJoWlZtdFdTMVl4YkhOaFJ6bFZVbTEwTlZwVlZUVmhhekZXVGxod1dHRXhjSEpXVkVGNFpFWnJlbUpHWkdsV1JWVjNWakZhWVZkdFZrZFViR3hvVW1zMWNGbFljRmRXVm1SWFdrUlNXbFl3TVRSV2JUVlBWakpLZEZWc1pGVldiSEF6V2xkNFlXUkZNVlphUm1SWFlraENObFpVU2pCaE1WbDVVMnRrVkdKSGFGaFdibkJIVkVaV2RHVkhkR3BOV0VKSVYydGtjMVV3TVhSaFJrcFhZbGhvY2xSclduTldNV1IxVkcxR1ZGSllRbGxYVjNoWFdWWmtSMWR1VW14VFIxSldWVzB4VTFkc2EzZFdiWFJXVFVSR1dGa3dhSGRXYXpGeFZtdDRWMkV5VWt4VmJYTXhWakpHUjFkck5WTmlhMHBPVm0xNFYxbFdiRmRYV0doaFUwVTFhRlZ0Y3pGVU1WcHpWV3hrVDFadFVucFdiWGhyVjJ4YWMxWnFWbFppUjJoeVdWZDRTMk5yTlZkaFJuQm9UV3hLVkZkclVrZGtNV1JJVm10b1UySkZOVmhaVkVaM1RsWlplV1JIUmxSTmExcFlWVEo0YjFWR1RraGhSbXhhWVRGd2FGWXdXbGRPYkVweldrZHdUbFl4U2paV2FrbzBZakpHU0ZadVNsaGlSMUpZVm1wT2IyRkdXbkZSVkVaVFRWWndlbGxWWkRSVk1WbDRVMnhzV0ZZelVtaFZla1pyWXpGa2NtRkhlRk5YUmtwWlZrWmFZV1F4WkVkaE0yUlhZa1UxV0ZSV1duZFNNVmw1WlVWT1YxWXdWalJaTUZadlYyMVdjbGRyZUZwbGExcHlXWHBHVTJSSFJrWk9WbVJZVWxWd1VsWnRNVFJoTURWSFYxaG9hVkp0VWxSV01HUnZWMFpzZEdONlJtbE5WbG93V1ROd1IxWnJNVmRUYkdSWFZucFdURlpITVV0VFZrWnlXa1prVG1KdGFGRldiVEI0VXpGSmVWUnJaR0ZTYlZKUFdXMHhiMU5XV25SbFIwWlVUVlpzTkZkcmFFdGhSa3B6WTBab1ZWWkZjSFpWTVZwaFpFVXhTV0ZHVm1sV2JIQTJWbXhqTVZReFdYbFRhMmhXWWtkb1dGbHNVbGRTUmxaelYyMUdhazFYVWpCVU1XUjNWR3hLUjFkcmJGZFdla0Y0VmtSR1ZtVldUbkphUjNCVFlrVndhRmRYZEd0Vk1sSnpWMnRvYkZKdFVuRldiWFJoVm14V2RHVkZkRlZpUm5CNldUQmFjMVl5U2xWU2FscFZWbTFTU0ZreWMzaFdNV1J6WVVkc1UwMVZjRmxXTVdRMFlqRlZlRlZyWkZoaWEzQm9WVzB4VTFkV1duRlJiVVpVVW14YU1GcFZaRWRXTURGeVkwVm9XazFHV25wV2FrWmhUbXhLV1ZwR1ZtaE5XRUpOVjFod1IyRXlVbGRVYms1V1lsZDRWRll3Vmt0WGJGcDBUVWhvVDFKdGVGZFViR2hQVjBkS1NGVnNiRnBoTWxKVVZtdGFVMVl4V25SU2JYaHBVbTVCZDFkVVFtRmhNa1pYVTI1S2FsSkZTbUZXYkZwM1ZVWmFjVk5yZEZOTlYxSXdXVlZhWVdGSFJYaGpSbFpYVm5wRk1GZFdaRTlqTWs1R1drWlNhVll6YUZWV2JUQXhVVEZrYzFkdVVtdFNNRnB3VkZaYVIwNUdXblJPVlRsWVVqQndTRmt3V25OWGJGcEdVbGhvVjJGclducFpNbmhoVmxaR2NrNVdUbWxYUjJoWlZtMXdTMDFIUlhoWFdHeFVZVEZ3Y1ZVd1pEUlhSbEpZVGxVNVQxSnNjRlpWYlRGSFZqQXhjazVWWkZkV00yaHlWbXBLUzFOV1JuUlBWbWhYWWxVME1GWnJZM2hXTVU1SFZHNUtZVkp0YUhCVmJGSlhaR3hhUjFadE9WSk5WbkJZVmpJMVQxWnRSalppU0VKVlZteGFXRlJyV21Ga1IxWklaRVprVG1FeFdURldiR1EwWXpGYWRGTnJhR2hUUm5CWFZGVmFkMlZzYTNsbFIwWnFZbFpLU0ZZeU1YTlZNa3B5VTJ4c1YyRXhjR2haYWtwU1pVWmtkVlJzYUdsaGVsWmFWMVpTUzJJeFdYaFhia1pWWWxSc1YxVnRlSGRsVm1SeVYyMTBWazFyY0VkVWJHaDNWbXN4ZFdGSVNsZGhhMXBvV2taYVIyTnNjRWRhUjJoT1ZtNUNXbFp0TVhkU01VNTBWbXRrVkdKc1dsWlphMVV4WTBaV2RFNVZUbGROVm5CNFZWZDRZVlJzV25OV2FsSlhUV3BXVUZacVNrdFdiR1J6Vkd4V1YySklRbTlXYWtvMFl6Sk9jMVp1VGxWaVJuQndWbXhvUTFOR1duRlRhbEpvVFZac05GVXlOVTlXUjBwSVlVWm9WMkV4V2pOVk1GcGFaVVp3UmxwR1RtbFNhM0EyVm1wS05HRXlSbGRUYmxaU1lUTkNXRmxyWkZKa01WcDBZM3BHVjJGNlZscFdWM2hYWVVkS1NWRnRPVmRXZWtWM1drUkdhMUl4WkhWVWJHaHBZbFpLVmxaWE1UUmtNV1JYWTBWYVYxWkdXbFpVVmxaM1pWWlplVTVZWkZkaVZYQmFXVlZrYjFZeFdrWmpSV2hWWWxob2FGa3ljekZXTVdSMFlrWk9hRTB3UlhsV2JYaGhWVEZKZUZkWWFGaFhSMmhaV1cxMGQxVkdXbkZVYTA1VlRWWndlbFl5Tld0WFJrcHpZMFpzVlZac1NrUldhMVY0VmpKT1IySkdaR2xYUjJnMlYxWldZVk15VWtkV2JrNWhVbTFTY0ZZd1pHOWlNVnBWVVcxR1YySldSalJXTWpWSFZtMUtSazVZUWxaaVIyaEVWR3hhWVZaV1RuRlZiRkpPVm0xM01GWnFTakJpTWtaSFUydGthbEp0YUZoWmJHaHZUVEZaZDFkc1pHcFdhM0I1VjJ0a2QxUnNXbGxSYWxKWFlsUkNORlJyV2xabFJtUnpZa1pLYVZKcmNGbFhWM2h2WWpGWmVGVnNXbGRYUjJoeFZGWmFkMlZzYkZaYVNFNVdUVmRTUjFVeU5XOVdNVXB6VjI1S1ZXRXhWalJXYWtaclkyMUdSazlXWkU1U2JrSXlWbXRhWVdFeFZYaFRXR2hvVFRKU2IxVnNaRk5YVmxaeFVXNWtWRlp0ZUZkV01uUlBWakpLVmxacVZsZFdNMUYzVjFaYVlXTXhXbGxoUm1ScFVtNUNTVmRyVm1GVE1rMTRZMFZvYkZJeWVGUlphMlF6VFd4YWRHVkdUbE5OYTFZMVZsWm9jMVpzWkVoaFNFSldUVVphTTFrd1dsWmtNVnBWVW0xd2FWSnJjRnBXUmxwVFZUSkdkRk5yWkdsU1JUVllXV3RhUzFOR2JGaGpNMmhYWVhwV1dGZHJXbmRXTVZwelZsaG9WMkV5VVRCVk1qRlNaREExVjFac1NtbFRSVXAyVmtaa05GTnRWbk5hUm1SV1lUSlNWVlJYZUV0WFJtdDNWbTVPVm1KVmNFaFdNalZQVjJ4YVJsZHViR0ZTUlZweVdUSjRhMlJHU25SaVJUVlhWa1phU1ZaclpEUlpWbGw0VjJ0b1ZHRXllRk5aYTJRMFZqRnNjbHBHU2s1U2JrSklWakl4UjJGck1WaGtSRnBhVmxad2NsWkhNVVpsUjA1R1lrWm9WMkpGY0ZGWGExSkhXVmROZUZwR2JHbFNiSEJ3Vld4b1ExZFdXblJrUm1SVVRWWktTRlpYTlU5WFIwcFpWVzVHVlZZelVtaFZha1pyWTJ4YVZWSnNaRTVTUlZwSlYxUkNhMUl4V1hoWGExcHBVa1pLVmxsVVJuZFdSbFp4VW10MFdGWXdjRWhXTWpGdllWWktkVkZ0UmxkTlYxRjNXVlJHVm1WR1VuSmFSMnhUWWxkb1VGWnRNWHBOVmxwSFZtNVNUbFpGU2xCWmExcGhWMVp3Vmxack9WZFdNSEJKVmxkMGMxZEhSbkpPV0ZwWFRVZFNSMXBXV2xOalZsWnpWMjFvYUUwd1NscFdiVEIzWlVaTmVGTnVVbE5oTWxKWVdXeGtOR0l4Y0ZobFIwWnBUVlp3TUZrd1ZrOVdNa1kyVW14a1ZXSkhhRkJXTUdSR1pWZEdSazlXWkdsU01VcFZWMVJLTkZZeVVrWk9WbHBWWWtkb2NGVnROVU5UVmxsNVpFZDBUbEpzY0hwV01qVlBWakpHY2s1V1pGVldlbFpFVmpCYVdtUXhjRVprUmxKVFRVWndTRmRXVm1GV01WbDVVMnhrVkdFeWVGaFpWM1JoWVVaYVJWTnNUbFJTYkhCNVZqSXhORlV5UlhwUmJFSllWak5TV0ZwRVFURlNNV1JaWVVkR1UxSlZjSFpXUmxwWFl6QTFWMWR1VWs5V2F6VllWbTB4VTFOV2NGWlhhMDVYVFd0YWVWa3dhR0ZYYXpGSFkwZG9XazFXY0V4YVJWcExZMnM1V0dKR1RsZFNiRmt3Vm1wR2EwMUhTWGhVV0doV1YwZFNUMVp0TVc5aU1WWnpXa1JTVjJKSGVIbFhhMXBQVm14S2RHVkdhRmhoTVZsM1ZtcEJlR050U2tWWGJIQlhWbTVCZWxkV1dtRlpWa3B6V2toT1UySkhVbFJaYTFwM1pWWmFXR05GWkdoTlZYQjVWREZhYTJGV1NuUlZiVGxWVmtWS1RGWnNXbUZTTVd3MlVtMXNhR1ZyV2paV2Fra3hVekZrY2sxSWJGWmlSVXBZV1d0YVMxTkdWWGRYYkhCc1VqQmFTbFpITVc5V01rWTJWbXRzVjJGcmEzaFZWRVpyWkVaT2NscEhjRk5OYldoWFYxZDBZV1F4VVhoalJWWlVZVEpTVkZSV2FFTlRWbkJXV2toT1YxSnJjRmRaTUdSdlZqSktSMU5yYUZwaGExcEhXbFZhVTJSV1VuTldiV2hPWW0xb1dWWXhaRFJpTVVWNFlrWmthVk5GTldoVmExcExWVEZTVjFwR1RteFNiRlkxV1ROd1YyRkZNVlpqU0hCYVRVZG9kbFp0ZUdGT2JFcFpXa1prVGxKdVFrMVdha1poVWpGa1dGSnJaRmhoZWxaWVdXdG9RMDVXV25GU2JVWlhZbFphU0ZkclZtdFdWMHB6VjJ4a1dtRXhjR2haYWtaelZsWkdkVnBIZEdsU2JrRjNWa2Q0YjJFeVJuSk5WVlpUWWtkb1dGVnFUbTloUmxweldrVjBWMVl3Y0VwVlYzaGhZVWRGZUdORk1WZFNiRnBvVjFaa1UxSnJOVmRhUjBaVFRXMW9VRlp0ZUdGWGF6RlhXa2hLVjJKWVFrOVdiVEUwVjBaWmVXUkhSbGhTYkhCSFZUSXhiMVp0U2xsaFIyaGhWak5vV0ZreWVHdGpiSEJIWVVaT2FXRXdjRWxXTVZKRFdWWlZlRlpZYUdGU1ZuQlZXVmQ0ZDFkR1VsaE9WazVZVW0xNGVGVnRlSGRpUmxwelkwaHdXbFpXY0ZSWlZtUkdaREpPUjFWc1pHbFhSVXBOVjFkd1MxSXhTWGhhUm14aFVtMW9jRmxzV2t0bFJscEhWMjEwVDFKVVJraFdWelZQVjBkRmVsVnRPVlZXYkhCNlZHdGFWMlJIVGtkYVJtaHBWbFpaTVZkV1ZtRmlNV1J6VjI1U1ZtRXphRmhaVjNSaFkyeHJlRmR0Um1wTlZuQjZWa2N4TkdGRk1WaFBTR3hYWVd0dmQxZFdXbk5YUmxKMVZXeGthVkl5YUZsWFZsSkhXVlphUjJKSVRsZGlWVnBZVlcxNFMxZEdXWGxPVjBaVllsVndTRll4VWt0V2JGbzJVVlJHVjJGclJqUlpla1pyWkZkT1IyTkZOVk5pYTBreVZtMHhNRmxYUlhoVFdHaGhVMFphVTFscmFFTmpSbFowWlVoa2FVMVdjRWhXYlRGSFlVVXhjazFVVWxkV2VsWllWbXRrUjA1dFNrWlBWbVJvWVROQ01sWlVTalJaVms1SVZXdG9hMUl5YUU5V2JGSlhUbXhhY2xwRVFsZE5WbHA2VmpKMFlWUXhXblJsUm1SYVlUSlNWRlpFUm5kV2JHUnpVMjE0VTJKV1NYZFdSRVpoVlRGVmVGZHJaRmhpU0VKWVdWUktUMDVHYkRaVGEyUlhUVmRTTVZaWGVFTldNVXB5WTBad1YySlVWak5WVkVFeFVqRmtjbFpzU2xoU01taFdWbGN4TUdReVZuTmlSbHBZWVRBMVdWVnRkSGRsYkd0M1ZtcFNWMDFXYnpKV2JYQlBWakpHY21ORk9XRldWMUpNVlRGYVUyUkdTbk5VYld4WFlUTkJNbFpxUm10T1JsbDRZa1prWVZORk5WbFpWRXB2WTJ4V2RHTjZSbWxOVm5CNlZsZDBUMVF4U25OaVJGWmFUVVphY2xZeWVHRmpiVTVIV2taV2FWSXlhRzlXYWtvMFdWVTFjMU51U210U01GcFlWRlJLYjJJeFpISlhiVVphVmpGS1NWWlhkR3RXYlVwR1RsWm9WbUpHY0hsYVZscGhZekZXY2xwR1pFNWhNbmN3Vm1wR2IyTXhXWGxUYmtwUFYwVmFWMWxzVWtaTlJscHpWMnh3YTAxV2NIbGFSVnBUVkd4YWMxZFljRmhXYkZwb1ZrUktSMU5HVG5KaFIzaFRVbFZ3YUZkV1VrZFpWbEpIV2taa1YxZEhhSEZVVmxVeFpVWldXR1ZIUm1oV2JIQklWakp3WVZZeFdrWmlla0pXVFdwR1dGVXdXbE5qYlVwSVVteE9hV0V3Y0ROV2JURXdWakZzVjFkclpGaFhSM2h4Vld4a1UxVXhVbGRYYm1SVVVteGFNRlJzV2s5WFJrbDNWMVJLVm1KVVZrUldha3BMVmxaYWNsVnNWbGRTVm5CNVZtcENWbVZHVGxoU2EyUllZbGQ0V0ZacVRtcGtNVmw0VjJ4T1ZVMXJNVFJXYlhSclYwZEZlR05HYkZwaVdGSk1WMVphYzJNeVJraFBWbFpUWWtWdmQxZHNWbUZVTVZWNVUydGtWR0p0ZUZoVmFrNXZUVEZzVmxaWWFHcFdNRmt5VlcxNGExVXdNSGxoU0d4WVZqTkNURlZxUmxwbFJuQkhZa2RvVTJKV1NuZFhWM1JoWkRGWmVGZHNhR3hTYkhCUFZtMTBkMU5HV2xobFIzUmFWbXR3VmxadE5VOVdNa3BaWVVST1ZWWnNjSHBaTW5oclpGWlNjMXBIYUd4aE1XdzBWbTEwWVdJeVVYaFhXR1JPVmxkU1dWbHRkR0ZXYkZwMFpVaGtiRlp1UWxoV01uTTFZVEZhY2xkdWNGWk5ibWh5VmtjeFMxSnRUa1ZUYkdScFZrVlplbFpYY0V0VWJWWlhWRzVXVldKR1dsbFZha1pMWWpGYVdHTkZUbHBXTURWWVZtMDFSMVZ0U25SVmF6bFdZbGhvTTFZd1duTldiRnB5VDFaa1UwMUlRa2hXUjNoWFpERlplRmRxV2xOaGF6VllWRmR3UjFSR1dYZGFSbVJUWWtaS2VsbFZaRzloUlRGSlVWUktWMkpIVVhkWFZscEtaVlpXY2xkck5WZGlWMmgyVmxjd2VGVXlUWGhpU0VwWVltMVNVRlp0ZUhkbFZscDBUVmhrYVZKcmNIcFZiWEJYVmpGYU5sWnNVbGRpVkVaTVZUQmtSMUl4Um5OYVIyaE9WbTVDVGxac2FIZFNNVmw0VjJ4a1ZtSnJjRkJXYkZKelYwWnNXV05HWkZoU2JIQjZWMnRTUTFkc1duTlNhazVWVm14d2RsbFZXa3RYUjFaSFYyeHdWMUpZUWxWWFZFbzBWbTFXV0ZacldsaGlXRkpQVm14b1FtUXhXa2hsUjBaclRWWktNRlZ0TlV0WFIwcElaVVpvVm1KWWFHaFpNbmhoVmxaS2RHUkdaRTVXYTI5NFZtMHhOR0V5UmtaTlNHUlVZa1phV0ZWdGVHRldSbHAwVFZaa1YwMVlRa3BWTW5odllWWmtSbE5zUWxkaVdHaFVWV3BHVDFZeFpISmhSM0JUVFVad2RsWkdXbGRqTURCNFZXNU9hRkpWTlZsWmExcDNaV3haZVdSSE9WaGlWWEJhV1ZWU1QxZHRWbkpYYmtwYVRWWndXRnBGWkZOU01YQklZa1prVG1KWGFFMVdiVEV3WVRBeFNGSlliRk5YUjJoV1dXMXpNVlpzYkZWU2JtUnFWbXhXTTFac1VrZGhSa3B6VjI1d1dHRXlUVEZXTUZwTFpGWkdjMkZHYUdoTlZtd3pWMVprTkZNeVRuTmFTRVpTWWtoQ1QxVnFSa3RPYkZweVdraHdiRkpzYkRWVk1XaDNZVVpLZEdGSE9WVldiSEF6VkZkNFlXTnNhM3BoUmxwT1ZtMTNNVlpYZUc5a01rWlhVMjVLVkdKSGVGZFpiR2h2VFRGc1ZsZHRSbE5OV0VKR1ZWZDRiMkZXV25KWFZFSlhZVEZ3ZGxsVVNrZFNNVkp5WWtaS2FWWXlhRmRXYlhCUFZUQXdlRlZzV2xoaVIxSnlWV3hTVjFkR1draGxTR1JYVFd0d1NsVlhkSGRXTVVwR1YyNUdWVlpzY0hwV2FrWlBaRlpXZEdGR1RtaE5TRUp2VmpGYVUxTXhWWGhXYTJSb1RUSlNhRlZ0ZEhkak1WcDBUbFZPVkZKdGRETldiRkpIWVVaSmQyTkdjRmRXYkVwRVZtcEJlRmRHVW5GVWJGWlhZa2hDV1ZkVVNucE5WbVJYVkc1U2FWSnJOVmhaYTJoRFZteGFkRTFZWkZSTlZsWTFWbGQwYTFkSFNrZFhiRlphWWxSV1JGWkVSbE5XTVhCSFZHeE9UbFl4U21GWFZFSlhZVEZhYzFOdVRtcFNSVXBoVm14YVlXVnNXbk5hUlhSVVVteGFlbFZYZUhkV01rcFhVMnN4VjJKWVFreFZNakZYWkVaS2NscEhjRk5OYm1oWlZsZDRZV1F4Vm5OWGJrcFlZa2RTYjFSV1ZuTk9SbVJ5Vm0xR1ZsSnNjREJhVlZwdlYyeGFSazVWVWxkaE1YQXpWakJrVjFOR1NuUmxSMnhUVFZWd1lWWXllRmRoTURGSFYxaGtUbGRGTlZsWlYzUkxWakZzYzJGSE9XeGlSbkI2VjJ0V01GVXlTa2hWYWtKVlRWWndjbGxWWkVaa01WcHhWV3hvYVZKdVFtOVhWbEpMVkcxV1YxTnVTbGhpV0VKVVZGYzFiMVZHWkZkVmF6bFNZbFpHTkZZeU5WTlViRXBHVjJ4a1ZWWnRVVEJXTUZwclkyeGFkRkpzVms1V01VcEtWbXhqZUZJeFdYbFRiR3hWVjBkU2FGWnFUbTlqYkd0NFYyczVhbUpXU2tsYVJWcFBZVlpPUmxKcVVsZGlXR2h4V2xWYVNtVkdjRVphUmxKcFVteHdXVmRXWkhwTlZtUlhWMjVLVjFaRlduTlphMlF3VGxad1ZtRkhSbWxTYkhCNldUQmFkMWRzV2xoVlZFSlhZVEZ3VEZsNlNrOVNiVlpIV2taa2FWSllRa1pXYkdoM1V6RldkRlpyWkdwU1YzaFhXV3hrTkZaR1duTmhSVTVyVFZad1NGZHJVa05oTURGRlVtdG9WMDFxVmxSV1JFWmhZMnMxV0ZKc1pHbFdSVnBWVmxkd1IxVXlUWGxTYTJoclVtMW9jRlZ0TlVOT1ZscEhWbTA1YVUxWFVqQldiVFZMVjBkR2NrNVdhRlZXVm5CWFdsVmFXbVF4V2xWU2JHaFRUVlZ3U1ZaclpIcE5WMFpYVjI1S2FVMHlhRmhaYkdodlYwWmtWMWRzWkd0U2JGcGFWMnRhUTFZeVNrbFJibVJYVmpOb2FGZFdXbFpsUm1SWldrWmthRTB4U2xaV1JscGhWakF3ZUdKR1dsaGhlbXh2VldwQ2QxTldjRlpWYTA1WVlsVldORll5ZERSWFJscHpWbXBTVmsxSFVsaFZiWGhoWXpGa2MxcEhlR2xTYmtKaFZtMXdSMWxXYkZkaVJscFBWMFUxVlZsdGVHRldiR3h5WVVWT2FrMVhlRlpXUjNSUFZESktTRlZzV2xaV00yaHlWa1JHU21WR1RuTmhSbHBwVmtaYVNWWnNVa3RUTVdSWFVtNUtVRlp1UW5CVmFrWkxWbFphUjFwRVVtaE5WMUpIVkZaV2MyRkdTblJWYXpsYVlURmFNMVV4V210V1ZrWjBVbTF3VGxadVFscFdWRWt4VXpGYVNGTnVTbGhpVjJoWVdXeFNSMVpHVW5SbFJrNVhWbXR3TUZwRldrOWhWa2w2V1ROc1YxWnRUalJWYWtaVFl6Rk9XV05IYUZOWFJrcFpWbGN4TkZsWFRuTmlSbFpUWW1zMVdGUldaRk5YYkd0M1drYzVWazFWY0RGVlYzaDNWMFpaZWxWc1pGVldiSEJNVldwS1JtVnNjRWRoUjJ4cFZtdHdORlpzWTNoTlJteFhXa1prVmxkSGFHaFZNRlV4WWpGYWRHVklaR3hpUjNoNFZrY3hNRll3TVVWU2FrWmFWbGRvYUZacVJrdFNiVTVIVVd4YVRsSnVRazFYV0hCSFpERk9TRlJyV2s5V1ZGWndWV3hvUTJJeFduUk5WRkpwVFd4R05GWXhhSE5XVjBwSVZXNUNWazFHV21oV2JYaHpZMnh3UjFSdGNHbFNia0kwVmxjeE1FMUdWWGhYYms1WVlrZG9XRlp1Y0VKTlZscHlXa1YwVTJKVmJ6SlZNbmhyWVZaYVIxZHNSbGRoYTJ3MFZYcEdUMUl4V25WVWJXaFRUVVp3V1Zkc1pEQlpWazVYVjI1R1UySlZXbGRVVm1SVFYwWlplVTVWT1doaVJYQldWbTB3TlZkdFNraGhSazVWVmxad1lWcFZXbkpsYkhCR1RsWmthVkp0T1ROV2JYUnJUVVpzV0ZKc1pGUmlSMmh6VlRCV2QxWXhiRmhrUlZwc1VtMTBNMVl5TlU5V01ERlhZMGhzV0dFeVVucFpWbHBMVmxaYWMyRkdaR2hOYkVZelZtdFNTMUp0VmtkYVNGWlhZa1Z3Y0ZWcVRtOVdNVnAwVFVob1ZtRjZSa2haYTFwdllXc3dlV0ZJU2xaaGExcG9WVEo0YTJOc1pITlViR1JPVm01Q05WWnFSbTlrTVZsM1RWaFdVbUV5YUdGV2JuQkhWMFphZEdONlJsZE5hMXBKV2xWYVQxUnRTblJoUm5CWFlURndhRmRXWkZOamF6RlpWRzFHVTJKV1NscFhWM2hUWXpGYWMxVnNaR2hTVlRWVVZGWmFSMDB4YkZaWmVsWm9WbXR3ZVZSc1ZtOVdNREYxVlZoa1YySllhR2hWYlhoUFkyMVNSMVp0YkZOaWEwcFNWbTB3ZUU1SFVYaFRXR2hxVWxkb2NWVnNVbGRpTVhCWVpFWmFiRkpzY0RCVVZsSlRZVVV4Y2xacVZsWmlXRkp5VmpCYWExTkhSa2xSYkZwcFltdEtXVlp0ZUdGVk1WcHpZMFZhVDFZemFGUlpiR2h2VGxaWmVXUkdaRTVTYlZKSVZUSTFUMkZzU2taWGJVWlZWbGRTVkZwSGVHRmpWa1paWVVkMFYwMUdjRXRXVm1RMFlURlZlVk5yWkdwU01taFpXVlJHUzFSR1dsVlNiSEJzVm10d1dsa3daSE5WTWtWM1kwWnNWMVl6YUdoYVJFcFNaVVp3UjJGRk5WZFNhM0JWVmtaa01HUXlWbk5YYmxKclVqTlNXRmxyWkZOVFZscFlaVVZrVjAxcmNFbFdWbEpEVm1zeFYyTkdVbHBsYTFvelZXeGFWMlJIUmtkYVIyeFRUVEpPTTFadE1YZFRNbEY0WWtaa1lWTkZOVmxaYlhoTFlqRldjMVZ1VG1oU2JGb3dXbFZvYTJKR1duVlJiR2hYWWtaS1dGWnFSbUZqYlU1RlVXeHdhRTFzU2paWFZscGhVekZaZVZOWWNHcFNiVkpZVld4YWQxZFdaRmhqUlVwc1VtdHNOVlZzYUhkaFZrcHpVMjVDV2xaRlNqTldhMXBoWkVkT1JtUkdXazVXVkVVd1ZtMHhORll4Vm5SU1dIQldZWHBzV0Zsc1VrZFdSbkJZWlVkMFYxWnNTakJVTVdSdlZqSkZlV1F6Y0ZkU2JIQlVWbXBHYTJSR1NsbGlSMmhUVm10d1dWWlhNSGhWTVZKSFlUTnNiRkpVYkZsV2FrSmhVMFpyZDFwRVVtaFNWRUl6VlRGb2IxWXdNVmhWYWs1V1pXdGFUMXBXV2xkamJIQkhZVWRzYVZKdVFsbFdNV1EwVmpGc1YxcEdaRmRpYXpWWFdXdGtVMVF4VWxkYVJrNVhZa1p3U1ZSc1ZUVmhSMHBXVjFSS1YxWXpRbFJXTW5oaFZqRmtkVmRzWkZOU1ZuQk1WMnhhWVZZeVRuUlZhMlJZWVhwV1ZGbFVUa05UYkZsNFYyMTBUMUl3TVRWV1YzUnZWakpGZUZkc1pGcGlSMmhVVmpCYVlXTldVblJQVms1cFVtNUNXVll4YUhkU01rWnlUVlpvYkZKdGFGbFpWRVpoWTJ4YWNsZHRkRlJTTUZwSlZXMTRWMVl3TUhkVGExSllZVEZLU0ZsVVNrOVdNVkoxVTIxMFUwMHhTbFZYVjNSdlVXMVdSMWR1VGxwTk1taFVWRlprVTFOR1ZYbGxSbVJYVFd0YWVWUnNXbk5XTWtwWllVUk9WMkV4Y0ZSV2JYaHJaRlpPZEdWR1pHaGxiRlkwVm0wd2VHVnJNVmRYV0dST1ZsWmFXRmx0TVZOWFZscHhWR3hPYTJKSGVIaFZWbWh2VmpBeFYxZHViRnBoTWxKMldXdGtTMUp0VGtoUFZtUlRZa2hDV1ZkclVrZGhNazE1VTJ0a1dHSlhhRlJVVkVaTFlVWmFkRTFJYUZaTlZXdzBXVlJPYTJGR1NYcFZiR3hhWWtaYU0xVXhXbUZYUjFaSVQxWndWMkV6UVhkV2JHUTBWVEZhZEZKWWFHcFNWMmhoVkZaYWQxTkdjRVphUlhSVVVqRmFTRmRyV210V01sWjBaRVJhVjJKVVJqTlZla0V4VTBaT1dXRkdWbGhTTTJoV1YxY3hlazFYVGxkV2JsSnNVbGhTVjFSV1pEUlhWbkJHVm1wQ2FGWlVSbGhXTWpWdlZtMUtXV0ZJU2xwV2JWSk1WVEJhVjJOV1JuTldiR1JwVmpKb1VsWXhaREJaVm1SMFZWaGtUbFpzV2xsWmEyUlRWMFpzYzFkcmRHeFdiR3cwVmpJeE1GWkZNVmhWYTJ4WFlsaFNlbGxYZUVwa01XUnpWV3hrYUdFeGNFMVdha1poWVRKTmVGcElUbUZTTTBKUFZteFNWMU5XV2xWVFZFWlhUVlpzTlZVeWVHRlhSMHBHVGxaYVYySkdjR2hVVjNoM1VsWktjMk5IZUZOaVZrbDNWa1JHWVZNeVJsZFRhbHBvWld0YVdGWnJWbUZrYkd3MlVtMTBVMDFYVWxwWmExcGhZVlpaZVdGSGFGaFdNMUp5VmxkemVGSXhWbk5hUm1ocFYwWktlRmRYZEdGa01WcHpWbTVTVGxkRk5WZFVWVkpIVTJ4V1dHVklaRmROYTNCV1ZWWm9iMWxXU2taalJXaFdZV3RhTTFWdGVHdGphemxYV2tVMVRsSllRblpXYWtaclRrZEZlVlp1U2s1V1YxSnhWV3hrYjJOc1ZYZFdWRVpYVm14YU1GUldXazlpUmtwelYycENWVlp0YUZCWlZWcGhZekpPUjFkc1pGZE5NRXBSVm1wQ1lWbFhUWGxVYTJ4VFlrWmFjRlZxUmt0V1ZscDBUVWhvVkUxVmNEQlZiWFJyWVVaSmVXVkhPVlZXVjJoRVZGUkdZV014Vm5KVWJIQlhZWHBGTVZacldtOWlNa1pHVFVoc2JGTkZXbFpXYTFaM1pHeHNjVkpzWkdwV2ExcFdWVzE0VDFZeVNsbGhSbWhYWWtkUmQxbFVTa2RUUmtweFYyeE9hV0pyU2xsV1JtTXhVVEZrUjFkdVNsZFhSMmhZV1Zod1YxWXhXbGhsUm1Sb1VqQldORmt3VWt0V01WcEdVMnhrVlZac2NGQldha1ozVTFaT2NrNVdaRTVOYldoYVZtMHhORmxYVVhkTlZtUllZa1phVkZsclpGTmpSbEpYVmxob1QxWnNWalZhUldNMVZqSktWbFpxVm1GV1ZuQjJWakl4UzFaV1NsVlJiSEJPVW01Q05sWnRjRWRaVjA1elkwVm9hMUl5ZUZSVVZsWjNWMnhhY1ZOcVFsZGhlbFpaVlcxMGIxVXhaRWxSYlRsV1lrWndhRlpxUm1Ga1YwNUdXa1UxVGxZemFGZFdWekI0VFVaVmVWTnNXbXBTV0VKWldWUkdkMVpHV25GU2JVWnFZa2RTV2xrd1dtRlVhekIzVTJ0V1dGZElRa2hXUkVaclVqRmFkVk50YUZOaVJuQjNWbTF3VDJJeVVuTlhibEpyVWpOU2NGbHNXbUZYUmxwellVYzVWMDFyV1RKWmExcFBWMjFGZVZSVVJsVldSVnA2V1RKNFlXTXhVbk5YYld4WFYwVkpNVlpzVWtwbFIwbDRXa2hPV0dKck5WbFpWRXB2WVVaV2NWUnRPVlpTYkhCNFZXMDFhMVV5UmpaaVJtUlZZa1p3Y2xaSGVFdFNNV1JaWTBaa2FFMXNSWGRXYkZKSFZXMVdWMU51U21GU2JXaHZXV3RvUTFkV1pGZGFSRUphVm0xU1dGbHJhRXRaVmtvMllrWldWVlp0YUVSVk1GcHJZMnhhZEdSR2FGTmhNMEpYVm0weE5HTXhaSEpOVldoV1ltNUNXRmxVUm5kVVJtdzJVMnM1VkZZd2NFaFhhMVV4WVZkS1dGb3piRmRpV0ZKeFdsVmFUMlJHV25OYVJtUnBZWHBXZDFaWE1UUlpWMDVIVjFoa1lWSjZiSE5WYlRGVFYwWlplV1ZGT1ZkTlJFWkdWVzE0YjFkSFJYaGpTRXBYVFc1T00xcFdaRWRUVmtaelYyMXNVMDF0YUZaV2JURTBXVmROZUZkc1pGVmliRXB5VldwS05GWkdXbkpXYlVaYVZtMVNXRlp0ZUU5Vk1ERlhZMFpvVjFJelVuWlpWekZYWTJ4T2MySkdjRmROTVVwTlYyeGtORll5VG5OYVNFcGhVbTFvVkZsdGRFdFRSbVJWVVcxR1ZFMVdTbnBWTW5ocllXeEtSbGRzYUZwV00xSm9XVlZhYzFaV1NuTlRiWGhYWVROQmVGWlVTWGhPUmxwSFUyNU9hbEpzU2xsV2JURlNaREZrVjFwRk9WZE5WbHA2V1ZWVk1WWXdNSGhUYm14WVZqTlNjbFpVUm1Gak1XUnlZVWQ0VTAweFNuZFdWekUwWkRGa2MySkdXbFpoTWxKWlZXcENWMDVXYkZaV2JFNVlZa1p3TUZaWGREUldNa3BIWTBkb1lWSnNjRlJaZWtwUFVtczFXR0pHYUZOTmJVNDFWbTB4ZDFJeFZYaFVXR2hWVjBkNFZsbFVSbmRWVmxweldrUlNXRlp0ZUZaV1IzUlBWbXN4VjFOc1pGZGlWRVpJV1ZSR1lXTXhXbkZWYkdScFYwVXdlRlpzWkhwbFJrcFlVMnRrYUZKdVFsaFdiWGgzVFd4YWNsVnJaRlZOVld3MVZrZDBZVlF4V1hkWGJHaGFZVEZ3TTFVeFdtdFhSVEZWVld4V1RsWnVRalpXYkdNeFV6RmFTRk5zV2xoaGVteGhWakJvUTFZeGNFVlNiVVpyVWxSR1dsZHJXa3RVYlVWNFYxUkNWMDF1VWxoWFZtUkhZekZPY2xkc2FHbFNiSEJaVjFkMGExVXhXa2RXV0dSWVltczFXVlZxUm1GVGJGcElZM3BXYUZac2NIbFpNRlozVmpKRmVWUnFVbHBsYTNCSVZXcEdhMk50UmtoU2F6Vk9ZbTFvV1ZacldtRlpWbXhYVm10a1YySkhhSE5WTUZwM1l6RmFkRTFXVG14aVJuQlpWRlpTUTFaWFNsWmpSbWhXVFc1b00xWnFSa3RqTWs1SFZXeGFWMUpZUWxSWGJGWmhWakpPVjFwSVRsVmlWMmh3Vld4b1EwNVdXblJOVkZKcFRXdHdlVlJXV210V2JHUklWVzFvVm1Gck5WUlpNRnBoWkVkV1NWcEZOVmRpV0doWVZteGtNR0V4WkVkVGJrcHFVbTE0V0ZWdE1XOWtiRmw1VFZWMFZGSnNXbnBXVjNoclZHeEtjMVpxVWxkaGEwcHlWa1JHVDFOR1ZuSmFSbFpvWld4YWQxZFhlR3RWYXpGWFYyNUdVMkpZUW5OVmFrRjRUa1pXYzJGSVRsZFNNSEJKV1ZWYVUxZHRSWGxWYmxwWFZsWndhRmt4V2xOak1WSnpXa2RzVTAweVp6SldiWEJLWlVaSmVGVnVUbFJpYkVwWFdXMDFRMWxXV25OWGJGcE9WbTE0V1ZwVlZuZGhNREZGVm10YVZtSllhRE5XYWtaaFkyMU9SbUpHYUZkaVZra3lWMnhXYTFSdFZrZGpSV3hUWWtkU2NGVnRkSGRWUmxwMFpVWk9WMDFWY0ZoV01uUnZZV3hLV0ZWdVFsVldiRlY0VldwR1UyTXhXblJQVm5CWFlUTkNZVlpXWkRSV01WcDBVMnhXVjJFeFNtaFZhazV2WTJ4YWMxZHJPV3RXYkVwNlZUSnpNV0ZGTVZoUFZFNVhZa1pLU0ZscVNsSmxSbVJaWWtaU2FXRjZWbHBYVnpFd1pERlplRlZzV2xoaVIxSlFWVzB4TkUxR2NGWlhiWFJXVFVSR1dGVXlOWE5XTVVsNlZGaG9WMkZyUmpSVmJGcExWbFpLYzFwSGJGZFNWVmt3VmpGb2QxSXhWWGhhUldSVlltczFhRlZ0TVc5WFZsWnhWRzA1V0dKSFVsbGFSV1F3VmxkS1YxZHJhRmRXTTJob1YxWmFTMVpYU2tkUmJHUnBVbXR3V1ZacVJtRlZNVmw0WTBWb1VGWnRVazlWYTFaS1RWWlplV1JHVGxWTlZtd3pWRlpvVjJGR1RrZGpSbVJWVmpOQ1NGVjZSbmRXTVdSeVpFZHdUbUV6UWtsV2JUQjRZakpLU0ZOc2JHaFNSVFZZV1ZSR2QxWkdWbkZTYXpWc1VtNUNTRmRyWkhOVk1rcFhVMjFvV0dKSFVYZFhWbVJQWXpGa2RWVnJPVmRXVkZaYVYxZDBZVll3TlVkYVJteHFVbTFTYjFWc1VrZFhWbHBZWkVkMFYxWXdjRWxaVlZwRFZqQXhkVlJxVW1GU1YxSllWVEZrUzFJeVRrWk9WazVwVWpOUmVsWnFTakJXTVZwMFZtdGtZVkpYYUZSWlZFcHZZMVpXZEdSSVpGVk5WM2g2VjJ0ak1XRXdNVmRpUkZaaFVsZFNTRmxWWkVkT2JFcHpZa1phYVZaR1dsVldiVEI0VW0xV1dGSnJiRkppUm5CUFZXMDFRbVZzWkZWUmJVWnFUVlpzTkZZeU5VdFpWa2w2Vlc1Q1ZtRnJXa3hWYWtaaFkyeHdSVkZyTlZOTlJuQlpWbFJKTVZZeFZuUlRibEpXWWxWYVdGbFVSbUZOTVd0NVpVaE9hbUpHY0ZwWlZWcHZWakF4UjJORlpGZFdla1V3VmxSR1dtVkdaSE5XYkdSb1RWVndXVlpHWXpGUk1VcEhZa1JhVTJGNmJGaFVWbWhEVTJ4YVdFMVhPVlpOUkVJelZUSTFZVll5U2xsaFJtaGFaV3RGZUZsNlJuZFNNWEJIWVVkc1dGSlZjRkZXYlRGM1VqRk5lRnBGWkdoTk1sSlpXVzF6TVZkR1ZuUmxTRTVQVm14d1dWcFZWakJXTURGWFkwVmtWazF1VVRCV01qRkxVakpPU1dKSFJsZGlSbGt3Vm0xd1IyUXhUa2hUYTJSaFVtMW9WRlJYTVZKTlJscDBZMFYwVGxJd2JEUlZiR2h6VlRKS1NHRkdWbHBoTVhCb1ZqQmFjMlJIVGpaU2JIQlhZa1Z3V2xaSGVGZFRNa1YzVFZab1ZtSkdjRmRVVnpWU1pERnNXR1ZGZEdwaVIxSjZXV3RhYjJGRk1WZGlNM0JYWWtkU05scFZXa3RrUms1eFYyeE9hVkl4U2xCWFZ6QjRZakF4YzFkdVRsWmhNSEJ6VlcweFUxTkdXbGhPVm1SWFlsVlpNbGxyV2xOV1ZsbDZZVVY0WVZac2NHaFZha1p5WlcxR1JrOVdUbGRTVm5CYVZqRmtNR0l4VlhoVmJrNVlZbXhLVjFsdGN6RlhSbXh5VjJ0MGEySkdTbmxXTWpWclZqSktWbGRyYUZoaE1YQlVXVlphUzFZeFpGbGpSbVJYVWxad1ZWWnRjRWRaVmtweVRWWmtXR0Y2VmxWVmFrcHZZakZhZEUxVVVtdE5SRUkwVmpGb2ExZEhTa2hWYmtaWFlsaFNNMXBYZUhKa01WcFZVbTFvVjJFelFqWlhWM0JQWXpGWmVWSnVTbWxTUlRWV1ZtMTRkMWxXY0ZkWGJHUnFUVmhDU1ZsVlZURlVhekZHWTBac1YwMVhUalJVVlZwT1pWWlNjbHBHV21sU01taDRWbGN4ZWsxWFRrZGlTRXBYVjBkb1QxUldaRk5sVmxwMFRWVmthRkl3V1RKVmJYUnpXVlphVjFkdWNGZGlXRTQwVmpCa1IxSnNWbk5YYXpWcFlsZG9VbFpzVWtkWlZsbDVWV3RvVldFeVVuRlZha28wVjBaU1ZWTnRPVk5XYkhCNFZUSTFhMVZyTVhKTlZGSldUVzVTY2xaVVNrdGpNV1IxVVd4YWFHRXdjRzlXYWtaaFZqSlNTRlZyYkZWaGVteFVXV3hhUzFZeFdsVlNiVGxvVFZaS2VsVXlOVk5WUmxwSFUyMUdXbFpGV2pOV2ExcGhVbFpLYzJOSGVHbFNWbTk0Vmxaa05GWXhXWGROU0dSVVlrZDRXVlpyVm1GaFJteFZVbXh3YkZacmNIbFhhMXBUWVZaWmVtRkdRbGRpV0VKUVdXcEJkMlZHY0VkYVIyaFVVakZLZGxaR1dtdFZNV1JIVmxoc2FsSXdXbGhaYkZaM1ZteGFkR1ZHWkZkTmEzQkpWbGMxUzFaV1drWlhibkJWWWxob1NGcEdXbE5qTVZKeVRsZHNVMWRGU2t4V2JURTBZVEF4Ums1VlpGaGliRXBZV1cxek1WZFdXbkpXYlVaWVVteEtXVlJzWXpWaGJVcEhZMFphVmxadGFIWldha0Y0WTJ4YWNWZHNjR2hOV0VKNVZtMXdTMVl5VWtoV2EyeGhVbTFvV0ZSVVNtOWlNVmw0VjJ4YWJGSnJiRFJaTUZaelZsZEtXR0ZHVWxkaE1sRXdXbFZhWVZkSFRrWlRiWGhUVmtWSk1GWnFTakJpTVZGNFYxaGtXR0pVYkZaV2JYaDNUV3hTV0dWSFJtcE5hMXBKV2tWYWExWXlSWHBSYkdoWFVqTm9XRlpVUm10U01XUlpZMGRvVkZKdVFsbFhWbEpMVlRGT1IxVnVVbXhUUjFKVVZGZDBkMU5HV2toTlZGSm9WbXR3TVZWWGNGTldNa1p5VjI1R1lWWlhVazlhVlZwTFpGWlNkR0pGTlU1aWJXaFpWakZqZUU1R1RYaFhhMlJwVTBaS1QxWnJXa3RXVmxKWFYyMUdUbFp0ZEROV01qRXdZVWRHTmxKc2JHRldWMmd6VmpCa1JtVkhUa2xUYkhCb1RXeEtUVlp0TVRSaE1rMTVVMnRrYWxKdFVsUldNRlpMVGxaYWRHVkhSbHBXYkhBd1ZsWm9iMVpYU25OWGJGSmFZVEpvUkZscVJuTlhWMDVIV2tab1YySldTalZXYWtsNFRVWmFjazFXV2s5V2JXaFlWbXBPYjJWc1duRlRhM1JZVm10YU1WVlhlR3RoVm1SSVdqTndXR0pHY0doWlZFcFBZekZ3U1ZWdGRGTmlSbkJRVjFaU1QxRXhUa2RhU0VwWFlrZFNjRlJXV2tkT1JsbDRZVWhrYUZKck5VZFZNbmh2VjJ4WmVsVnRhRnBXVm5CVVdrVmtWMU5XVW5OYVJUVm9UVmhDU1ZaclVrZFpWbXhYVjFoa1RsWlhVbkZWYlRWRFYwWnNWVk5yTld4U2JGa3lWVzAxVDFZd01WbFJhMlJYVFdwR2VsWnJXazlTYkU1elYyeGthVmRIYUc5WGEyTjRWVzFXUjJORmJGUmlSMUp2V1ZSQ2QxZFdXblJqUldSVVRWVTFXRll5ZEc5VWJHUkdUbGM1VjJKWVRYaFZNVnByWTFaU2RFOVdaR2hsYTFwWlZtcEtORkV4V25OWGExcHFVbXRLVjFsWGRIZFZSbFY0VjJ0a2FrMVZOWHBYYTJRMFlWWmtTRm96Y0ZkaGExcHlWR3RhYzFZeVNrZFhhelZYVmpGS2IxWlVRbFpOVjBsNFZtNU9WbUpyTlhGV2JYaGhaVVpXV0UxVlpGZE5WbkI2VlRJMWQxZHNXbGRXVkVaWFRXNW9hRmw2U2t0T2JFNXpXa2RzVjFKc2NGcFdha1poV1ZaTmVGcEZaRmRpYkZwWVdXdGtiMkl4YkZWU2JtUlRWbXh3TUZwVldtRmlSa3B5WTBac1ZrMXVVbWhaVjNoTFkyczFWMVZzWkdsU2JrRjVWMnhrTkZsV1dsZFRiazVoVWpKNFQxVnJWbUZUVm1SWFZXczVhazFXY0VsVk1qVkxWa2RLUms1V2FGcFdNMUl6Vm10YVYwNXNTbk5hUm1SWFlURndOVmRyVmxaT1ZsbDVVMnhrVkdGc2NGbFdiWGhoWVVaYVJWSnNUbXBOVjFKYVYydFZOVll4U2xaalJtUllWbXhLVEZaVVNrOWpNV1JaWVVab2FFMVlRbmxXUm1SNlRWWk9SMkpJU2xoaWJWSnZWV3BDVjA1V2NFWlZhemxYVFVSR01WVlhkRzlaVmtwR1YyNUtWMkZyV2pOVk1WcFhaRWRXUjFSck5VNVNXRUY2Vm1wR2EwNUhTWGxTV0dST1UwZG9hRlZ0TVZOWFJteHpZVVpPYWxac1NsbGFWVll3VjBaS2RHVklhRmRTZWtFeFdWVlZlRkpXU25GUmJVWlhWbTVDU1ZadGVHRlpWMUpJVW10c1dHSkdXbGhaYTJoRFZWWmFkRTFVVWxaTmF6VjZWbGMxVDFWdFNraFZia0pYWVd0d2RsVjZSbUZqYkhCRlZXMW9UbFpyV1RGV1Z6RTBZakZWZVZOclpHcFNiRXBoV1d0YVMxZEdaRmRYYkU1WVVqQTFSMWRyV205Vk1rcEdZMFpvVjAxdVVtaFdSRVpyVWpGa2RWTnJPVmRTVm5CWlYxZDRiMVV3TUhoWGJGWlVZa2RTY1ZSV1pGTk5WbXQzVjIwNVYwMUVRalZaVldoelZqSktXVkZyZUZkaGEzQlVWV3BHVDJSV1VuUmhSazVPWWxkb1VWWnJXbUZaVjFGNVZWaG9XR0pzU25GVmJGVXhXVlphYzFWclRrOVNiSEJJV1ZWa01GZHNXbkppUkU1WFRXNU5NVlpxU2tkamJFNXhWR3hXVjFadVFtOVdWRUpyVkRGS2MxVnVVbWhTYXpWd1ZXNXdiMDVXV1hoYVJFSldUVlZzTkZZeWRHdFhSMHBIWTBaQ1YwMUdjRE5aVlZwWFpFZFdTVnBGTlU1V2JYZDZWbTE0YjJJeFpFZFRXR2hZWVRKNFlWUlZXbFpsUm14WFYyMTBWRkp0ZERaWmExcHJWMFpPUmxOcmJGZGhNVXBJVlcweFVtUXdOVlppUjJoVFRXMW9WVlp0Y0V0aU1WWlhWMnhvYWxKWVVsZFVWbFY0VGtaYWRHVkdaRlppVlZZMVZsYzFRMWR0UlhsVldHUlZZa1p3VkZacVJtdGtSMUpIVm0xc1UxWXpZM2RXYkZKTFRrZFJlRmR1U2s1WFJWcFlXV3RrYjFZeFVsaE9WemxWVW14S01GcFZaRWRoTVZwelUyNXdXazFIVW5wV1ZFRjRWbTFPUjJOR1pFNWliV2g0VjJ4V1lWTnRWa2RqUldSaFVteHdjRlZxVG05WFZtUllaVWQwVDFJd05VaFdNalZQVjBkS2MyTklTbFZXYkhCNlZHeGFkMVpzV2xWV2JGcHBWbGhDV0ZaSGVHOWpNV1IwVWxob1dHSkdTbGhVVnpWUFRrWndSbGRzWkdwaGVrWllWako0YTFVeFpFWlRiRXBYVFZkT05GUnJXbE5rUmxwMVZXeFNhRTFZUWxkWFYzaHZWVEZrUjJKSVVtdFNXRkpaV1d0YWQxTkdXWGxOVkVKVlRWVnNNMVl5TlhOV1ZscDBZVVpTV21FeGNFeFZha3BQVWpGa2MxZHRiR2xoTUhCS1ZtMTRWMWxYVVhoVWExcE9WbTFTVmxsclpHOVdSbHB5VjIxR1YwMVdjRmhYYTFKRFlUQXhWMWR1YkZWV1YyaHlWa1JHYTFJeFpITmFSbFpYVFRCS1dWZHNaRFJqYlZaWVZtdHNXR0pZVWs5WldIQlhVakZhY1ZOWWFFNVNiRll6VkZaV1YxWXlTblJWYkd4WFlsaG9NMVl3V2xkalZrNXlaRWR3VG1GNlZrdFdhMlEwVmpKR1dGSlljRkppUlZwWVZXMTRkMk5zYkhGU2F6bFhUVlphTVZaSGVHRmhWMFkyVm14d1YySlVSWGRhUjNONFl6RmtkVlZyTlZoU01VcGFWMWQ0VjJReFduTldibEpPVm5wc1dGWnRlSGROUmxwWVpFUlNXbFpyY0ZoWk1GcFRWMnN4VjJORmFHRlNWMUpJVldwR2QxTkhWa2hpUm1oVFRWVldNMVp0TVRSVk1VbDRWMWhvV0dKcmNFOVdiVEZ2Vmxac1ZWTnRPVmRXYlhoNVYydGpOVmRHU25SbFJFSlZZa1phVUZsV1ZYaFdNa3BGVkd4a2FWSXlhREpYVmxKTFV6Rk9SMVp1U2xoaVIxSlVWRlJHUjAweFpGZFhiVVpVVFd4S1dGVnROVmRoUmtwelkwVTVWMkZyY0haVmJGcGhWbFpPY1ZWc1ZrNVdWRlpaVm0wd01WVXlSbk5UYmxaU1ltdEtXRmxYY3pGa2JGWnlWMnh3YkZZd05VZGFSVnBoVkcxS1JtTkZiRmRXUld0NFZtcEtSMVl4VG5OaVJrcHBVbXh3V0ZkWGVHOWlNREZ6Vld4b2JGSnVRbk5XYWtaaFUxWlJlRmRzVG1oV2EyOHlXVmh3UTFZeFduUlZWRUpYVmtWYVdGcEZXazlqTVhCSVkwWlNVMVp1UW05V01XUXdXVmRSZVZKclpHcFNWbkJaV1d0Vk1WZFdWbkZSYkhCT1lrWmFNRmt6Y0VkV01ERkZVbXRhVm1KR1NraFdha3BMVmxaR1dXRkdjR3hoTVhCWlZsY3hlbVZHV1hsVGEyaG9VbXMxVkZadE5VTlpWbHB6V2tSU2FFMVdTakJXVm1odldWWk9SbGRzVGxwaVdFMTRWbXhhWVdSSFRqWlNhelZUWW10S1dGWXlkRk5STVZsNFUyNUthbE5JUW1GWmJUVkRVMFpaZDFkdFJrOWlSWEF4V1RCYVlWWXhTbGRqUm1oWVlrWmFjbFpFUmtwbFZrcHlXa1pXYVZZemFGcFdWM2hYWkRBMVYxZHVUbGhpVkd4eVZGWmFjMDVXV2tobFIzUm9VbFJDTlZwVlZUVldNa3BWVW14U1dtRnJXbGhaTVZwTFkyMVNSMVZzWkdsVFJVWXpWakowVjJFeFNYbFNhMlJZWW10d2NGVnJXa3RYUmxKWVRsVk9VMUpzYkROWGExWXdWa1pLYzFOc2NGcFdWbkJZVm1wR1lXTXlTa1ZVYkdSWFRUQktUVlpzWTNoV01XUkhWRzVLYUZKck5YQlZiRkpYVlVaa1dFMUlhRlpoZWtaWVZqSTFSMVZ0U2toVmJGcFZWbXhWZUZSVldtRlNNa1pJWkVkb1YyRXpRbHBYYkZadlVqRmFWMWRxV2xOaVJrcFpWbTE0ZDFaR1dYZFdWRVpZVWxSc1dWbHJWVEZXTURCNVZHcFdWMkpZVW5KYVYzTXhWakZrYzFkck5WZGlWMmg2Vmxjd2VFNUdXbk5YYmxKT1ZtdHdUMVZ0ZUhkV01XUnlWbTEwVjAxcmNFZFViRkpEVjJzeFIyTkdVbGRoYTNCWVdUSjRTMk5XVm5OaFJtUk9UVlZ3TlZac2FIZFNNa1Y0VTFob1lWTkdXbGhaYkdoRFZrWlNXRTFYT1ZoaVJuQlpXbFZhVDFZd01YSk9WbWhYWWtkb2RsZFdXazlTYXpWWFZHeFdWMVpyY0RaV2JYQkhaREZhYzFkdVRsVmlSbkJ3Vm14b1ExZEdXa2hsUm1ST1VtMVNlbGRyVm5OVmJVcElZVWRHWVZZelVtaGFWM2h6VG14S2RWcEdUazVYUlVwS1YyeFdhMk14V1hoWGJsWlNZbGRvV0Zsc2FGTmhSbHBWVW01T1YwMVdTakZXUjNoVFlWZEtSMk5IT1ZkV1JVcFlWWHBHWVdNeFduVlViR1JYVWxad1ZWWlhNSGhPUjFaeldraEtWMkpZVWxsVmJYUjNWbXhhZEdWSVRscFdhM0JZV1RCYWIxZHNXbk5qUjJoYVpXdHdTMXBYZUhkU01YQkdUbGRzYVZZeVpEVldiVEV3VlRGTmVGVllhRlZoTWxKWFdXMTBZVmRHYkhOYVJ6bFhVbXhhZWxZeU5XdGlSa3B6WTBWb1dHRXhTbFJXTW5oaFZsWmFjMkZHWkZOaVYyZ3lWbTE0YTFNeVRuUlVhMlJTWWtaYVdGbHNXa3ROYkZwVlVtMUdWazFyTVRSV2JUVlhWbGRLU0dGR2FGcFdSV3N3V2xaYVlXUkZNVWxoUjNST1ZqRkpkMVpVU2pSV01WWjBVbTVPVkdKWGFGZFpWM014Wkd4U1ZWSnNXbXhTYlZJd1ZXMHhNRll5U2taaU0yUlhWbnBGTUZkV1pFdFRSazV5V2tkd1UxSnVRbGxXUm1NeFlqRmtSMkpJUmxOaE1YQnpWbTE0WVUxV1dsaGxSbVJvVmpCd1NGa3dXbTlYUmxvMlVWaG9WbFpGV2s5YVZWcGhaRlpPYzFkdGFFNVNSbG96VmpGa01GbFhVWGhVYkdSV1lrZFNXVmxzYUZOaU1WSlhWbTVrVGxac1dsbGFWV2hyVmpBeFZtSjZTbGRpV0ZKVVZqSjRZVTVzU25OaFIwWlRZa2hDV1ZkclZtdFVNVWw1Vkd0b2FWSnRVazlVVlZKR1pXeGFjVk5xUW1oTlJFWkpWa1pvYTFReFduUlZiRkphWWxob2FGa3hXbGRqVms1eFZXeFdUbFpyY0ZsV2Fra3hXVlpTYzFkdVRtbFNSa3BZVm1wT1VtUXhXbkZSV0doWFRWVTFNVmt3V25kaFJURlpVV3BhVjJKSFRqUlZla3BUVWpGYWRWVnNRbGRpVmtwM1YxY3hNRk14WkZkYVNFcFlZbFZhWVZacVFYaE9SbVJ5WVVWMGFFMVZjSHBXTW5odlYyeGFSbE5xVGxkTmJtaG9XWHBHY21WdFJraGlSVFZvVFZacmQxWnNVa2RpTWtWNFYxaG9XR0V4Y0hGVmJURTBWMFpzYzFWclpHdGlSbHA1VmpJMWExVXhXbkpPV0d4aFVsWndWRlpVUVhoVFZrWnlZMFpvVjFKVmNHOVhhMUpIWVRGSmVGUnVWbFJpV0VKVVZXeFNWMWRzV25SalJUbFNUVlV4TkZaWGVHRlpWa3B5VGxoS1ZtSllVak5VVmxwaFpFZFdSMXBIYUZkTlNFSkxWbFpqTVdFeFpFZFhibEpWVjBkb1dGWnJWbmRWUmxaeFVtNWtVMDFZUWtsWlZWcFBWakZKZW1GRVRsZGlSMUV3VmxSR1dtVldXbkphUm1ocFVqRktkbFpYZUZOak1XeFhWMjVTVGxack5WVldiVFZEVmpGYWRHTkdUbGROVm5CNldXdFNZVmRzV2xkVGJFSlhZV3RHTkZacVNrOVNNVVowVW14T2FWWnJjRkpXYkZKRFlURkplRk5ZYUdwU1YyaHpWV3BLTkZkV1ZuRlNhMXByVFZad01GcFZXazlWTURGeVZtcFdWMVp0YUhwV2JURkxZekZPYzJGR2NHbFhSa2w2VjFod1IxWXlUWGhhU0VwclVtMVNXRmxzYUc5T2JGcHpXa1JDYUUxcldsZFVWbHByWVd4T1NHRkdhRlppYmtKRFZGWmFjMWRIVFhwaFJtUm9aV3hhV1ZkWGRHRmtNVkp6VTFoc2FGSjZiRmxXYlhoaFlVWmtWMWR0ZEZkTmF6VkhWbTE0WVdGV1NYaFRibVJYWWxoU2FGWXlNVmRqTVdSWllVWm9hVlpXY0haV1JscFhaREF4UjFkcmFHdFNiVkpaVldwQ2QxTkdXWGxsUms1WFlsVndTRlV5ZUc5V2JVcEhZMGhLVjAxSFVsQlZiVEZUVWpGU2NrNVdaRTVXV0VKTVZtMHhORmxYU1hsVldHaGhVbGRvVlZsclpEUldNV3haWTBoT1dsWnNjREZaTUZaaFlrZEtSMU5zYUZkTmFrVjNWbXBCZUdOc1pISmpSbHBPWW1zd2VGWnRjRXRUTWs1elZHNUdXR0pIYUZoWmExWjNWVlprV1dORmRGTk5WV3cwVmxjMVMxbFdTWHBSYkZKWFlURndhRmxWV210WFIxSklVbXh3VjAxR2NFbFdiR1EwV1Zaa1NGTnJXazlXYkVwWVdXeG9UbVZHVWxaWGJtUlRZa1p3VmxWdGVHdFViRXBHVjJ0c1dGWkZTbWhhUkVaclUwWk9jbHBHYUdsaE0wSlhWbTE0WVdReFdrZFhibEpxVFRKb1ZWWnROVU5TTVZGNFYyMTBWazFyY0VwVlZ6RkhWakpLV1ZGclVscFdSWEJZV1RKemVGWXhjRWhpUms1cFZqSm9VVlp0TVRSaU1VVjVWRmhvV0dKck5WZFpWRXBUVjFac2NscEdUbXhXYlZKNVdWVlZOVll4V1hkalJtUlhUV3BXTTFacVFYaGpWbHB4Vkd4a1RsSnVRbTlXUnpFMFVqRmtXRkpyWkdGU2JWSlVWakJXUzFkc1dYaFZhM0JzVW14YU1GWnROVk5XUjBWNFkwWkdWMkpVUmxSV1JFWlRWMFV4V0U5Vk5VNVdia0YzVmtaYWIyRXhWWGROVm1oc1VtMVNWbGxyWkc5VlJteFhWMnQwYTFKc1dqQlVNVnBoWVZaS2NtTkdiRmhXUlc4d1dYcEtUbVZHWkhWVmJFNXBVakpvV1ZkWGRGZGtNRFZ6VjFoc2ExSnJOVk5VVm1SVFpXeFplVTVXVGxkaVZWWTFXbFZhYzFkc1drWlhhM2hXVFVad1lWcFdaRmRUUmtweVQxZHNVMkpyU1RKV2JGcHJUa1paZVZKcldrNVdiVkp4Vld0YWQxZFdXbkpXYTNScVlrWndXVlJXV210WFJrcHlUbGhzV2xaWFVqTldWRVpoVWpGa2RWZHNhRmROTW1neVZteGtlbVZHU1hoYVJteG9VbXh3YjFSVVFrdGxiRnBZVFZSU1UwMUVWbGhXYkdoellURktObUpHYUZkaGEwcG9XbGQ0V21WWFZrZGFSbVJPWVRGWk1GZFVRbE5VTVZsM1RWWmthbEpGTlZoWlYzUmhZVVp3UjFkc1RtcGhlbFpaV1d0YVQyRlhSWGRoTTJ4WFlXdGFhRlpxUm1GamF6VlhZVVpPYVZJeFNsWldha0pyVlRGV1IxZHVTbGRpVlZwWlZXMTRZVTFHVWxkWmVsWm9VbXR3TUZwVlduTlpWbHBYVjJwT1dtRXhjR0ZhUkVaclkyMU9SMkZIYUU1WFJVWTJWakZhVjFadFZrZFRiR1JUWWtkNGIxVnRNVk5XUm14eVZtNWtWVlpzY0ZaVk1XaHZWakF4Y2sxVVVsZFdlbFpZVm1wS1MxSXhUblJQVjBaWFRURktiMVpzVm1GWlYxSklWV3RvYTFKVWJGUlVWbHAzVTFaWmVXUkhSbWhOVm13MVZUSjRjMVZ0U2taVGJHUmFWak5TYUZaRldscGtNV1IxVkcxd2FWSXhTWGRXUkVaaFZqSkdWMU5zVmxkaE1uaFpWbXRXUzJOc2JIRlNiVVpYVFZkU2VWWXllRzloVmxsNVlVYzVWMVl6VWxoWFZtUlhZekpGZW1KSGVGUlNNVXBWVmtaYVZrMVZNVWRqUlZwaFUwVTFXRlJXV25kU01WcHpZVWhPVjAxcmNFaFZNblF3V1ZaYVdGVnNUbUZXVm5CWVdYcEdhMk5yTlZkaFJrNVlVbFZ3VTFadE1IaE5SbGw1VlZob2FWSnRVbkJWTUZaM1lVWldkV05JVGxkU2JGb3dWR3hXVDFaR1duTlRiR2hYWWxoQ1JGbFZWWGhXYlU1SlkwWndUbEpyY0VsV2JYQkxVekZhVjFOc2JHRlNiVkp2VkZab1ExUldXblJsUjBaVVRWZFNXVlV5ZEd0aFJrcDBWVzVPV2xaRlNubGFSRVpoWkVVeFdWcEdVazVXYkZrd1ZsUkdiMk14V2xoU1dHeFdZbXRLVjFsc2FHOWhSbXQzVjI1T1YxWnJXakZYYTJRMFZUSktWMU5xV2xkaGEyOHdWa1JLUjJOck1WbFViRTVvWWtWd2FGZFdVa3RpTVZwSFYydG9iRkl3V25GWldIQlhWMnhXV0dWSFJtaFNNRlkwV1RCak5WWXhXWHBoUjJoWFZrVndUMXBXV2t0amJHUjBVbXhPVG1KWGFESldNbmhyVFVaT2NrMVdaRmhYUjNoeVZXNXdjMVV4VWxkYVJrNVVVbXhXTlZSc1ZqQldWVEZXVGxWd1ZsWjZSa2hXYWtwTFZsWktjMVZzWkZOV2JrRjZWbGN4TkdFeVRuUlZhMmhyVW0xU2NGVnRNRFZOTVZweldUTm9UMUl3YkRSV2JHaHZWMGRGZUdOR2JGcFdNMDE0VmpCYWMxWldTbkprUmxaVFlrVndOVlp0ZUc5aU1WVjNUVmhLVDFaWFVsaFVWM0JHVFVaYVZWSnRSbXBpVlRWSVZqSjRiMVl5Vm5KV1dHUlhWMGhDU0ZsNlJscGxSbkJIWWtkR1UySldTblpXUmxKSFV6RldSMWRyWkZoaVdGSlFWVzB4VTFOR1pISlhiazVvWWtWd1dWWlhNRFZXTWtaeVUycE9WMkZyV2xSWk1uaFhZMnh3UjFwSGFHeGhNWEJhVm14U1NtVkhTWGhYYmtwT1YwVmFWRmxVU2xOaFJsWnlWbTFHYW1KSGREVmFWVnBQWVdzeFdGVnVjRmhoTWxKNlZsUktTMk5zVG5KalJtUm9ZVEZ3TWxkclVrZFRiVlpIVkd4c2FGSnRhSEJaV0hCWFZteGtXRTFVUW10TlZuQllXV3RvUzFsV1NqWmlSbWhWVm14d1RGWnRlRlpsVlRGRlZteGFUbFpZUWpaWFZFSmhZakZaZDAxWVZtaFRSWEJZVm10V1IwNUdXblJOVlRsVFlraENTRlp0Y3pGV01rVjZVVzVhVjAxV2NGUlZha1pPWlVaa2RWVnNWbWhOYkVwWFYxZDBhMVV5VGtkV2JsSlBWbFUxY0ZSV1pGTldiRlpZVFZWa1YyRjZSbGRaTUdoM1ZqQXhjVlpzYUZkaVIxSk1WVzB4VDFOV1JuTlhiV3hUWW10R05sWnRjRU5aVjBWNFYxaG9WMkpyY0ZGV2JYaGhWREZhZEdWSVpFOWlSbkI0VlRKd1UxZHNXblJWYTJ4V1lrZG9jbFpFUm1Ga1JsWnpWMnhrYUUxV2IzbFhiR1EwVlRGYWMxcElVbE5pUjJoVVZGWmFkMU5HV1hsa1IwWm9UV3RhV0ZVeWVITlZiVVp6VjJ4c1YySllhR2hXYWtaM1ZteGtjMWR0ZUZOaVZrbzJWakowYTJReFZYaFhia3BxVW0xNFdGbHNVa1pOUm5CRlVteHdiRkpzV2pGVk1qRkhWVEZhUjFkdWNGZFdla1V3V2tSS1YyTXhaRmxpUjNoVFZrZDRkbFpYZUZOU01VNXpWbXhvYkZKck5WbFZha0ozVTBacmQyRkhSbGhpVlZwNVZqSjBhMWxXV2xkalIyaGFaV3RhTTFWcVJuZFRSMFpHVGxkc1UxZEZTbUZXYlRFMFlUQTFTRk5ZYkZSWFIyaFZWakJrYjFkR2JIUmxSWFJxWWtaYWVsbFZXazlXTURGWVpVaHNWMDFxVm5KV2FrRjRWakZPYzJGR2NGZFdNbWg1Vm0xd1MxTXhTWGxVYTJ4cVVtMVNUMWx0ZUV0TmJGcDBUVlJTV0dKV1dqQlZiWFJoWVVaS2MxZHVRbGRoTVZwb1ZteGFZVmRGTVZWVmJGWk9ZWHBGTUZacll6RlVNV3hYVTI1U1ZtSkhhRmRaYTFwaFpWWndWMWR0Um10U01WcEpWVzB4YjFSdFJqWlNXSEJYVWpOb1dGbFVSbUZYUms1MVUyczVWMkpGY0doWFZsSkhaREF3ZUZkdVNsaGlhelZZVm0xNFMyVldXa2hsUm1Sb1ZtdHdlbGt3VW1GV01rcFZVV3BTVm1GcldsaFpNbk40VmpGd1IyRkhiRk5OYldoYVZtdGFhazFYU1hsU2EyUnBVbTFvY1ZSVVNtOVhWbFp4VW0xR1ZGSnRVbmxXTWpGSFlVWmFkRlZyYUZaTmJrNDBWbXBLUzFJeFRuSmxSbVJvWVRGd2VWWnFRbUZUTWs1eldraE9WMkpYZUZSWmJYUkxWMnhaZUZwRVFscFdNVVkwVmtkNGExZEhTbkpPVm1oYVlUSlNWRlpWV2xka1IxSkpWR3M1VTJKR1dURldSM2hYVFVaWmVGTllaR3BTVjFKaFZGVmFkMlJzV25GVGEzUlRUVlUxZVZsVldsZGhWbVJJWVVjNVYySllRa2haVkVwT1pVZE9SbHBHVm1obGJGcFpWbTB3TVZGck1YTlhia1pVWVd0S1lWWnRlRmRPVmxWNVpFZDBWMUl3Y0VoWk1HaEhWbTFLV1ZSWWFGZE5SbkI2V1RKNGEyUkdTblJoUms1cFVtNUJNbFp0Y0V0T1JsRjRWbGhzVkdFeVVuRlZNR1EwVjFac1ZWSnVaRlZTYlhoWVZqSjBNRll3TVhKT1ZXaGFWbFp3Y2xsVlZYaFhWa1p6Vm14b1YySkZjRWxXYlhCSFV6Sk9jazFXWkZoaVIyaHdWV3BLYjJSc1drZFdiRTVYVFZkU1NGZHJXbTloTVVsNlZXNUNWVll6VW1oVk1GcGhaRVUxVm1SR1pFNWhNWEEyVmxSS05GVXhXbGRYYms1cVVsaG9hRlp0ZUhkV01YQlhXa1prVTJKV1NraFhhMVV4WVVVeFdHUkVWbGRpUjA0MFdrUkdjMVl4WkZsaFJtaHBZWHBXZUZaWE1IaGlNVmw0WWtab2ExSXdXbFZWYlRFelRXeFdkRTFVUW1oaVJuQjZXVEJTUTFsV1dsZGpSa0phVm0xU1IxcEVTazlTTVZweldrZHNWMUpXVmpOV2JURjNVakpOZUZkWWFGVmlhelZvVlcxNGQySXhVbGRoUlU1WVZtMVNXRlpYZERCV2F6RlhWbXBTV21FeWFFeFdha3BMVm14a2MyRkdWbGRpVmtWM1ZtcEtOR050VVhoalJWWlNZbGRvVkZscmFFTk9iR1JWVVcxR2FFMVhVbmxVVmxaclYwZEtSbE5zYUZwaVIyaDJXVlZhVjJSSFZrWmtSbWhYWW10S1NWZFVRbXRPUjBaR1RWWnNVbUV6UWxoWmJGSkRUa1pTY2xkck5XeFdiRW94VmtkNFYyRlhSalpXYkdoWVZqTm9kbGxxUm10V01WcDFVbXhTYVZaSGVGaFdSbHBoWkRKV2MxZFliRTVXVjFKWVZGVlNSMVl4YkhKVmJFNVhZWHBHZUZadGREUlhiVVY0WTBWNFYyRnJjRkJWYWtaWFl6Sk9SMXBHVGxkV2Vtc3lWbTB4TkZVeFNYaFdXR2hZWWtkU1ZWbHRkSGRqYkZaMFkzcEdWMUp0ZUhsV2JUVkxZa1phYzJOR2JGVldWMmgyVmtkNFMyTXhaSEZSYkZwT1lteEtiMVpxUW10VE1VNUhWbTVPV0dKR1dsaFdha1pMVFd4YWMxWnRSbHBXYlZKSlZrWm9kMkZHU25KT1dFSldZV3RhVEZSc1dtRmpiSEJGVld4d1YySldTa2xXVkVadlpERmtjazFJYkZaaVIyaFlXV3hTUjFVeFVsWlhiR1JxVm10d01GVnRNWGRVYkZwVlZsaG9WMVpGYkRSVWExcFdaVVprY2xkc2FHbFNiSEJaVjFkNGIxVXhaRWRhUm1SWVlUTlNWRlJXWkZObGJHUnlWMjA1YUZacmJEUlZNbmhyVjBaWmVtRkdaR0ZXVmxWNFZXcEdZV1JXVm5SbFJrNU9VbTVDV1ZacldtdE5SbGwzVFVob2FFMHlVbGxaYkZaaFYwWlNWMWR1WkZOTlZrcDZXVlZrUjFZd01WZGpTSEJhVFVad2RsWnFTa2RqYkdSMFlVWndUbUp0WjNwV1YzQkhWVEpOZUZWdVRtaFNhelZQV1d4a2IxTXhXblJOVkZKb1lsWmFSMVJXVm10V1ZtUklZVVpvV21KWVRYaFdNVnB6WkVkU1NWcEdhRk5pV0dkM1ZrZDRWMVF4WkVkVGJrNXFVMGQ0V0Zsc2FGSmtNVnB5VjJ0MGFrMVhVbnBaYTJSSFZqRmFjMk5JYkZkaE1VcElWakl4VjFJeGNFbFRiVVpUWWtoQ1VGZFhNSGhpTVZKWFYyNVNhbEpYVW1GV2JYaHpUbFphU0dSSFJtbFNhM0F3VmxkNFUxWXlTbGxoUkU1WFRWWndhRlZxUm1Ga1JrcHpWR3MxYUdWclZYZFdiWFJxVFZaWmVGZHNhRlJpUm5CWldWaHdjMVpzV25OWGEzUllVbXh3ZVZZeU1VZGhNVWw0VjJ0b1dHRXhjRE5XYWtwR1pXeEdjMkpHYUZkU1ZYQnZWMWR3UzFKdFZrZFViazVwVW10d2NGbFVSbmRXTVZwMFRWUlNXbFl3V2toV01qVkhWVEpLU0ZWdVNsWmhhMXBNVldwR2QxSnNaSFJrUm1ST1VrVmFXVmRVUW10U01XUkhWMjVPV0dKSGFGaFZhMVpoWVVac05sSnRkR3RXYkVwNldWVmtiMkpIU2xsaFJtaFhUVlp3VkZWcVNsSmxSbEp5V2tkb1RrMXNTbTlXVnpCNFZURmFSMkpJU2xkV1JWcHpXV3RhVjA1V2NGWmFSRUpYVFVSR1dGa3dVa2RXYkZsNlZHcFNWMkZyY0VkYVZWcHJZekpHUjFwSGFHaE5XRUpOVmpKNFYxbFdUWGxWYkdSV1ltczFWbGxzWkRSV1JteDBaRVYwV0ZKc2NEQlpNRlpQVmpKR05sSnNhRmRpUjJoMlZqQmtTMk5yTlZkaFJuQnBVbXh3YjFac1VrZFZNVmw0V2toU1UySkhhSEJWYWs1dlRsWmFjMXBFVWxWTlZuQXdWVEo0WVdGc1NsaFZiR2hWVm5wV2Rsa3llR0ZqVmtweVpFZDBVMDFHY0V0V2FrbzBZVEZaZVZadVNsaGlSM2hZV1ZkMFlXTnNWbkZTYTNScVRWWmFNVlpIZUc5aFZrbDRVMjVrVjFaNlFYaFZWRVpQWXpGa2RWUnRSbE5TVlhCWlZrWldVMVl4VGtkV1dHeFBWbFJzV0ZWcVFuZGxWbXQzVjJ4a1dHSlZWalJXTW5CUFZqRktSbGRzYUdGU2JWSlFWVEZhVTJOck9WaGlSazVwWVRCd1lWWnRNWGRUTURWSVVsaG9WMWRIVWs5V2JYaDNWMVpzZEU1VlRsZE5WM2g2V1ZWV1QyRkdTblJsUm14VlZteHdjbGxVUmt0ak1XUjFZMFphYVZaRldrbFdiWEJMVmpKTmVGcElUbGRpUjFKWVdXdFdkMU5XV25SalJXUllZbFphU0ZkcmFGZFdWMHBXVjJ4U1dsZElRbGhXTVZwaFkxWkdkR1JIYkU1V1ZGWlpWbXBKTVZNeGJGZFRhMXBVWWtaYVZsWnRlSGRoUm5CWVpVWndiRlpVVmxkYVJWcFhZVlpKZUZOcmRGZFdiVkV3V1ZSR1dtVldUbk5pUjJoVFRXMW9XRlpHVm1Ga01XUkhWMWhrWVZKdFVsVlZha1pMVTBaa2NsZHJPVlZpUm5BeFZWZDBNRll3TVZkalJtaFlWbXh3VDFwVldtdFhWMFpIWVVkc1UwMVZjRFJXYkdRMFdWZFJlRnBGWkZkaWF6VlpXV3hXWVZkV1ZuUmxSMFpzVW14YU1GcEZaREJoUjBZMlVteGtXazFIYUROV2FrRjRaRlpTV1dGR1pHaE5XRUpOVm0xNFlWbFhUWGxTYTJSaFVqSjRXVlZxU205WGJGcHhVbTFHV2xacmNEQldiWFJyVjBkS2MxZHNXbHBoTVhCb1dXcEdjMk5zV25WYVJtUlRZbFpLV2xkclZtRmhNV1J6VjI1T2FWSkdTbGhaYkZKWFZrWnNWVkpyT1ZSU2JGcDZWako0YTJGV1pFZFRXSEJYWWxSRk1GWnFTbE5UUmxaeVYyeENWMkpXU25kV1Z6QXhVVEExYzFkdVJsUmhiRXB2VkZaa1UwMUdXblJPVlhSWVVqQldOVmxWV205WGJVcElZVWhhVjFKV2NIbGFWbVJYVWpGd1NHUkdUazVTUmxwS1ZtMTBhMDVIUlhoWFdHaFVZa2RTYjFSVVNqUlhSbXh6WVVjNWFGSnRVbGhXTW5oM1lrWktjazVXY0ZwV1ZuQlFXVlprUjA1c1duTlhiR2hYVFRGS2IxWXhXbXRVTWsxNFYyNVdWV0pHY0hCVmFrWkxWMFphUjFkdFJtdE5iRnA2VmpJMVUxUnNXbGhWYkdoV1lrWktTRll3V2xabFYxSklaRVprVG1FelFtRldiR014VXpGWmVGZHFXbE5oTTJoWFdXeG9iMk5zYkRaU2JtUlRUV3MxU0ZkcldrOVdNVXB6WTBaT1YySlVRalJVYTFwaFpFWmFjbHBHVW1saGVsWnZWbFJDVjJReFduTmlTRXBZWW0xU2NWVnRNVFJsYkd4V1draGthRTFFUmxoWk1GcHZWMGRGZUZOc1VsZFdSVVkwVm1wS1QxTlhUa2RYYXpWb1lrWndUbFp0TUhkbFJrbDNUbGhPVkdKck5WZFphMlJUWTBaWmQxcEhOV3hpUm5CWldrVmtSMWRzV25OaVJGSllZVEpvVUZkV1drdGpNV1IxVVd4a2FWSnJjRWhXUmxaaFdWWmtSazFXVmxaaVNFSllXV3RhV2sxV1dsaGxSemxvVFd0YWVsVXlOVTlYUjBwSVlVWm9XbFpGV2xkYVZWcDNVMGRXU0ZKc1RrNVdNVW8yVmpKMFlXRXhVbk5YYmxaU1lXeGFXRlJYTlZOaFJscEZVbXhhYkZKdVFrZFpWV1J2VlRGWmVXRkdiRmRpVkZZelZXMHhVbVZHV25GWGJFNXBVakZLZUZaR1dtdFZNbFp6VjI1U2JGSllVbTlXYWtKM1pWWlZlV1ZJVGxkTmEzQldWV3hTUTFkR1duTmpSa0pXWVd0YWFGbDZTa2RUUjFaSFZHeG9VMkV6UW1GV2JYaHJaREZKZUdKR1pGUlhSMmhaV1d0a2IyTXhWbk5oUms1WVVteEtXRll5Tld0WFJrcDBaRVJPVjJKVVJraFdha0Y0Vm0xT1IyRkdaRTVpYldneVZtMHdlRkl5VG5OYVNFcG9VbTVDYzFsVVJuZFVWbVJaWTBWa2FFMXJOWGxVYkZwclZtMUtSazVXYUZaaVdHZ3pWako0WVdSRk1VbGhSVGxUWWtkM01GZFhkR0ZoTVZWNFdrVm9hRkp0YUdGWmJHaE9aVVphZEdWSVRsaFNNVnBIV2tWYVlWUnNXWHBoUkZaWFlsUkNORlZxUmxwa01ERlhXa1pvYUdFd2NHOVdWM2hyWWpKT2MxZHVUbGhpVlZweFdXeFZNVk5HWkhKWGJYUlZZbFZ3ZWxVeWVFZFdNa3BWVWxSQ1dGWnRVazlhVlZwM1UxWk9jMUZzWkdsaE1IQTJWakZhVTFJeVVYaFViR1JZWW14S1QxWnJXa3RXVmxKWVkzcEdiR0pHY0VsVWJGVTFWakZKZDJOR2NGcFdWbkI2Vm0weFIyTnRUa2xYYkZwcFVtNUNiMWRZY0VkaE1sSkhVMjVPWVZKVVZsaFdhazVxWkRGYWMxVnJkRTVTYlhoWlZUSjBhMVpIU2toVmJrWldZbGhvVEZkV1dtRmpiRnB5WkVVMVRsWnVRalZXYWtsNFVqSkdkRk5yWkdwU1JVcFhXV3hvYjFWR1duRlRhM1JUWWtkU1ZsVXllRzlXTVVwV1kwWldWMVpzU2toWFZscHJVakZTZFZOc2FHbFNNbWgzVmxkd1IxTXhaRWRhUm1oc1VucHNWMVJWVWtOT1JsbDVaRWQwV0ZJd1ZqWldWM2h2VjIxRmVWVnNVbUZXYkhCb1ZUQmtWMU5HU25OYVJUVm9UVEJLU2xZeFVrTlZNVmw0V2tWa1lWSlhlRk5aVkVwdlYwWmFjbFp0Um1oU2JYY3lWVzF6TldFeFduSk9XSEJYVm5wR2VsWlVSbUZTTVdSellrWmthRTFZUWxWV1dIQkxVMjFXUjFSdVNtRlNiV2h3VldwR1MxZHNaRmhrUjNSV1RWWndlbFpYZUd0WFIwcElWV3M1VlZadGFFUldha1poWkVVeFZscEdaR2hsYTFvMVZtMHhkMVF4WkhKTlZXUnFVbXRLV0ZsWGRIZFVSbFYzVjJ4a2FsWnRVbnBXYlhoclZURmFkVkZ1V2xkaVZFVXdWMVphU21WV1VuVlViWEJUVmpGS1ZsZFhlR3RPUmxwSFYyNVNUbFpGU2xCVmJYaHpUbFp3VmxkdGRGZE5SRVpYVkZaU1UxWXlTbFZXYkVKWFRVZFNURlZxU2s5U01rcEhZMFpvVkZKVmNFcFdiVEI0VGtaWmVWUllhR0ZUUmxwb1ZXMTRkMVpHYkhKWGJtUllZa2RTZWxadGVHdGhSVEZYWWtSV1ZrMXVhR2hXYWtwSFl6Sk9SMkZHV21oaGVsWXlWbXRXWVZsWFRsZFRibEpUWWtkU1QxbFljRmRUUmxweldrUlNhRTFXYkRWVk1uaHZZVVpLUjJOR2FGWmhhelZVV1ZWYVYyTldUbkpPVjNoVFlYcFZlRlpyWkRSaU1rWlhVMnhXVjJKc2NGaFZiWGgzVjBad1JWSnNTbXhTYlZKNldWVmtORlV5U2xkVGJXaFhZbFJGZDFacVFURlNNV1IxVlcxNFUySldTbGxXVjNCRFpERmFjMkpJU2xoaGVteFlWbTE0ZDFkR1ZYbE9WMFpYVmpCV05Ga3dhRXRYYXpGMVlVZG9XazFxUmxSVmFrWnJaRWRLUjFSdGJHaE5TRUphVm0xd1IxbFdXWGxUV0d4V1YwZG9XVmx0Y3pGWFZteDBZM3BHV0ZadGVGWlZNakExVmpBeFYyTklhRmRTZWtFeFZtcEdTMk15VGtsaVJtaG9UVmhDZVZac1VrdFRNVXB5VGxac2FsSnNjRTlaYlRGdlpWWmFkR05GWkZwV01VcFlWVzAxUzFsV1NuUlZiVGxWVm14d00xWXhXbUZrUjA1R1drWlNhVlpzY0VsV1ZFa3hWakZhV0ZOcldrOVdiWGhYV1Zkek1XUnNjRmhsUjBaWVVqRmFTRll5Y3pGV01rcEdZMFJhVjJKVVFYaFdSRVphWlZaT2MxZHNhR2xTVkZaWFZtMHhOR1F5UmtkWFdHUllZbFZhY2xWc1VrZFhiR1J5V2tjNWFGSXhXbmxXTW5odlZqSkdjbUo2UWxwV1JWcG9Xa1ZhVDJNeVNrZFhiV3hYVFcxb1dsWnRNVEJXTVd4WFZXdGtWMWRIYUZsWmExVXhWMFphZEdWRmRHeGlSbkF3VkZaU1UyRkdTbFZTYkhCV1ZqTm9URlpxU2t0U01rNUpVMnhXYUUxWVFreFhiRlpoWVRKU1YxUnVUbEppUjFKWVZGUktiMWRHV1hoYVJFSlhUV3hHTkZkclZtdFhSMHB5VGxac1dtSlVSbFJXYTFwWFpFZFdTVnBIZUZkaVIzY3hWMVJPZDFZeFdsWk5WbHBxVTBoQ1dGUlhOVk5rYkZwMFRWVjBXRll3V2tsWlZWcHJWakZLV1ZGcmFGaGlSbHBvVmtSS1QyTnJOVmRhUm1ocFZqTm9WVmRYZEc5Uk1sSnpWMjVPV0dKRk5WUlVWbHB6VGtaWmVHRkhPVmhTTUhCSldsVmtiMVp0Um5KT1ZWSlhVa1ZhYUZwRlpGTlNNazVJWlVkc1UySnJTbUZXYTFwaFZURkZlRmRyV2s1V2JWSlpXVmQwUzFkR2JITmhSemxzWWtkNFYxWXlkREJYUmtwelYyNXdXR0V4Y0hKWlZscHJVMGRHU0U5V1pGZFNWWEJ2Vm0xd1MxVXhUa2RXYmtwWFlrWndjRlZzVWxka01WcFlaVWM1VWsxRVZsaFdNbmhYVmtkR2MxTnNWbFZXYkhCNlZHdGFXbVZIUmtsYVJtUnBWbFp3TmxkVVFtRmlNV1J6VjJ0YVdHRnJOVmhVVlZwM1YwWnJlRmRyZEdwaVNFSkpXVEJWTVZZeFdrZFhWRXBYWWxob2NWcFZWVEZTTVZwWllVWm9hVkl6YUZSWFYzUmhVekZrUjJKSVRtaFNlbXhaVlcweFUxZEdXWGxqZWtacFVtdHdlbFl5TlhOV01ERjFZVWhLVjAxR2NFdGFWbVJIVWpGV2MyRkdaRTVOVlhCYVZtcEdZVmxXWkhSV2EyUmhVMFphVmxsc1pHOVdSbHB5V2tSU1dGSnRVbGxhUldSSFlUQXhWMkpFVWxkTlYyaDZXVlJHUzFaWFNrZGhSbkJZVTBWS1JWWkhlR0ZrTVU1WVZHdGFWV0pIVWs5V2JUVkRWMVprVlZGc1pHbE5WbXcxVlRKNGMyRkdTbGxoUjBaVlZucFdkbGt5ZUhKbFYwMTZZVVprVGxacmNEWldNblJoWVRKR1dGSllaR3BTVjFKWVdXeFNSazFHWkZkWGJrNVhUVmRTV2xsVldtRmhWMHBHWTBaa1YyRnJTbkpaYWtaaFVqSktTVk5zYUdsaVZrcFpWbGN3ZUU1R1duTldiR2hQVmpOU1dGUldWbmRsYkd0M1YyMUdWMDFWYnpKVlZsSkhWakZaZWxScVVsZGhhMXB5V1hwS1IxSXhjRWhpUm1oVFlUTkJNVlp0TVRSVk1VbDRWRmhvWVZKdGFGUlpWRVozWVVaV2RHVklaR3BTYkd3elZqSjBNRlpXV25OalNIQllZVEZLVkZZeWVHRmpNazVKWWtaV1YySklRalpYVm1RMFV6Sk5lVlJyWkdoU2JrSnZWRlpvUW1Wc1dsVlNiVVphVm0xU1NWWlhkRzloTVVweVRsVTVXbGRJUWxoVWJYaGhaRVV4VlZWdGNFNVdia0phVmxSS01GbFhSbk5UYmxKb1VtMW9ZVmxVUm5kTk1WSlZVbXhrYW1KSFVqQlZiWGhyVkcxRmVHTkZkRmROYmxKeVZHdGtSMU5HV25WVWJGSllVMFZLV1ZaWGRGZFRNbEp6WWtaV1UySkdjSE5XYlhSM1YyeGtjbHBJWkZaTmEzQkhXVEJhYzFkR1dYcFZiV2hoVWtWYVVGVnFTazlTTWtaSVpVWk9UbEp1UWxwV2JUQjRUVVpzV0Zac1pHRlRSWEJaV1ZST1UySXhXblJrU0dSc1lrZDRWbFpITURWWFJrbDNZMFZvVjAxdWFIWldiVEZYWTJ4a2MyRkdjR3hoTVhCNVYxaHdSMkV5VFhsU2EyaHBVbTFTVkZSVVNtOVhWbHAwWlVkMFQxSXdWalJXYkdodlZqSkZlVlZzYUZwaE1sSjJXWHBHVjJNeGNFZFViR2hUWWxob05WWnFTakJOUm1SSVUydGthbEpYZUdoV2JGcGFaREZhY1ZGWWFGZE5helZJV1ZWYWQxUnNTbk5qUmxaWFlsaENURlZ0TVZkWFJrcHlZa2R3VTJKR2NIWldSbHB2VVRKSmVGZHNhR3BTVjFKVlZGZHplRTVHWkhKaFJUbFhWakJ3V1ZsVlZUVldNREZIVjJ0NFYxWldjR2haZWtaM1VsWldjMXBGTlZkTk1taGFWbXhrTkdJeVNYaFhXR3hVWVRKb1YxbHJaRzlYUm14VlVtNWtWVkpzY0ZkV01uaFBWakF4V0ZWdWJHRlNWbkJ5VmtkNFlXTXlTWHBhUm1ob1RWWndiMVpyVWt0U01VbDRWR3hzWVZKdFVtOVpXSEJYVmpGYWRFMUlhR2xOUkVJMFZqSTFVMkpHU1hkWGJrWlZWbTFTVkZwV1duTldiR1IwVW14a1RsSkZTVEZYVmxaaFZqRlplRk5ZY0doVFJYQllXVmQwWVZNeGNGWlhiRTVyVm14S2VsWlhNWE5WTURGV1kwWndWMkpVUWpOVVZscEdaVVpPV1dGR2FHbGhNMEpaVjFkMGExVXhaRWRWYkdSWFltczFVRlZ0ZUdGTlJsSnpWbFJXVjJGNlJubFpNRlp2VjJzeFIxWlVSbGRpV0U0MFZXcEdZVmRYUmtkYVJUVlRZbXRLVmxadE1IaE9SbXhZVld0a1ZHSnJOVlZaV0hCWFYwWnNjbGR1U214V2JHdzBWMnRTUTFack1WZFdhbEpYWWxSV1ZGWnJaRVpsUjA1SFlrWndhRTFzU2xWV2JYQkhZekpOZVZKclpGVmlSMUpVV1d0b1ExZEdXblJsUnpscFRWZFNTRlV4YUc5WFIwVjVWV3hvVm1Gck5YWlpWVnBoWTFaS2NtUkdhRmRoTVhBMlZteGtOR0l4WkVkVWExcFVZVEo0V0ZacVRrTlRSbVJYV2tVMWJGSnNTakZXYlhoVFlWWktjbU5JWkZkV2VrVjNXa1JHYTFJeFpISmFSbHBvVFRGS2QxWkdXbUZUTWxaelYxaHNiRkl6VWxsVmFrSjNVMVphV0dWSGRGZFdiSEF3VmxkNFUxbFdXbk5qUkU1WFlsaG9hRnBGV2t0ak1XUnlUbGRvVGxadGR6Sldha1pUVVRGc1YxVllhRmhpUjFKWldWUkdkMk5XVlhkWGJtUlhUVmQ0VmxWdE5XdFdNVXB6VjJwQ1lWWlhVa2haVnpGTFUxWkdjbUZHV2s1aGExbzJWbXhTUjFsWFVsZFNiazVwVW0xU2IxUldWbmRTVm1SWVkwVmtWbUpXV2toV01qVlhWbGRLU0dGSVFsWmlWRlpFVmpKNGExWXhWbkpUYXpWWFlsWktTVlp0TURGVk1rWjBWbTVLVkdGNmJGZFpiR2h2WVVaWmVGZHVaRmRpUm5Bd1drVmFhMVJ0UlhwUmEyaFlWa1ZLZGxwRVJtRmpNV1JaWTBaV2FHSkZjRmxXYlhSWFdWZEdSMWR1UmxSaGVteFVXV3RhWVdWc1pISlhiWFJvVm1zMVIxVXllSGRXTWtwWlZXNUdZVlpXY0ZSYVJWcGhZMnh3UjFWdGJHaGxiRnBoVmpGa01GWnJNVmhUV0doV1lrWndiMVZzVlRGWFJsWjBUVlpPYkdKR2JEVlVWVkpYWVVaYVZWSnNaRmRpV0VKVVZtcEtTMWRYUmtsVGJHUm9ZVE5DU1ZaSE1IaFRNVXB5VDFaa2FsSXlhRTlXYlRWRFpHeFplV1ZHWkZwV01VWTBWVEkxVDJGc1NsaGhSa1pYWWxob00xa3dXbGRrUlRWV1ZHeG9VMkpJUWpSV1ZFcDNWVEpHUmsxV1pHcFNiV2hYVkZjMWIyTnNXWGRhUlZwc1ZqQmFTRmRyV210aFIwWTJWbXBLVjFaRlNtaFhWbVJUVTBaU2NWZHNaR2xTYTNCWlYxZDBWMlF3TlhOWGJrWlVZV3hLYjFSV1duTk9SbGw1VGxaa1ZtSlZWalJXTW5odlYyMUZlR05FVG1GU00yaDZWRzE0UjFaV1NuTlVhelZYVjBWR05GWnRkR3RPUmxGNVVteGtWR0pzV2xOWmExcGhWMVphZEdWRmRGUlNiRmt5VlcxNFQyRnJNVmRqUkVaWFVqTm9jbGxXV21GV01rNUhWV3hrVTJKSVFtOVdNVnBoWVRGSmVGcElWbFppV0VKeldWUkdkMlJzWkZkaFNHUlRUVlpzTkZscmFFdFdiVVkyWWtab1dtSkdXak5XTW5oaFYwZFNSVlZzWkU1V2JUaDVWbGN4TkdJeFdYZE5WbWhXWVRKb1YxbHNhRzlXUm13MlVtMTBhazFZUWtsWmExcFBZVmRGZDJORmVGZGlWRUkwVkZWYVdtVkdaRmxhUlRsWFZqRktWbFpxUW10aU1WcFhZa2hTYTFOSFVsaFdiVEUwWlZaYWRFNVhkRmhTYTNCNldUQm9iMVpzV25OVGEyaFhVa1Z3VEZWcVNrOVNNa1pIV2tVMWFXSlhhRFZXYlhoVFVXMVdSMWR1VG1GVFJscHhWVzB4VTFkR1VsVlJhM1JZVm0xU1dWcEZaRWRXUlRGeVRsUkNWMUl6VW5KV2JHUkxVMFpXZFZGc1dtbFhSMmQ2VjFkd1IxbFdaRWhXYTJoVFlrWndUMVpzYUVOT2JGcHhVMVJHVkUxWGVGaFZNalZMWVd4T1JsTnNaRnBoTVhBelZGUkdXbVF4WkhSa1JtUlhZa1Z2ZUZZeWRHdGlNVkp6VjFob1ZHRnNXbGhWYlhoM1YwWmtWMWR0ZEZSU2EzQmFXVlZhYjJGV1NuVlJiR2hZVm14S1NGZFdXbE5TTVZweFYyeE9hV0Y2VmxGWFYzUlhaREpXVjFkWWJFNVdSVXBXV1d0YWQxZHNWbGhqUm1SWFRXdHdWbFZzVWtOV01rWnlWMnhvV2sxdVRqUlZNV1JMVTBkR1IxUnNaR2hOTUVwaFZtMHdkMlZGTlVoVldHaGhVbGRTV0ZsdGRHRldWbXh5V2taT2FsWnNTbGhXYlRWcllrWktjMk5FUWxWV2JFcFVWbTF6ZUZZeVRrZGpSbHBYVFRKb1ZWWnRjRXRUTVdSWVVtdGtZVkl3V2xoV2JYaFhUa1prV1dORlpGcFdNREUxVlRKMGIyRldTbkpPVmxKYVZrVTFSRlpzV2xwbFJuQkZVV3hrVGxZemFGbFdha1p2WWpGWmVWTnVUbFJpYXpWWFdXdGFWbVZHV25SbFIwWnJVakZLU2xkcldtdFViRnAwWkhwR1dHRXhXbGRVYkZwYVpWWk9jbHBIY0ZSVFJVcFpWa1prZDFZeVZuTlhXR3hPVm0xU2NWbHJaRk5sVm14V1YyMTBhRlp0VWtsWlZWVjRWMFphUm1KNlFsZFNSWEJQV2xWYWEyUldWblJsUms1cFZqSm9WbFpyV21wbFIwbDRVMjVPV0dKc1NuTlZha0poV1ZaYWRHVklUazlTYkZZMFdWVmpOVll4U1hkV2FsSmFUVWRvVUZadE1VdFNNazVGVkd4a2FFMVlRalpXYlhoaFVqSlNWMk5GWkZoaGVsWllXVzEwU2sxc1duUk5WRkpwVFd0c05WVXlkRzlXUjBWNVZXeHNXbUV5VW5aV01GcHpZekpHUjFSdGNHbFNia0pYVmxjeE1HUXlSWGROVlZaWFlraENZVmxVUm5kaFJscElaVWRHYW1KVk5VcFphMXByWVVkRmVVOUlaRmROVm5Cb1YxWmtUbVZIVGtaaVJsSnBVbXh3ZDFaWGNFZFRNbEY0VjJ4b2JGSnJOVmRaYkZwSFRrWlplV1ZIZEZwV2EzQklWVEo0VTFaV1duTmpSRTVoVmpOb1YxcFdWVEZXYXpsWFYyMXNWMVp0ZERWV2JHTjRUa1pWZUZwSVRsaGhNWEJaV1Zkek1WWXhiRlZTYm1Sb1VteHdlRlZ0TVRCaGF6RlpVV3RvVjJKVVJucFdha1poVW14YVdWcEdaR2xTTURRd1ZrZDBZV014V1hoWGJHeHBVbXMxV1ZWcVJrdGxSbHBZVFZod1RsWXdXa2hXTWpWVFZHeGFObUpJU2xwaE1YQm9WbTE0VjJSSFZraGtSbVJPVWtWYVdWZFVRbTlqTVdSSVVsaG9hbEpyU2xoV2ExWmhZMnhWZDFwRlpGTmlWVnBJVjJ0Vk1XRlhTa1pqUm5CWFlrZG9NMVZxUmxwbFZsSlpZVWRHVkZKVVZscFhWbWgzVmpGa1YxWllaRmRoTTFKWlZXMTRkMDFHVWxkVmJFNVlZa1p3ZVZSc1ZtOVdNa3BaWVVoYVdtRXhjRXhXYkdSTFVqRkdjMXBIYUdoTldFSjJWbXhTUTFsV1pIUldiR2hYWVRGd2NsVnRNVk5VTVZwMFRsVk9XRlp0VWxaVlYzaGhWR3hhYzJKRVVsWk5ibWh5VmpCa1MxTkhSa2RhUm5CWFRURktiMVpVUW1Gak1EVnpVMjVLYTFJelFrOVdha1pMVG14YVYxcEVVbFpOVmxZMFZqSjBhMWRIU2tobFJtaGFZa1pLUjFSVldtRmpWa3AxVkd4a1RsWllRbUZYVmxaaFlUSkdWMU5ZY0doVFIxSllWbXBPVTJGR1ZqWlNiRnBzVWpCd1NsVXllR3RoVmxwWFkwWnNWMUpzY0doWFZsVjRVakpPUmxkc1dtbFNWRlpaVjFkMFYyUXhXbk5XYmxKc1UwVTFZVlp0ZUhkWFJsbDVaVVZPVjAxcmNGcFpWV1J2Vm0xS1ZWSnJaR0ZXZWtaSVZXcEdhMlJIUmtaT1ZtUnBWMFpHTmxadE1UUmhiVlpHVGxWa1ZWZEhlRlpaYlhNeFZteHNkR042UmxkV2JYaDVWMnRhVDFkR1NuTlRiRnBXWWxoU00xWkhNVXRTTWs1SlkwWndWMVl5YUhsV2JHUjZaVVphZEZOclZsWmlSbkJQV1cweGIyVldXblJqUlhSVFlsWmFTRlpITlZkV1YwcEhZMGhDVm1KWWFESmFWM2hoWXpGV2NscEdjRmROUkVVd1ZtcEpNVlF5Um5OVFdIQm9VMFZLVjFsc2FHOU5NV1JYVjIxMFdGSXhTa2hXUjNoaFZHeGFjMkl6WkZkV1JXOTNWMVphYTFOR1RuSmhSbHBwVWpKb1dGZFhlRzlpTVZKSFYyeGFXR0pWV2xsVmJGSkhWMFprY2xkdE9WZE5SRVpJV1RCV2IxWXlSWGxWVkVKWVZteHdZVnBXV2s5amJIQklZMFpPVjAweWFGcFdNV1F3V1Zac1YxcEZaRlppYTNCWldWUk9VMk5XVWxkV1ZFWk9WbXhXTlZwVldrOWhSbHB5WTBad1ZsWXphSHBXYWtwTFYxWldjMkZHV214aE1GWTBWMWh3UjJFeVRYaGpSV1JvVWpKNFZGUldWbmRXYkZweVYyMUdWMDFYZUZsV2JUVlBWMGRLU0dGSVJsWmlWRVpVV1RCYVYyUkhVa2xhUm1ST1ZqTlJlbFpxU25wT1ZsbDNUVmhLYWxKWGFGaFVWM0JIWkd4YWRFMVZkRk5OYXpWSVZsZDRZV0ZXWkVoaFJ6bFlWa1Z2TUZwRVJrcGxSbEoxVlcxc1UyRjZWbGxYVnpFd1V6RmtjMWR1VWs1V1JVcGhWbXBDYzA1R1dsZGhSemxYVFd0d2VWUnNXbk5YYlVWNFkwUk9WMDFXY0hwV2JGcExaRVpLYzFwSGJGTmlhMFl6VmpKNFYyRXhTWGhYYTFwT1ZtMW9jbHBYZEhkV01XeHpZVVpPYW1KR2NIaFZNblF3VlRKS1ZrNVZjRnBoTVhCb1ZrY3hTMlJIUmtkU2JHaFhUVEZLYjFkV1VrZFVNVTVIVTI1S1dHSkdjSEJWYWtaTFYxWmtXR1JIT1ZKTlYxSllWakkxVTJGc1NsaFZiRlpWVm14d00xcFdXbEpsUm1SeldrWm9VMDFJUW1GV1ZtTXhWREZrZEZOclpHcFNXR2hZVkZWYWQyRkdWbkZTYlVacVRWaENTRmt3V210aFZrNUdVMVJLVjAxV1NrUldha3BHWlVaa1dXSkdUbWhpU0VKWlYxY3hNRmxXV25OWGJsSnNVakJhYjFWdGVIZGxSbFowWlVkMGFFMVZiRFJWTW5SdlZqRktObEp1V2xkU2VrWkhXbFZhYTFkWFRrZGFSazVwVTBWSmVWWXlkRk5TTVd4WVZGaG9ZVk5HV2xaWmEyUnZZakZTV0UxWE9WaFdiSEF3V1RCVk5XRlZNVmRqUldoWFZucFdVRmRXV2t0a1JsWnpWV3h3YUUxV1ZqUlhiR1EwVm0xV1dGWnJhR3RTYlZKUFZtMDFRbVZHV2xkYVJGSlZUVlpzTlZWc2FHOVhSMHBJWVVab1dsWXpVbWhWZWtaM1ZteGtjbVJIZEZkaVJYQTJWbXRqZUdNeFZYbFRia3BVWWtkb1dGbHNhRU5TUmxwMFl6Tm9WMDFXY0ZwWlZWcHZZVmRHTmxac2JGaFdNMmhZVjFaYVlWSXhaSFZWYXpWWFVtdHdXbFp0TURGUk1VbDRWMjVTVDFZelVtOVZha0phVFd4V2RHVkhkRmROUkVZeFdWVm9TMVl5U2xWU2EzaFhUVlp3V0ZreU1WZFNNWEJIV2tkNGFFMVlRbUZXYlRGM1VqSkZlRk5ZYUZSaWF6VlhXVzF6TVZkV2JISmFSazVxVW14YU1GUnNWazlYUjBwSFkwaHdXR0V4U2xSV2FrRjRVbFphY21GR1drNWhiRnBSVm0xMGExTXlUblJVYTJSWFlraENiMVJXV25abGJGcHhVVzFHVjAxck5WaFdSelZUVlVaYWNrNVZPVmRpVkZaRVZUQmFZV1JGTVZWVmJXaE9WbXhaZWxaR1dtRlpWbVJJVTI1V1VtSkhVbUZaYTJSdlVrWnNWbGR1VGxkTlYxSjVXa1ZhYTFSc1dYaFRhbFpYVWpOb2FGZFdaRWRXTVU1MVZHMXdVMlZ0ZUZsV2JURTBVekZPUjFkdVJsTmlTRUp6VlcxNGQwMVdXbGhsUlRsb1ZtdHdXbFZYZUVOV01WcEdVMjVLV21GcldsQlZha1pyWXpKR1JrNVdaRk5XV0VKWFZtdGFZVmxXYkZaTlZXUllZbXhLVUZadGN6RlhSbXh6Vm14a1QxSnNWalZhVldSSFZqSktWbU5GYUZwTlIxSjJWbTF6ZUZJeVRrZGhSbVJPVWpGS1dWWlhNVFJrTVVsNFkwVmtZVkl5YUhOWmExcHlaVVphZEUxVVFtaE5iRm93Vm0xMGExWXhaRWhoUm14YVlUSlNWRmt4V2xkak1XUnlaRVpvVTJKSVFYZFdSbHBxVGxaU2NrMVdaR3BTVm5CWFdXeG9VMkZHYkZWUldHaHFUVmRTZVZkcldtdFViVXAwWVVaR1dGWnNXbGRhVlZwUFZqRktkVlJzV21sU01VcDNWbXBDWVZNeVNYaGFTRXBXWVRKU1ZWUldXbk5PUmxwMFRsVjBXRkl3Y0VsV1Z6QTFWbFpaZW1GRmVGZGhNWEJ5VmpCa1UxSXhjRWRoUjJoc1lURnZNbFpxU2pCaU1VMTRWMWhzVkdFeGNGQldiWGgzVjBac2MyRkdUazVOVm5CNFZXMTRkMkpHV1hoVGEyUlZUVlp3Y2xsV1drdGtWa1p4VjJ4a1YxSlhkekJYVjNCSFdWZE5lRnBJU2xoaVJrcFlWV3hXZDFkR1pGaGxSemxwVFZaS1NGbFVUbk5pUmtwVllraEdWVlpzVlhoVVZWcDNWbXh3U1ZSc1pFNWhNVmt5Vmxaa01HRXhXWGxUYkd4V1lrZG9XRmxYZEdGWlZuQldWMnM1V0ZZd1draFdSekZ6WVVkV2MxZHNXbGROVjFGM1dWUkdWbVZHWkhKYVJtaFlVakZLV1ZadGRGZFpWbGw0Vld4a1dHSnRVbk5aYTFwM1RVWlNWMVp0ZEZkaGVrWllXVEJvZDFkck1VZGpTSEJYVFdwR1IxcFZXazlqTVZaeldrWmtiR0V4Y0U1V2JHTjRUa2RGZVZSWWFHcFNWMUpaV1d4a05GZEdWblJsU0dSVllrWndNRnBWWkhkaVJrcHlZa1JTV0dFeGNIWldWRXBHWlVkT1IxZHNjR2hOV0VGNlZtcENZV015VG5OYVNGWmhVbXh3V0Zsc1drdFpWbVJWVVd4a2FFMVdWak5VVm1oTFZERmFXR1ZHYUZwaVIyaFVXVlZhWVdOc2NFWmtSazVwVmxSV1NWZFdWbUZoTWtaWFUyNVdVbGRJUWxsV2JYaGhZVVprVjFkcmRHcE5WMUl4VmtjeFIxVXlSalpXYkVKWFlsaG9hRnBFUVRGak1XUnpZVWQ0VTJWdGVIZFdSbVF3V1ZaWmVGVnNXbWhTTTFKV1ZGWmFkMlZXVW5OWGJUbFlZbFZXTkZrd1pHOVhiRnBYWTBab1YySkdjRXhaZWtaclpFZFdSMVJ0YkZOaVZHc3dWbXBHVTFFeFduSk9WbVJXWW1zMVZWbFVTbTlqVmxKVlUycFNXRlpzY0hsV2JGSkhWR3N4V0dWR1dsWmlXR2h5Vm10YVMyTXlUa1ZTYkdScFYwZG9XVlp0Y0VkVE1WcFhWMjVPWVZKdFVsUlphMVozVlZaYVYxVnJTazVXTURFMFZtMDFWMVV5U2taalJtaFdZbGhvTTFaV1dtdFhSMVpJVW14U1RsWlhkekJXYlhodll6SktSMU5zYkZaaVIyaFdWbTE0ZDAweGNGaGxTRXByVFZad1dsbFZXbXRVYkZwWlVXeHNWMkZyYkRSWmFrWmFaVVpPY2xkc2FHaE5iV2hvVjJ4a01GbFdVa2RpUkZwVFltMVNWRlJXV25kbGJHeFdWMnM1VjAxVmNIcFpNRnBoVmpKS1ZWRnFVbFZoTVhCaFdsVmtTMUl4Y0VkVWJHaFRUVzFvWVZZeFkzaE9SbXhZVkd0a1YySnJjRmxaVkU1VFYxWmFkRTFVVW14V2JIQXdWRlpXYTFZd01VVlNiR2hYVFc1Q1JGZFdXa3RXTWs1SFVXeGthVkp1UW05WFZFbDRWREZKZUdORlpHRlNWRlp3V1d0V2QxVnNXblJOU0doUFVtMTRXVlpHYUc5WlZrNUhWMjVDVm1KWWFHaFpha1p6VmxaS2RWcEdaRmRpU0VGM1ZrWmFVMVV4V2taTldFcFBWMGhDV0Zsc1VsZFdSbXhYVjJ0d2JGWXdXa2RVTVZwaFlVZEdObFpxUmxkU2JWRXdWMVprVG1WR2NFbFZiRTVwVWpGS1VGWnRlR3ROTURGSFYyeG9UbEpGV2xaVVZscDNUVVpWZVdSSGRGZFNNSEI1Vkd4YWExZHNXWHBVV0doV1lURndhRlpzV2t0a1JrcDBZMFUxVjJKclJqTldiR040VGtac1YxVnVUbGhpYTNCeFZXeGtiMWRHYkhOVmExcHJUVmQ0VmxWdGVHdGhNVXB5VGxoc1YwMXVhSFpaVmxwS1pVWk9jMXBHWkdsWFIyaDVWMWR3UjFZeFNYaGFTRlpWWWtkU1dWVnFTbTlXVm1SWVpFZDBWazFzV2xoV01uUnZZa1pKZDFkc2JGWmlXRko2VkcxNGExWldVblJrUm1ST1ZtNUJkMVpzV2xOUk1WcDBVbTVLV0dKWGFHRmFWM1JoVlVad1IxZHJPV3BoZW14WVYydGFhMVV4V25WUmJHUlhZbFJDTkZSVlpFWmtNRFZXV2taU2FFMXNTbHBYVjNSclZURmtWMkpJU21GU2F6VllXV3RrTkdWc1duTmhSemxWVFZWd2VsWXljRU5aVmxwWVZXdG9WMkpZVGpSWk1uaGhZMVpTYzJORk5WTmlhMGw1Vm1wR1lWbFdiRmhWYTJoVFlUSjRXVmxyWkc5WFJteHlZVVZPV0Zac2NEQlpNRlpyVjJ4WmQwNVljRnBOUmxweVZteGtTMUpyTlZkaVJscG9ZVE5DTWxaVVJtRlpWMDE0WVROd2FGSlVWbFJaV0hCR1RVWmFkRTFFUmxWTlYxSkpWVEowYjJGR1RrWmpSbVJWVmxkU2RsVnJXbUZqVmtwMFVtMTBVMDFXY0VwV1Z6RTBWVEZWZVZOclpHcFNia0paV1d0YVlWZEdiRlZTYkVwc1VtMVNXbGxWV205aFJURnpVMnhvVjFKdFRYaFpha1pUVWpGa2RWSnNUbWxXVm5CWlZrWmtlazFXU1hoWFdHeHNVak5TVjFSV1duZGxiR3QzVjIwNVYwMVZiRFpaVldSdlZtMUdjbU5GT1dGV1ZuQlFXa1phVTJNeVJraGlSazVwVTBWS2FGWnRlR3RPUmxWNFYxaG9XR0V5VWxsWmJYaExZekZXZEUxV1RscFdiSEF3V2tWYWExUXhTbk5qUkVKVllrWndjbGxWV21GamJVNUdZVVphVG1GclJYaFdha2w0VW0xV1IxcElVbWhTYlZKdldWUkdkMWRXWkhKV2JYUlhUVlUxUjFReFdtdFdNa3BJVlcwNVZWWkZTa3hXTVZwaFpFZE9SbVJGTlZOaVJWa3dWbXBKTVZReFpFaFRia3BQVm0xNFlWbHNVa1pOUmxwMFpVaE9XRkl4U2tsVmJYaHZWVEpLU1ZGWVpGaGlSbHBZVkZWa1IyUkdUbkphUm1ocFlsaG9WMVp0TVRSV2JWWkhWMnhXVkdFeGNITlZha0oyVFd4VmVXVkhkR2hXYTNBeFZWY3dOVll5U2xsUmEyaFdUV3BHV0ZWcVJrOWtWbHB6Vm0xc1UySnJTak5XYkdONFRVZFJlVlp1VGxoaVIyaFBWbXRhUzFaV1VsZFhiR1JQVW14c05WUnNWVFZXTURGeVkwWmtWMDF1YUZoV2FrcExWMWRHUm1WR1dtaGhNWEJ2VjJ0V2ExVXhUa2hWYTJSWVlsZDRXRll3Vmt0VFZscDBZMFYwVDFJd1ZqUlhhMmhQVjBkRmVHTkdRbGRpV0ZKTVZqQmFjMVpXU25OYVJUbFRZa1p2ZDFkc1ZtdE5SMFowVTJ0a1ZHSnVRbGhVVnpWdlpHeGFWVkZZWkd4V2JFcDRWa2Q0YTJGV1NuVlJibXhYVWpOU2FGVXlNVmRTTVhCSlZteFdhVkpyY0hkWFZsSlBVVEZXVjFkdVVteFNhelZVVkZaYWQxTkdXWGxPVlRsWVVqQndNRlpYZUZOV2JVcFpZVVJPVjAxR2NHRmFWbVJYVTBkU1IxcEdaRTVUUlVwWlZtdGFZVlV4VlhoWGJsSlVZa2Q0YjFWcVNtOVhSbHB5Vm01a1UwMVlRbGRXTW5NMVlURmFjMU51Y0ZwTlJuQnlWbFJHWVZkV1JsVlNiR1JvVFZoQ1ZWWlhjRWRqTVdSSFZXNU9ZVkpyTlhCWlZFNURZakZhV0UxWWNFNVdiRVkwVmpJMVUxUnNTa2RUYms1V1lsUkdWRnBYZUdGa1IxWklaRVprVTFaRldsbFdha2t4WkRGWmQwMVlWbWhTTW1oWVZGVmtVMUl4Y0ZobFJtUnFUVmRTZWxZeU1YTlZNa3B5VTI1YVYySkdTa1JYVmxwYVpVWndSbUZHWkdoTldFSnZWbGN3ZUdJeFpFZGlTRXBYWW0xU1VGWnRlSGRsYkdSeVlVaGthVkpyY0hwV2JYQlRWakF4ZFdGSVNscFdNMmhNVm1wR1QyTXlSa2RhUjJ4WVVqSmtObFl4VWt0T1IwMTRWMnhrVkdKcmNGbFpiR2hUVkRGc2NsZHVaRlJTYkhCNFZUSndVMVpWTVhKWGEyUlZWbXhhZWxaWE1VdFNNVTV6WVVaYWFWZEhhRTFXVjNSaFpERktWMU51U21wU00yaFVXV3RhZDA1V1duRlRhbEpvVFd0YVIxUldhRTlXUjBwSFUyeHNWMkZyTlZSV01GcGhZMVpHV1ZwSGVGTmlSbkJoVmpKMGEySXhWWGhYYTJoc1VtMW9XVlpxVGxOaFJuQkZVbXh3YkZKdFVscFphMlF3VlRGYVNHVkdiRmRTYkhCWVdrUktWMVl4Vm5WVGJGcG9UVVJXV1ZkWGRHRmpNRFZ6WWtaYVYySlViRmhVVjNSM1YyeHNWbFpxVWxoaGVrWXhXVlZhYjFkck1YVlVhbEpYWVd0YVZGbDZSbmRTTVhCSVlrZG9UbE5GU2tsV2JUQjNaVVUxUjJKR1pGZFhSMmhXVmpCa2IyRkdWWGRYYTNSWFlrWnNNMWRyWXpWV01VcDBaVWhzVjAxcVZuSldha1pMWkVkV1IxZHNXbGRsYkZwNVZtMHhlbVZHWkZkU2JrNXBVbXhhY0ZWdE5VTlZWbHAwWlVkR1dsWXdNVFJYYTJoUFlVWktkRlZ1UWxkTlJuQk1XbFphWVdNeFZuSmFSbEpPVmpGS1dsWlhNVEJaVm14WFUyNU9hbE5GU2xoVVZWcDNWRVphUjFkdFJtcE5XRUpHVmxkNGQxWXlTa2xSYkd4WFZucEJlRlpxU2tkak1VNTFWbXhLYVZJeWFHaFhWbEpIWkRBd2VGZHJaRmhpVlZwWVZGWm9RMUpzV2xobFJUbFZZa1p3TUZwSWNFTlhSbHB6VTJ4Q1lWSkZXbWhXTUZwUFkyeGtkR05HVG1sV01taGFWakZrTUZsWFVYZE5TR2hYWW10d1dWbHNWbUZYUmxKWVpFZEdWR0pHY0VsWk0zQlhWbXN4Y2xkVVNsZGlXRko2Vm1wR1lVNXNTbFZSYkdoWFlraENXRmRzV21GVE1XUllVbXRvYWxKck5WaFZiWGgzVjFaWmVGcEVRbHBXYlhoWlZXMTBhMVl5U2tkWGJGSmFZVEpTVkZZd1dsTldNV1IxV2tkNFYySkZjRFpXYlhoVFZqRmFXRk5yWkdwU1JVcG9WV3RWTVUweFduRlNiVVpQWWtWd1dsZHJXbXRXTVVwWFkwUmFWMkZyU21oVmVrcE9aVlpPY21GSGFGTmhlbFpaVm0xMFlWbFdaRmRYYmxKT1UwZG9VRlZ0TVRSWFJscElaRWQwVjAxcmNIbFpNRnB2VjJ4WmVtRkZlRmRoTVhCNldUSjRhMlJXY0VobFJtUnBVbXhyZUZZeWVGZFdNREZIVjFoa1RsWnRVbkZWYlhoM1ZqRnNjMkZGVG1oU2JIQjRWVzB4UjJGck1YSk9WV2hhVmxad2FGbFZaRVpsUjA1R1lrWm9XRk5GU2tsV2JYQkxWRzFXUjFkdVZsWmlXR2hVV1Zod1YyUnNXa2RXYlRsU1RWWndXRll5TlZOVWJGcEhVMjFHVjJKWVRqUlVhMXBoWkVVMVZrOVdaR2xXVmxrd1YxUkNZV0l4WkhOWGExcHFVbXhLV0ZaclZtRmxiR3Q1WlVkR2ExSnJjSHBaVlZwcllWWmFjbUo2UmxkaVZFSTBXbGR6TVZZeFpITmFSbWhwWVROQ2VGWlhNSGhWTVdSSFZXeG9UMVpyTlZkVmJYaDNUVVp3VmxwRlpGWk5hMWt5Vm0xNGQxWXdNWFZoUjJoWFlXdGFURlp0TVVabGJIQkhXa1prYkdFeFZqTldiR2gzVXpGUmVWUllhRlppYkZwV1dXdGFTMk5HVm5GU2EzUldVbTFTV1ZwRldtdGhNREZXWTBod1YwMXFWa3hXYWtwTFUwWldjMkZHVmxkaVJuQTJWa2QwWVZZeVVrWk9WbHBRVm14d1QxbFVUa05UVm1SVlVXMUdXbFpzYkROVVZsWnJWakZrU0dGR2FGZGhNVnBvV1ZWYWMwNXNTblJTYlhSVFlUTkNObFpVU25wTlZsbDVVMnRzVW1KWGFGaFVWbVJTWkRGYVZWSnNXbXhTYkhBeFZsZDRVMkZGTVZsUmJIQllWak5TY2xaVVJscGxSMHBKVkcxb1UyRjZWbGxXVnpFMFpERk9SMWRZYkd0U1JVcFlWRmQwZDFOV1dsaE9XRTVYVFZWc05sbFZaRzlXTWtaeVYydDRWMkpHY0doYVJWVTFWakZ3UjFwSGJGTlhSVXBIVm0xMGEwMUdiRmRVV0d4VlYwZG9WbGx0ZUdGV1ZteHlWMnQwYWxKc1ducFpWVlpQVjBaYWMyTkVRbHBOUmxwTVdWUkJlR014WkhWalJtUk9ZbTFvTmxkV1pEUlRNVnB5VGxaa1ZtSkdXbGhaYTFwM1lqRmtjMXBFVWxkaVZscFpWbTEwYTFaWFNsaGxSbEphVmtVMVJGWXdXbXRXVmtaMFVteFdUbFp0ZHpGV1ZFb3dZVEZrU0ZOc2FHaFNiVkpoVm1wT1UyRkdXbkpYYkdSclVqRmFTVlZ0TVhkaFZrNUdVMnRzVjFaRmJEUlpla1pXWlVaa2RWWnNTbWxTTTJoWlYxZDRiMVV5UmtkaVNFWlRZa1Z3YzFWdE1WTmxWbVJ5VjIwNWFGWnJjREZWVjNoM1YwWmFjMU5yVGxWV2JIQmhXbFZhYTFkV2NFaFNiRTVUVmtaYVVWWnNZM2hPUm14WFdrWmthbEpzY0ZoWmJHaFRWMFpTV0dSSVpGTk5WM1F6V1ZWb1QxWXhXWGRqUldoWFlsaENWRlpxUm1GU2JHUjBZVVphVGxJeFNsbFdWekUwVmpKTmVHTkZaR0ZTTW5oVlZXeFdkMWxXV25STlZFSm9ZbFphU0ZaWE5WTldNa1Y1Vld4V1dtSllUWGhXTVZwelkyeGFWVkp0YkU1V2EzQllWMVpXVjFReFpFaFRhMlJxVTBoQ1dGWnFUazVOVm14WFZsaG9hbUY2VmxoWlZWcHJZVlprU0dGSWJGZGlXRUpNVlcweFYxWXhXblZVYkZwcFUwVktXVlpYZUZOV01ERnpWMnhvYWxKWFVsaFVWM2hMVTFaYVdHUkhSbWhOVlhCNldUQm9RMVp0U2xWV2ExSlhUVlp3YUZwRlZYaFNWa3AwWkVVMVYySnJTVEpXYlhCS1RWWlJlRnBGYUZOWFIzaHZWVzB4VTFkR2JGaGpla1pyWWtaV00xWXllRTloYXpGWlVXdG9XR0V4Y0ZCWlZscExWbFphY1Zkc1pGZFNWemgzVjFaU1IxZHRWa2RhU0ZaWFlrVndiMVJYZUV0WFZtUlhWV3RrV2xadFVraFdNalZIVlRKRmVsRnVUbFppV0ZJelZGWmFZVk5IVmtkVWJXaFhZVEozTVZkV1ZtOWtNVmw0VjFod2FGSXlhRmRhVjNSaFZrWnNObEp0Um10V2JFcDZWMnRrYzFZeFduVlJiRlpYWVRGd2FGZFdXbk5XTVhCR1drWm9hV0pGY0hwV1YzQkRXVlphYzFWc1dsWmhNbEpVV1d0a05GWXhXbGhqZWxaWFRWWndlbGt3YUhkV01ERjFWVlJDVjJGcldtRmFWekZIVTBkR1IxcEZOVk5OVlhCV1ZteFNSMkV4VVhoVFdHaGhVMFUxYUZWcVNqUldSbXgwWkVWMFZFMVdjREJhVldSSFlVVXhSVlpyYUZkaVIyaHlWa1JHWVdSSFJrZGhSbkJYVWxoQ1ZWWnFSbUZqTWs1elYyNVdZVkp0YUZSWmEyaERUbXhhY1ZOVVJtaE5WbkJKVlRKMGEyRnNTbGhWYkdoYVlrZG9kbGt5ZUdGV1ZrWlpZVVprYVZJeFNYaFhWRUpoV1ZkR1YxcEZhR2hTZW14WVdWUktVazFHV2tWU2EzUnFZWHBXV0ZkcldtOWhWa3B6WTBac1YySlVSVEJhUkVwS1pVWmtjMXBHV21oTmJFcFpWa1phYTFVeFpGZFdXR3hyVW0xU1dGbHNWbmRTTVd0M1lVVk9WMkpWY0VoWk1GSlBWakF4UjJOSGFGZE5SbFkwVmpGa1QxSnJOVmRhUjJ4VFYwVktZVlp0ZUZOVE1EVkhWMWhzVTJKSFVsVlphMXAzVlVaYWRFMVdUbGhTYlhoNldWVmpOV0ZHU25OalJWcFdZbFJXVUZaRVNrdFNiVTVKWWtab2FFMVlRbmxYVmxwaFV6RmtWMUp1UmxkaVIxSllWV3hqTkdReFpISlZhMlJhVmpBMWVWUldWbk5oVmtsNVlVWldWazFHV2t4V01WcGhaRVV4VlZWdGRFNVdNVXBKVm0wd01WSXhWWGxTV0hCV1ltdGFZVmxyV25kaFJsWnhVbXh3YkZZeFdrZFVNV1J2VlRGYVJsZHJkRmRXYlZFd1ZsUkdXbVZXVG5OaVIyaFRUVzFvV1ZkV1pEQmtNV1JIWWtSYVUySlZXbkZVVm1oRFUwWmtjbHBIT1ZWaVZYQkhXVEJhVjFZd01WaFZXR1JYWVd0YWNsa3ljM2hXTVhCSVkwWk9hVk5GU2xwV01WcFRWREZWZUZkWWFHbFRSWEJaV1cweFUxZEdVbGRYYms1UFZtNUNSMVl5TVRCV01ERlhZMGhzV2sxR2NIWldha0Y0WkZaV2RWZHNaR2xYUjJob1YyeGplRkl4U25SV2EyUmhVakpvVDFadGVGZE9SbHAwVFVob1QxSnNiRFZXUm1odlZUSktjMU51VGxaaGEyOHdXVEJhVjJNeVJrWlViRnBwVW01QmQxZHNWbXRTTVdSelYyNU9hVkpHU2xkVVZtUnZaR3hhYzFwRmRHcGlWVFZLVmtkNFlXRldTblZSV0hCWFlsaFNhRmw2Um1GV01VcDFWbTFHVTJKSVFsQldiVEF4VVRBMWMxZHVUbHBOTWxKUVZtcENkMU5XVlhsa1IzUm9Za1Z3TUZsVldtOVhiVXBJWVVaU1drMXVhR2hXTUZWNFZtMVNSMVJ0YkZOTlZYQllWbXhqZDJWR1NYaFhXR2hZWW1zMWNWVnNVa2RYUm14eVdrWktUbEp0VWxoV01qRkhZV3N4V1ZGcmNGWk5ibWhFVm1wS1MxSXlUa2RXYkdScFZrVkdORlpXVWt0V01WbDRXa2hPWVZJd1dsUlZiWFIzVmxaYVIxZHRSbXROUkVaSVZqSjBhMkZHVGtoVmJHaFhZV3RLTTFWcVJuSmtNV1IwVDFaa1RtRXpRa2xYVkVKVFZERmFkRkpZYUdwU01taFlXVmQwZDFOR1ZYaFhiRTVxWVhwc1dGWkhNVzlpUjBwSFkwVjBWMkpZYUhGYVZWVXhVakpLUjFwR1pGaFNNMmhWVm1wQ2EySXlUbGRXYms1V1lrZFNXRlJXWkRSbFZsbDVUVlZrYUZKcmNIcFdNbmhoVm0xS1dXRklTbGRoYTFwb1dYcEdUMk5XUm5OV2F6VlhZbXRLVGxadGRHdE9SazE0Vkd0a2FsSkdjRk5aYTJSVFZERnNkR1ZGZEZoV2JIQmFXVEJXYTFZd01YSk5WRkpZWVRKb1VGWnFTa3RYUjBaSFZteGFUbEpzY0UxV2FrSmhXVmRTUmsxV1ZsWmlTRUpZV1Zod1YxTldXblJOVkZKcFRXdHdTRlpIZEd0aGJFNUdZMFphVjJKWWFGZGFWVnBhWlZkV1NGSnNVbE5OVm5CSVYydFdZV0V4VW5OWGJsWlNZa2Q0V1ZaclZrdFhSbHBWVW14d2JGSnRVakZXVnpGdlZrWk9SbE5zWkZoV2JFcElXa1JHVDFJeVNrVlhiRTVvVFRGS2VGWkdXbXRWTWxaelYyNVNiRkl6VWxkVVZscDNUVlpXV0dWR1pGZE5SRVpZV1RCa2IxZHRSbkpqUlhSaFZsWndURll4WkVkU01YQklZa1pPVGxaWVFtRldha1poVlRGTmVGWllhRmhpUjFKWVdXMXpNV0l4Vm5WalNFNVhVbXhLV0ZZeU1VZFViRXAxVVd0a1YySllRa1JXYWtwSFRteEtjMkZHY0U1U2JrSXlWbTB3ZUZNeFNYaFViazVTWWtkU2NGVnRlRnBsYkdSeldrUlNVMDFYVWxoWk1GWnJXVlpKZVdGRk9WZE5SbHBNVlRKNFlXUkZNVWxoUlRsVFlYcEZNVlpyV205aU1WVjVVMjVLYWxKVWJGaFpiR2hPWlVaWmQxZHRSbXRTVkZaWFZrZDRUMVl5U2tsUmFscFhZV3RzTkZWcVJscGxWa3B4VjJ4a2FFMXVhRmxXVnpCNFlqSlNjMWR1UmxSaE0xSlVWRmR6TVZOR1dsaGxTR1JYVFZWd1YxbHFUbmRXTWtwSFUydG9ZVkpGV21GYVZscExZMjFHUjFGc1pHaE5NRXBSVm0wd2VFNUhVWGhhUm1SWVlteEtUMVpyVmt0aU1WSlhWMjVrVkZKc1ZqVmFWV2hQWVVaS2NtTkdiR0ZXVm5CMlZtMHhSMk5yTlZkVmJHUlRWbTVDYjFacVFtdFdNVTVIVTI1U2ExSnJOWEJWYkdNMVRrWlplRlZyVGxwV2JYaFlWakZvYzFaSFJYbFZia1pXWWtkUk1GWXdXbUZrUlRGWFUyczFVMkpJUWxkV1ZscFRVakZrUjFOdVRtcFRSM2haV1ZSR2QyRkdiRmRYYTNSWVZtdGFlbGxyV210aFZtUklZVWM1V0dFeFNraFdSRVpLWlVad1NWTnNhR2xTTVVwM1ZsZHdSMU14V2xkWGEyUllZa2RTWVZacVJtRmxiRnAwVGxVNWFGSnJOVWxXVjNoclYyMUtSMWRzYUZWaE1YQlhXbFprVjFKc2NFZGFSbVJwVTBWR00xWnRlR3RPUmxWNFYyNU9XR0V4Y0ZsWmEyUnZWMFpzV0dSSFJtaFNiSEI2VmpKNGEyRXhTWGRPVldSVllrWndjbFpxU2t0amJFNXpZMFprYVZkSGFIaFhiRlpXWlVaSmVGVnNiR2hTYldod1ZXcEtiMWRXWkZoa1IzUlBVakJzTkZadE5WTmhiVlp5VjJ4b1ZWWnNjRE5VVlZwM1ZteHdSbHBHWkZOaE0wSTJWbXBKTVdNeFdYbFRiR3hTWWtaS1dGWnJWbmRVUmxaMFRWVTVWRll3Y0VoV01uTXhZVmRLV0dGRk5WZGlWRVl6VldwR2EyUkdXblZVYkdScFlURndXbGRYZEd0Vk1rbDRWV3hrVjJKdFVsUldiWGgzVjFacmQxWnRkRlpOUkVaNVZGWlNVMVl4U2paV2EyaFhZV3R3VEZZeFpFZFNNVlp6V2tkc1UwMXRhRVpXYlRFd1dWWnNXRlZyYUZkaE1sSm9WVzAxUTFkR2JGbGpSVnBPVW14d2VsZHJVa05YYkZwellrUlNWMDF1VW5KV01HUkxVbXMxV0ZKc2NGZFNWbkJ2VjFaV1lWbFhUbGRUYmxKclVtMVNXRmxyVm5kT1ZscEZVbTFHV2xZd1dsaFZNalZYVlcxS1NHRkdhRnBXTTFJeVdrUkdZVkpXU25OalIzaFRZa1Z3TlZkV1ZtdE5SMHBJVWxoa2FsSnRlRmhaYkdoRFZVWnNjVkpyT1ZOTlYxSXhWbGN4TkZVeFpFZFRibWhZVmpOU2FGZFdaRmRXTVZaeldrWm9hR1Z0ZUZsV1JscGhaREF4VjFac2FHdFNiVkpZVkZkMGQxTkdhM2RhUnpsWFRXdGFlVmt3V205WlZrcFhZMFpTVjAxWFVraFZha1ozVTBkS1IxUnRiR2hOU0VKWVZtMXdSMkV3TlVkV1dHaFVWMGQ0VmxsVVNsTmpSbFowWlVkR1ZrMVhlREJaTTNCSFlXc3hXR1ZJYkZkTmFrWklWakJhUzJNeVRrVlJiVVpUVmpGR00xWnRNWHBsUmxwMFUydFdWbUpIVWs5WlYzaGhUbXhhZEUxWWNHeFNiVkpKVlcxMGExVnRTa2hWYkdoVlZrVndkbGxxUm1Ga1JURlZWVzFvVG1KRmNFaFdSRVpoWVRKR2MxTlliR3hTYkVwaFdWUktiMUpHV2tkWGJIQnNVakJhU2xkcldrOVViRnBZWkhwQ1YyRnJhM2hXUkVaaFUwWk9kVk50Y0ZOaVZrcG9WbXBDYjFFeVZuTlhia3BZWWxWYWNWUldhRU5TYkZwWVkzcFdhRlpyY0RGVlYzaHpWakpHY21KNlFscFdSVnBYV2tSQmVGWXhaSE5oUjJ4cFlUQndXbFpzWkhkVU1rbDRWMnRrYVZORmNGbFpWRTVUVjBac2MxWlVSbFJTYkhCSldsVmtNR0ZHV25KalNIQmFUVWROTVZacVJscGxiVVpJWVVaa1YxSldjRTFYV0hCSFlUSlNWMVJ1VWxOaVJUVnZWRlJDUzAweFduTmFSRkphVm0xU2VWUldXbXRYUjBWNVlVaE9WbUpVUmxSV01GcFRWakZrY21SR2FGTmlSbGt4VjJ4V2ExSXhaRWRUV0dSWFlXczFWbGxyV25kamJGcHhVMnQwV0ZZd1drbFpWVnByVlRGS1YyTkVXbGRTZWtVd1ZYcEtUMk15VGtaYVIwWlRUVzVvVlZacVFsZFRhekZYVjI1T1ZtRXpVbEJWYlhONFRsWlZlV1JIZEZwV2EzQlpXVlZqTlZadFNrZGpSWGhYVFVad2FGcEZaRmRUVm5CSFlVWk9hVk5GU2toV2JHTjRUa1pSZUZkWWJGUmlSMUpaV1ZSS1UxZEdVbGhPVnpsV1VtMTRWMVpzYUc5V1JscHlWMjV3VjFZemFISlpWbHByVTBkR1IyRkdhR2hOVlhCRVYydFNTMVl4U1hoWGJrNXBVak5DVkZSVVFrdFdiRnBWVVd4a1ZFMVdXbGhXTW5SclYwZEtTRlZ0UmxkaVdHaDZWR3RhWVdSRk5WZFViV2hPVmxkM2VsWnFTalJoTVZwWFYyNU9XR0pIYUZaWmJHaHZaV3hhZEdWSGRHcE5XRUpJVjJ0a2MxVXlTbkpUVkVwWFlsaENURlJWWkVwbFJtUlpZa1pPV0ZJeWFGcFdiWFJYVXpGWmVHSklUbWhTZW14V1ZXMHhNRTVXY0ZaV1ZGWm9ZWHBHVjFSc2FIZFhSMFY0WTBoS1YxWkZSalJhUlZweVpXMUtSMXBIYkZkU1ZsWXpWbXBHWVZsV1pIUldhMlJWWWtkNGIxVnRjekZqUm14WlkwWmtWMVp0VWxoWGExSlRWMnhaZDAxVVVsZGlWRlpRVm1wS1MyUkdWbk5hUmxaWFlraEJlbGRzWkRSWlYxSkdUVlphWVZKdFVsaFphMmhEVG14YVZWTnFRbWhOVm13MVZUSjBhMVpIU2toaFJtaFhZbTVDU0ZaRldsZGtSMVpJWkVkd1RsZEZTa2xXTW5Scll6RlZkMDFZVW1oU2EzQllXV3hvYjJOc1VuSlhiazVYVFZkU01WWkhNVWRXUmtwWlVXeHNXRll6YUZoWFZscHJVakZrZFZWdGVGUlNNVXBYVmxjd2VGVXhaSE5oTTJSWFlsaFNWMVJWVWtkWFJtdDNZVWhrVjJGNlJuaFdiWFEwVmpKRmVWVnJlRlppV0UxNFZtcEtSMUl4WkhKT1ZrNXBZVEJ3VDFadE1UUldNV3hYWWtaa1dGZEhhR2hWTUZVeFlVWldkR042UmxWTlZuQjZWbGQ0YTFReFduUlZibkJYWWxob2NsWXllR0ZqTVZweFZteGFhVkl5YUhsWFZtUTBVekpPY2s1V1pHaFNia0p2VkZkNFMxWkdaSEpWYTJSclRWZFNTVlp0ZEc5Vk1rcEdUbFpvV2xaRldqTlViRnBhWlZkU1NGSnNVazVoTVhCWlZsUktOR0l4VmtkVWEyaG9VbTE0WVZsVVJuZGhSbGwzVjJ4a1QySkZjSHBYYTJSM1ZHeFplRk5xV2xkaGEyOHdXV3BLUjFOR1duVlRiR2hwVWpGS1dWWnRjRTlpTWtaSFYyNUdVbFpGV2xSVVZscDNaV3hzVmxwRVVsWk5WbXcwVlRKNGMxZEdXWHBWYldoV1pXdGFjbGw2Um10amJVWklaVVpPV0ZKcmNGcFdhMXBoV1ZkUmVGcEZaR2hOTWxKWVdXdFZNVmRHVWxkWGJtUlRUVlpzTlZwVlZrOVdNVmwzVm1wU1drMUdXblpXTWpGWFkyeGtjbVZHY0d4aE1YQjVWMWh3UjFVeVVraFNhMXBQVm0xU1dWVnNWbmRWYkZwMFRWUlNhRTFFVmtoV01XaHZZVlpLZEZWc1VsZE5SMUoyVmpCYWMyUkhUalpTYld4T1ZteHZkMWRVVG5kU01WcHlUVlprVkdKSFVsaFdibkJYVkVaYVNFMVZkRlJXYTFwNVYydGFhMVJ0U25SaFJrWlhZbFJDTkZWNlJrcGxWbEp5V2tkR1UySldTbEJYVnpCNFlqRk9WMWR1VW14U01GcFZWRlphYzA1R1pISmhSWFJvVW10d2Vsa3dXbTlXVmxwR1kwaGFWazFXY0doYVJWVjRVMWRHUjFadGJGZGlTRUV5Vm0xNGFrMVdVWGhYV0d4VVlUSm9WMWxyWkc5WFJteHpWV3hrVTFKc1ducFdNakZIWVdzeFdGVnFRbFZOVjFJelZrZDRTMUl4WkhKaVJtUlhaV3RHTkZaclVrZFdiVlpYVkc1S1lWSXpRbFJaYTFaM1lVWmtXR1JIZEZaTmJFcDZWakowYjJKR1NuUlZia1pYWWxoU2FGWnRlRmRrUjFaR1pFWldhVkp1UWpaWFZFSmhZekZaZVZOc1ZsTmhiSEJXVm0weFUxTkdhM2xqTTJoWFRWZFNlbGxWWkhOVk1ERldZMFpzVjAxWFVUQlpha1pXWlVaV2NscEdhR2xoTTBKdlZsY3dlRlV4WkZkWGJrWlNZbFZhVlZWdGVHRk5SbkJXV2tWa1YwMUVSbmxaTUZadlYyc3hSMWR1Y0ZkaGExcG9WRzE0UzFkV2NFZFdiV2hPVjBWS1RsWXhhSGRTTWtWNVZXeGtWV0pyTlZkWmJHUTBWa1paZDFacmRGaGlSbkF3VkZWb2IxUXhTblJsUm1SVllrZG9VRll3WkV0VFJsWnpZa1p3YUUxc1NsVldiWFJoVlRGWmVGZHVVbE5pV0dod1ZXMDFRbVF4WkZWUmJVWm9UV3RhV0ZVeU5VdGhiRXBHVTIxR1YySkdjRE5XVlZwaFkxWk9jbVJHVGs1V01VbDNWMVpXWVZsWFJraFNXR2hxVW14YVdGWnVjRVpOUm1SWFdrVTVhazFyTlVkWGExcFRZVlpaZW1GR1ZsZGlWRUY0VlZSR2EyTXhaSFZWYlhSVFRVWndkMVpHV21GU01EVkhWMjVTVDFaVWJGbFZha0ozVTBacmQxZHVUbGhpUm5CSFZXeG9iMVl5Um5KWGJuQmFUVzVvYUZac1drZGphelZYVkcxc1dGSXlhRnBXYlRGM1V6QXhTRkpZYUZoWFIzaFZXVlJHZDJOV1ZYZGFSRkpZVW14S1dWUnNWVFZVTVVwelkwWmFWbUpVUmtoV2FrRjRZMnMxVmxwR1pGZE5NbWg1Vm0xd1MxTXhUbGRTYmxKUVZtMW9XRmxzVlRCTlJscHlXVE5vVjAxVk5VaFdSelZMV1ZaS2RHRklRbFppUmtwWVdrZDRZVkl4V25SUFZrcE9WbTVDV1ZacVNURlVNVnAwVW1wYWFWTkZTbFpXYlhoaFYwWlNjbGR0Um10U01WcEpXa1ZhYTFSdFJYaFhWRVpYWWtkUk1GbDZSbUZrUms1eVlVZG9WRkp1UWxoV1JsWmhaREpXYzJFemJHeFNNRnB4V1d4YVMxTkdXWGxOV0U1V1RXdHdlVlV5ZUhOV01rVjRZMGRvV21GcmNGTmFWVnByWkZaU2MyRkhiR2hsYkZwaFZqRmFVMU15U1hoWFdHaFlZbXRhVmxsc1VuTldNVlowWlVoa2JGWnRVbmxXTWpFd1Ztc3hjbU5GWkZWaVIyZ3pWbTF6ZUdSWFJrbFRiR1JvWVRGd2IxZHJXbUZTTWs1elkwVmtZVkl5YUU5V2JUVkRWMnhhZEUxWVpGTk5WVFV3Vm0xMGExWkhTbk5YYkZwYVlURlZlRmt3V2xka1JUVldWR3hrVGxadVFqUldWbVEwV1ZaU2MxZHVUbGRoYkVwWVZGZHdWMVZHV25GVGEzUlhZa2RTZWxaSGVGZFdNa3BKVVcwNVYyRnJiekJaZWtwUFl6RmFkVlJzVm1sU2JrSjNWbTE0YjFFeFRrZFhia1pVWVd4S2IxUldXbk5PUmxWNVRsVTVWMUl3Y0VsWlZWcHZWakpGZUZkcVRsWk5SbkJoV2xWYWQxSnNjRWRVYld4VFlUTkJNbFp0Y0V0T1IwVjVVbXhrVkdKc1dsTlpWRTVEVjBac2NscEdTbXROVm5Bd1dUTndSMVl5UmpaV2JIQlhWak5vV0ZsVlpFdFRWa1owVDFaa1YyVnJWak5YYTFKSFlURkplRnBJVmxWaVIyaHdXV3hhUzFac1dsaE5WRkpyVFZkU1dGa3dWbUZXTVZwSFYyeGFWVlpzV2pOYVZscGFaVlUxV1ZwR1pHbFdXRUpoVjFaV2EySXhXWGhYYTFwcVVsZG9WbGxzYUc5aFJtdDVZM3BHVjAxWFVqQlphMXBQWVVVd2QxSlliRmRpV0dob1ZsUkdTbVZHWkZsaFJtaFlVakpvV2xkWE1UQmtNVlpIVjI1R1ZXRXdOVlpVVmxwM1pXeFplVTVYZEZoU2EzQjZXVEJhYzFaV1duTlRhMUpYWVRGV05GWnFTazlTTWtwSFdrZHNXRkl5WnpKV01WcFhXVlpOZVZWclpGZGlhelZvVlcweFUyTkdXWGRhUnpscFRWWndWbFZYTVVkV01rcFhVbXBTVjAxcVZraFdiVEZMVW1zMVdWRnNXbWxTTW1oRlZrZDRZVmxXV2xkVWJrWldZa1pLVDFadE1UTk5SbHB4VTJwQ2FVMXJXa2hWTW5ScllXeEtkR0ZHYUZwaVIyaDJWRlJHV21ReFpITmFSM0JYWVROQ05WWXlkR3RrTVZKelYyeHNVbUZzU2xoWmJGSkRUa1pTY2xkc1dteFNiVko2V1d0YVMyRldTbkpqUm14WVZqTm9kbGxxUmxwbFJsWnpWMnhrV0ZJeWFIaFdSbHBoWkRKV2MySkdXbUZUUlRWWFZGWmtVMUl4VlhsT1Z6bFhUVlZ3ZWxZeU5VdFdWMFY0Vm1wU1YyRnJXbkpaTWpGSFVtczVWMXBGTlZOaWEwbDVWbTEwWVZsWFJYaFdXR2hVVjBkb2IxUlVTbE5pTVZaeldrWk9XRlpzV25oVlZ6VnJWa1phZEdWR1pGZE5ibEpRVm1wS1MxWnNXbkZXYkdSWFRURkdNMVl4V21GWlYwMTRWMnhzYUZKdFVuQlZiVFZEVTFaa2NsWnRSbFJOYXpFMFdUQldiMkpHU1hsbFJsSmFZVEpSZWxSWGVHRmtSMVpIVkd4T1RtRXhXVEZXYkZwdll6RmFjMXBGYUdoVFJVcFhWRlZhWVUweGEzZFhiRnByVFZad1ZsVnRNWGRoVmtweVkwWndWMUpzY0ZSV1ZFcEhaRVpPY2xwSGJGTlNWRlpaVjFkMFlWTXhUa2RpUm1ocVRUSm9XRmxZY0ZkWFJtUnlWMjVrVjAxV2NIcFdiR2h2VmpKRmVWVlVRbFpOYWtaVFdrUkJNVll4V25OVGJXeFVVbFZ3TWxacldtdE9SazUwVm01T1lWSnRVbGRaVkVwVFZsWlNXR1ZGZEZoU2JYUXpWbTAxVDFadFNsWmpSV2hYVFdwV1VGWXllR0ZTYkdSMVlrZEdVMUpXY0hsWFZFbzBZVEpTUjFOdVVtbFNWRlpZVm10YVlWTldXbkphUkZKYVZteHNORll5ZEc5V1IwVjVaVVpPV21FeVVUQldha1p6WTJ4d1IxTnJOVk5pYTBwSlZtcEplRkl5Um5KTlZtaHJVa1p3WVZac1duZGpiRnBJVFZWYWJGSXdOVWRaYTFwdlZqSktSbU5HUmxoaE1VcElWMVprVG1WR2NFZGlSMnhUWWtoQ2QxWlhlRzlSTVdSWFYyNVNhMUp0VWxWVVZscExVMFphV0U1Vk9WaFNNSEJhVmxjMVIxWldXWHBWYldoV1lXdGFjbGt5ZUdGV1ZrcHpXa1UxVTFKV2NFcFdNVkpEWVRGSmVGZFlhRmhoTVhCd1ZXdGFTMVpzYkZWU2JtUlhVbXhhZUZWdGREQlhSbGwzWTBWb1YwMXFSblpaVmxwTFpGWkdkRkpzWkU1V01VWXpWMVpTUjFadFZrZFZia3BoVWpKNFZGbHNaRzlWUmxwMFRWaHdUbFpzY0VoV2JUVlRWR3hhUmxOc1FscGhNWEJvVmpGYWQxWnNXbkpQVm1SWFRVaENTbFpzWkRCak1XUklVbTVLVDFkR2NGaFVWV1JUVWpGd1YxZHNUbXBXYkZwNlZqSXhiMkZGTUhkVGJIQlhZbFJDTTFwVldrNWxSazUxVld4T2FFMXNTbGxYVjNoclRrZEplR05HYUd4U01GcHdWRlphZDAxR2EzZFdhemxYVFd0Wk1sVnRlR3RXVjBwSVlVWkNWMDFIVWtkYVZtUkhVbXM1VjFwSGJGTk5WWEJXVmpGU1MwNUdXWGxWYTFwUFZteHdWbGxyWkc5alJsWjBUbFZPVkZac2JEVmFSV1F3Vkd4S2MyTkljRmROYWxaUVZtcEtSMk5yTlZkYVJsWlhaV3hhUlZacVFtRlhiVkY0WTBWYWExSnNTbFJVVlZwM1UwWmtWMVp0UmxkTlZtdzFWVEo0YTFaSFJYbGxSbWhhVmpOU2FGbFZXbUZTVms1elZHeFNVMkpJUWpWV2FrbDRUa1pWZVZKWWNGSmlSVXBaVm1wT1UxZEdjRVZSVkVaVFRWZFNXbGxWWkVkVk1VcFdZMGhhVjFKc2NGaFpla0V4VmpGa2RWVnJPVmRoZWxaWlZtMHdlRlV4VGxkalJscFlZVEExV0ZSWGRHRmxWbXQzWVVkR1dHRjZSa2haTUdSdlYyc3hWMk5GZUdGU1ZuQk1XVEp6TlZkSFNrZFViR1JUWWtacmQxWnRjRWRoTURGSVUxaG9WVmRIYUZkV01HUlRWREZhZEUxWE9XbE5WbHA2VjJ0U1UxWXlTa2hsU0d4WVlURndVRlp0ZUV0a1IxWkhZVVpvYUUxV2JETldiWEJDWlVkT2RGTnJWbGhpU0VKWVZtMDFRbVZzWkZkWGJVWmFWbXR3ZWxkcmFFOVZNa3BJVld4U1dtRXhjRE5hVmxwaFYwZE9SbHBIYUU1V1dFSTFWa1JHWVdFeVJsZFRibEpXWWxSc1ZsWnJWa3RVUmxwelYyMUdVMDFYZHpKVmJURnpZVWRXY2xkcVdsZGhhMnQ0VlhwR2EyTnJNVWxpUmxwcFVsVndXVmRYZEdGVE1VNUhWbGhrV0dKSVFuTlZha0poVTJ4YVNFMVhPVmROYTFreVZtMTBjMVl5Um5KaE0yaFdWa1ZhY2xwRldrOWpiSEJJWTBaT1RtSlhhRmhXTVdRd1dWZFJlRlZZYUdwU1ZscFZXVlJLVTFaR1VsZGhSVTVVVm01Q1YxZHJhRTlXTVVweVkwWmtXazFIVW5aV2FrcExVakZPY21GR2NHaGhNWEJJVjJ4V1lWVXlVbGRWYms1WFlsZG9UMWx0TVc5WFZsbDRXa1JTYVUxVlZqUlphMXByWVZaT1JrNVhhRlpoTVhCTVZsUkdVMVl4Y0VkVWJYaFRZa1paTVZkVVRuZFdNa1pHVFZaYWFsTklRbUZVVldSdlpHeGFkR1ZIUms5aVJYQmFWMnRhYTFSc1NuVlJhekZYWVd0YWFGVnFSbXRYUmtweVdrWm9hR1ZzV2xsWFYzUnZVVEExVjFkdVJsTmlWVnBZV1d4YVlWTkdaSEpXYlhSWFZqQndlbFl5ZUd0WGJVVjRZMGRvV21GclducFdiRnBIWkZad1NHUkhiRk5pYTBZelZtdGtOR0l5UlhsU2JrcE9WbFphVkZsclpHOVhSbFp4VkcwNWFGSnNjSHBYYTFZd1ZqRlpkMk5GY0ZaV00yaG9XVlZrUm1WSFRrWk5WbVJUWWtad2IxWXhXbXRWTVVweVRsWmtZVkl3V2xSVVZ6RnZWVVphZEdWSFJsaGhla1pZVjJ0b1MxWXlTbGxSYXpsWFlsUkZNRll3V2xwbFYxSklVbXhvVTJKSVFraFdWRWw0WWpGYWRGTnNiR2hTTW1ob1ZtcE9iMWRHYTNsbFIzUnFZa2hDU0ZsVldrOWhWMFYzWTBWc1YwMVdTa1JYVmxwV1pVWmFXV0ZIUmxOV2JrSldWMVprTkdReFpFZFZiR2hQVm1zMVdWVnRNVFJsUmxaMFpVaGthVkpzY0hwWk1HaDNWMnhhVjJOR1VscFdiVkpIV2tSS1QxSXhWbk5hUjJ4WVVsVndUbFl4WkhkVE1VbDRVMWhvWVZKdGVHaFZiVEZ2WTBac2MxZHJkR3hTYkhCSVZqSXhNRlF4U2xWU2EyaFhWbnBXVUZZd1pFWmxiRlowVDFaV1YySklRalpXUjNSaFZqSlNTRlJyWkdGU2JXaHdWbXhhV2sxV1pGZFdiVVpwVFZkU2VsWXlOVk5XYlVWNllVWm9XbFl6VW1oWk1uaHlaVVprZEZKdGNFNVdia0kyVm10amVFNUhSa1pOVm1oUVUwZDRXRmxYZEhaa01XUlhWMjVPV0ZKc1NqRldWM2hyWVZaSmVXRkdiRmhXYkVwSVYxWmFZVkl5U2tsVWJHUnBWbFp3V1ZaWE1UUlRNV1JIVjFoc1QxWXdXbFpaYkZaM1UwWlplRlZyZEZkaVJtOHlWVlpTUjFZeVJuSlNhbEphWld0YWNscEdaRTlTTWs1R1RsWk9hV0V3YTNsV2JUQjRUVVpzV0ZKWWFGUlhSMmhvVlRCYVlWVXhiSEpoUlU1cVVteGFNRnBWYUd0aFZURlhZMFZvVjJKVVJraFpWVlY0WTJzeFZWVnNaRmRsYkZwWlZtMTBhMUl3TlhSVGExcFFWbTFTYjFsVVRrTk5iRnBWVTJwU1dsWnJOVWxXVjNSdllURkplV0ZGT1ZkaVJrcFlWRzE0WVdOc2NFVlJiR1JPVm14d05sWnFTakJaVmxGNFYyNVNiRkp0VW1GWlZFcFRWa1phUlZKdVpGZGlSMUo2VlRJeE5GVXlTbGRUV0dSWFVrVmFhRlpVUmxabFJtUnlXa1pvYVZORlNsbFhWbEpMVkRBMVIySkVXbFJoTWxKWVZGWmtVMDFXV2xobFJVNVhUVlZ3ZVZrd1duZFdNa3BWVm1wT1ZsWkZSWGhWYWtaclkyeGFjMU5zYUZOTmJXaFhWbXhqZUUxSFVYbFdiazVwVW14d1dWbFVRVEZYVmxaMFpFaGtiR0pIZEROV2JYQlRWakF4VjJKNlNsZGlXRUpRVm1wS1IyTnRUa1pQVjBaWFZqRktUVlpVUm1GVk1sSkhVMjVPVldKWGVGaFpWRTVDVFd4YWNWSnRkRTlTYkd3MFdXdGFhMWxXVGtaT1ZteGFWa1Z3ZGxreWVGZGtSMDQyVW0xc1RsWnVRalpXYkdRd1ZERlJlRk51VG1sU1JscGhWRlZhWVdOc1dYbGxSMFpxWWxVMVNGZHJXbGRoVmtsNVlVYzVWMkZyYnpCWFZsVXhZekZPZFZOdGRGTk5SbkJaVmtaU1MySXlTWGhhU0VwWVlsVmFZVlpxUmt0VFZscFlaRWQwVjJKVmNFZFViRnB2Vm0xS1IyTkliR0ZXYkhCb1dYcEdWMk5zY0VkYVJUVm9UVzVqZDFadGNFZGlNazE0VjFoc1ZHSnJjRkJXTUZaaFZqRnNjMVZyV2s1U2JIQjZWako0ZDJFd01WZGpTR3hoVWxad1ZGWkhlR0ZqTVdSWlkwWm9WMkpHY0c5V2ExSkxVakZPUjFSdVNtaFNNMmhVVld4V2QyRkdaRmRWYTJSYVZteEtTRmRyV210V01XUklZVWhHVlZac1ZYaGFWVnBYVjBkV1NGSnRhRmRpU0VKSlZtcEtkMWxXV1hoWGExcHBaV3RLVjFSWGNFZFhSbFYzVjJ4T2FtSlZjRWxWYlhoUFlWZEZkMk5FVGxkaVZFVjNWbXBHYzFZeFpISmFSbWhZVWpOb2VGWlhlR3RWTVZWNFZXeGtXR0p0VWxWVmJYaGhUVVpTYzFkck9WaFNhMnd6VmpGU1MxWnRTbFZXYTFKWFlXdHdURlpzV21GamJGWnpWbXhrVTFadVFqVldiWEJEVm0xV1IxUnNhRk5oTWxKWldXeGtORmRHV25GVWJYQnJUVlpzTkZZeWVFOVdWVEZ5VFZSU1YySllVbkpXTUdSR1pVZE9SMkpHY0dsWFJrcE5WakZhWVdNeVRYbFNhMmhRVm14YVZGbHJWblprTVdSelZtMUdWVTFXVmpWVk1uUnJWa2RLZEdWR2FGWmhhelYyVkZSR2MxWnNXbGxoUjNCWFRVWnJlVlpYTVRSaE1WVjNUVWhzYUZOSGVGbFdhazVEVkVaV2NWSnNjR3hTYmtKSVdXdGtiMVV5U2xkVGJtUllWak5TYUZwRVJscGxSbVJ6WVVkNFUySklRbEJXYlRFd1pERk9SMWRzYUd4U00xSmhWbTEwZDFac1duUk9WVGxYVFd0d1dsbFZVazlXVmxwelkwaHdXazF1YUhKYVJscFRZekZ3U0dGSGVHaE5WM2N3Vm0weE1GbFhTWGxWV0doWVYwZFNUMVpzWkZOWFZteDBaRWRHVjJKR2NEQmFWV2hyWWtaYWRWRnNhRmROYmsweFdWUkdZV05zWkhWalJscE9ZbTFvZVZaclkzaFRNVXAwVkd0V1ZHSkhVbkJXYTFaYVpXeGFXR05GZEZWaVZscFlWa2MxVjFaWFNrZFhiR3hXWVd0YVRGbHFSbUZYUjA1R1ZHeHdWMDFFVmxsV2JUQXhVakZXZEZOdVVsWmhlbXhYV1d4b2IwMHhXWGRYYms1WFlrWndlVlF4V210Vk1ERkpVV3RvVjFJemFGaGFSRVphWlVaa2NWZHNUbWhoZWxaWlZrWmtkMUl4VWtkWFdHUmhVbTFTVkZscldrdGxiR3hXV2tjNWFGSlVSa3BWVmxKTFZqSktTRlZZWkZoV2JIQkxXbFphVjJOc1pISk9WbVJwVmpKb01sWnNZM2RsUmxWNVZGaG9hVk5GY0ZsWmJURlRWVVphZEdWSVpHeFdiSEF3VkZab2EyRldTbkpqU0hCV1lsaENXRlpxUm1GT2JGcHpWV3hrYVZaRldrMVdWRUpyVWpGSmVGSnVUbUZTTW1oUFZtMDFRMVJzV25OaFNHUlRUVlpzTkZZeWVHdFdiVXB5WTBaQ1YySkdTbnBXTUZwelYxZE9SMXBHYUZOaVNFSTJWakowVTFFeFpITlhiazVUWVdzMVZsWnRlSGRrYkd4V1YydDBXRkl4V2toV01uaDNWakZLV1ZGc1ZsaFdSVzh3Vm0weFYxZEdXbkpYYkdocFYwWktVRlp0ZUc5UmJWRjRWMnRvYkZJd1duSlVWbHBMVFVaV2RFNVZkRmhTTUhCSldsVmFiMVp0U2xsaFIyaGFUVzVvYUZac1drdGtSMUpIV2tVMVYyRXlPVFJXYlRCNFRrZEZlVkpyV2s1VFIxSlZXV3RhWVZkR1ZuUmxSMFpYVW14d01GUldXbXRXTURGWlVXdHdWazF1YUhaWlZscHJVbXhPYzFGc1pHbFhSMmhWVmxkd1IxUXhXWGhhU0Vwb1VqTkNWRlJWV25ka2JGcEhWMnhrYWsxRVFqUldWelZQWVVaS1ZrNVdiRnBoTVhBeldsZDRXbVZYVWtoUFZtaHBWbGhDWVZkV1ZsTlVNV1IwVm01S1dHSnJjR0ZVVmxwM1YwWndSbHBHVGxOTldFSkpXV3RhYTFSdFNsaGhSVEZYWWxSRmQxbFVRWGhUUmtwWllrWk9XRkl5YUZkWFZ6RjZUVlphYzJKR1ZsTmliVkp4Vm0xNFYwMHhXbk5WYTJSb1VtdHdlbFl5TlhkWFIwVjVWRlJHVjAxR2NFeGFSbHBIWXpKR1IyRkhhRTVXYlhkNlZqRmFhMDVHVFhsVWJrNWhVMFZhVTFscmFFTlVNVlp4VW10MFQySkdjSGxYYTJoM1lrWktjMkpFVmxaTlYyZ3pXVlZhUzJSSFJraFBWbFpYWWtoQmVsWkdaRFJaVjA1ellUTndhRkpzY0U5V2JURXpUVlphV0dWSE9XdE5hMXBZVlRJMVMxWkhTa2hsUm1SYVlrZG9kbFJVUm5OV2JHUjBVbXhPVGxkRlNrZFdWbVEwWWpKR1YxZHVTbGhXUlVwWVdWUkdkMlJzYkZWVGEyUlRUVlpLZVZscldrdGhWbGw1WVVaa1YySllRbEJXVkVGM1pVWldjMWRzYUdsU01VcDVWbGQ0VTFZeFpFZFhhMmhzVTBkU1dGUlhkSGRUYkZaWVpFaGtWMDFWY0VkV01qVkhWbFphYzJOSWNGZGhhMXBRV2taYVYyUkhSa2RVYldoT1UwVktkbFpxUm1GVk1VMTRWbGhvVjJFeVVtOVVWRXBUWVVaV2RHUklaR3BOVm5Bd1ZHeFdUMVpHU25Sa1JFNVhZa1pLU0ZsVldrcGtNazVIWTBaa1YySkZjRVZXYlhCQ1pVWmtSMVZ1UmxWaVJscFlXV3RvUTFkV1pGVlRibkJPVm0xU1dGWkhOVk5oVmtweVRsWm9XbUV5YUVSV2JYaGhaRVV4V1ZwR1VrNVdiRmt4Vm14a01HRXhaRWhUYTJSWVlrWmFZVmxzVWxkU1JscEZVbXhPVjAxWVFraFdSM2hQVkd4WmVGTnRSbGhXUlVwWVdWUkdZV014VG5WVWJYQlRVbFZ3YUZadGVHRlpWMVp6VjI1T1lWSllVbFZWYlhoaFpXeFdXR1ZJWkZkTmEzQllWVEp6ZUZZeVNsbFJhM2hXVFdwR1dGcEZXa3RqYkhCSVkwWk9UbUp0YUZwV2JHUTBXVmRSZUZadVRsaGlhM0JaV1d0a1UySXhVbGRXYms1UFVtMVNlVlp0TVVkV2JFcHpZMFJDWVZaV2NIWldNbmhoVW1zMVZsVnNaR2hOV0VGNlZtcENhMVl4VGtkVGJsSnNVako0VkZSV1ZuZFpWbGw1WlVaa2FFMUVSa2hXTVdoclZHeGtSazVXYkZwV00xSk1WbXBHYzJNeVJraFBWM2hwVW01Q05sWXlkRmROUmxWNVUydG9WbUZyU2xaVVZscDNZMnhzVmxwRldtdE5WbkI0VmxkNGIyRldTblZSYlRsWVZteEtURlpITVZkV01VNTFVMnhvYVZkRlNsVldSbU14WWpGV1IxcEdaRlpoZW14VFdXeGFSMDVHV1hsT1ZrNVZZa1Z3UjFZeWVHdFdWbHAwVlZSQ1YwMUdjSEpaTW5oaFpFWktjMVpyTlZkTlZYQkxWbTE0YW1WR1NYaFhXR3hVWWtkNFZsWXdaRk5oUmxweFZHMDVhbUpIZERSV01uTTFZVzFLVjFOcmJHRlNWbkJRV1ZaYVQxSnNTbkZWYkdScFYwZG9lRmRzVm1GVGJWWkhZMFZhWVZKc1NuQlZiWGgzVjFaa1YxcEljRTVXYlZKWVZqSTFTMVl4V2taWGJrNWFZVEpSZDFSc1duZFdiVVpJVW0xc1UySklRalpYVkVKaFpERmtjMWRzYUZaV1JVcFlXVlJHZDFSR2JEWlRhemxUWWxaYVNGZHJXbXRoVmtwWlVXdGFWMkpIYUROVmVrWlhaRVphY2xwSGNGTldNMmhZVjFkNGEwNUdXa2RYYms1b1VsVTFjbFJXV25kVFJtUnlWV3RPYUUxRVJrWlZiWFJ2VmpBeGNWWnNVbGRTUlZwb1dUSnpNVmRHU25OYVIyeFhVbFp3Vmxac1pIZFNNVlY1VkZoc1UyRXlhSEpWYlRGdlkwWldkRTVWVGs5V2JIQklWbTB3TldGVk1WaFZha0pYWWxSV1RGWXdaRWRqYXpWWFlVWldWMVp1UWxoWGJGWmhWMjFSZUZkc1ZsTmlSMmhVVkZaV2QxTldXbkphU0hCT1ZqQmFXRll5TlV0aFZUQjVZVVpvV21KSGFIWldNRnByVmpGa2MxcEhkRk5pUm5CaFZqSjBZVkV4V1hsVGEyeFNZbTFTV0ZacVRtOWhSbVJYVjJ4YWJGSnRVbHBYYTFwcllVVXdlRk5zV2xkU2JIQm9WbXBCZDJWSFNrZFhiR2hvWlcxNGRsWlhjRU5rTVU1WFkwWmFWbUV3TlZsWmJGWlhUa1paZVdSRVVsaFNiSEI2Vm0xd1UxWnJNVWhWYkdoV1lsaG9hRmw2Um10ak1YQklaVWRzVTJKclNtaFdiVEYzVWpGc1YySkdaR2xTYkhCUVZqQlZNVlpXYkhSbFIwWlhZa2Q0ZVZsVlZrOWhhekZZWlVaYVYxSXpVbEJXUkVwTFUwWldjMWRzV2xkTk1taDVWbXRTUjFOdFZrZFViazVvVW14d2NGWnJXbUZUVmxwelZXdDBWRTFYVWxoVmJUVkxWVVphZFZGdVFsWmhhMXBNVm14YVlWSXhjRVZWYldoT1ZqRktTRlpHV2xkak1rWkhVMjVTVm1GNmJHRlpWRVpoVFRGVmVGZHRkRmRXYTFvd1ZXMHhkMVJzV25WUmJIQlhWa1ZyZUZWNlJtRlRSazUxVTJ4b2FWWXlhRmxYVjNoVFVqRmFSMVZ1VW14U2F6VllWbTEwZDAxR2NFWlhhemxvVm10c05sZFVUbk5XTVZwMFZHcFNWbUZyV2xSWmVrWlBWMWRPU0dGR1RsaFNhM0JhVm14amVFNUdiRmhVYms1cFVteGFWRmx0Y3pGWFJsSlhXa1pPV0dKSGRETlhhMk0xVm1zeFZtTkVSbFpXTTJnelZqQmFXbVZzVm5OYVJsWlhZa2hDVFZaWGNFdFNiVlp6WTBWa2FGSXllSEJXYlhSM1RrWmFjMWt6YUU1U2JYaFlWMnRhYTFac1pFaGhSMmhXVFVaVmVGbHFSbUZrUjFaSldrZDRhVkl6YURSV2EyTjRUVVpaZDAxVlZsTmhhMXBoVm14a2IyRkdXbkZTYTNSVFlsVTFTRlZYZUdGVWJFcDFVV3N4V0ZkSVFraGFSRVpQVTBaU2NsZHJPVmRXUmxwM1ZsZDRiMUV5U1hoWGJsSk9Wa1pLY0ZSWGVFZE9SbGw0WVVoT1YxWXdjRWxXVnpWRFZtc3hSMWR0YUZkaVdHaDZXVEo0ZDFJeFVuUmpSMnhUWW10Sk1GWnNZM2hOUlRGSFZsaG9XR0pyTlZsWmEyUnZWMFphZFdORlNrNVdiSEI1VjJ0V01GVXlTbFppZWtwV1RXNW9jbGxXV21GU01XUnpVbXhrYUdFeWR6QldXSEJIVkRGSmVGZHVWbFZpVjJoVVZGVmFkMWRXWkhOYVJFSmFWbXMxV0ZZeU5VZFZNa3BXVjJ4a1ZWWnRVbFJXTUZwYVpWVTFWazlYYUdsU1dFSlhWbTB3ZDA1V1pIUlRhMmhvVW1zMVZsWnNXbmRaVm5CV1YyNUtiR0pJUWtkVWJGcHJZVlpLZEU5VVRsZGlXRkp5VkZWYWMxZEdTbk5hUmxKcFVqSm9lbFpVUWxka01WbDRZa1pvYTFKV2NITlZiVEV3VFRGWmVVNVZPVmROUkVaWVdUQm9jMWRIUlhsVmJuQmFWbXh3VEZac1dtRmpNa1pIV2tkb1RtSkZXWHBXYlhSVFV6RktkRlpyWkdGVFJscFlXV3RXZDJOR1ZuRlViVGxYVFZad01GUlZhRzlXYlVZMlVtdG9XbUV4Y0haWlYzTjNaVmRHU1ZOc1dtaGhNWEJ2VmxSS05HRXlUbk5hU0U1VllrZFNUMVp0TlVOT1ZscHhVbTA1YTAxV2JETlVWbWhYVlcxRmVXRkhSbGRpYmtKSVZqQmFZV1JIVGpaU2JHUk9ZVEZ3U2xkc1ZtRlVNVkowVTI1U2FGSnVRbGhaVkVaM1lVWmtWMXBHVG1waGVrWmFWa2N4UjFVeVNsZFRiSEJZVmpOb1ZGbDZSbUZqTVZaeldrZG9VMVpVVmxWV1JscGhVakF3ZUdKR1dscGxiRnB2Vm0xMGQyVldVbk5XYlRsWFRVUkdNVlpXYUd0V01rcFpZVWRvVm1KWWFGQlpNakZUVWpGYWRHSkdUbWxoTUhCVFZtMHdkMlZGTlVoVldHaFVWMGRvY1ZWc1pHOWpWbFp6Vld4a2FVMVlRbGxhUlZwaFlrWktjMk5FUWxWV2JFcFVXVlZWZUdOc1duRldiRnBwVjBaS2VWWnFRbUZoTVU1SVVtdHNVbUpHY0hCWmJYUkxWMVphZEdWSFJsWk5WbkI2V1RCV1lWUXhXWHBoUmxKYVlrZG9kbFJzV2xwbFYxSkhXa1UxVTJKV1NrbFdWRWt4VkRKR2MxTnJXbGhpVlZwV1ZteGtVMVpHY0VobFIwWnFWbXRhV2xsVlpEQldNREZIWTBWMFYxWnRVVEJaVkVaV1pWWk9jbHBIY0ZOTmJXaGFWMVpTUjFNeFVrZFhiRlpUWWtoQ2MxWnRkSGRYYkd0M1draE9WazFyVmpOWk1GcHpWakZaZW1GSGFHRlNSWEJUV2xWYWQxSXlSa1pPVm1SVFlUTkNWbFpyV210TlIxRjVWbTVPV0dKc1NuSlZhazVUVjBac2NscEdUbFJXYkhCWldsVldhMVl3TVhKalJXeFhWbXhLUkZadGMzaFdNazVIVld4d2JHRXhiM3BXVjNoaFZqSlNTRkpyWkdGU01uaFVWRlJLVDAweFduUk5XR1JVVFd4R05GbHJXbXRaVms1R1RsWnNXbUpZYUV4WmFrWlhZekZXZFZSdGFGTmlSbTkzVjJ4V2IyRXlTa2RYYmxaU1lrZG9XRmxyV2t0WFJscHhVbTFHYW1KVk5VWlZWM2gzWVVVeGMxTnFXbGhXYkhCb1ZYcEdXbVZXVGxsalIzQlRZbFpLV1ZaWGVHRmtNV1JYV2tab2FsSlZjSE5WYlhSelRsWldjMkZJWkdoV2EzQjZWVEkxUTFkc1drWlRhazVYWVRGd2FGcEZaRTlTYlZKSFYyczFWMVpGVlhkV2JUQjRUa1paZUZadVVsTlhTRUpYV1Zod2MxZEdiSE5WYTJSWFVtNUNXVnBWWkRCV01WcHpVMnBDVlUxWFVuWldha3BHWlZkUmVtTkdaRk5pU0VKVlZtMXdSMkV5VWtkVGJHeHBVakpvVkZadGRIZFhWbHBZVFVob1ZrMVdTa2haVkU1ellrWktWV0pHYkZkaGEwcG9WVEJhY21ReGNFVlZiV2hUVmtWSmVsWlVSbTlpTVZsM1RWWm9WbUZyTlZkYVYzUmhWREZ3VjFkc1pHcGlTRUpJV1ZWa2MyRldTblZSYkd4WFRWZFJNRlpxUm5OV01YQkhXa1prYVdGNlZsaFhWM1JyVlRGUmVGVnNaR0ZTYXpWWVdXdGFkMU5XVW5OV1ZGWm9VakJ3VjFZeFVrdFdNVmw2VVd4U1YwMXVhR2hXYWtaclpGWmtjMXBHVGxOV2JrSk5Wako0WVZsV1dYbFVibEpXWVRKU1dWbFljRmRXUm14VlZHdE9WR0pHYkRSV01qRXdWREZKZDAxVVZsZFdNMUoyVm1wS1JtVkdaSE5hUm5CcFVqSm9WVlpxUW1GWlYwNVhWVzVTVUZack5YQlZiVFZEVjFaWmVHRklaRk5OYTFwNVZGWmFiMkpHU25SaFJteGFWa1ZhYUZreWVHRmpiR1IwWkVaU1UwMUdjRXBXVnpFMFZqRlpkMDFJWkZSaE1VcFpXVlJHUzFOR2JGVlRhemxYVFZaS01WVXlNVEJWTURCNFUyeFdXRll6VW5aVlZ6RlhVakZrZFZSc2NFNU5iV2hWVmtaYWExVXhUa2RXV0d4c1VtMVNXRlJYZEdGbFZsSnpWMjVPVjAxcmNGcFpWVkpQVmpKRmVHTkdVbGRpV0doeVdrWmFUMlJIVmtkYVIyaHNZa1paTUZadE1IZGxSMVp5VFZaa1dGZEhVazlXYkZwaFYwWnNkRTFXVGxoV2JIQjRWa2Q0VDJFeVNraGxTR2hXVm0xb2RsWnFRWGhXTVdSMVlrWndhRTFzU2pKWFYzUnJVekZLZEZScmFGQldiVkpVV1d0b1ExZFdaSEpWYTJSb1RXc3hOVlV5ZEd0WFIwcFlZVVpTVlZaRldreFpWVnBoWkVVeFNXRkdXazVXVjNjd1YxWlNUMkV5UmtkVFdIQldZa2Q0WVZscldtRk5NVlY0VjIxR1dGSXhXa2xVTVZwM1ZqSkZlbEZZWkZkaVIxRXdWbFJHWVdSR1NsbGhSM0JUVmpKb2FGWkdXbUZrTVU1SFkwVmFZVkpZVWxWVmFrWmhVMFprY2xkdGRGZE5iRm93V2tWU1lWWXlTbFZTYWs1V1pXdEZlRlV3V2s5WFYwWkhWbXhvVTAweWFGZFdNV040WldzeFdGUnNaRmRpYkVwelZXeG9VMVl4VWxkYVJGSllWbTVDUjFadGNFTmhSbHBWVW14b1YwMXFWblpXYlRGTFYxZEdTVk5zY0ZkaVZrcE5WbFJDWVZZeVRsZFNiazVYWWtkU2NGWnFTbTlWYkZsNFdrUkNXbFp0VWpCV1ZtaHJWR3hhYzFkc2JGcGhNbEpVVmpCYWMyTXhaSEprUjNoWFlrZDNNRlpxU1hoTlJscEdUVlpvVm1FeWVGaFpiR2hUWld4c1dHVkZjR3ROVjFKNlZsZDRhMkZIUlhoalJURlhZV3RhYUZsVVNrNWxSbkJKVkcxR1UwMHdTbEJXYlhoVFZqRk9WMWRzVmxSV1JWcFlWRlphYzA1V1ZYbGxSMFpZVWpCd1IxUnNXbUZXTWtwSFkwZG9WVll6YUROVmJGcExZekpPU0dWR1RtbFdhMnd6Vm10U1IxbFdUWGxTYkdSVVlXeHdiMXBYZEdGWFJscHlWbTFHYTJKSGR6SlZiVEV3VlRBeFdGVnNjRnBoTVhCb1dWWmFXbVZYUmtoaFJtaFhUVEZLZVZac1pIcGxSa2w0Vm01T1lWSnRhSEJXTUZwTFpVWmtXR1JIUm10TlZuQjZWbTAxVTFSc1pFWk9WbVJWVmxaS1NGVXllRmRYUjFaSldrWmtUbUV6UWxkV1ZscHZZakZzVjFOcldtcFNWMmhYV1ZkMFlVMHhWblJsUjNScVlYcHNXRmRyVlRGVWJFcFpVVzVhVjJGclduSlVhMlJHWlZaYWRWTnJOVmRXTVVwNFZsZDRhMkl5VG5OV1dHUlhWa1ZhV0ZadGVHRk5SbEpYVjJzNWFWSnJjSHBXTW5CRFZsWmFkR0ZHUWxwV1ZuQm9XWHBLVDFJeFpITmFSbVJPVFVWd1VsWnRjRU5aVm14WVZGaHNWV0V5ZUZSWmExcGhZMFpXY1ZKcmRGZFdiSEF3VkZWb2IxWkZNVlpqUkVKV1lsaFNjbGxWV2twbFYxWklUMVpXVjFZeWFFVldSbEpIV1ZkTmVGWnVTbFZpU0VKWVdWaHdSazFXV25KWGJUbHBUV3RhUjFSVmFITmlSazVHVjJ4YVYyRXhXak5hUjNoelkxWktjMXBIY0ZkaE1YQlhWbGN4TkZReFdYbFRiR3hvVW0xb1dGbHJaRkprTVd4VlUydGtWRkpyY0hoV01uaFBZVmRLY2xOc2JGZFNiVTE0VlZSR2ExSXhaSFZUYkdSWVVqSm9XVmRXYUhkV01WbDRWMnhvYkZKdFVtOVZha0pYVGtacmQxVnJkRmROVm5CSFZUSjRhMVpXV25OalJrSlhZV3RhTTFVeFdrOWphelZYV2tVMVRtSlhhR0ZXYlRCNFRrWnNXRlZZWkU1V2JWSlpXV3RhWVZaR2JISmFSazVxVW14S1dGWnNhRzlVTVZwelZtcFdZVkpYVFRGV2FrcExWbXhhY1ZadFJsZFdia0l5Vm1wSmVGTXhXbGRUYkZaU1lraENUMVZ0TlVOT2JGcDBZMFZrV2xZd05YcFpNRlp2WVRGSmVXVkdVbFZXYkZvelZqSjRZV05XVG5GUmJHUm9aV3hhV2xaWE1UQmlNVlY0V2tWc1VtSlViRmRaYTFwM1lVWmFjVkp0Um10V01EVkhWMnRWTVZSc1dYcGhSbVJYVm5wQ05GUlZXbFpsVms1elYyMXdVMWRGU2xwWFZsSkhaREZhUjFkdVJsTmlWVnB4V1d0a1UxZHNhM2RYYlVaVllYcENNMVV5ZEZkWFJtUkpVV3RvVjFKRlduSlZha1poWkZaT2RHRkdUbWxTYmtJelZtMHhkMVF5U1hsVmJrNVlZbXhLY2xWcVRsTmpSbXh6VjIxR1dGSnNjSHBaVldNMVZqQXhjbGRVU2xwaE1YQlFWakl4Um1WV1VsVlNiRlpYVWxad05sZFVTalJaVjAxNFZXNU9XR0pYZUZoV01GWktUVlphYzFWcmNHeFNNR3cwVjJ0b1QxZEhTbkpPVm14YVZrVndkbGxWV2xkalZsSjBUMVphVTJKSVFqUldWekF4WVRGVmVWSnFXbWxTYlZKV1dXdGFkMk5zV2tobFJYUlRUVmRTV2xrd1dtdGhSVEZ6VWxoa1YySkdTa2hXVnpGWFZqRk9kVk50UmxOaVYyaDJWMWQwYjFFeFpGZGFSbVJoVWtWS1lWWnRNVk5YUm14eVlVVjBXbFpyYnpKWmExcFhWbFphZEdGRlVsWk5SbkJ5V1RKNFlXUkhVa2RoUms1b1RUQktXRlp0TUhoT1IwMTRXa2hLVGxaWGFGZFpiVFZEVjBac1ZWSnVaRlZTYlhjeVZUSnpOVlpHV1hkalJXaFlZVEZWZUZsV1pFdFhSbTk2WWtaa2FWZEdTbmhYYkZaaFZESlNSMWR1VG1GU2JWSndXVmh3VjJReFdsaE5WRkphVmpBMVNGWXhhR3RaVmtvMllraE9WbUpVUmxSV01GcGFaVmRXUms5V1pFNVNSVnBIVmxjeE5HSXhaRWhTV0docVUwVndXRlJYTlU5Tk1YQlhXa1ZrVkZaclducFdNakZ6VlRBeGRHRkdXbGRpVkVVd1YxWmtUbVZHWkhOYVJsWnBZa1Z3ZVZaWGNFdE9SbHBIVjI1S1YySlZXbUZXYlRGVFYwWmFkR1ZGT1ZaTlJFWllXVEJhYjFZeFNYcFZibHBhVm5wR1dGa3llRTlqTWtwSFkwWmtUazFWY0U1V01uaHJUa1paZVZSdVRtRlRSWEJvVlcweGIxWkdiSFJrUlhSVVVtMVNWbFZYTVVkV1JURlhVMjV3VmsxdWFISlpWM2hMVW14a2MyRkdjRmROTVVwdlYxWldZV014V2xkVGJrNVVZbGhvV0ZsVVRrSmxSbHBWVTFob1QxSnNjRWhWTWpWUFlXeEtjMU5zYkZkaVZFWlRXa1JHYTFZeGNFWlBWbVJPVm14d05sZFdWbFpOVmxsM1RVaG9WR0p0ZUZsV2FrNVRZMnhhVlZKdFJtcE5WMUo1V1ZWa05GVXdNSGhUYm1SWFZucEZNRnBFUm10ak1rcEhWMnhhYUUxc1NscFdWM0JEVmpBMVYySkdXbGRpUlRWWldXdGFkMDFHV2xoa1JGSlhUV3R3U0Zrd1pHOVpWa3B6WTBaU1dtVnJjRkJWYlhNeFYwZEtSMkZHVGs1aVZUUXhWbTB3ZUdReFNYaFdXR2hWVjBkb1ZsWXdaRFJXYkd4VlVtNWtWbFpzY0hwWGExSlRWMFphZEdWR1dsZFNNMUpRVm0xemVGWXhUbk5hUm1ScFZrVmFTVmRXVWtkWlYwMTRWMjVHVm1KSFVuQldNRlYzWlVaYWMxcEljR3hTYTNCWlZUSjBhMkZHU25WUmJHaFhZbGhvTTFSWGVHRmpiRlp5V2taV1RsWlhkekZXYTJRd1dWWlJlRmRZWkZoaVIyaGhXVlJHZDAweFZYaFhiWFJZVWxSR1ZsWlhlRmRVYkZwMVVXcGFWMkpIVFhoVmVrWmhVMFpPYzFkc2FHaGxiWGhvVm1wQ2IxRXhXWGhqUlZaVFlsVmFjbFZzVWtkWGJHUnlWMnQwVldKVlZqUldNVkpEVmpBeGRWVnNhRmhXYlZKSVdYcEdUMk5zWkhOaFIyeFRZa2hDV2xZeFpEQmhNVlY0VjJ0a1YxZEhVbGxaYlhNeFYxWldjVkp0UmxSaVJuQkpXVE53VjJGR1duTmpTR3hhVFVaYU0xWnFTa1psVmxKeFZXeHdiR0V6UWtsV1YzQkhZVEpPZEZKcmFGTmhlbFpQV1cweGIxZFdXbkpYYlVaYVZtMTRXRlp0ZEd0V01rcElZVWhPVmsxR2NETlpla1poWkVVeFYxUnRlR2xTYmtKYVZrWmFVMUV4V2xoVGJGcHFVbTFvVjFSWE5XOU5NVnB4VW10MGFrMXJOVWhXVjNoaFZqRktXVkZzVWxoaVJscG9WbXBLVDFZeGNFbFViRlpwVmpKb2QxWlhlRzlSTURWWFYyNVNUbFpHU25CVVYzUjNaVlpTVjFkdGRGZGlSMUpKVmxjeGIxWnRSbkpPVmxKYVRVWndhRnBGWkZkVFZuQkdUbFprYVZkSGFGbFdiWGhyVFVkRmVGcEZaRlJpYTNCeFZXMHhORmRHVm5STlZ6bHJZa1pzTlZSV1ZqQldSa3B6VjI1d1YxWXphSEpXUjNoTFl6RmFjVlZzWkdoaE1IQjVWbXRTUjFReFRrZFdia3BoVW14YWIxcFhlR0ZrTVdSWVpVZDBWbUY2UmxoV01qVkhWVEpLV1ZGdVRsWmhhMFkwVkd0YVYyTXlSa2xVYkdSVFRVaENTbGRXVm1GVk1XUjBVbGhzVm1Kc2NGaFdiRnAzWVVacmVGZHNUbXBOVmtwNlYydGtjMVV3TUhsYWVrcFhZbGhDUzFwVldrcGxSbFoxVkd4U2FXSkZjRmhYVnpBeFVURnNWMWR1VGxoaVJuQlBWbTB4TkZkV2NGWldibVJvVFVSR1JsWnRkR0ZXYlVwWllVUk9WMkZyV21oWk1qRlBVbTFLUjJGR1pHbFdhMnQ1VmpKNFYyRXhVblJXYTJScVVsZDRWRmxyWkZOalJsWjBaRWhrVmxKc2NEQmFWVnBQVmpBeFZtTkdhRmROYmxKMldWZDRTMWRHVm5WUmJGWlhZa1pXTkZaWGNFZFZNazE0VjI1U1VGWnVRbGhaVkU1RFdWWmFWMXBFVWxkTlZuQXdWVEo0VjFZeVJYaFRiV2hXWVdzMWRsa3llR0ZqTVdSeVQxZDBWMkpGY0RaV1ZFcDZUVmRHUmsxV2FGQldSVFZZV1d0YVMxTkdiSEZUYkVwc1VtMVNXbGxyV2xOaFYwWTJWbXh3V0ZaNlJYZGFSRVphWlVaV2MxZHNhR2xTTVVwUlZsY3dlRTVGTVVkalJscFlZbGhTVjFSVlVrZFhSbFY1VGxoT1YwMVZiRFpXUm1odlZqSkdjbEpxVWxaaVJuQk1WbXhhUzJNeGNFaGlSbVJUVmxacmQxWnFSbTlrTVVsNFZsaG9ZVkpYVWxaWmJYTXhZVVpXZEUxWE9WaFdiRnA0Vmtjd05WZEhTa2hWYkd4aFVsZFJkMVpzWkV0V01XUnlZVVprVjAweWFHOVdNVnBoVXpGYVdGTnJaRkppUjFKd1ZXMTBkMWRXV25GU2JVWldUVlpzTkZrd1ZtOVZSbHAwVldzNVZtRXhXa3RVVmxwYVpWZFNSMVJzVms1V2JYZDZWa1phYjFZeVJrZFVhMlJxVW0xU1ZsWnFUa05UUmxZMlVtNWtWMDFYVW5sYVJXUjNWRzFGZWxGcmJGZGlWRUkwV1dwS1MxTkdUbk5pUjJoVFVsUldXVmRXVWtka01WcEhWbTVHVTJGNlZuTlZiVFZEVTBaa2NscElUbFpOYTNCWVZUSXhiMWRIU2toVldHUllWbTFTVUZsNlJtdGtWbFp5VDFaa1YxWkdXbUZXTVdRd1dWWlpkMDVWWkdGU2JYaHhWVzB4VTJJeFZuTlZhMlJZVm14d1dWcEZaREJXTVZsM1kwVnNXbFpXY0VSV2FrRjRaRlpTY1ZWdFJsTldNVXBaVmxSR2ExTXhTWGxVYTFwUFZtczFjRlZxVGxKbGJGcHhVMnBDVjAxV2NEQldiWFJyV1ZaS1dHRkdVbHBXUlhCMldURmFWMlJIVWtsYVJsWk9Wak5vTmxZeWRHcE5WMFYzVFZaa2FWSkdXbWhWYkdSVFUwWnNWbHBGWkU5aVJYQjZXV3RhWVdGV1drZFhiRlpYWWxSQ05GVnRNVmRYUmtweVlrWkthVkp1UWxCV1Z6QXhVVzFXYzFwR1ZsSmlWVnB4VkZaYWMwNUdXWGxPVlhSYVZtdHNObFpYTlVOV2JVWnlWMnQ0Vm1GcldtaFpNbmgzVWxaR2NrNVdUazVTYmtKYVZteFNTazFXV1hoV2JsSlVZbXhLVjFsc1ZtRlhSbXhWVW0xR1RrMVhkRFZhVldoUFlXMUtSMk5HY0ZwV1ZuQjJWbXBCZUZJeVRrWmFSbVJYWld0VmQxWnNVa2RYYlZaSFdraE9WMkpIVW05VVZsWjNWMVphUjFsNlJsSk5WWEJJV1d0U1lWVXlSalppUm1oVlZtMW9SRlV5ZUdGWFJURllUMVphVGxKRlNYcFdWRWt4V1ZaWmVWTnNiR2hTYldoaFdsZDBSbVZHYkRaU2JtUlRUVmhDU0ZsVlpITlhSa3BXWTBaR1YySlVSak5WYWtaT1pVWndSbHBIYUU1TmJFcGFWMWN4ZWsxV1pFZFdibEpzVTBVMVVGWnRlSGRYVm5CV1ZtcENWMDFFUmxoWk1GWnJWbXN4ZFZWVVFsZE5ha1pNVldwS1QxTlhTa2hTYkdScFVteHJkMVp0TVhkU01sRjRWR3RvVkdFeVVtaFZiVEZ2VmtaU1dFMVdTazVTYkhBd1dUQldNRlJzU1hkaVJGSldZa2RvZWxaVVNrdFRSMFpIVm14d2FFMVlRbTlXYWtKaFl6SlNTRlJxV2xOaVNFSllXV3RXZDFkc1draGxSbVJVVFd0V00xUldXbTlXYlVwSFkwWmtWVlo2VmxOYVJFWnpWMGRXUm1SSGNHbFNNVW8yVjFkMFlXSXlSa1pOVm1ScFRUTkNXRmxyWkZOT2JIQldWMnQwYTFKck5YaFdNbmhQWVZaSmVGTnNRbGhXZWtJMFdXcEJlR014WkhWVWJGcG9UVWhDZWxaWE1IaFZNVTVIVjJ4b1QxWnRVbGhaYkZaYVRXeHNjbGRzVGxkV2JHdzJXVlZXTkZsV1duTmpSMmhXWVd0YWVWcFhNVWRTYXpsWFZHeGtVMVp1UW1GV2FrWnJUVWRKZUZaWWFGWmlhelZaV1cxNFMxWXhiSFJqZWtaWVVtMTRlVll5ZERCaE1rcEhVMjVzVjAxcVZuSldha3BMVm14a2NtRkdhR2hOV0VKVlYxWmFZVk14V1hoYVJteHFVbTFTV0ZWc1duZFdWbHAwWTBWa1dsWnJjSGxVVmxwclYwZEdObFpzVmxaaGEzQjJXV3BHWVdSRk1WVlZiWFJPVWtWSk1GWnFSbTloTVdSSVUydG9WbUpyV2xoWmJHaFRUVEZ3V0dWSVNtdE5WbkJXVlcweGIxWXlSWHBSYWxwWVZqTkNVRmw2UmxwbFZrcDFVMjFzVTFKVVZsZFdiVEUwWkRGc1YyTkdaRmhpUjFKeFZGWm9RMU5XYkZaV1ZFWlZZWHBHUjFrd1duTldNREZZVkdwU1ZWWldjRTlhVmxwVFkyeHdSMWR0YkZOTmJXZzBWbXhqZUdWck1WaFVhMlJwVTBWd1dGWXdaRzlVTVZKWFdrWk9iRlpzY0RCVVZsWnJZVVpKZDFkVVNsWmlXRko2VjFaYVlWWXhaSFZqUm1ScFYwVTBNRlpxUW10U01VcHpWbTVPV0dGNlZuQlpiR1J2Vld4YWMxVnJaRnBXYkd3MVZsZDBiMVpYUlhsVmJrWldZV3R2TUZZd1dsTldWazUwVDFaT1YySklRalJXVkVreFlURldjazFZU2s1V1JrcFhWRmMxVTJOc1dsVlRhM1JxVFZkU01WVlhlR0ZoUjBWM1kwYzVWMkZyV21oV2FrcFRVMFpXY21KR1ZtaGxiWGhWVjFkNFlWTXhXWGhYYkZaVFlsUnNiMVJXV2t0bGJGVjVUbFpPVmxKc2NFaFZNakZIVjJ4YVJsZHFUbGRoTVhCb1ZXeGFTMk15VGtobFIyeFRWbTA1TkZac1dtdE9SbGw0VjFoa1RsTkhVbFZaYTJRMFYxWmFjbFp0Um1oU2JYaFdWVzE0ZDJKR1duSmpTR3hZWVRGd1ZGbFdXbHBsYlVaSFVXeGthVmRGU2xGWFYzQkNaREpXUjJORlpHRlNNbWhWVldwR1MyUnNXa2RYYlhSV1RWZFNTRlpzYUhOaGJFbDNWMnhvV21KR1dqTldiWGhoWkVkV1IxcEdaRTVoTTBKS1ZteGpNVk14V2xkWGExcFlZbTVDVmxsc2FHOVRSbkJIVjJ4T2FrMVdTbmxVYkdSelZURmtSbE5yZUZkaVZFVXdXVlJCZUZKck5WWmFSbWhwWWtWd1dWZFhNWHBOVm1SWFYyNUtWMkpWV2xsVmJYaExWMVpTYzFsNlZtaGlWWEJJV1RCYVlWWnNXblJoU0ZwWFlXdEdORmt5ZUdGalZtUnpZMGRvVGxkRlNqVldiVEYzVXpGWmVWVnJhRmRoTW5ob1ZXMHhiMWRHVWxWVGJUbHBUVlpzTkZZeWVHRmlSa3B5WWtSU1drMUdXbnBXYkdSTFYwZEdSMVZzWkdoTmJFVjNWMnhXWVZsV1pFaFVhMXBVWWxob1ZGWnJWa3BOUmxweFUycENhVTFXUmpSV01XaHJWMGRLVldKR1dsZGlXR2d6VkZkNFUxZEhWa2hTYlhCT1lURndTbGRyVm1GaE1WbDVVbGh3VW1KSGFGaFZhazV2VjBaYVZWSnRkRk5OVjFKYVdUQmtiMVpHU25WUmJHeFlWbXhLVEZaVVJrOVNNVloxVlcxNFZGSXhTbFZXUm1Rd1pERk9SMWRyYUU1V1JrcHZWbTEwZDAxV1ZsaGpSazVYVFd0YWVWWXlOVWRaVmxwWVZXczVZVlpXY0V4YVJscFRaRWRLUms1Vk5XbGlWMmhhVm1wR2FtVkZOVWRVV0doWVlUSlNjRlV3V2t0VU1WcHlWMnQwVjFac1NsaFdNakZIVkd4YWRHUkVUbGROYWtWM1dWVmtSMDVzU25OaVIwWlhWakpuZWxacVFtdFNiVlpJVkd0c1ZHSklRbTlVVjNoTFZGWmFkRTFVVW1oTmF6RTFWVEowYTJGc1NuUlZiRkpYVFVaYVRGUnNXbUZrUjFaSVVteHdWMkpJUVhkV2JGcHZZakZhV0ZOdVRsaGlSa3BoV1ZSS2IxSkdiSEZTYms1WVZqQTFTRmRyV205V01rcFhVMnBXVjJGcmJEUlVWVnBoWTJzeFYxZHJPVmRpVjJoWlZtMXdUMkl5Vm5OWGJrWlVZVE5TV1ZadGRHRk5WbFpZWlVkMGFGWnRVa2xYYWs1M1YwZEtSMk5IYUZwV1JYQlFXWHBHZDFOV1ZuUmtSazVwVW01Q1VWWXhXbE5VTVVWNFZHdGtZVk5GY0ZoWmEyUlRZMFpTVjFkclpFOVNiR3cwV1ZWb2EyRkdTbkpPVldSV1RXNW9kbFl5ZUZwbGJGWjBZVVp3VjFadVFsVlhhMVpyVmpGT1YxVnVUbUZTVkZadlZGWm9RMU5XV25KVmEyUmFWbTE0V0ZZeGFHdFViRnBZVlc1R1ZtSlVWa1JXTUZwelZsWk9jazVYZUZOaVJtdDVWbGN3TVZReFdYZE5WbXhTWVRKU1dGUlhjRWRsYkZweVYyczVVMkpGTlhwV01uaHJZVlprU0dGSE9WaGhNazQwVmxjeFYxSXlUa1ppUmxKcFVqRktkbGRXVWtOa01XUlhWMjVTYWxKWFVsVlVWbFV4VjBaWmVXUkhPVlZpUjFKSFZHeGpOVll5U2xsVVdHaFdUVlp3Y2xreFdsTmtSVGxYV2tkb2JHRXhjRnBXYlhCTFRrWkZlRmR1VGxoaE1YQnhWVzEwUzFZeGJGaGtTR1JXVW14V05GWXlkR3RoYXpGV1RsaHdXR0V5VVRCWlZscHJVMFp2ZW1OR1pHaGhNWEI1VmtkMFlXTXhXWGxUYTJSWVlYcFdXRlpxUmt0aU1WcFZVV3hhVGxZd2JEUldiVFZQVm0xS2NrNVlSbGRpV0dob1dsVmFWMWRGTVZaYVJtUk9WbTVDTmxaVVNURmtNV1J6VjJ4a1YxWkZXbGhVVnpWdllVWnNObE5yZEU5aVJUVjZWMnRrYzFZeFNuTmpSbkJYWVd0YWFGZFdXazVsUm5CR1drWmthV0pHY0ZsWFYzUnJZakpKZUdKR1ZsTmliVkpVVm0xNGQwMUdjRlpYYlVacFVtdHdlVmt3V25OV2F6RjFWVzFvV2xZemFFeFpNbk14VmpGV2MxcEhiRk5pYTBZMVZqSjRhMDVHYkZkWGJHUlVZbXMxYUZWcVNqUlVNVlp5Vm0xR1ZGWnRVbGhXVjNNMVlXc3hWMk5GYkZaTmFsWk1WbXRrUzFKck5WZGhSbkJYVFRGSmVsWnRkR0ZXTURWelUyNU9ZVkp0VWxoWlZFWjNUbFprY2xac1drOVdiR3cxVlRKNGExWkhSbk5qUm14WFlsaG9hRmxWV21GU1ZrcHpWRzF3VGxZeFNtRldNblJXVGxaWmVGTnNXbXBTYlZKWlZtMTRTMVJHV2xWVGF6bHFUVmRTV2xsVldtOWhSVEZaVVc1c1YxSnRValpVVmxwUFVqSktTVk5zYUdsaVZrcDJWbGR3UTFZd05WZGpSVnBXWVhwc1dGUlZVa2ROVmxaWVpFYzVXbFpyY0VkV01qVkxWakpHY2xkcVRsWk5WbkJZV2tWa1YxSXhVbkpPVlRWVFYwVkdObFp0Y0VkaE1EVklVMWhzVTFkSFVrOVZNR1J2WVVaV2RFMVdUbGhTYlhoNldWVmFUMkZzV25OVGJHeGhWbFpaZDFZd1drdGtSMVpKWVVaa1UyVnJSWGhYVmxaV1pVWktWMU51UmxKaVZWcFlWbTAxUTFOV1duUmxSMFphVmpGS1NWVnRkSE5YUjBwSFYyeG9XbUV5YUVSV1ZscGhaRVV4VlZWc1drNWhlbFkyVm14ak1WUXhWblJUYTJoV1ltdEtXRmxYZEhka2JGWTJVbTFHYW1KSVFrWldWekZ2Vkd4YWNsZFVSbGRXZWtVd1dXcEdWbVZXVG5KYVIzQlRZa1Z3YUZkWGRHRlRNV1JIV2taa1dHSkZOVmxWYWtFeFVqRmtjbGR0T1ZaTmEzQkhXVEJhYjFZd01YVlZiV2hYVWtWYWNsVnFSbXRrVms1eVQxWmtVMVp1UWxwV01XUTBZakZWZDAxSWFGaGlSbHBWV1d0a1UyTldVbGRhUms1T1ZtMTBNMVl5TURWV01ERkZVV3BXV2xaWGFIcFdha3BMVjFaR2NtVkdaR2hoTTBKVlZsZHdSMVF5VWxkVmJsSm9VbXMxVDFsc1pHOVZWbHB5VjIxR1dsWXhSalZXVm1odlYwZEtjMU51UmxaaVJsVjRWMVphWVdNeFZuSlVhemxUWWtoQ1NWZFdWbXROUm1SelYyNUthVkpGTlZoVVZ6Vk9UVlphY1ZOclpHcGlSVFY0VmtkNFYxWXhXblZSYlRsWFZrVktjbFpFUmt0ak1WWjFWVzFvVTJGNlZuZFdWelYzWWpBMVYxZFlhR0ZTUlVwWFZGWldjMDVHV1hsa1IzUllVakJ3U0Zrd1drTldNREZIWTBST1dsWldjRmhhUldSWFUxWndSazVWTlZkaVdHUTJWbTB4TkdJeVNYaGFSV1JVVjBkb1dWbFVTalJaVmxKV1YyeGFiRkp0ZUZoV01qRXdWa1pLZEdSRVdscGhNWEJ5VmpCYVQxSnNUbkppUm1Sb1RWVndTVlpYTUhoVmJWRjNUbFphYVZJeWFGUlVWekZ2VmxaYWRHTkZkR2xOVmxwWVZqSjRiMkZzU2xsVmJHUlZWbXhXTkZScldtRmtSMVpIV2taYWFWWldXVEZXYkdNeFVURmtkRkpZYkZaWFIxSldXV3RhZDFaR1duRlNiWFJyVWpGS1NGWnRNWE5WTVZsNldUTmtWMkpHU2t4VWEyUlNaVVprZFZOck5WaFNWbkJaVjFkMGEySXhXWGhWYkdoUFZucHNWbFZ0ZUV0TlJuQldXa1ZrYUUxV2NIcFZNalYzVjJzeFNGVnVjRmRXUlVZMFZtMHhUMUl5VGtkYVJUVnBZbGRvTkZZeWVGZFpWazUwVm10a2FsSlhVbWhWYlhoM1kwWldjVlJ0T1ZoV2JWSlpXbFZrTUZReFNYZE9WV2hYVFdwV1VGWXdaRXRqTWs1SlUyeFdWMkpJUWpaV1IzaGhaREZhYzFkc1ZsZGlSbkJ3Vm14b1ExZEdXa2hsUnpscVRWZFNNRlZzYUc5WFIwcEhVMnhvVlZaNlZsQlVhMXAzVW14a2MxcEhjR2hsYTFwWlZtcEtOR0V4VlhoYVJWcFVZa1Z3V0ZSV1pFOU9SbEp5VjJ4T2ExSnNjREZXVjNoVFlVVXhXVkZzWkZoV00yaDJWbFJHYTFJeVNrbFZiWFJUVjBaS1dsZFhkR0ZrTVU1SFYxaHNUbFpGU2xaVVZsWnpUVEZaZVU1WVRsZFdiSEF3V1ZWYVUxZHRSWGhqUlhoV1lXdHdVRlZxUm10ak1XUjBZa2RzYUUxSVFrdFdiVEUwVmpGc1dGVllhRlZoTVhCUFZtMHhVMVpzYkhKYVJ6bFhVbXh3ZVZZeU1VZFdNREZYWTBab1dHRXhTa1JaVkVGNFZqRmtkV0pHVmxkV01taDVWbXRTUjJFeFNYaGFTRTVoVW14YVdGUlVRa3RYVm1SeldrUlNhbUpXV2xsV2JYUnpWMGRLV1ZWck9WcFhTRUpZVldwR1lXTldUbGxoUlRWVFlrWlplbFpHV2xkV01WbDVVMjVTVm1KSGVGaFpiR2h2VFRGWmQxZHNaR3BXYXpWNVdrVmtkMVJ0UmpaV2EzUlhZVEpSTUZacVNrZFhSa3BaWTBaS2FWSldjRmxXVnpFMFpESk9jMkpJUmxOaGVteFlWRlphWVUxV1draGxSMFpvVmpCWk1sWnRlSGRXTWtwVlVsaGtZVkl6VGpSWmVrWnJaRlpXY2s1V2FGTk5WWEJoVmpGa05GWXlVWGhYYms1WFlteEtUMVp1Y0hOWFJscDBaVWhrVGxKc2NGbGFSVkpUVjJ4YWNtTkdhRnBOUm5CVVZqSnplRll5VGtaaFIwWlRWakZLU1ZaWGNFZGtNVTVJVm10b2FWSnRhRlJVVmxaWFRURmFkRTFVVWxaTlZXdzBWakZvYjFkSFNuSmpSVGxYWWxSR2RsWnNXbk5XVms1MFQxWmtWMkpZYURWV01uUnFUbFprUjFOdVVteFNSVXBXV1d0YVlWVkdiRmRXV0doWFRXdHdSbFpIZUd0aFZrbDVZVVJLV0Zac1NreFZla1pQVWpGYWRWTnNhR2xTTVVwVlZrWlNSMUl3TUhoYVJtUllZbFZhVlZSWGVFdFhSbFowVGxaa2FGSnJjSHBaTUZVMVZqSkdjbU5JV2xaaVJuQm9WbXhhVDJOV1ZuTldhelZYVmtaYVdsWnRNSGROVmxWNVVtNU9WR0pzV2xOWmJYUkxWMFpzV0dONlJtdGlSbHA1VmpKNGQySkdXWGRPVldSaFVsWndhRlpITVV0U2JVNUdZa1prVjFKWGREUldiWEJMVWpGWmVGUnVUbWxTYTNCd1ZXMTRkMWRHWkZobFJ6bHBUVVJHZWxaWGVHOWlSa3AxVVc1T1YyRnJXbWhWTVZwU1pVWmtjMVJ0YUZkaE1qaDVWMVpvZDFFeFdYaFhibEpXVmtWS1dGWnJWbUZYUm5CR1YyczVhazFZUWtsWk1GcFRWVEZhZFZGdE9WZE5WMUYzVjFaa1VtVldTbkphUjNCVFZtNUNXbGRYZEZaTlZtUlhWbTVHVW1KSVFrOVphMXBoVFVacmVtTkZaRmROUkVaR1ZXMTBZVlp0U2tkVGEyaFhZV3R3VEZac1drZFhWMFpIWTBkNGFFMVlRbHBXYkdONFpXMVdSMWRZYkZSaE1taHZWVzF6TVZaR1duUk9WVTVhVm14d2VsZHJVbE5oUlRGWFUycENWMVp0YUhaWFZscFBVbXhrYzFSc2NHbFhSVEUwVm0xNFlWbFhVa2hVYWxwVFlYcFdWRmx0ZEV0WFJsbDVaRVpPVWsxV2JEUlZNalZMWVd4T1NWRnRSbHBpVkZaRVZUQmFXbVF4WkhSU2F6bHBVbGhCZUZkVVFtRlpWbGw0VTJ4a2FsSnRhRmxaYTFwaFkyeGFSVkpyY0d4V2EzQjVWMnRhVjJGV1dYcGhSbkJYVmpOb1dGcEVRVEZXTVdSMVZHeG9hVlpIZUhsV1JscGhZekExVjFkcmFHeFNNMUp2Vld4U1EwNVdjRlpXVkZaWFRXdHdWbFZ0ZUZOWGJVWnlWMnhvV2sxV2NFeFpNakZUVWpGV2MxcEhiRlJTVlZsNlZtcEtNRll5UlhoVFdHeFRZVEpTV1ZsdGRIZGpSbFp5VjJ0MFdGSnNTbGxVYkZaUFZURktjMkpFVGxoaE1WbDNWbXRhUzJNeFRuTmpSbkJYVm01Q1dWWnRjRWRaVjAxNVUydFdWV0pIVWxoVVZFSkxWRlphYzFremFGZE5WMUpJVmtjMVMyRkdTbkpPV0VKV1lrWktXRlpWV210WFJURkpZVVphYUdWcldsbFdha2t4VWpGV2RGTnJhRlppUm5CV1ZtMTRWbVZHVWxaWGJVWlRUV3RhU1ZwRlpHOVdNa1Y2VVd4d1dHSkdXblpWYWtaaFZqRmtjVmRzVG1sU2EzQmFWbTB4TkdReFdrZFhXR1JYVmtWYVdWVnNVbk5YVm14eVZsUkdWMDFFUWpWV1IzQlhWakpLV1ZWdVNtRldNMDE0Vm1wR2EyTXhaSEpPVm1ScFZqSm9ObFpzWTNkbFJUVkhWMjVPV0dKc1NrOVdiWFIzVkRGV2RHVklaRmROVjFKNVZtMHhNRll3TVhKalJXUlZZa1pLUkZZeWMzaFNNazVIVld4a2FHRXpRbGxYVkVvMFV6Sk9WMVp1VG1oU2JWSlBWRlpXZDA1V1duTmhTR1JUVFd0V05GVXhhRzlaVms1SFYyeG9XbUpIYUVSV2ExcFRWMFV4V0U5V2FHbFNia0phVjJ4V1lWUXhXWGROV0VwUFZtMW9XRmxyWkc5a2JHUlhWMnM1VTJGNlZsaFdSM2hYVmpGYWNtTkVXbGRpV0VKSVdrUkdZV014WkhWVWJGWnBVbTVDZDFadGVHOVJNV1JIVjJ0b2JGSnRVazlWYlRGVFpXeGtjbFp1VGxaaVZYQkpXVlZrUjFsV1dYcFZiV2hoVmpOb2VsUnRlRXRrVm5CSFZHczFXRkpWY0V0V01uaFhZVEpOZUZkWWFGaGliRnBUV1d4a2IxZEdiSE5oUms1b1VteHdWbFZ0TlU5V01ERlhVMnBHVjFJemFGUlpWbVJMVWpKT1NFOVdaRmRTVlhCWlZsaHdSMWxYVFhoWGJsWlZZa2RTV0ZWc1duZFdWbHBZVFVob1QxSXhXbnBYYTJoTFZqSktXVlZzYkZaaVdGSXpWbTE0WVdSSFZrbFViSEJYWVROQ1dWZFVRbUZpTVdSelYyNU9hbEl5YUdGYVYzUjNVekZ3V0dWSVpGTk5XRUpIVkd4a2MyRldXWGxhUkZaWFlsUkZkMVpVUms1bFJsWlpZVVpXYUUxc1NsaFhWekV3V1Zaa1IySklUbUZTZW14WVZXMTRZV1ZzV1hsT1YzUnBVbXR3ZWxrd1ZtOVhSMFY0VTJ4U1YwMXVhR2hXYkZwaFl6SkdSMXBHVG1sV01tZDVWbTB4TkdFeFRYbFVibEpWWVRKU1UxbHJXbUZYUm14elYydDBUbUpHY0ZaVmJURkhWbXN4Y2sxVVVsZGlWRlpZVm14a1MxTkhSa2RoUm5CWFVsZHpkMWRzV21GWlYxSkdUVlZzYUZJelVrOVdha1pLWkRGYVZWTnFVbGROVmxvd1ZXMDFUMVpIU2xoaFJtUmFWak5OZUZwSGVGTldWa3B6VjIxNFUySldTWGRXVnpCNFRVWlplVk5yV21sTk1sSllWbTV3UmsxR1pGZGFSWFJVVW1zMWVWZHJaSGRWTVVwMVVXeHNWMUp0VFhoWmFrWnJVakpLU1ZKc1RtaE5XRUo2Vm0weE5GbFZNVmRYYkdoc1VtMVNiMVpxUW5kVFJtdDNWMjA1V0ZKc2J6SlZWbWh2Vm14YVJsZHJPV0ZXVm5Cb1drWmFUMk14WkhSaFJUVlRVbXh2ZWxacVJtdE5SbXhZVlZob1ZXSkhVbGRaYTJSVFYxWnNjMkZHVG1sTlZrcFlWbTAxYTFSc1duTlhiR3hoVmxkb2NsWnFRWGhXYlVvMlUyeGthVmRHU2xWV2FrbzBXVlUxYzFOdVRtaFNNRnBVV1d0b1ExZFdaSEpXYlhSVlRWVnNOVlpIZEc5aFZrcDBWV3M1VlZaV1NrZGFWM2hoWTFaT2NWRnRhRTVTUlZwS1ZtdGFiMkV4VVhoWGJsSldZa1pLWVZsc2FHOWhSbXQ0VjJ4a2FsWnJOWGhXVjNoWFZHeGFjbU5HYkZkaGEydDRWMVphVTJNeFpIVlViV3hUVW10d1dWWnRjRTlWYlZGNFYyNUdVbGRIYUZoVVZsVXhUVlpyZDFkdVpHaFNWRVphVlZkd1lWWXlTa2hVYWxKV1pXdHdWRlZxUm1Ga1ZsWnpVV3hrYVZacmNETldNV040VFVaTmVGcEdaR0ZUUlhCWldXeFdZVmxXV25GUldHaFBVbTFTZVZsVlZqQmhSVEZXWTBod1YwMXVhSFpXTW5oaFVteE9jVlJzWkU1aWJXaHZWMWh3UjJOdFZuUlNhMmhwVWxSV2IxUldXbkprTVZwelZXdGthVTFyVmpSV01XaHZWMGRGZUdOSVJsWmlWRVV3VmpCYWMyTXhWbkphUjNScFVteHdOVlpxU1RGaE1WVjRWMjVLVDFkSGVHaFZiRnAzVmtaYVZWRllhRlJXYTFwNVdUQmFiMVl4U2xaalJ6bFlZVEZLU0ZsVVJrcGxSbEoxVm14U2FWZEZTbFZXVjNoVFZqRmtjMWR1VW1wU1ZHeFRWRlpWZUU1R1dsaGxSMFphVm10d2VWUnNhRXRXYlVwWlZXcE9WVlpzY0doYVJXUlhVakZ3U0dGR1pFNVRSVXBNVm14YWFrMVhSWGhhUldSWVlteEtWbFl3Wkc5WFJscHlWbTVrVmxKc1duaFZiVFZyVlRBeFdWRnJiRnBXVm5CUVZtcEdTbVZ0UmtWVWJHUnBVakZGZDFac1VrZFhiVlpYVjI1S1lWSnRhSEJWYWtaTFpHeGFXR1ZHVG1wTlYzaFlWakkxVTFSc1duSk9WbFpYWWxSV1JGWnFSbUZrUjA1SFZHeGtUbFp1UWpaWFYzUlRXVlprYzFkc1pGUmlSVXBZV1ZkMFIwNUdXbkZUYXpsVFRWVmFNRlZ0ZUU5aFZscHlZMFpLVjJKR1NrUlpWRVpLWlVaT1dXRkhjRk5XTW1oNlZsZHdTMDVHWkZkV2JrWlRZVEZ3Y2xSV1duZE5SbkJXVjJzNVZrMUVSbmxXYlhCWFZqRmFkR0ZJY0ZkaVZFWk1XWHBHVDJNeVJrZGpSMnhZVW10c05sWXhhSGRTTVZsNVZGaG9ZVk5GY0hKVmJURlRWMFpzYzJGSE9VOWlSbkI2VjJ0U1EyRkZNWEpYYkdSVlZteHdjbGxYZUU5VFIwWkhZVVphYVdKclNrUldSbHBoWXpGa1NGUlljR2hTYlZKdldsZDRZVmRXWkZoa1IwWnJUVlpLZWxVeGFITmhSa28yWWtac1YySllhR2haVlZwclZqRmtkR1JHWkU1aGVsWklWbTB4TkZsWFJsZFRXR2hVWW0xU1dGbHNhRk5oUmxsNVRWWmthazFYVWxwWlZWcHZZVlphVjJOSVdsZFNiSEJZV2tSQmVGSXhaSEpoUjNSVFlsWktXbFpYY0VOa01VNUhWMWhzYkZKck5WaFpiRlozVTBaVmVXVkhPVmRpVlhCSVdUQm9TMVl3TVVoVmJFSldZbFJHVkZWcVJsTmphelZYV2tVMVYxZEZTazFXYlRCNFRrWnNXRk5ZYkZaWFIyaG9WV3hrYjFaV2JISmFSRkpYVFZkNFdsa3dhRTlYYkZwelkwUkdXazFHV21oWmEyUkxVakZPYzJGR1pFNWhhMVl6Vm0xd1FtVkhUbk5hU0VwcVVteHdUMWx0YzNkbFJscDBZMFYwVkUxck5YcFdSelZIVjBkS1NHRkdhRnBoTVZvelZsWmFhMWRYVGtaa1JrNU9WbGQzTUZac1l6RlRNV3hYVTFod1VtSkdTbGhaVkVaM1lVWnNWbGR0ZEZoU01VcEpWVzE0ZDFZd01VZGpSV3hYWWtkUk1GZFdXbXRUUms1eVYyczVWMkpGY0ZsWFYzaHZWRzFXUjFWc1dsaGliVkpVV1d0YWQxWnNWblJsUjNSVllrVndSMVl5ZEhOWFJscEdVMjFvWVZKRlduSlZNRnBQWTJ4d1IyRkhiR2hOTUVwWVZtMHhORmxYVVhoWGEyUllZbXhLY1ZSVVNtOVdWbHAwVGxWT1UwMVdSalJXTWpFd1Ztc3hjbU5GY0ZaV2VrWklWbXBLUzFkV1JuSlZiSEJYVWxoQ1dWZFVTbnBsUmxsNFkwVm9hVkpyTlhCV2FrcHZWVlphZEUxVVVtbE5WVlkxVmtab2IxZEhTbkpPVm1SYVZrVndWRll4V25OamJIQkhWRzE0VjJKV1NqVlhWbFpXVGxaWmVGZFlaR3BTYlZKWVZGZHdWMDB4V25GUldHaHFWbXh3ZUZaSGVHdFViRXAxVVcwNVYxSjZSVEJWYWtaclYwWktjbHBIUmxOaVZrcFZWbXBDVjFNeFpITlhXR2hXWVROQ2MxVnRlR0ZOUmxwMFRsWk9WMUl3VmpSWk1GcEhWakpLVlZKc1VsZFNSVnBVVmpCVmVGZEZPVlpPVlRWWFltdEdNMVpyV21GaU1rVjRWbGhrVGxadGFITlZiVEZUVm14c2NscEhPVlpTYlhoWVZqSjBNR0V4U25OWGFrSlZUVlp3YUZsV1drdGpiVTVIWWtab1YxSlhPSGRYV0hCTFZHMVdSMXBJVmxaaVJUVndWV3BLYjFkV1pGaGtSbVJyVFVSV2VsWXhhSE5oTVVweVRsWk9WVlp0VWxSYVYzaGFaVlUxVjFSc1pHbFdWbGt4VjJ4V1lXTXhaSE5YYTFwWVlUTm9WMVJWV25kWlZuQlhXa1prVkZKcmNIbFVNV1J6VlRKS2NsTlVTbGRpUm5CeVZHdGFXbVZXU25KWGF6VlhZbFpLZUZaWGRHRmtNV1JYVjI1S1YyRXpVbkZaYTFwM1YxWlNWMWR0ZEZoU2EzQjVWR3hvYzFkc1dsaFZhazVYVmtWYWFGVnFSbXRrVm1SellVWmtUazF0WjNsV2JYaHJaVzFXUjFOWWFHRlNiWGh2VlcxNGQySXhVbFZSYTNSc1lrWndXVlJXVWxOVk1ERkZWbXhvVjJKSGFIcFpWRVpMVG0xS1IyRkdaR2hoTUhCdlYyeGtORmR0VmxoV2EyUmhVbTFTVDFsVVJscE5SbVJWVVd4T1ZVMVdiRE5VVmxwcllXeEtSazVXYUZwV00xSm9XVlZhZDFJeFpITlViWEJvWld4YVdsZFhkR0ZVTWtaWVVsaGthRTB5ZUZoWlYzUmhZVVphY1ZKdFJtcGhlbFpZV1ZWYVQyRldTWGhUYkZwWFlXdEtjbFpVUmxkU01XUjFVMnhrYVZaV2NGcFdWekUwV1ZVeFIxVnNaRnBsYkZwdlZXMTBkMDFHY0ZaWGJrNWFWbXh3V0ZZeWNFOVhiVVY0WTBkR1lWSkZXbkpaTWpGUFVqSkdTR0ZGTlZoU1ZWa3lWbXBHWVZZeFduUldhMlJVWWtkU1ZGbHJaRFJpTVZaMFRWWk9WMUp0ZUhsV2JUVnJWbFphYzJOR1dsWk5WMmgyVm1wQmVHTnJNVlZWYkdSWFpXeGFXVlp0Y0V0VE1VbDRWRzVTVUZZd1dsaFVWRVpMWWpGYWMxWnRSbHBXTVVwSlZsZDBiMkV4U2xWaVJsSlZWbXh3TTFVeFdscGxWMUpJVW0xb1RsWnRkekZXVkVvMFl6RldkRk5yV2xSaVIxSmhWbXBPVTJGR1drWlhiSEJyVFZkU01WWkhNWGRoVmtsNFUxaGtWMUpGV21oV2FrcEhWakZPYzFac1pHaE5ibWhhVm0xMFYxTXlUbk5pU0VaVFlsVmFXRlJXWkZObFZsbDVaVWM1YUZac2JEVlpWV00xVmpGWmVsVnNhRmhXYlZKWVdYcEtSbVZ0U2tobFJsSlRUVlZ3VmxacldtRldhekZXVFZWa2FsSldjR2hWTUZVeFYwWlNWMWR1WkZOTlZuQjZXVlZvVDFZd01YSmpSV2hXVFc1UmQxZFdXbUZYUmxaelZHMUdWMVp1UWxsWFdIQkhZVEpPY2s1V1pHaFNhelZaVld4V2QxVXhXblJOU0doT1VteHNOVlpXYUc5aFZrcDBWVzVDVmsxR1dqTlpWVnBYWkZkT1NWUnNaRk5pUm05M1ZrZDRWMVF4V2tkWGJrNVVZa2RvV0Zsc2FFTlNSbXhXVmxob1YySlZOVXBaTUZwM1ZHeEtjbU5GYkZkaVdFSk1WWHBHWVZZeFRuTmlSMFpUWWxaS2RsWkdXbTlSTVZKWFYyNVNiRkl3V2xWVVZtUlRWMVpWZVdSSGRHaFNhM0F3VmxjMVQxZHNXa1pUYm14aFVrVmFhRnBGVlhoWFZuQkhWV3MxVjJKR2EzZFdiRkpIWWpKTmVGZHNhRk5YUjNoWFdXMTBTMVl4YkhOaFJ6bG9VbTEwTTFZeU5VOVdNVnB5VjJwR1dHRXlVVEJXVkVwTFZqRk9jVmRzWkdoaE1qaDNWbXRTUzFJeVRuSk5WbXhWWWtVMWIxbHJWbmRoUm1SWFZXdDBhVTFXY0VoV01uUnZZa1pKZDFkdVJscFhTRUpZVmpKNFYxZEhWa2hTYldoVFRVWlpNRmRVUW1wT1ZsbDRWMWh3YUZJeWFGaFdhMVozVkRGd1YxZHJkR3BpUjFJd1ZXMTRUMVJ0U2xoaFJFcFhUVzVvY2xSVldrOWphekZYV2tab1dGSXphSGxXVnpWM1l6RlZlRlZzWkdGU2F6VlZWVzE0VjA1V1VuTldha0pYVmxSR1YxUnNWbmRXYkZvMlVtdG9WMkZyY0V4V2JGcExZekZXYzFwR1RsZGlhMFkyVm14amVFNUhSWGxVYmxKV1lUSm9jbFZ0TVZOalJsWjBUVVJXVGsxV2NIcFhWRTV2VkRGSmQySkVVbGRpUjJoMlZqQmtSbVZIVGtkaVJuQlhUVEF4TkZacVFtRmpNVnBYVTI1S2ExSnNXbFJaYTFaM1RsWmFkR1ZIT1dsTlZsWXpWRlpvUzFReFdsaFZiR2hWVmpOQ1IxUlZXbUZXVmtwMFVtMXdhVlpVVmtsV2FrbzBZakZaZVZadVNsZFhSMUpZVmpCb1ExTkdiRFpTYkhCc1VtNUNTRmxyWkVkVk1rcFhVMjVhVjFKc1NraFZla1pYVWpGa2NscEdhR2xYUmtwUlZsY3dlRlV4VGtkYVNFcFlZbXMxYjFsclZuZFhWbHBZVFVSV1YwMXJXbmxWTW5CUFZqSkdjbGRzVWxwTmJtaFlXVEo0ZDFJeGNFaGhSM2hvVFZoQ1lWWnRlRk5UYlZaSVUxaG9XR0pyY0U5V01GWmhWa1pzVlZOc1RtaFNiRnA1Vm0weFIyRnRTa2hrUkZaaFZsWndVRmxYYzNoWFJsWjFZMFpvYUUxc1NqWldiRkpMVXpKT2MxUnVTbXBTYlZKdldWUkdkMDFzWkhKVmEyUlVZbFphU0ZaSGVITmhSa3AwWVVoQ1dsZElRbGhXYlhoclYwVXhWVkZ0ZEU1V2JrSlpWMWQwYjFNeGJGZFRhbHBwVW0xb1ZsWnRlSGRVUmxwMFpVWmFiRlpVUmtaV2JYaGhWR3hhV1ZGcVdsaFdSVXBvV1dwR1dtUXdNVmxXYldoVVVsaENXVlp0ZEZkU01EVkhWMjVTVGxaVWJGUlphMmhEVTBaYWRHTjZSbGROYTFZMlZWYzFZVll3TVZkalJsSldZV3RhVDFwVldtdGtWbFp6Vm0xb1RtSkZjRmhXTVdRd1lURlZlVlJyWkZkaWJFcFFWbXhWTVdOR1VsZGFSazVYWWtaYVdWUldWbXRXTWtZMlVteGtXazFIYUROV2FrRjRZMVphYzJGR1pHbFNNVXBOVmxjd2VGUXhUbGRTYms1WVlsZDRWRmx0ZEVkT2JGcDBZMFZPV2xZd1ZqUldNV2h2VmpKS2NtTkdSbGRpV0dob1ZrUkdZV1JIVmtsYVJUbHBVbTVDTkZaVVNuZFZNV1J6VjI1U1ZtRXllRmRaYTJSdlkyeGFSVkp0Um10U2JGcDZWako0YTJGRk1WZGlNMnhZWWtkUk1GWlVSbUZqTVhCSlZXeE9hVkl5YUZWV1JscGhaREZPUjFkWWJHdFNNRnB2VkZkMFlWZEdWWGxsU0U1V1lsVmFlbFl5ZUhOV01rcFpZVWRvVjJGcldqTldiWGhyWXpGa2RHVkdUbWxXYTI4eVZtcEtNR0V5VVhoV1dHaFlZbXR3Y1ZWdE1UUlhSbXh6Vld0YVRsSnVRa1pWYlhoM1lrWktjMWRxUmxaTmFrWklWbFJHWVZJeFpIVmpSbVJYWld0VmQxZHJVa3RXTWsxNFdrWnNhVkl6YUZSV2EyUTBaR3hhV0dWR1RsTk5WVFY2Vm0xNGIySkdTbkpPVm14V1lXdEtNMVV3V25Ka01rWklVbXhvYVZaV2NEVldha293WVRGc1YxZHNaR3BTTW1oaFdsZDBZVTB4Vm5GU2JtUlVVakJhUjFSc1pITlZNV1JHVTIxR1YySlVSVEJaVkVFeFUwWk9XV0pHVWxoU01taFdWbXBDYTJJeFpFZGlTRkpzVWxoU2NWbHJXbUZsYkd4V1YyczVWMDFFUmxsYVZXaHpWakF4Y1ZadVNsZGhhMFkwVm1wR1QyTXlSa2RqUm1SWFRXMW9OVlp0TVhkVE1VMTRVMWhzVldFeWVIRlZiVEZUVkRGc2RHVkZkRTVpUm5Bd1ZGWlNVMWRIU2xkWGFrSldZbGhTYUZsVldrdGpNV1IxVVd4a2FFMVdjRzlXYlhoaFdWWmtSazFXVmxaaVJscFBXVmh3UmsxR1duSlpla1pWVFZkNFdGVXlOVk5XYlVwSVlVWmtXbUV4Y0doYVZscDNWakZrZEZKdGRGTk5WbkJLVmxjd2VHSXhVblJTYWxwVFYwaENXRlZxVG05WFJteFZVbTFHV0ZKck5URlZNbk0xVmpKS1JtTkhhRmhXYkVwSVdrUkJkMlZHWkhWVGJHaHBZWHBXV1ZadE1UUlRNbFpYVjJ0b2JGSnRVbTlXYlhSM1pXeHJkMVZ0UmxkTmEzQldWVmR3VTFadFJuSlhiR2hhVFc1T05GWnFSbmRTTWtaSVlrWk9UbUpYYUdGV2JYUmhZV3N4V0ZOWWJGTmhNbEp3VlcweGIyTldVbFZUYlRsWVZteGFlRlZ0TVVkV1JrcDBWVzVzVjAxcVJraFpWVnBoWkVaV2NtRkdXazVpYXpRd1ZtMXdTMU14U1hoVWJrcHNVbTFTYjFsVVJuZGxWbHB4VVcxR1ZFMXJOWHBYYTJoUFZqSktXR1ZHVWxwaVdGSk1Wako0V21WR2NFVlJiSEJYVFZWWk1GWnJaRFJoTVdSSVUyNUtUMVp0YUdGWlZFcFRWa1phVmxkc1pHdFNNVXBLVmtkek5WVXlTa2RYVkVaWFVqTm9XRlJWV2xwbFJrNVpXa2R3VTFZeFNtaFdSbFpoWkRKU2MxZHVSbFJoTTFKVVZGWlZNV1ZXYkZaWGJHUm9WbTFTU1ZsVll6VldNa3BaVVd0b1dsWkZjRTlhVldSUFVteHdSMVp0YUd4aVJuQmFWbTB3ZDAxV1JuSk5XRTVZWW10YVZWbFhkRXRaVmxwMFpVWmtUMVpzVmpWYVJXUXdWakZKZDJORmFGcE5SMmhJVm0weFMxZFdVbGxoUm1ST1VtNUNObGRVU2pSaE1sSkhVMjVTYUZKck5YQlZiVFZDVFd4YWRHTkZkRTlTYkVZMFZteG9jMVpIUlhsVmJrWldUVWRSTUZZeFduTldWa3AxV2taV1UySllhRmxXYWtvd1RVWlpkMDFZU2s5V1YyaGhWbXhhZDJOc2JGWldXR2hZVm10YWVsWnRlRzlXTWtwR1kwVnNWMkpZUWtoVmVrcFBZMnN4VjFwR2FHbFNNbWgzVmxkd1MySXlVbk5YYTJSWFlrVTFXRlJXWkZOVFJtUnlWMjA1YUUxVmJEWldWelZEVmxaWmVsVnRhRlpOUm5Cb1drVlZNVlp0VWtkYVJUVm9UVmhCTWxac1VrdE9SbFY0VjJ4a1dHSnJOWEZWYkdodllVWmFkR1ZJWkZkTldFSllWMnRhYTFVeVNsZFRhMmhZWVRGVmVGbFZWWGhYUjFKRlZteGthVkl3TkRCWGExSkhZekZaZUZwR2JHaFNiV2h3V1Zod1YyVkdXbGhOU0docFRWWnNORmxyV205aE1VbDNWMnhXVm1KVVJYcFVWM2hYWkVVeFZWRnRhR2xTYmtJMlYxUkNVMUV4YkZkWGJHUnFVbXRLWVZadE1WTlNNWEJGVTJzNVUwMVdjSHBYYTJSelZqRktWMVpxVGxkaVZFWXpWV3BLVG1WR1pGbGhSbFpwWVhwV2IxWlhNVFJrTWtsNFZXeGthRkpWTlZsV2JURlRWMFphV0dSRVFsZGhla1pZVm0xd1UxZHRSWGxoUlhoWFlXdHdURlp0ZUd0ak1rWkhWbXhrYVZaclZqTldiWEJMVGtkT2RGVllhR3BTVmxwVFdXeGtiMVpHYkhKaFJVNVBZa2RTVmxWWE1VZGhSVEZZVlc1c1ZWWnNXbkpXTUdSTFVteE9jMkZHY0dsU01tZ3lWMVpXWVZZeVVraFdhMXByVW0xb1dGbHRkRXRUVm1SVlVXMTBUMUl3V2tkVVZscHpWVzFGZWxGc2FGcGlSa3BFVkd0YVUyTnNaSEpPVjNoWFlrVnZlRlpyWkRSV01rWllVbXBhVjJKSGFGbFdhazV2Wkd4c2NWSnRkRmROVm5BeFZXMTRVMkZXV2tobFJtaFhVbXh3YUZwRVNsZGpNV1JaWWtVMVYxWXhTbGxXUmxaVFVqRlplR0pJU2xaaVJUVllXVmh3UjJWR1duUmtSRkpZWWxWV05Ga3dWalJXTWtaeVkwWkNWbUZyV2xoWmVrcFBVakZ3UjFSc1pGZGxiWE41Vm0wd2VFNUdWWGhUV0doWFYwZG9XVmxyWkZOV1ZteDBaRWhrYW1KR1dqQlpNM0JIVmpGS2RHVkliRmRpVkZaTVdXdGFZV015VGtkaVJsWlhWakpvTWxaclpEUlRNazE0V2toR1VtSkdjRTlaYlhoTFlqRmFjVkZ0ZEZSTlZUVklWbTAxVDFkSFNrZFhiR2hYWVd0YVRGUlhlR0ZqTVZwMFVteHdWMkpXU2twV2ExcHZaREpHUjFOdVNrOVhSVXBYV1ZkMFlWUkdVbk5YYlVacVlraENSbFpYZUhkV01rcFhVMnRzVjFaRlduWmFSRVpyWTJzeFNXSkdXbWxTTW1oWlYxZDRVMUl4VlhoVmJGcFlZa2RTY1ZadGRIZE5SbFowVFZoa1ZXSkdjRlpXYkdodlZqRmFSbUpFVWxWaE1YQlhXbFZhYTJOc1pITmhSMnhUWWtoQ1dsWXhaRFJpTVZWNFdrVmtZVkp0VWxsWlZFNVRWa1pTVjFwR1RteGlSMUo1VmpJd05XRkdXbkppUkZKV1RXNW9jbFl3V2xwbGJVWkhXa2RHVjFac1ZqUldWM0JIV1ZkU1YxWnVVbXhTYXpWUFZXMDFRMWRXV25KWGJYUk9VbXhzTTFSVmFHOWhSVEI1Vld4c1dtSkdXbWhXTUZwVFZqRmtkVnBHVGs1V2EzQTJWMVpXYTFJeFdYZE5WbVJxVTBoQ1lWUlZXbmRrYkZweFUydGthbUpIVWpCWlZWcDNWRzFLZEZvemNGZFdNMEpJVmxSS1RtVkdWblZVYldoVFlYcFdVRmRYZUd0aU1VMTRWMjVTVGxaR1NtOVpiRnBoVWpGU1YxWnRkRmRXYlZKSldWVmFiMWR0U2xsVVdHaFhUVlp3ZWxwRlpGTlRWbkJIWVVaT2FWZEhaRE5XYTJRMFZqRlJlRnBGWkZSaWF6VnhWVEJrTkZkR2JITmhSa3ByVFZad2VWWXlkREJoYXpGWVZXNXdXbUV5VWtoV2FrWmhZekpPU1dKR1pHaE5WWEJKVm1wSmVGWXhTWGhqUld4VVlsVmFWRmxyYUVOVlJtUllUVWhvYVUxV1NsaFdNalZUWVd4S1dGVnRSbGRpV0doNlZHeGFZVk5IVWtoU2JXeFRZVE5CZDFac1pEUlZNVmw1VTJ4c2FGSkZOVmhVVmxwM1lVWldjVkp0Um10U2EzQjZWa2R6TVdGSFZuSldXR1JYWWxoU2NWUldXbHBsUm1SellVWlNhVkp1UWxwWFZtaDNZekZhYzFkdVRsaGhNMUpaVlcxNGQyVldXWGxOVldSb1RWVnNORll5ZEc5WFIwVjRZMFJPVjJGcmNFZGFWM2hIWXpKS1IyRkdaRk5XV0VKMlZqRmtkMU14U25SV2EyUlZZbXMxY0ZWdGRIZGpSbXhWVW01a1YwMVdjREJVVmxKVFYyeFpkMWRyYUZkTmFsWklWbFJLUzFOR1ZuVlRiRnBvWVRGd1RWWlhjRWRrTVVweldraFNhMUp0VWs5VmExWmhWMVprVlZGdGRGTk5WMUpJVmpJMVQxZEhTa2hoUm1oV1lURmFhRmxWV25OT2JFcDBaRWQwVjJKRmNEWlhWbFpyWWpKS1NGTnNiR2hTYldoWVZGWmFkMVpHVm5GVGJFcHNVbXhLZVZkclpHOVVhekZ6VTIwNVYxWjZRalJXVkVaaFVqSktTVk5zWkZkU1ZuQjZWMWQwWVZZd05WZGpSbHBoVWtWS1dGUlZVa2RYUm10M1ZXdGtWMkpHYkRaV1IzQlRWakpHY21ORlpHRldWbkJ5V1hwS1IxSXhjRWhoUjJoT1YwVktUbFpxU2pSV01XeFhWRmhzVm1KSFVsZFpiWE14Vm14c2MxcEVVbGRTYlhnd1drVldNRmRHU25OalJFSmFUVVphVUZacVNrZE9iRXB6WVVaa2FWSXlhREpXYWtKclV6Sk9jazVXWkdoU2JrSndWVzE0ZDJJeFduTlZhMlJXVFZac05GZHJhRk5WTWtwSVlVaENWbUZyTlhaVWJGcGhZekZ3UlZWc1ZrNVdia0YzVmxSS05GbFhSbk5UYkdoV1lrZG9WbFp1Y0Zka2JHdDVaVWRHYWxacmNIbGFSV1F3VlRBeFIyTkZkRmRoYTI4d1dWUkdXbVZXV25WVGJHaHBVak5vV1ZkV1pEQlpWMDV6Vm01R1UyRXpVbkZVVmxwaFRWWmFTR1ZIT1doV2EydzBWVEkxYTFZeFdqWlJXR2hXVmtWYVVGbDZSbXRrVmxKMFVteE9VMVpZUWxwV2ExcFhWVEZaZUZSclpGZFhSM2hRVm14U2MxZEdWbkZSYm1Sc1ZtMTBNMVl5ZUd0WFIwcFdWbXBTVjAxdVFsQldha1pMVW14a2MyRkhSbE5pVmtwUlZsUkdZVlV5VG5KUFZtaHBVbXMxY0ZsVVFuZFpWbHAwVFZoa1ZFMUVWa2xWYkdodlZqRmtTRlZyT1ZkaVdHZ3pWakZhYzJSRk5WWlViR1JPVmpOb05sZFdWbGRVTWtaSFUyNVNiRkp0ZUZaV2JYaDNZMnhzVlZKcmRHcE5WMUl4V1RCYVlXRldXa1pYYTJ4WFlsaENURlpxU2s1bFJuQkpWR3hrYVZJeFNsbFhWM1JYWkRGT1YxZHVVbXBTVjFKWldXeGFZVk5HWkhKaFJtUlhWakJ3VjFZeWVGTlhiR1JKVVd4b1YwMVdjR2haTVZwSFpFZFNTR0pGTlZkV1JscGFWbTF3U2sxV1RYaGlSbVJVWVRGd1ZWbHJXbUZXYkZwMFpVaGthRkp1UWxsYVZWcDNZa1phVlZac1pHRlNWbkJZV1ZaYVNtVkdUbkprUm1SWFlsWkZkMWRXVWtkWGJWWlhWRzVPYVZJeWFGUlVWekZ2VjBaYVIxWnRSbXROVjFKSVZqRm9hMWxXU25SVmJGWldZV3RhVEZVd1dtdGpiR1J5VDFaV2FWSnVRWGhXVm1Rd1RVWlpkMDFXWkdwU2JXaFpWbTE0ZDFReGNGWlhiWFJZVmpCYVNGbFZaSE5WTURGV1kwUlNWMkpIVVRCWFZtUlNaVVp3UmxwR1pHbGhlbFphVjFkNFYxbFdaRmRXYmxKc1VqQmFjMVZ0ZUdGTlJuQkdXa1JDYUZJd1dUSlZiWGhyVjJzeFNHRkVUbGRoYTBZMFdrWmFVMWRYUmtkYVIyaE9WMFZLVGxadE1UUlpWbXhZVkZoc1UyRXlVbWhWYWtvMFYxWldjVk50T1ZoaVJuQjRWVzB4UjFkc1duSmpSRUpYWWxoU2NsWXdaRXRqTVdSelYyeHdhRTFZUW05WFYzQkhZekpPYzFkdVZtRlNiVkpVV1d4YVMxZHNaSEpXYlVab1RWZFNlbFl5TlU5aFZrcEhVMnhvV21KR1NsaFdhMXB6VmxaS2NrOVdVbE5pUm5BMlZtcEtOR0V5UmxkYVJXUlVWMGhDV0Zsc1VrWk5SbHB4VTJ4T1ZGSnNXbmxXTW5oRFZqSktWMU51WkZkV2VrRjRWVlJCTVdNeFpIVlNiRkpvWWtWd2RsWkdXbXRWTURGSFYyNVNUMVpZVWxsVmFrSlhUbFpzVmxkdE9WaGlWWEJKV1ZWb1lWWXhTbGRqU0d4aFZtMVNXRlZxUm5kVFIxSkhWR3MxVTFKc2NFdFdiVEV3WVRBMVNGSllhRmhYUjJoVldXdGtVMkl4VWxWVGFsSllVbTE0ZWxsVll6VmhSa3AwVld4b1YwMXVhRE5aYTFwTFkyczFWMk5HY0ZkV2JrSlJWMVphYTFJd05YTlhiazVZWWtkb1dGUlVSa3RpTVZsNFYyMTBWVTFyTVRSV01qVlhWbGRLUjJOSVFsWmhhMXBNVmpCYVlWSXhaSFJTYlhST1lrWndObFpxU1RGVk1WSnpWMnhvVm1KSGFGZFphMXBMVTBaWmQxZHNXbXhXTVVwSldrVmFhMVJ0UlhwUmJVWlhZa2ROZUZWNlJscGxSbVJ4VjJ4T2FFMHlhRmhYVjNodllqSk9jMkpFV2xOaWJWSlVWRmR6TVZOR1pISlhhemxYVFZWd2Vsa3dXazlXTWtwVlVXcFNWV0V4Y0doYVJWcGhZMnh3UjFWdGJHaGxiRnAyVm14U1ExWXlVWGhYYms1cFUwVndXVmx0TVZOalZsWjBUVlJTYkdKSGVGZFhhMmhyWVVVeFJWSnNhRnBOUm5CMlZqQmtSbVZHVG5OVmJHUlhVbFZaTUZadGNFdFVNVTVZVkd0a1dHRjZWbTlaYTFwM1ZHeGFkRTFJWkd4U2Eyd3pWR3hvVDFaSFNuSk9WbVJhWVRKU1ZGa3dXbHBrTVhCSVRsZDRhVkp1UWxwWGExWnJVakZrYzFkdVRtbFNSa3BaV1ZSS2IxVkdaRmRYYTNScVRWZFNNVlZYZUd0aFZrcHlZMFZvVjFKc1dtaFhWbHByVW1zeFYxWnNXbWxUUlVwWlYxZDBZVmRyTVZkWGJHaHNVbnBzYjFSWGRHRmxiRlY1VGxVNVdGSXdjRWxaVlZwdlYyeGFSbGRzWkdGV1ZuQXpWVEJrVjFOR1NuTlVhelZYVFZWdk1sWnFTakJaVjBWNFZXNU9XR0pzV2xOWlYzaGhWMFpTV0U1V1RtaFNiSEJHVlcxNFlXSkdTblZSYTJSYVZsZFNkbFpVUmxwbFYwWkhZa1prYVZaR1dYcFdWekI0VlcxV1IxZHVSbGhpUlRWd1ZXcEdTMlZHV2tkWGJYUldUV3hhZWxZeU5WTmlSa3BaVlcwNVYyRnJTak5hVmxwV1pWZFdTVlJzWkU1aE0wSlhWbGQ0VTFFeFpFZFhiazVxVW10S1YxbFhkR0ZoUm13MlUydGtWRkl4V2toV1IzaHZWVEpGZWxGdFJsZGlXR2h5V2tSR1NtVkhTa2RhUmxKWVVqSm9XbGRYZEd0aU1rMTRWbTVPYUZKck5WbFZiWGhMVjBaWmVVNVhkRmhTYTNBd1drVlNUMVl5U2xWU2EyaFhZV3RHTkZadE1VOVNNa1pIV2tVMWFXSlhaM2xXYlRCM1pVWkplVlJ1VG1GVFJYQnZWVzAxUTJNeGJGVlNibVJWVm0xU1dsa3dWbXRoUlRGeVRsaHNWV0pHY0hKV2JURkxVbXMxVjJGR1dtbFhSMmQ2Vm1wS05GbFhVa1pOVld4b1VsUnNWRmxyWkROTlJtUllaRWRHYUUxV1ZqUlhhMVp2WVVaS2RHRkhSbHBpUjJoUFdsVmFZV1JIVmtsVWJHaFRUVlp3U0ZkclZtRlpWbEp6VjFod2FGSkdXbGhaYkZKRFRrWldjVkpzY0d0TlJFWllWMnRhYjJGSFJYZGpSemxYVmpOb2NsbHFTazlqTVdSMVZHeG9hVlpXY0hoWFYzaFdUVlpPUjFwSVNsaGlXRkpXV1d4V2QyVnNWWGxsUldSWFRXdHdWbFZzVWtOWFJscDBWV3M1WVZaV2NETlZNVnBQWXpGR2MxcEhiR2hOU0VFeVZtcEdZVlV4U1hsVldHaFZZa2RTV1ZsdGVFdFVNVnB5VjJ0MFYxWnNTbGxaTTNCSFlrZEtSMk5GYkZWaVJsVXhWbXBHU21ReVRrZGpSbkJYVm01Q05sWnRNSGhTTWs1MFZHdHNXR0pHY0hCVmJUVkRZakZrV1dORlpHaE5iRXBJVlRJMVQxbFdTbFZXYkdoWFlXczFjVnBFUm1Gak1WWnlaRVUxVTJKWWFGcFdWRW93WVRGYVNGTnJhRlppYTFwWFdXeG9iMVJHWkZkWGJVWnFZa1p3ZVZwRlZURlViRnAxVVdwV1YyRnJiRFJWYWtwSFpFWk9jbHBIY0ZOU1ZYQllWMWQ0YjJJeFZrZFhia1pVWVROU1ZGbHJaRk5XYkZWNVpVYzVWMDFWY0ZkWk1GcFhWakZhYzFOcmFGaFdiSEJ5VldwR1UyUldUbk5oUjJ4VFRXMW9NMVpzWkhkU01VMTRXa1ZrWVZKdGFITlZibkJ6VmpGU1ZsVnJUazlTYkd3MVdrVmtNRmRHU1hkV2FscFhWak5vZGxZeU1VWmxWbFp6VlcxR1YySklRbTlXVkVKclZqRk9SMU51VG1GU1ZGWnZWRlJDUzFOc1dYaFZhMDVXVFZac05GZHJWbXRaVmtwWVpVWk9XbFpGY0haV01GcGhZMnhhZEZKdGFGTmlXR041VmxjeGVrNVhSWGhYYmtwUFYwaENXRlp1Y0VkbGJGcFZVbTFHVTAxWFVucFphMXByWVVVeFdWRnNWbGRYU0VKTVZUSXhWMUl4VW5WVGJVWlRZbGRvZDFaWGNFZFRNV1J6V2tab2ExSXpVbGRVVmxwM1pXeGFXR1ZIZEZoU01IQkpWbGR6TlZaV1duUmhSVkpYWVd0YWFGcEZWWGhXYkhCSFdrZG9iR0V4YnpGV2JUQjRaREZSZUZwSVNrNVdWMUp4VlcxMFMxZEdiRmhrU0dSVlVteFdNMVl5ZUd0aGJGcDBWVzV3VjJKWWFISldWRVpoWkZaR2RWZHNaR2xXUlZWM1ZqRmFZVk50VmxkVmJsWlZZbGhDVkZacVJrdFdiR1JZWlVkMFQxSnNjRWhXTWpWVFZHeGFSbE5zUWxaaVdHaDZWR3hhZDFac1pIUmtSbVJPVWtWYVdGWkdXbE5WTVZsNVUyeFdWMkpGU2xoVVZXUlRWRVpXY1ZOck9WTk5hM0JJV1RCYWIxWkdTbFpqUlhCWFlsUkNORlJyV2xwbFZsSlpZVWRHVkZKc2NHOVdWekUwWkRGYVIySklTbGhpYlZKWldXdGtVMlZzV25SbFIzUm9VbFJHV0ZsclVsZFdhekYxWVVkb1YyRnJjRWhaZWtwUFVqSkdSMWR0YUdobGJGbDVWbTEwVjFsV2JGaFViR1JVWW14S1ZGbHJaRk5VTVd4WlkwWmtWRkpzY0hwWGExSlRZVVV4VjJKRVZsWk5ibWgyV1ZWYVMxSXlUa2RoUmxwb1lYcFdWVmRXVm1GV01rNVhWRzVLVDFZemFGUlpXSEJXWlVaYWNscEVVbWxOYTFwWVZUSjRWMVl5U25OalJtaFdZbGhvTTFZd1duZFNWa3B6VTIxNFUySldTalpYVmxaclRrWlZlVk5zWkZSaVYyaFlXV3hTUm1ReFduRlJWRVpUVFZkU01WWlhNVFJWTWtwWFUyeHNWMVl6UWtSYVJFWmhZekpLU1ZOc2FHaGxiWGhaVm0weE5HUXhaRWRXV0d4UFZqQmFXRlpxUWxkT1JtdDNZVVYwV0dGNlJqRlpWV1J2VjJzeGNWSnNVbFpoYTFweVdrVmtTMUl4VW5SaVIyaE9VMFZLWVZadE1YZFNNV3hYVjFoc1ZGZEhlRmRXTUdSdlYxWnNkR042UmxoV2JYZ3dXVE53UjFkR1duUmxSbHBXVFdwQk1WWnFRWGhXTWs1SllVWmtVMlZyUlhoV2JYQkhVekpOZVZScmJHbFNiV2h2VkZab1EyVldXbk5WYTNSVVRWVndlVlJzV25OaGJFcHpZMFU1V21KVVJuWmFWbHBoWkVkT1JscEdjRmROVlhCWlZsY3dNVk14YkZkVGJsSldZbFJzVmxadGVIZE5NVmw0VjIxR2ExSXdOVWRYYTFwVFlWWmFjMk5GYkZkV1JXdDRWbXBHWVZkR1RuSlhhemxYWWxob1dGZFdaSHBOVjFKelkwWm9iRkl3V2xsVmFrWmhVMFpaZVdONlJsZE5hM0JIV1RCU1lWWXlTbFZSV0doWFVrVmFZVnBXV2s5ak1XUnpZVWRzVTFaR1dsaFdiVEI0VGtkUmVWSnJaRmhYUjFKWldXeFdZV05zVm5OVmEyUllZa2RTZVZkcll6VmhSa2w0VjI1c1YwMXVhSFpXYWtwSFkyMUtObEZzY0ZkU1ZuQnZWMnRXWVZReVRYbFRhMlJZWWxkNFdGUlhNVzlYYkZwMFRWUkNWMDFYZUZoV1YzUnJWakZrU0dGR2JGcGhNVlY0VmpCYVlXUkhWa1prUjNocFVtNUJkMVpHV2xOVk1rWkhVMnhXVTJKSVFsZFdhazV2VkVaYWNWTnJkRk5OYXpWS1ZUSjRWMkZGTVZsUmEzaFlZa1phYUZsVVNsTldNVkoxVkd4S2FWSXhTbGxXUmxKTFlqRmtSMWRZYUdGU1JVcFlWRmQ0UjA1R1pISldiWFJZVWpCd2VWUnNXbk5YYlVwVlVteFNWMkV4Y0ZoYVJXUlhVMVp3U0dWR1pHbFNNMk40VmpGU1QyUXhXWGhYYkZwT1ZteHdjVlV3YUVOWFJsSllUbFpPYTJKR2NEQlVWbFl3VjBaWmQxZHJiRnBXVm5CeVZtcEdTMWRXUm5KaFJtaHBVbXh3YjFaclVrdFVNazV5VGxaa1lWSnRhSEJXYWs1dlZsWmtXR1JIT1ZKTmJFcDZWakkxVDFkSFNrWk9WbEpWVm14d2VsUnJXbHBsUjBaSVQxWm9VMDFJUWtwWGJGWnJZakZhZEZKdVNrOVdWa3BZVld0V1lXRkdjRVphUms1VFRXczFTVnBWWkhOVk1rcHlVMjFHVjJFeGNHaFdWRVpHWlVaa2NsZHJOVmRpVmtwYVYxWmtNRk14WkVkaVNFNW9VbnBzYzFsclpEUldNVmw1WkVSQ1dGSnJjSHBXTWpWM1YwZEZlR05JU2xwV2JIQnlWVEJrUjFORk9WZGFSbVJUVmxoQ2RsWnRNWGRUTVZWNFZHdGtWMkpyY0ZoWmExcDNZMFpXYzFWc1pHdE5WbkJaV2xWak5WVnJNVVZXYkdoWFRXNW9XRlpyWkVkak1VNXpWbXhXVjJKSVFqWldSM1JoVjIxV1NGSnJiR0ZTYlZKd1ZteGFkMDVzWkZWUmJVWnBUVmRTZWxZeWRHRlhSMFp5VGxab1ZWWldjRE5XTUZweVpVWmtjbVJIY0dsVFJVcEtWMVJDVmsxV1dYaFhhMlJZVmtWd1dGbHNhRzlqVm5CV1ZsUkdVMDFXY0ZwWlZWcHZZVlpKZW1GR1VsaFdNMUpvVlhwR2ExSXlTa2xVYldoVFpXMTRXbFpYTUhoVk1XUkhWMWhzYW1WclduQlZiWFIzWld4WmVVNVlUbGROUkVZeFdWVm9TMVl3TVVkalJYUmhWbTFTU0ZWcVJsZGpNa1pIV2tVMVRsWllRbUZXYlhCSFdWWnNWMXBJVWxkaE1sSm9WVEJhWVZac2JITmFSemxYVW14d2VWZHJVbE5YUmtwMFZXeHNZVkpYVWtoWlZFRjRWakpLUlZWc1pFNVdNbWcyVjFaU1IxTXhXbGhUYTJSb1VtNUNXVlV3Vmt0U1ZscElaVWRHYTAxVk5WbFdSM1JoVmxkS1NGVnJPVmRpVkZaRVZqRmFhMVpXUm5OYVIyeE9WbTEzTVZaVVNqUmpNa1pIVTJ4c2FGSXdXbFpXYm5CWFpHeHJlV1ZJU214V01ERTJXVlZhYTFSc1duSmpSRnBYVFc1U2FGbFVTa2RYUmtwWldrZHdVMVl4U2xsWFYzaFRVbXN4UjFwR1pGaGlhelZZVkZaa1UxZHNiRlpYYlVab1ZqQndSMWt3V210V01rWnlVMjVLV21GcldtaFZha3BMVTFaT2MyRkhiR2xXYTNCYVZteGpkMlZGTlVkWGJrNVhZa2RvVUZacVRsTlhSbEpYVm01a2JHSkhkRE5XTWpGSFZqQXhWbUo2U2xaV2JFcElWbXBHV21Wc1VuRlZiR1JvWVRGd2VWZFljRXRTTVVsNFkwVm9hVkp0YUZSWlZFNUNUVlphZEUxVVVsWk5WV3cwVmtab2IxbFdTblJoUmxKYVZrVmFNMWxWV2xka1IxWkpXa2R3VTJKSGQzcFdha293VFVaYVYxZHVUbXBUU0VKWldWUkdTMVpHV1hsbFIwWnFUV3MxU2xscldsZFdNa3BKVVdwYVdGWnRVVEJWZWtwT1pWWlNjbHBIYUZOaWEwcDJWa1phYjFGdFZuTlhiRlpUWWxWYVlWWnRNVk5UVmxwWVpFYzVhRTFWY0hsVWJGVTFWMnhrU1ZGc2FGVmlXR2hvV2tWVmVGWldWblJqUlRWWFltdEtZVlpzVWt0TlJteFlVbTVPVkdKc1NtOVZiVEZ2V1Zac1ZWSnVaRTVOVmtwV1ZXMTRhMkZ0U2toVmFrSldZbGhvY2xaSE1VWmxSMDVHWkVaa1RtSnNTbmxXUjNSclVqRk9SMWR1VmxWaVJrcFpWVEJXUzFkV1dsaGtSbVJVVFd4S2VsbHJXbGRWTWtwSFkwaE9WMkpZVWpOV01uaHJZMnh3U1ZwR1drNWhNMEpJVjFSQ1lXTXhaRWRYV0hCV1lsZG9hRlZyVm1GVlJsWnhVMnM1VTAxcldrbGFWVnBQVkd4S2RWRnNjRmRpVkVJMFZGVmFjMWRHV25OYVIwWlVVbGhDV2xkV1VrOVZNa2w0VjI1U2ExTkhVbk5aYTJRMFZteGFTRTFFVmxoU2Eyd3pXVEJXYjFZd01YVmhTRnBYWWxSR1dGa3llR3RqTWtaSFkwZDRhRTFZUWpWV01XaDNVakpGZVZSWWJGTmhNbWh3VlcweFUxWkdVbFZUYlRsWVZteHdNRnBWWkRCVU1VbDNWbXBTVjJKSGFIWldha3BHWlZaV2MyRkdjR2hOYkVveVYxaHdSMVl5VFhoalJXUlZZa2RvVkZsc2FHOU9WbHB4VTJwQ1RsSnRVa2xWTW5ScllXeEtXR1ZIYUZkaVJuQmhXa1JHWVdOV1JsbGhSbVJPWVhwV1NWZFdWbUZrTVZKelUyNU9hbEpzV2xoWmJHaERWRVpXZEUxV1pGaFNhM0I1V1d0a2QxVXlTa2RqU0ZwWFVteHdkbFZVU2twbFJtUnpZVWR3VTFZeFNsWldSbVI2WlVVMVIxcElTbWhTVkd4WVZtcENkMWRXYkZaV1ZGWlhUVVJHU0ZZeWREUldNVnBYWTBkb1dtVnJXak5WYkZwWFl6RndSazVXWkU1TmJXaGhWbTE0YTA1SFNYbFRXR2hZVjBkNFZWbFVTbTlXTVd4eVdrYzVXRkp0ZUZaVmJUVnJWbFpLYzJOR1pGZE5ibWhRVm1wQmVGZEdWblZpUjBaVFZtNUNlVlpyWkRSWlYwMTVVMWh3WVZKdGFHOVVWbHAzWWpGYWNsVnJkRk5OVld3MFZrZDRjMWxXU25SVmJUbGFWMGhDV0ZacVJtRmtSVEZKWVVkc1RsSkZTVEJXYWtreFZUSktSMU5ZWkZoaWExcFdWbTB4VTFaR2NGZFhiazVYWWtkU01GVnRlR3RVYkVwR1UxUkdXRlpzV21oV2FrWmFaVVpPV1dOSGFGUlNXRUpaVjFaa01GbFdUWGhqUmxwWVlrVTFjbFp0ZUV0bGJGcFlUVmhPVmsxRVJsZFpNRnAzVmpKS1ZWRnFUbFZXYkhCSFdsVmFUMWRYUmtkaFIyeG9UVEJLV2xZeFpEQmhNVlY0V2tWa1ZtSkhVbGhaYlhNeFZVWldkR1ZIUms1U2JFcDZWbXhTVjFZeVJqWlNibXhhVFVaYWRsWXljM2hTTVZwVlVteGthVmRGTkRCV1YzQkhXVlprV0ZKclpHRlNWRlpVV1cxMFMxWnNXblJOU0doUFVtMTRXVlpYZEd0V1IwcHlUbFpXV2xkSVFsaFdNRnB6WTJ4a2RWTnRlRmRpUjNjd1ZqSjBVMUV4V25KTlZtUlhZV3hLV0Zsc1VsZFdSbHB5V2tWYWJGSXdOVWhaYTFwM1lVVXhjMU5zVmxkaVdFSklXWHBLVG1WV1NuSmFSbFpwVWpGS1ZWZFhkRzlSTVdSSFYyNVNiRko2YkhCVVZtUlRVMFpWZUdGSE9WaFNNRlkxVmxkNGIxWnRSbkpPV0ZwYVZsWndhRmt4V2t0amJWSkhZVVprYUUxWVFUSldiWGhyVGtkSmVGcEZaRlZoTVhCVldWUktORmRHV25GVWEwNVVVbTFTV0ZkclZURmlSa3B6VTJwR1YySllhRlJaVmxwTFkyMU9TVnBHWkZkbGExWXpWMnRTUjJFeFNYaGFTRXBoVW14d2IxUlVSa3RrTVZwSFYyMUdWRTFzV25wV01XaHpZa1pKZWxWc2JGWmhhMG96VlRGYVlWZEhWa2hrUm1SWFlraEJkMVpzWkRSVk1XeFhWMjVPYWxKRk5WaFpiR2h2WVVad1JsZHJkR3BOVjFKNVZHeGtiMVJzV25Sa2VrcFhZV3RhVkZWVVJuTldNVlpaWVVab2FWSXhTbHBYVmxKSFpESk9WMVpZWkZoaWJWSllWRlprTkZac1ZuUk9WM1JYVFZWd2VsWXljRU5aVmxwWVZXdG9XbFo2Umt4Vk1WcEhZMjFHUjFkck5XaGhNVzh5Vm0xNFUxSXhiRmhWYkdSVFltczFjRlZ0TVZOaU1WSlhWbTVrVTFadFVsbFpNRlpyVm0xS1YxZHJhRmROYWxaWVZteGtTMU5IUmtsUmJGcHBWa1phUlZacVNqUmhNVmw0Vm01S1ZHRjZWbGhaYkZwTFUxWmFkRTFFUmxaTmExb3dWbTAxUzFaSFJqWmlSbVJhWWtkb2RsbFZXbHBsUm1SMVdrWmthVkp1UVhkWGExWmhZVEZTZEZKWWNGSmhNbWhaVm10V1MyUnNjRVZTYlVacVRWZFNXbGt3V2xkaFIwcEdZMFpzVjJKWVVsaFhWbVJIVWpGa2RWSnNVbWhsYlhoVlYxZDBZVmxYVm5OYVNFcFlZbGhTYjFadGN6RlNNVlY1WlVoa1YwMXJjRnBXVnpWSFdWWmFWMk5HVW1GU1ZuQm9XVEo0ZDFJeFZuUmlSMmhzWWtad2FGWnFSbXROUmxweVRWWm9WRmRIYUZkWmExcDNZakZXYzFaVVJsaFNiRm93VkZaYVQySkhTa2RpUkZaVlZsWktXRmxWV21GV1ZrcHpXa1prYVZkRlNsVldiWEJMVXpGa1dGSnJiRlJpUjFKdldWUk9RMU5XV2toTlNHaFVUVlZ3ZVZReFdtdGhiRWw1WVVVNVYySlVWa1JhUjNoYVpWZFdSMXBHY0ZkTlZWa3dWbFJKTVZReVJuTlRiR2hvVW10YVdGbHNhRzlOTVd0M1YyeGthMUpVVmxkV1IzaHZWVEpLU1ZGcVVsZFdSWEF6VmxSS1IxSnJNVmRhUjNCVFlsZG9XRlpHWXpGaU1rNXpWMWhrWVZKV2NITldha0poVTBaa2NsZHRkR2hTTUZreVZtMXdTMVl4V2taVGJXaFlWbTFTVkZVd1dsTmpWbVJ6V2tkc1UyRXpRbHBXTVdRd1ZqSlJkMDVZVGxoaWExcFZXVmQ0UzJJeFVsZFhiazVQVW14c05WUnNXbXRXYlVwV1ZtcFNWMDF1YUhaV01qRkdaVWRPUlZSdFJsTk5NbWcyVmtjeE5GSXhXbGRUYms1VllYcFdXRll3VmtkT1JscDBaRWQwVDFKc1JqVlZiWGhyVmtkS2MxZHNUbHBoTVhCb1ZqRmFZV1JIVmtaa1JsSlRZa1pyZVZaWE1UUlVNa1p5VFZaa2FsSkZXbGhWYWs1dlkyeHNWMWR0UmxkTmF6VklWbGQ0YTFVeVNrbFJiVGxYVFZad2FGbFVSa3BsUm5CSlZteGFhVmRGU25wWFZsSkhaREpTYzFwR1pHaFRSMUpVVkZaYWMwNUdiSEpoUlhSWFlsVlpNbGxyV205WGJVcEhWMnBPVjAxdWFHaFdNR1JUVWxaV2MxcEZOVmRpVkdnMVZteGplRTVIU1hoWFdHUk9WbTFvVjFsVVNtOVdNV3h6WVVjNVYxSnRkekpWYlRFd1lXc3hXVkZyYkZwaE1YQlFXVlprUm1ReVRrWmxSbVJwVmtWSk1GWkdWbUZYYlZaSFdrWnNZVkpVYkZoV2FrWkxWbXhhY1ZGdGRHbE5WbkJZV1d0b1UyRXhUa2hWYkdoWFlsUkZNRnBXV21Ga1JUVllaRVpvVTJFelFqWlhWRUp2WWpGYWMxZHVUbFJoTW1oWVZXdFdkMVJHVm5GVGF6bFRUV3RhU0ZkclZURmhWMHBZWVVSV1YySllhRlJWVnpGWFVqRmtkVlJ0UmxSU2JIQjRWbGN3ZUZVeFpFZFZiRlpTWVROU1dWWnRNVk5YVm5CR1drVmtWMUpVUm5sVWJGSkRWakZKZWxWdVNsZGlSMUpNVlRCYVYyUldSbk5YYld4WVVqSmtObFl4WkhkU01XeFhXa1ZvVjJFeWFGUlphMXAzVkRGYWMyRkZUazlpUm5CNFZURlNSMVpGTVZobFJtaFdUV3BXVEZsWGVFOVNiRTV6V2tad2FFMVlRWHBXUmxKSFYyMVJlRnBJVW10U2JWSllXV3RXZG1WR1dYbGtSM1JwVFZaS2VsWXhhRzlXUjBaelYyeG9WbUpZYUROV01GcHJWakZrZEdSR1VsTmhNMEpoVjFaV1lXSXlSbGRUYmxaU1lrZG9XVlp0ZUV0VFJtUlhWMnhPVTAxV2NIaFdNbmhQWVZkR05sWnNSbGhXTTFKWVdrUktWMVl4WkZsaVJUVlhVbFZ3VjFkWGRHRmtNV1J6Vm14b2FsSnRVbGhVVjNSM1ZteFdjMVZyVGxkTmExcDVWako0YjFkck1YVlVhbEpXVFZkU1RGVXdaRWRTTVZKeldrZG9UazFGY0doV2JUQjNaREpXUms1VmFGWlhSMmhvVld4a1UxZEdiSFJrUjBaWFZtMTRlVmRyV2s5aGJGcHpVMnhvVjJKVVZuSlphMXBMWXpKT1JWRnNWbGRpUlhCVlZtMHhlbVZHV1hsVWEyUnFVbXh3V0ZSVVNtOVdWbHAwWTBWMFZFMVhVbGxWYlhScldWWkpkMWRzYUZkaVdHaFlWR3RhYTFkWFRrWmFSbkJYVFVSRk1WWlVTakJpTWtaWFUyNUtUMVpzU21GV2ExVXhVa1phYzFkc2NHeFNia0pHVlZkNGExUnNXWHBoUm14WFlXdGFkbGxxUmxwbFZrNTFWR3hTYVdGNlZsaFhWM1JoVm0xV1IxZHVVbXhTTUZweVZXcEdTMU5zWkhKWGJYUlZZa1p3TUZwSWNFZFhSMFY0VjJ4a1ZXSkdjR0ZhVmxwUFkyeHdTR05HVWxSU1ZYQmFWbXRhYTJReFdYbFdiazVZVjBkNFQxWnRNVk5qVm14eVdrWk9iRlp0ZUZkV01qRXdZVVphZEZWcmJGcFdWbFkwVmpCYVlWSnRTalpSYkdSVFVsaENVRmRzVm1GaE1sSlhWbTVTYkZKck5YQldha3B2Vm14YWNsZHRjR3hTTUd3MFZUSTFUMWRIU25OVGJrNVdZV3RLYUZkV1dtRmtSMVpKVkdzNVUySkdXVEJYVmxacVRsWlplRk5ZWkZkaGJFcGhWRlZrYjFWR1duUk5WWFJUVFdzMVJsWkhlR3RoUlRGWlVXcGFWMkpZYUdoVmFrcFRWakpPUmxwR2FHaGxiRnBaVjFjeE1GTnJNWE5YYmxKT1ZrWktjRlJYZEhOT1ZsVjVaRWM1VjFJd1ZqVldWM2h6VjIxRmVWVnVXbGROUm5CNldYcEtSMUl4VW5SalIyeFRZbXRLV0Zac1kzaE5SMUY1VWxoa1RsWldXbGhaYTJoRFdWWnNWVkp1WkdoU2JIQkpXbFZrUjJGdFNsWk9WWEJhWVRGd2NsbFZaRVpsVlRsSldrWmtUbFp1UW05V01WcHJWRzFXU0ZScldtbFNiRXB3VlcxNGQyUXhXbGhqUldSVVRXeEdORll5ZUc5aVJrcHlUbFprV21KR2NFaFVhMXBhWlZkV1NHUkdjRmRoTTBKSlZsUktORlV4V2xkWGJrNXFVa1UxYUZacVRtOVdNWEJYVmxSR1YyRjZiRmhXTWpGelZqRmFkR1JFVmxkaVIwNDBWR3RhVm1WR2NFbFViR2hvVFZoQ1dsZFdaSHBOVmxsNFlrWldVMkp0VW05VmJYaDNaVVpXZEUxVVFtaGhla1phVlZkMGIxWXlTbFZTYm5CWFlXdGFhRlZ0ZUdGWFZuQkhXa2RzVTAxRVVYZFdhMlF3V1ZkTmVGZFlhRmhpUjNod1ZXMXpNVmRXVm5GU2EzUnNVbXh3V1ZSV2FIZFViRmwzVjJ0b1YwMXFWbFJXUjNoaFRtMUtTVk5zY0doTldFSnZWbTB4TkZZeVVraFdhMmhyVW0xU1QxVnJWbUZYVm1SVlVXMDVhazFYVWtsVmJHaHZZV3hLY2xOc2FGZGhNVnBvV1RKNFZtUXhjRVphUms1cFZsWndTVll5ZEZaTlYwWllVMnRhYWxKdVFsaFphMlJ2VFRGV2NWSnNjR3hXYkVwYVdWVmtSMVpHU2xWV2JIQllWbTFvTTFacVJtdFdNVnBaV2taa2FFMHhTbHBXVnpFMFpEQXhSMVZzWkZaaVJUVlpXV3RhZDJWV1VuTldiVGxYVFd0d1dsbFZhR0ZYYlVWNFkwVjRWMkpIVWt4VmFrWkhZekZ3U0dGSGFFNVhSVW95Vm0xNFUxRXhiRmRhU0ZKWFlrZG9XRmxVUm5kamJGWjBUVlpPVlUxV2NEQlViRlpQVjBaYWRGVnNXbFpXTTJob1ZrZDRZV015U2tWVmJGcE9ZbTFvZVZacVFtdFRNVTVJVW10a1lWSnVRbGhVVkVaTFlqRmFWVkZ0Um1wTlJGWjZWVEkxUzJFeFNYcFJhemxYWVd0YVRGUnRlR0ZXTVhCRlZXeGFUbFpzV1RCV2Frb3dZVEZrU0ZOcmFHeFNiV2hoV1d0YVMxSXhVbFpYYlVacVZtdHdNVlpIZUd0VWJGcFpVVzFHV0Zac1dtaFpWRXBIVmpGT1dXTkhhRlJTTVVwWlZtMXdUMVV5UmtkV2FscFRZa1p3YzFWcVFuZFRiRlY1WlVkMGFGWnNjRmhaTUZwelZqRktjMk5IYUZoV2JGWTBWV3BLVDFKc1pITlhiV3hUVmtaYVdsWXhaREJXTWxGNFYyNU9WMkpzU25OVk1GVXhXVlphZEdWSVpGaFNiR3cxV2xWV1QxWXdNWEpqUm5CYVZsZFNkbFp0TVV0V1ZrcHlXa2RHVjJWcldrbFdWM0JIWVRKU1NGSnJXazlXYlZKd1ZqQmFSMDVzV25STlZGSm9ZbFphUjFSc1ZtdFdWbVJJWlVaYVdtSllUWGhXYlhoelpFZE9ObEpzWkZkaVdHZzFWakowWVZReFpFZFRiazVVWWtad1YxbHNhRk5OTVZwSVRWVjBVMDFyTlVwWk1GcDNWakZaZVdGSWJGZGlSMUkyV2xWYVlXUkdUbkpXYkZwcFVtNUNVRmRYTUhoaU1sWlhWMjVTYWxKWVVsUlpiRnBoVTBaYVNFNVdaRmRXTUhCSVdUQm9RMVp0U2xsaFJFcGhWak5vYUZsNlJsZGpiSEJIWTBaa1RsSkZWWGRXYlhCS1RWWlJlVkp1VGxSWFNFSnZWVEJXUzFZeGJITmhSemxPVFZkU1dGWXlNVEJYUmtsNFUydG9WMUl6YUdoV1IzaGhZekpKZWxwR1pGZFNWemt6VmpGYVlXRXhUa2RVYmtwb1VteHdjRlZxU205WFJtUllaVWM1YVUxV1NraFdNbmhoVjBkS1ZsZHNiRlppUmtwSVZqQmFhMk5zWkhSUFZtUk9Va1ZhU1ZkVVFsZGlNVmw1VWxoc1ZsWkZTbGxXYlhoM1dWWndWMWRyT1dwaVNFSkpXVEJhVDFZd01IbGhSbkJYVFZkUmQxZFdXbk5XTVhCR1drWmFhV0V6UWxwWFZsSlBWVEpPVjFWc1pGZFdSVnBQVm0xNFYwNVdjRlpYYXpsb1VteHdlVmt3V25kV2JGbDZZVWh3VjJGcmNFeFdNVnBYWXpKR1IxZHRlR2hOUmxrd1ZqRm9kMUl5UlhsVVdHaHFVbGRTYjFWcVNqUldSbEpYVm01a1YySkdjSGxXTWpGSFZqQXhXR1ZHYkZkaVZGWlFWakJrUzFOSFJrbFNiRnBwVmtWYVZWZFVRbUZXTWxKSVZXdHNZVkp0VWs5V2FrNVNaV3hhY1ZOdWNFOVdiR3d6VkZab1MyRnNTbGhoUm1oVlZqTkNTRnBIZUdGa1JURldaRVpPVG1GNlZrbFdiR1EwV1ZkR1YxcEZhR2hTZW14WlZtdFdkazFHY0VWU2EzQnNVbXhLTVZaWE1YTlZNa1kyVm14c1dGWjZSWGRWZWtacll6RmtkVlZyTlZkU1ZYQm9WbTF3UTJNd05VZFhiR1JvVW5wc1dGUlhkSGRsVmxKelYyNU9XR0pWVmpSWk1GSlBWakF4VjJOSWNGZGlSbkJNV2tWYVMyTXhjRWhpUms1cFlUQlplbFpxU2pSV01rVjRVMWhvV0dFeGNFOVdiVEZ2WTJ4d1dHUklaRmROVjNoNldWVmFUMkZ0U2tkalNHaFdUVzVSZDFaVVNrdFdhelZXWTBad2FFMVlRbTlXYTJONFV6SlNTRkpyWkZOaVIyaFlWRlJHUzJJeFpGZFZhMlJWVFZVMVNGVXlOVXRYUjBwSFkwaENWbUZyV2t4V01WcHJWMGRTU0U5V1NrNVdNVXBaVm1wSk1WVXlSbk5UYkdoV1lrWmFWbFp0ZUhkTk1YQlhWMnhLYkZKdFVucFhhMXB2VlRBeFNWRnRSbGRXYlUxNFZrUkdhMlJHVG5KYVIzQlRWMGRvV1ZaR1ZtRmtNa1pIVm01R1UySlZXbkZVVm1oRFUwWnJkMWR0ZEdoV2F6VkhWVEZTUzFZd01WZFRhMUpYWVd0d1IxcFZXbXRYVjBwSFZHMW9hVk5GU2xwV01XTjRUVVpzVjFkdVRsaGliRXB6VldwQ1lXSXhWblJsU0dSc1VteGFNRnBWWkRCaFJURldZa1JTVmsxdVVuWldha1pMVG14S2RWZHNaRk5sYTFwSVYyeFdZV0V4WkZoVWEyUmhVbXMxY0ZVd1ZrcGxWbGw1WkVaT1UwMVhlRmxXUm1odldWWk9SMWRzV2xwaE1sSjJXV3BHVTFkRk1WaFBWbWhYWWtoQmQxZFVRbFpPVjBaV1RWWmthbEpYYUZoV2JuQlhWVVprVjFkcmRHdFNiRnA2VmxkNGQyRkZNVmRXYWxKWVlrZFJNRlp0TVZkWFJscHlZVWQwVTJKV1NsQldiVEF4VVcxV1IxZHNaR0ZTUmtwV1ZGWmFjMDVXVm5OaFJ6bFlVakJ3U1ZsVldtOVhiRmw2Vlcxb1ZtVnJXak5XYlhoclkyMVNTR1JHWkdsU1dFRXlWbTEwYW1WSFRYaFdXR3hVWW10d1ZWbHJaRzlYUm14ellVVk9VMUpzY0RCWmVrNXZWakF4VjJOR2NGcFdWbkIyV1Zaa1IwNXNXbk5pUm1oWFRUSm9XVll4V21GWlZrbDRXa2hXVm1GNlZsaFZiWFIzVjJ4YWRFMUVSbEpOVld3MFZqSTFVMVF4V1hwVmJUbFdZV3RLWVZSWGVGZGtSMVpJWkVaa1RsSkZXWGhYVmxadlV6RlplVk5zVmxOaE0yaFlWRlphZDFkR2EzbE5WbVJUVFZoQ1NGZHJaRFJoUlRGWlVXMUdWMkpVUmpOVmFrcEdaVVpPV1dGR1VtbGhlbFpZVjFjeGVrMVdaRmRpU0VwaFVtczFjVlZ0ZUdGTlJsSnpWbXM1V0ZJd2NFaFpNR2gzVjBkRmVGTnNVbGRoYTBZMFZXeGFZV050UmtkWGF6Vm9Za1p3VWxadE1UQmhNVTE1Vkc1U1ZXRXlVbGhaYTJoRFlqRlNWMWR1V214aVJuQjRWVmN4UjFZd01YSk9WbWhYVW5wV1ZGWlZXbUZqYXpWV1QxWmthVlpHV2tWV1ZFSmhXVmRTUmsxV1ZsWmlWMmhQVm0xNFdtVnNXa2RYYlVaYVZtMVNTVlV5TlZkVmJVcElWVzFHV21FeVVuWlZhMXB6Vm14a2RWUnNaRTVXTVVvMVYydFdZV0V4VW5OWFdHaFVZV3hhV0ZWcVRtOWhSbVJYV2tWa1YwMVZOVEZXUnpGM1ZUSldkR1ZHYkZkaVZFVXdWWHBHVDFJeFpIVlNiRTVwVTBWS2VsWlhNVFJrTURGWFYyeG9iRkpVYkc5V2JYUjNWMnhXV0dWRlRsZE5WbkJIVlRJMVMxZHRSbkpYYkVKV1lXdGFjbGw2U2tkU2F6VlhXa1pPVjFkRlNsaFdiWFJoV1Zac1YySkdXazVXVjFKWldXMTRTMVZHV25SamVrWllVbTE0ZWxadGVHdFVNVXB6Vm1wV1lWWlhVa2hXYWtwTFZtMU9SbUZHY0U1U01Vb3lWbTB4ZW1WR1NYbFVhMlJvVW0xU1QxVnFSa3RYVmxwWVRWUlNhMDFWYkRSWk1GWnJXVlpKZVdGSVRscGhNWEI1V2xWYVlXUkZNVlZSYldoT1lrWnZkMVp0TVRCaE1WbDRXa1ZvYUZKdGVHRlpWRXBUVmtacmVGZHNaR3BOVjFKNVdrVmFiMVV5U2tsUldHUlhVbXh3Y1ZSc1dsTmphekZYV2tkd1UxWnVRbGhYVjNodlZUSkdSMkpHVmxKWFIyaHhWRlprVTJWV1pISlhiWFJWWWxWd01GbFZXa2RYUmxwelYyeGtZVlpXY0ZCV2FrWkxaRlpTYzFkdGJGTk5WWEF6Vm0xd1ExbFdUWGxUV0doaFUwVndWMWxVU2xOV1ZsSlhWMjVPVDFKc2NEQlViRll3VjBaSmQyTkZiRmRXZWtFeFZteGFXbVZ0UmtabFJtUm9UVmhDZVZacVFtdFZNVWw0WTBWa2FGSXlhSE5aVkVaMlRXeGFjVk5xUW1sTlZURTBWakZvYzFaSFJYaGpSa0pYWWxob00xWXdXbk5qTWtaSFZHczFUbFp1UWpSV1Z6RTBaREpLUjFkWWFGUmhNbEpXVkZaYWQyTnNiRmRYYTNSclZtdGFlRll5ZUd0V01VcFlaSHBDV0ZZelFraFhWbVJPWlVad1NWTnNhR2xTYTNCWlZsZDRWMlF4WkVkYVJtaHNVbnBzY0ZSV1drdFRSbXhWVkc1T2FWSnJjRlpaYTJoSFZsWmFjMVpZYUZWV1ZuQXpWbTE0ZDFOV1VuTmFSVFZvVFZacmVWWnNXbXROUjBWNFYxaHNWR0pIZUZkWmEyUnZWMFpzV0dSSFJscFdia0pYVmpKek5WZEdXWGRYYTJoWFVucEdlbGxWWkZkak1XUnpWMnhrVGxZeFJqTlhWbEpIVm0xV1IxcElTbUZTYldoWlZXcEdTMWRXV25Sa1JtUmFWbXhzTkZaWGVHdFhSMHAwVlc1T1dtRXhjRE5VVlZwVFZqRmFkR1JHWkdobGExcFpWMVJDYjJReFpISk5WV1JxVTBoQ1dGUlhjRWRTTVhCV1YyczVhazFXV25wWGExcHJZa2RGZUdORk5WZGlSMDQwVkd0a1JtVldVbGxoUjNCVFZqRktXbGRYZUd0T1JtUkhWbTVTYkZOSFVsWlphMXAzVFVad1ZscElaR2xTYTNCNVdXdFNVMWRIUlhoalNGcFhWa1Z3UjFwVlpFOVNNV1J6WTBkb1RsZEZSalpXYlhCRFdWZE5lVlJ1VG1GVFJscG9WVzE0ZDFkR2JITlhhM1JhVm0xU1ZsVlhlR3RoUlRGWFZtcE9WVlp0YUV4V1JFWmhWMGRXUjJGR2NHbFNNbWhWVjFaV1lWbFhUbk5qUlZwclVtczFjRlpzVWxkVFZtUlhWbTFHYUUxcldsaFZNalZYVld4a1NWRnNiRmRpV0dob1dWVmFhMVl4WkhKa1IzQk9WakZKZUZaclkzaFNNVlY1VW1wYVYySkZTbGhaYkdodllVWndSVkZVUm1wTlYxSjZXVlZrTkZVeVZuUmxTR1JYVW0xUmQxZFdXbHBsUmxaelYyMW9VMDB4U2xkV1JscGhaREpXVjFWdVRsaGlWR3haV1d4V1YwNUdhM2RhUnpsWVlrWndXRmt3V205V01rcEhZMFY0V21WclduSmFSV1JYVWpGU2RHSkdUbWxXUjNOM1ZtMXdSMVV4UlhoWGJrcFBWbTFTVjFsdGN6RldWbXhWVTIwNWFsWnNTbFpWTW5CVFYwWmFjMk5JYkZkaVJrcElWa2R6ZUZkSFZrZFhiRnBwVjBkb2VWWnRkR0ZUTWsxNVZHdFdVMkpIVW5CV01HUnZWMVphZEdORlpGUk5WbkJZVmpJMVQxbFdTblJWYkZKYVlURmFNMVpXV21GV01WWnlVMnMxVjAxRVJUQldiVEF4VmpGVmVWTnJXbXBTYldoWFdXeG9iMDB4V2xkWGJYUllVakZhU1ZWdGVGTlViRnBZWkhwQ1YySllhSFpaZWtwTFVqRk9jMkpHV21sU01taFhWbTB4TkdRd01IaGpSbWhzVTBWd2NsUldXbmRYYkd4V1YyMTBWV0pHY0ZwVlYzaHpWakpHY21KRVVscGhhMXBoV2xWYVQyTnNaSE5oUjJoT1lsZG9iMVl5ZUd0TlJteFhWV3RrYVZKR2NGUlpiVEZUVmtaU1YxZHVaR3hpUjNoWFZqSnpOVll3TVZaalNIQmFUVVp3YUZacVNrdFdWa1p4Vld4V2FFMVlRbWhYYkZaclV6RkplR05GWkZWaVIyaFVWRmN4YjFsV1dYaFpNMmhQVW0xNFdWWkhkR3RXTWtweVkwWnNXbFpGTlZSV01WcGhaRVV4VlZWdGVGZGlTRUYzVmtaYVYyRXhXWGROVlZaVFlrZG9XRlJYTlVOU1JtUlhWMnQwVjAxck5VaFZWM2hyWVZaS2RWRnRPVmhXUld3MFZrUkdTbVZIVGtaYVIwWlRWa1phZDFkWGRGZGtNVlp6VjI1U1RsTkhhRkJWYlRFMFYxWmFSMkZIT1ZwV2F6VklWakkxUTFadFNsbGhSMmhhWVd0YWVsWnNXa3RrVm5CSFdrWmthVk5GUmpOV2ExcGhWVEZWZUZkcldrNVhSWEJRVmpCb1ExZEdiSE5WYkdSWFVtMTRXRll5ZEhkaVJsbDNWMnRrVlUxV2NHaFpWV1JIVG14YWNWSnNaRk5pVmtWM1ZqRmFhMVJ0VmtkalJXeFdZa1UxY0ZWcVJrdFZSbHAwWlVkMFRrMUVSa2hXTW5odlZHeEtSbGRzV2xWV2JIQXpWRlZhVm1WWFVraGtSbVJUVFVoQ05WWkhlR0ZoTVdSelYxaHdWVmRIYUZkWlZFWjNZVVphYzFkcmRHdFNhM0F3V1RCVk1WWXlTbkpTYWs1WFlrZE9ORlJyV25OV01WWjFWR3hvYVdFelFuaFdWM2hyWWpGa1IySklUbFpoTVhCeVZGWmtORlpzVm5SbFIzUm9UVlZ3ZVZSc2FITldNREYxWVVoYVdsWnNjRXRhVlZwUFl6RndSMXBIYkZoU01tZzFWakZrZDFJeFdYaFRXR2hoVTBaYVZsbHJaRk5YVmxaeFUyMDVWMVp0VWxsYVJXUXdWbXN4YzFkc2FGZE5ibEoyV1d0YVNtUXhaSE5pUmxwcFYwWktObFpITVRSaE1WcFhWVzVTYTFKdFVrOVdiVFZDWkRGYWMxZHNUbEpOVm5Bd1ZXMDFTMWRIU2xoaFIwWmhWak5TYUZaVlduZFNNV1J5VDFkd2FHVnRlRmxXTW5SaFlURlZlRmR1VmxKaVIxSllXV3hTUTA1R1VsWmFSVnByVFVSV1YxZHJXbE5oUlRGelUyeHdXRll6VW5KV1ZFWnJWakpLU1ZOdFJsTmhlbFpaVjFkMGEwNUhWbk5YYms1b1VucHNWbFJXVm5kbGJGbDVZMFZPV2xac2NGbFdWM1J2VmpKS1dWUnFVbHBOYm1ob1dURmFVMk15VGtaT1ZrNXBZVEJzTlZadGNFZFpWbXhYWWtab1ZtRXlhRlJaVkVvMFYxWnNjbHBIT1ZoU2JYaDVXVlZXVDFkR1duTmpSRUphVFVaYWNsWXllRnBrTURWWlkwWndUbEpzY0hsV2JYaHJVekZLY2s1V1pHbFNiSEJ2V1ZST1EwMXNXbFZTYlVaYVZqQXhORmxVVG5kaFJrcFZWbXhTV2xkSVFrZFVWVnBoWkVVeFJWSnNWazVXTVVwS1ZsUktNR0l5UmtkVWExcHFVbTFTVmxac1pGTmtiRlp5VjIxR2FsWnJjREJWYlRFd1ZUQXhWMk5GY0ZkV2VrVXdWbFJHVm1WV1RuSmFSM0JUWW10S1dsZFhkR0ZaVm1SSFlrWldVMkpGY0hOVmJURlRWMnhzVmxkdE9XaFNWRVo2VlRKNGIxWXhTblJVV0doYVlXdGFWRlZxUm10a1ZrcHpWRzFzVjFadVFscFdhMXByWldzeFYxTllhRmhYUjNoelZXcE9VMVl4VWxkWGJtUnNZa2QwTTFZeU1EVldNREZXWWtSYVdsWlhVblpXYlRGSFkyMU9SazlYUmxkV2JrSlJWMnRhWVZVeVRYbFNhMmhwVW1zMWNGVXdWa3RoUmxwMFpVZDBUMUpzVmpSV01XaHZWMGRGZVZWc2JGcGlXR2hNV1hwR1YyUkZNVmRVYkhCWFlraEJkMWRyVm1GaE1WRjRVMjVPYWxKRlNsWlphMXAzWTJ4c1ZsZHRSbXBpVlRWSFdWVmFZVlJ0Um5KU1dHaFhZV3RzTkZWdE1WZFNNWEJKVlcxb1UySldTblpYVmxKSFpERmtWMXBJU2xkaVdGSllWRlpWTVZJeFVYaFhiWFJYVFd0d1NWWlhNRFZXVmxwR1UydDRWMDFXY0doYVJXUlBVbTFTUms1V1RtbFNWbXQzVm0xd1NrMVdVWGhhUldoVVltdHdVRlp0TVRSWlZteHpWV3RhVGxKc2NEQmFWV2hQVjBaSmVGTnJiRlppV0doMlZsUktTMU5XUmxsYVJtaHBVbXh3V1ZaR1ZtdFNNbEpIVkc1S1lWSnRhSEJaYkdodlZqRmFkRTFVVWxkaVZscElWako0VjFaSFJYaGpTRTVXWVd0S01sUlhlRlpsVjFaSVpFZG9WMkV6UVhoV1ZtTjNUbFpaZVZOc2JGSmhNbWhYVkZkd1IxZEdWbkZTYXpsclZteHdlbFp0TVhOVk1rcHlVMnBPVjJKSFRqUlVWV1JTWlZaYWRWUnNhR2xTTW1oUVZtMTBZVk14V2xkVmJHUllZa2RTVUZWdGVITk9WbEp6VmxSV1YwMUVSbmxaTUZwclZqQXhkV0ZHYUZkaGEzQk1WakZrUjFKdFZrZFhiV2hvVFZoQ2RsWXlkRmRoTVZWNFZHdG9WbUV5VWxsWmJHUTBWMFpaZDFacmRGUldiSEF3V1RCV01GUXhTWGRXYWxKWVlUSm9VRll3WkVabFIwNUhVV3hrYVZkR1NrMVdha0poWXpGYVYxTnVUbUZTVkd4VVdXdGFkbVF4WkhOV2JYUk9VakJhTUZVeWRHdFdSMHAxVVd4b1ZWWjZWblphUjNoaFZsWkdXVnBIZUZkaVJYQTBWbXRrTkdFeVJsZFRibFpTWW0xNFdGVnFUbE5oUmxWNVRWWmtVMDFZUWtwV2JYaFhZVlpLY21OSVpGaFdiRXBRVlZSR1YxWXhaSFZWYlhoVFlYcFdWVlpHV21Ga01VNUhWMWhzVDFaVWJGbFZha0ozVFVaYVdHVkdUbGRpVlhCYVdWVlNUMVl3TVVkalIwWmhWbTFTV0ZVd1pGTlNNWEJIV2tVMVZGSlZjRnBXYlhSaFdWWlZlRlpZYUZoaWJFcFZXV3RrTkdJeFZuRlRiVGxZVW14d2VWWnROV3RWTURGWlVXeGtWMDF1VFRGWlZFWmhZekZPZFdOR2NFNVNia0o1Vm14U1IxbFdaRmRTYkZaVFlrZFNiMVJXYUVOV1ZscFlZMFZrYWsxWFVraFdWelZQV1ZaS2NrNVlRbHBXUlRWRVdXcEdZVmRGTVZsalJUVlhZa1ZaTUZacVNURlZNVkp6VTJ0a1ZHSnJOVmRaYkZKSFZrWndXR1ZIUm10U01WcEpXa1ZhYTFVeFdrWlhiR3hYWVd0cmVGcEVSbHBrTURGWlZtMW9VMDF0YUZsV1JsWnJWVEZKZUdOR2FHeFNiVkp4VkZaa1UyVnNXWGxOV0U1V1RXdHdlVlV5TldGV01rcEhVMnRTV0Zac2NHRmFWVnAzVW0xR1IxcEhhRTVYUlVwMlZteGpkMlZIU1hoYVJXUnBVMFZ3V0ZsdE1WTlZSbHAwWlVoa2JHSkhVbmxaVldocllWWktjbU5JY0ZkaVdFSlVWbXBCZUdSWFJrbFRiSEJYVFRKb1RWWnRjRWRVTWsxNVVtdGtZVkl5ZUZsVmFrcHJUbXhaZUZWcmRFOVNNREUwVmpKNGExWkhTbkpqUm14YVlrZG9WRlpFUm5OamJHUjFXa1pTVTJKSVFqUldWRXAzVlRGYVZrMVlTbGhoTWxKV1ZtMTRZV1ZzV2xoTlZYUlRUVlUxZWxsVldtRmhWbVJJWVVVeFYxWXpVbWhhUkVaTFZqRk9kVk50Y0ZOTk1taFZWMWQwWVdRd05WZFhia1pVWVd4S2IxUlhkR0ZTTVZKWFlVVTVWMUl3Y0VoVk1uaHpWakpHY2s1V1VsZE5SbkJvV1RGYVIxZFdjRWhsUms1cFVtNUNhRlpxU2pCaE1rbDRWbGhvV0dFeWFITlZiVEZ2VjFaYWNWUnNUbWhTYmtKR1ZXMTRkMkpHU25SVmJIQmFZVEpSZDFaVVJtRlRSMVpIWWtaa1UySklRbGxYYTFKTFZqRlplRlp1VmxSaVJuQnZWRlZTVjFkV1pGaGtSMFpxVFVSV2VsbHJXbUZXTWtwVllrWm9WVll6VWpOV01uaHpWbXhhY1ZWc2FHaGxhMWw0VjFaV1lXSXhaSEpOV0ZaVllXeEtXRmxYZEdGV1JtdzJVbTVrVTAxWVFrbFphMlJ2Vkd4T1JsTnJiRmRpVkVJeldsVlZNVkl5U2tkYVJtUllVakpvVjFacVFtdGlNa1pIVmxoa1dHRXpVbGhaYTFwelRURmtjbGw2VmxkTlZYQXdXbFZvYzFZd01YRldia3BYWVd0YVRGcEZaRmRTTVdSelYyeGtiR0pHY0RWV2JUQjRaVzFXUjFwR1pGTmlhelZ3VlcxNFlXTkdWblJPVlU1V1ZteHdNRnBWWkVkWGJGbDNUVlJTV0dFeWFGQlpWVnBMWkVaV2RWRnNaRTVTYmtKTlYyeGFZVmxYVFhoV2JrcGhVbXhLVDFacVJrdFhiRnBZVFZSQ1dsWnRlRmhWTWpWUFlXeE9SbE5zYUZWV1ZuQXpWa1ZhWVZJeFpIUlNiWEJPVjBWS1IxWnNaRFJrTVZsNVUydHNVbUpIZUZoV2JuQkNaVVphY1ZOclpHcE5WVFV4Vm0xNFMyRldTWGxoUjJoWVZteEtTRnBFUVhkbFJtUnlXa1pvYVZaV2NGbFdSbHB2VVRGS2MxZHNhR3hTVkd4V1dXdGFkMDFHY0VsalJVNVlVbXh3ZWxVeWVFTlpWa3BHVjIxb1YwMUdjRkJaTW5oclpFZE9SMVJ0YkZkTmJXaGhWbXBHYTAxR2JGaFZXR1JPVTBkb1dGbHRkSGRYVm14elZtMUdXRkpzU2xsYVJXUkhWa2RLUjJORmJGcE5NMEpZVm0xemVHTnNaRlZUYkdScFYwWktObFp0Y0VkWlZUVnpVMnhXVW1KSGFGaFphMmhEVjBaa2MxZHRSbFJOVjFKWlZXMTBiMkZzU25KT1ZtaFdZbGhvTTFZeFdscGxSbkJGVVd4d1YySllhRnBXVnpFd1lURlplVk5yWkZoaVJrcGhXVlJLVTFaR1dYZFhiRTVYVFZkU01WZHJaRFJXTWtwR1kwUmFWMkpZYUZSV2FrWmhWMFpPY2xwSGNGTlNWWEJ2VmxkMFZrMVZNSGhYYmtaVFlsVmFVRmxyVm5kWGJHUnlWMjEwVjAxVmNGaFpNRkpoVmpKR2NsTnRhRlpsYTNCUFdsWmFUMk50UmtoaFJrNW9aV3hhV2xadE1UQlpWbXhYV2taa1dHSnNTazlWTUdSdlZVWldkRTFVVWxoU2JIQkpXa1ZrTUZZd01YSmpTR3hhVFVad2RsWXllRnBsYlVaR1pVWmthRTFZUWpaWFZFbzBZVEpTVjJORmFHeFNiVkp3VlcxNGNtVkdXWGxsUm1SWFRVUkdTRll4YUd0VWJGcDBWVzVHVm1KWWFETldha1p6WXpKR1JsUnRhRk5pU0VJMFZsY3dlRkl5Um5KTldFcFBWbGRvWVZac1duZGhSbXhXV2tWYWJGSXdOVWRaYTFwdlYwWk9SbE5yYkZkaVdFSk1Wa2N4VjFJeFpIVldiRnBwVjBkb1ZWZFdhSGRXTWxKelYydGtWMkpVYkZOVVZscDNWMFpaZVU1V1RsVmlSbkJJVlRJeFIxWXlTbGxVYWxKVllURndhRnBGVlRGV2F6bFhXa2RzVjFac2EzZFdNVkpEV1ZkSmVGcElUbGhoTVhCeFZXMTRTMWRHV25KV2JVWnNZa2QwTlZwVlpFZGhNVXB5WTBod1dsWldjSEpaVmxwaFkyMUtObEpzWkdsV1JVa3dWMnhrZWsxV1dYaGFTRTVoVW0xb2NGbFVUa05sUmxwWVRVaG9WazFYVWtoV1YzaHZWREZhY2s1V1pGWmlXR2d6VkZWYWQxWnNjRVphUmxwT1lURnJlVlp0TVRSa01WbDNUVmhXYUZJeWFGaFpWM1JoVkVaYWRFMVZXbXhpU0VKSVYydGFhMkpIUlhoV2FrNVhZa2RvTTFWNlJsSmxWbEpaWVVaYWFXSkdjRmRYVjNSaFV6Sk9SMVp1UmxOaE0xSlhWVzB4VTFkV2NFWlhiWFJvVFVSR1Yxa3dhSGRXTURGeFZtdDRWMkZyY0V4Vk1GcFhZekpHUjFac1pHbFNia0V5Vm10a01GbFdXWGxWYTFwUFZteHdVVlp0ZUhkVU1XeFZWR3RPVkZadFVsWlZWekZIVjJ4YWMySkVUbFZXYkZweVZtcEdhMU5IUmtkaFJtUm9UVlp3YjFkV1ZtRmpNRFZ6VTI1U1UySllVbFJaVkU1RFRteGFWVk51Y0U1V2JHdzFWVEowYzFWdFNsaGhSbWhWVm0xU1UxcEVSbUZXVmtwelYyMTRVMkpJUVhoV2JHUTBWVEpHUmsxV2JGSmlTRUpaVm1wT1UyTnNXbFZTYkhCc1VqQndTbFpITVc5Vk1rWTJWbXhzVjFaNlJUQmFSRVpQVWpGa1dXSkhkRk5TVlhCWlZrWmtNR1F4VGxkWGJHaFBWMFUxV0ZSV1ZuTk9iR3hXV2tjNVYwMXJXbmxXTW5RMFZqSktSMk5IYUdGU1ZsVXhWbXBHZDFJeGNFaGlSazVZVWxWd1NGWnRNVEJoTURGSFlrWmtWVmRIZUZaV01HUnZWbXhzZEdWSFJsZFdiWGg1VmpKME1HRnNTbk5YYm5CYVZsWmFVRll3V21Gak1rNUZVV3h3VGxKc2NFMVhWbEpDWlVkTmVGcElWbXBTYlZKUFdXMHhiMDVzWkZkYVJGSlVUVlp3ZVZSc1dtdFdiVXBIVjJ4b1dtRXhjRE5aYWtacll6RndSVlZzWkdsV2JIQmFWbTB4TUdFeFdsaFRiR2hzVW14S1lWWnJWVEZTUmxsM1YyMTBWMVpyV2pCVmJYaFhWR3hhZEdSNlJsZFdSVzkzV1ZSR2ExTkdUbk5oUjJoVFlsWkthRlp0Y0U5Vk1rWkhWMjVLV0dKSFVuSlZha1poVTFaV2RFMVlaR2hXYXpWSFZUSjBjMVl4V2taaVJGSmFaV3RhVjFwVldtdGtWbHB6VTIxc1UwMHlhRnBXTVdRMFlqRlZlVkpyWkdsVFJWcFVXV3RXZDJNeFZuUk5WazVzVm0xU2VWWXlNRFZoUmxweVkwUkdWbFl6YUROV01GcGhZekZPY2xSc1ZsZGlTRUpvVjJ4V1lXRXhaRmRqUldoVFlrVTFWRlpyV21GVlZscHpXVE5vVDFKdGVGaFhhMXByWVd4S2MyTkdhRnBpUjJoVVZqQmFVMWRIVWtsYVJrNU9Wak5SZWxkV1ZtOVVNVmw0VjFoa2FsSlhhRmhaYkdoRFZrWmFjVkp0UmxOaVIxSXdXVlZhWVZSc1NYaFRiR3hYVm5wRk1GWnFTazVsUjA1R1drZEdVMDF1YUZaV1YzaFhaREZzVjFkdVVrNVdSVXB2V1d4YVlWTkdXbGhPVms1WFRXdFdOVlpYZUZkWGJVcFpWRmhvVjAxV2NIcFpNbmhoVmxaS2RHSkZOVmRoTTBKWlZqRmFWMVl4VVhoYVJXaFVZVEpTY1ZVd2FFTlhSbHB4VkdzMVRsWnRlRmhXYkdodllXMUdObFpzYUZwV1ZuQnlXVlphYTFOSFJrbGlSbVJwVjBWS1RWWlhNSGhXTVZsNFYyNVdWV0pHY0hCVk1GWkxWMVphV0dWR1RsZE5SRVo2VmpKNGIyRnNTbGhWYkdoVlZqTm9URlV4V21GWFIxSklVbTFvVGxaWVFqWlhWRUp2VVRGYWRGTnNWbGRoTVVwWVZGWmFkMkZHY0VaV1dHaFRWbXR3TUZwRlZURldNa3B5VTFSS1YySllRa3RVVmxwU1pVWndSbUZHVGxoU00yaDJWbGN3ZUZVeFpFZGlSbWhxWld0YWNsbHJXbGROTVZsNVpVVTVhR0Y2UmxwVlYzUnZWMGRGZUdOR1FscFdiSEJNVm14YVlXTldaSE5hUm1SVFZucG9NMVl4V2xOU01XUjBWbXRrWVZOR1dsaFphMVozWWpGU1dHVkZkRmhXYlZKWVZsZDBhMWRzV25SVmEyaFhUV3BXU0ZaVVNrWmxiRVoxVkd4YWFWZEdTWHBXUmxwaFdWWk9TRlpyWkZWaVYyaFlXVlJLTTAxV1pGZFdiVGxyVFZac05GWXhhSGRoUmtsNVlVWmtZVll6VW1oV2ExcHpUbXhLZEZKdGRGZGlSWEEyVmpKMGEyTXhXWGhYYmxaU1lrWmFXRmxVUm5kaFJtUlhWMjVPVjAxWVFrZFhhMXB2WVZkS1JtTkljRmRXTTBKRVYxWmFZV014Vm5OWGJGcG9UV3hLVlZkWGRHdE9SbGw0VjJ4b2FtVnNXbGhVVmxwM1pXeHJkMkZJWkZkTlJFWXhWbFpTUTFZeVJuSlhiVVpoVm5wR1NGVXdaRWRTTVhCR1RsWk9UbFpZUWxkV2JYaFRVakpGZUZWWWFGUlhSMmhvVlRCVk1XRkdWbkZUYWxKWFVtMTRNRnBGVmpCV1JURlhZMFJDWVZaWFVraFpWVlY0VWxaYWNtRkdaR2xTTW1oNVZtdFNSMWxYVWtoU2EyUm9VbTVDV0ZWc2FFTldWbHB4VW0xR2FrMXJOWHBXTWpWWFdWWktkR0ZHVWxwaE1taEVWRzE0WVdOV1RsVlNiV2hPVm01Q1NsWlVTakJoTWtaelUyeG9WbUpIYUdGWmEyUnZaR3hyZVdWSFJsZFdhMXBhV1ZWYWEyRldTWGhUV0doWVZrVkthRmRXWkVkV01YQkdZVWRvVTJWdGVGbFhWbEpMVldzeFIxZHJWbE5oTTFKeFdWaHdWMWRHWkhKWGJUbG9WbXR3ZWxrd1duTldNa3BWVWxSQ1lWSkZjRXRhVlZwcll6RndSMWR0YUU1aVJYQmFWbXRhWVdFeFZYaGFSbVJYVjBkNGNsVnRNVk5YUm14elZtNWtVMDFYZEROWlZWWlBWakpLVm1ORmFGcE5Sa3BRVm1wQmVGSXlUa2hoUm1ST1VteFpNRlpxUm10VU1VcHlUbFprWVZJeWVGUldNRlpMV1ZaYWRHVkdUbFJOUkZaSVZqRm9jMVV5U2toVmJGWmFZVEZ3TTFaVldtRmtSVEZYVkd4b1UySllhRFpYVmxacVRsZEdSMU51VG1wU1ZuQlhXV3hTVjFWR1drVlRhM1JUWWxVMVNsbHJXbTloUlRGWlVXNXNXRlpzY0doVmVrWnJWakZLZFZKc1pHbFNNVXBaVmxkNGFrNUhVWGhhU0VwV1lUSlNZVlpxUVRGbFZsSlhWbTVPYUZacmJEVlpWVnBYVm1zeFIxZHJlRmROVm5Cb1drVlZlRlpXVm5Sa1JUVlhUVlZ3U2xadE1IZE5Wa2w0Vmxoc1UxZElRbGRaYlhSaFdWWnNjbGR1WkdoU2JGcDRWVzE0ZDJKR1dYaFhhMlJWVFZkU2RsWlVSbUZTYkdSeVpFWmtWMkpXUlhkV2JGSkhWMjFXVjFSdVRtbFNNbWhVVkZjeGIxZFdaRmRhUkVKclRWZFNTRmxyVW1GVk1rcFdWMjVHVlZadGFFUlZNRnByWTJ4d1NFOVdWbWxXV0VKSVYxUkNZVll4V1hkTlZtaFdWMGRTV0ZsWGRHRmpiR3Q1WXpOb1YwMVlRa2xaTUZwUFlWWk9SbE5zY0ZkTlZuQlVWa1JHVm1WR1pGbGhSMnhVVWxoQ1dsZFhNSGhWTVdSSFZXeGtXR0pyTlZCV2JUVkRVakZaZVUxVVFsZE5SRVpZV1RCb2MxZHJNVWRqU0ZwWFlXdEdORnBHV2xka1ZtUnpXa2RzV0ZJeWFHOVdNbmhxWlVaSmVGTnVVbGRoTWxKb1ZXcEtiMVF4V25SbFJtUlBVbXh3TUZSVmFHOVVNVXB6WWtSV1YxSnRhSFpXVkVwTFl6Rk9kVlJzV21oaE1qaDNWMVJDWVZZeVRYbFNhMXBWWWtad2NGVnROVUprTVdSelZtMTBVMDFYVW5wV01qVlBZVlpLUjFOc1pGVldiVkoyV2tkNFlXTXhjRVprUjNCcFZsUldTMVpyWkRSWlYwWlhVMjVXVWxkSVFsaFpiR2hUWVVac05sSnRSbGROVlhBeFZtMHhSMVV5U2tsUmJFSlhZbFJCZUZWVVFURmpNV1IxVkd4d1RrMXNTbEZXYlhCRFpERk9WMVpZYkd0U00xSnZXV3RXZDAxR2JGWlhiVGxZWWxWd1NWbFZXbE5YYXpGMVlVZG9WMDFHVmpSV2JURlRVakZTZEdKR1RrNVdXRUpaVm0xNGFtUXlWa2RUV0doWVYwZG9XVmx0Y3pGalZsWnpWV3RrV0ZKdGVIbFhhMXBMVkd4S2RGVnNhRmROYWtaSVdWZHplRmRXUm5KalJscE9ZbTFvUlZadGNFdFRNVWw1Vkd0a1YySkhVbkJXYTFaSFRrWmFWMVZyZEZkTlZtdzBWMnRvVDFsV1NYZFhiRkpXWWxoU00xWnNXbUZTTVdSMFVtMTBUbEpGV2tsV2Frb3dZVEpHUjFScmFGWmlSMmhZV1ZkMFMwMHhWbkZTYmtwclRWZFNNRlF4V210VWJVVjZVV3RzV0ZaRlNsUldSRVpoWkVaS1dXRkhjRk5OYldoWlYxWmtNR1F4VGtkV1dHaFlZa1UxY1ZsWWNITlhSbHBJVFZjNWFWSXdjRWhaTUZZd1ZqSktXV0ZJUm1GV1ZsVjRWV3BLUzFJeGNFZGFSbWhUVFRKb1ZsWnRjRU5oTWtsNVZHeGtWMkpyTlZkWmEyUlRWMFpTVjFwRVVteFdiR3cxVkZaV2EyRkdTbkpqU0hCWFRXNW9hRlp0TVV0WFYwWkpVMnhrYUdFeGNHOVhXSEJIVkRKT1YxSnVUbGRoZWxaWVdXMTBTMVJzV25Sa1IzUlBVbXN4TkZaSGRHdGhiRXBIWTBaT1dtRXlVbFJXUkVaelpFZFdSbVJHYUZkaVNFSmhWMVJDVjJFeFdYZE5XRXBPVmtaS1dWbFVTbTlWUmxweFUydDBXRkl3V2toV2JYaGhWR3hLYzJORk1WZGhhMHBvVjFaa1UxSnJNVmRXYkZwcFUwVktXVmRXYUhkV01VNVhWMjVTVGxaR1NuQlVWM1IzVTBaYVNHUkhkR2hpUlRWSFdUQmFZVll5U2xsaFJtUmhWbFp3WVZwV1pGZFRSa3B6Vld4T1RsWnVRa2xXTW5SWFdWZEZlRlZ1VGxoaWJGcFRXV3RrTkZkV1duSldhM1JZVW14d1ZsVnRlSGRpUmtwMFZXcEdWMVo2Um5aV2ExcFBVbXhPYzFwR2FGZGlSWEJKVjJ0U1IxUXhTWGxUYTFaWVlrVTFiMVJVUmt0bFJscEhWMjEwVmsxc1ducFdNalZUWWtaSmVsVnNaRlZXYkhBelZGWmFWMWRIVmtkYVJtUk9Va1ZhV1ZkVVFtdGlNV1IwVW01S2FsSllVbWhXYkZwM1ZFWlplRnBGWkZOTldFSkpXV3RhVDFSc1dsbFJiVVpYWVd0YWFGWlVSazVsUmxwWllVWm9hVkl4U2xsWFZ6RjZUVmRKZUZadVZtcFRSVFZZVlcxNFMxZEdXWGxOVldSVllrVndNVlZYZEd0V01rcFpVV3RTVjJGcmNFaFViWGhMWXpKR1IyTkZOVk5pYTBsNVZtMHdkMlZHVFhoVFdHaFZZbXMxVTFsclpGTmpSbFowWlVad2JHSkhVbnBYYTFKVFZUQXhXRlZzYUZwTlJscHlWMVphU21WWFJrWlBWbVJPVW14d1RWWlVTalJaVjFKR1RWVnNhRkpVYkZSWldIQkdUVlphY2xkdE9XbE5WbFkxVlRJMVMyRnNTbFZpUm1oYVlrZG9UMXBWV2xwa01XUjBVbTEwVTFaR1dsaFdhMlEwVkRGWmVWTnJiRkpoYkhCWVdWZDBjMDVHVm5GU2JIQnNWbXR3ZUZZeWVHdGhSVEYxWVVac1YxWjZRalJaYWtwVFl6RmtkVkpzVW1oTk1VcFZWa1prZWsxV1RrZFhiR2hzVTBkU1dGUldWbmRXTVd4eFZHNWtWMDFyY0VoVk1uUnZXVlpLUmxkdFJtRldiSEJNV1RJeFIxSXhSbk5hUjJoT1RVVndVbFp0TUhkbFJUVklWVmhvWVZKdFVsbFpiWGhMVkRGYWNsWnJkR2xOVmtwWVZqSTFhMVpHU25OV2FsWmhWbGRvVUZsVldrdGpiVTVIWWtkR1YxWnVRakpXYlRCNFVqSk9jazVXWkZaaVIxSlVWbTAxUTJJeFduRlJiWFJYVFZVMVNGVXlOVk5oTVVweVRsaENWbUpIVFRGVWExcGFaVVpXY2xSc2NGZGlXR2haVm1wR2IyTXhXa2hTV0d4V1ltdGFWMWxyWkZKTlJsbDNWMjFHYTFKVVJsaFZNbk14VlRKS1NWRnNaRmRXYkhCVVZXcEdhMUl4VG5WVWJYQlVVak5vV2xkV1VrZGtNa1pIWWtaa1dHRXpVbGxXYlhSaFpXeHNjbGR0ZEdoV2JWSkpXVlZqTlZkSFJYaFRhMmhYVWtWYVMxcFZXbmRUVms1ellVZHNVMDFWY0ROV2JHUjNVakZOZUZkc1pGaGhNbEpaV1d0a1UxbFdXbkZTYlVac1lrWndNRlJzVlRWaFJrcHlUbFZzVjFZemFISldNakZMVWpGa2MyRkdWbWhOV0VKWVYyeGFhMVl4U25OalJXUmhVbTFTY0ZVd1ZrZE5NVnAwWlVkMFQxSnNWalJXTWpWUFYwZEZlR05HYkZwaE1sSjJWakJhYzFkSFVraFNiV2hUWWtoQ05sWnFTalJoTWtWNFUxaGtUMVpYVWxaWmExcDNZMnhhY1ZOcmRHcGlSVFY2V1RCYWEyRldaRWhoU0doWVlrWmFWMXBWV2twbFJsWnpZa2RvVTJKWGFIZFdWM0JMWWpGa1YxcEdhR3RTTTFKUVZXcENjMDVHV25ST1ZrNW9ZbFphZVZZeWVHOVdWbHB6WTBST1ZWWldjRE5XYlhoM1VteHdSMXBHVG1oTk1Fa3lWbTF3U2sxWFRYaFhXR3hVWWtkNFUxbHJXa3RYUmxweVZtNWtWVkpzV2pCVVZsVTFWa1paZDJORmFGZE5iazE0V1Zaa1MxZEhSa1pPVm1ScFZrVlplbFpYY0VkaE1sSkhWMjVXVldKSFVuQlpWRVozVjJ4a1dHUkhkRlpOYTJ3MFZsZDRhMVl5U25SVmJGSlhZbGhvTTFZeFduSmtNVnAwWkVaYVRsSkZXalZXUmxwVFZURlplRk5xV2xkaE1taFlXVmQwZDFSR1dYaGFSV1JUVFZaYWVsZHJaSE5WTURGMFlVVmFWMkpVUlhkWFZscHpWMFpXY21GR1pHaE5iRXB2Vmxjd01WRXhaRWRpUm14cVVsWndUMVZ0ZUhkbGJHUnlWV3RPV0dKR2NIcFphMUpUVmpBeGRWVnVTbGROUjFKTVZXMXpNVmRHU25OalJtUlRWbTVDZGxZeFdsZFpWbXhZVkd4a1ZHSnNTbkpWYlRGVFYwWnNjbFp1WkU5V2JIQkdWVzB4UjFkc1dYZFhiR2hXVFdwV1dGWlhNVXRUUjBaSFlVWndWMDB4U1hsWGExSkhXVlpLVjFOdVRtcFNNMmhVV1d0V2QwNVdaRmRXYlhST1VqQndTVlZzYUd0aGJFcDBaVVpvV21KSGFFUldWVnB6WTFaS2NrOVdUazVXTVVsNFZteGplRTVHVlhoYVJXUlVZbTFvV1ZacVRsTmhSbVJYV2taa1YwMVdXbnBYYTFwdllVZFdkR1ZHYkZkU2JIQm9Xa1JCZUZZeFduTmhSM1JUWWxaS1dWWkdaREJrTVU1SFlUTmtZVko2YkZoVVYzUmhaVlpyZDFkdE9WcFdhM0JZV1RCYVUxWXdNVmhWYTJoV1lXdGFNMVV3WkV0U01WSjBZa2RvVGxORlNsbFdiVEYzVWpKRmQwNVZaRmRYUjJoVlZqQmtORlpzYkZWVGJFNXFVbXhhTUZwVlpFZFdhekZZWlVSQ1drMHpRa2haVjNONFYwZFdTV0pHWkU1aGExcEpWbXBDWVZNeVRYbFVhMVpTWWxWYVZGWnFSa2ROTVZwMFRWaHdiRkpzY0RCVk1uUlhWbTFLU0ZWck9WcFdNMmhvVkcxNFlXUkZNVmxqUjNoVFlsWktTbFpYTVRCaE1WWjBVMnRvVm1KSGFGWldhMVozWkd4c2NWSnRSbXRTVkVaV1ZsY3hiMVJ0U2taalJXaFhVa1ZhYUZsVVNrZGpNVTVaWWtkNFUySkZjR2hYVmxKTFlqRktSMWRyWkZoaVNFSnpWV3BDWVZOc1pISlhhemxWWWtad1dWcEljRU5XTWtaeVlUTm9WMUpGV21oVk1GcFBaRlpPZEdOR1RtbFdhM0J2Vm0xd1EySXhSWGxXYms1WVltdHdXVmxzVm1GalZsSlhZVVZPVTJKR2NGbFpNM0JYWVVaYWNtTkVSbFpXTTJoNlZtcEtSMk50U2paUmJIQlhVbFp3V0ZkclVrSmxSbGw0V2toT2FGSXllSEJaVkVKM1YyeGFjMXBJWkZWTmEydzBWakowYTJGV1RrWmpSbXhhVmtVMVZGWXdXbk5qTVZwVlVteFNVMkpJUWtwWGJGWnJUVWRHUjFkdVNtcFRTRUpoVkZWa1RrMVdXbkZTYkhCc1lsVmFTVmxWV210V01VcFhZMFV4V0ZkSVFraFpWRXBUVmpGU2RWVnNUbWxTVkZaMlZrWlNRMU13TUhoWGJrNWhVa1pLWVZadE1WTmxWbEpYVjIxMFdGSXdWalZaVldoUFZtMUtWVkpzVWxkTlJuQlVWbXBHYTJOdFVrZGhSazVwVW14cmVGWXllRmRoTVVsNFdrVmtWRmRIVWxoWlYzTXhWbXhzY2xkdVpHcGlSbkI0VlRKME1GZEdXWGRYYTJ4YVZsWndjbFpVUmt0V01rNUZWMnhrVTJWclZYZFdXSEJMVkRKTmVWUnJXbUZTTUZwVVZGYzFiMVpXV25GUmJHUlVZWHBHV0ZZeU5VOVdiVVY2Vld4Q1ZtSllUalJVYkZwV1pWZFNTR1JHY0ZkaE0wSmFWMVpXYWs1V1duUlRhMlJxVWxob1dGUlZXbmRoUm5CR1drWmtWRlp1UWtoWlZWcFBZVlpPUmxOcmFGZGlSMDQwVkd0YVVtVkdaRmxpUmxKcFVqRktXbGRXVWt0Vk1XUkhWV3hvVDFaNmJGZFZiVEUwVmpGYWMyRkhPVmRTYkhCNVZqSTFkMVl4V1hwaFNFcGFWbXh3Y2xVd1pFZFNNa1pIWVVkb1RsWllRa1ZXTW5SVFV6RlplRk5ZYUZoaWF6VndWV3BPUTFaR1VsVlJhM1JYWWtad1ZsVlhlR3RXUlRGWFYyeG9WMDF1VW5KV01HUkxVMFpXZEZKc1pHbFhSMmcyVmtkMFlWbFhVa1pPVm1SVllsZG9UMVpzWkRObGJGcHhVMnBTYUUxV2NGaFdNalZQVjBkS1NHRkdXbHBpUjJoMldsZDRZV1JIVmtoa1IzQk9WMFZLU1ZZeWRHdGpNVlY1VTI1S1ZGWkZjRmhaYkdoRFZFWlNWbHBGY0d4U2JWSmFXV3RhVDFkR1NYbGhSbkJYWWxoU1dGVjZSbHBsUjBwSlZHMW9VMlZ0ZUZkV1Z6QjRUVVUxVjJOR1dsZFdSbHB2V1Zod1IxWXhVbk5oU0dSWVVqQldORmt3YUV0V01WcEdVbXBTWVZKV2NIbGFWekZMVWpGd1NHSkdaRk5XYkZsNlZtMXdSMWxXYkZkYVNGSlhZVEpTVmxsclpEUmlNVlowWTNwR2FsSnRlRnBaTUZwclZqRmFkRlZzYUZoaE1VcFVWako0V21Rd01WVlZiR1JwVmtaYVVWWnRjRXRUTWxKSFZtNU9ZVkpzV2xoWmEyaENaV3hrYzFwRVVscFdNVXBIVkZaYVlWbFdTblJWYkdoYVlUSm9SRlJ0ZUdGV1ZrNXhVVzFvVGxadGR6RldWRW93WVRGYVNGTnJhR2hTYldoWVdXMDFRMU5HV2taWGJHUnJVakZhU1ZwRlpIZFViR1JHVTJ0c1YwMXVVbkpaZWtaV1pEQXhXVlZ0YUZOaE0wSlpWMWQ0YjJJeVRuTlZia3BZWW1zMVdGUldaRk5OVmxwSVRWVmtWMUpyY0ZwVlYzaHpWMFpaZW1GR2FGaFdiSEJ5VldwR2EyUldWblJsUmxKVFRWVndXRlpzWTNkbFJsVjRXa2hPYUUweVVsaFpiR2hUVmpGU1ZsVnJaRmhTYlhReldWVm9hMVl5UmpaU2JtaFhZbGhSTUZacVNrWmxWbFp5WlVaYWFWZEZNVFJXYlhCTFVqRkplRnBJU2s5V2F6VndXVlJDZDFReFduUk5WRkpYVFZkNFdGbHJXbXRYUm1SSVlVZG9WazFHVlhoWlZWcFhaRWRPTmxKc1ZrNVdia0kyVm14a05HRXhVWGhYYmxKV1ltNUNXRmxzYUc5amJGbDVaVWRHYWsxV2NIaFdiWGhoWVZaSmVXRkliRmhXYlZFd1ZYcEtUMk5yTlZkYVIyaFRZbXRLZGxaR1pEUlRNVnBIV2toS1ZtRXlVbkpVVm1SVFUxWmFkR1JIT1ZaTmEzQkhWR3hhYjFkc1drWlhhazVWWWtad1lWcFdaRk5UUmtwelZXczFhRTFZUWxwV2JGSkxUa2RKZUZaclpGVmhNbWh2VlcweE5GbFdiRlZTYm1Sb1VteHNNMVl5ZUd0VU1rcEdZMGh3V0dFeVVqTldSM2hhWlVaT2NWZHNaR2hoTWpoM1YxZHdTMUl4VGtkWGJsWlVZa2RvY0ZWcVJrdFhWbHAwWTBVNWFVMXJXa2hXTWpWSFZXeGFSbGRzVWxWV2JIQXpXbGQ0YzFac2NFVlZiRnBPVm0xM01GWlVTalJqTVdSSFYxaHdWbUpYYUZkYVYzUmhZMnhzTmxKdGRHcGlWVnBKV2xWYVQxZEdTbkpqUm5CWFlURndhRmRXWkZKbFJuQkdXa2RvVGsxc1NsbFhWM1JXVFZaa1IxVnNaRmhpYlZKVVZGWmFjMDVXY0ZaV2F6bFhUVlpzTTFadGNGTlhhekZIVjI1YVYwMXFSbGhaTW5oclkyMVdSMk5IZUdoTldFSTFWakZvZDFJeFZYbFZhMmhUWVRGd1VGWnRNVk5YVmxaelZtNWtWbUpHY0RCVVZsSlRZVVV4UlZacmFGZE5WMmgyV1ZaYVMyUkdWbk5WYkdST1VqRktNbFpxUW1Gak1sSklWR3BhVTJKWGVFOVdiWGgyWkRGa1ZWUnVaRk5OVm5CNVZGWmFhMVpIU2toVmJHaFhZbTVDV0ZaRldtRlRSVEZXWkVaU1YyRXhjRFZXTW5SaFlURlNkRk51VW1oU2ExcFlXV3hTUTA1R1ZqWlNhM0JzVm14S2VWZHJaRWRWTWtwWFUyeENXRlo2UWpSWmFrWlBWakZrZFZWdGVGTk5SbkJXVmtaYVlXTXdOVWRhU0Vwb1VsaFNiMVZ0ZEhkbGJHdDNWMjA1VjFac2NFZFpNR2hoVm1zeFYyTkhhR0ZTVmxZMFZURmtSMUl4V25SaVJtUnBVMFZGZVZadE1UUmhhekZYVlZob1dGZEhlRlZaVkVwdlZqRnNjbHBIT1ZoU2JYaDZWbGQ0YTFVeFNuTlhibkJYVFdwR1NGbFhjM2hYUmxaeFVXeFdUbFl4U1hwV2EyUTBVekZKZUZwSVNtbFNiVkpZV2xkMFIwNUdXbkpWYTJSWFlsWmFXRlpITlV0WlZrbDZVV3hTV21FeFdqTlpWVnByVjBkU1NHUkdXazVpUlhBMlZtcEtNR0l5U2tkVGJsSldZbXRhV0Zsc2FGTmhSbHAwWlVaa2ExSXhXa2RhUlZwWFlWWktkVkZxV2xoV1JVcG9XWHBHV21WV1RuTldiRTVvWWtoQ1YxWnRNSGhWTVU1SFlUTnNhazB5YUZoVVZtUlRaV3hzVmxwSVRsWk5SRVpYV1RCYWMxWXdNVmhWVkVKYVlXdGFWMXBWV2xkamJIQkhZVWRzYUUwd1NuWldiR04zWlVaVmVGcEdaRmhpYTFwVFdXeFdZVlpXVm5SbFIwWk9VbTVDVjFkclZtdFdNREZGVW01c1drMUdXblpXTW5ONFVqRmtkV05HWkdoaE1YQnZWa2N4TkZNeFpGZGpSV1JYWWxkb1QxWXdWa3RVYkZsNFlVaGtVMDFyVmpWV1YzaHJWbGRLY2s1V1pGcGlSMUV3Vm10YVdtUXhXbkprUm1ocFVtNUJkMVpHVm05aU1WRjRVMjVTYkZKdFVsWlphMlJ2VlVaWmQxcEZkRlJTYkZwNldXdGFkMkZGTVhOVGJGWlhZbGhTYUZaVVJscGxSbVIxVld4T2FWZEhhSGRXVnpBeFVXMVJlRnBHVmxKaVZWcHZWRmQwWVZkR1ZYbE9WWFJvWWtWd1IxVXlNVWRXTWtwSFkwUk9WMVpXY0doWk1WcFBZMjFTUjFSck5WZE5WV3d6VmpGYVYxbFdiRmhTYTJoVFYwZG9jVlZ0ZUdGWFJscDFZMFZhVGxKdFVsaFhhMVUxWVdzeGNrNVZaRmhoTVhCVVdWWmFXbVZ0UmtkV2JHUnBWa1ZHTkZaV1VrZGhNazE0V2toV1ZtSllVbFJVVlZwM1pERmFSMWR0UmxOTlJGWklWakkxVTFReFdsVmlSbXhXWVd0S00xVXdXbkprTVdSMVZHeG9hVkp1UWtoV1YzaHZZakZaZVZKdVNsaGlia0poVkZjMWIyRkdXbk5YYTJScVlYcFdXRlpITVhOWFJrbDVZVVp3VjJKVVJqTlZla0Y0VTBaS1dXRkdhRmhTTTJoV1YxWlNSMlF5VGxkV1dHUmhVa1pLV1ZWdGVFdFhWbEp6VmxSV1ZVMVZjSHBaTUZwaFZtMUtWVkpyYUZkaGEwWTBXVEp6TVZac2NFZGFSbVJPVFcxb05WWnRNWGRUTVUxNFZHeGtVMkpzU2xGV2JURnZWMFpzYzFaVVFrNVNiSEI1VjFST2IxWXdNVlpPVldoWFVucFdURmRXV2t0a1IwWkpVV3hhYVZKcmNGbFhhMlEwV1ZaSmVGZHVVbEJXYTNCUFZtMDFRMWRXV25GVFZFWlZUVlp3TUZWdGNHRmhWazVHVTJ4YVYySllhR2hXTUZwVFkyeGtkRkp0ZEZOTlZuQktWMnRXWVdFeFVuUlNXR2hZVmtWYVdGbHJaRkpOUm13MlVtMUdhMUpyTlhsWlZXUnZWa1pLZFZGc2FGZFNiRnBvV2tSS1YyTXlSWHBpUjNoVFRVWndlRmRYZUdGVE1VNUhWMWhzVGxkRk5WZFVWM1IzWlZaVmVXVklUbGROYTFZMFdUQmtiMWR0Um5KalJrNWhWbFp3Y2xwR1dsTmpNa1pJWWtkb2JHSkdjR2hXYWtaaFZURk5lVk5ZYUZoWFIyaFpXVzEwWVZac2JITlZiazVYVFZaYU1GcFZhR3RpUmxwMFZXNXNWMDFxUlhkV2JYTjRZMjFPUmxwR1ZtbFNNbWQ2Vm0weGVtVkhVbGhTYTJ4VVlrZFNiMWxVUm5kaU1XUnlWMjFHVTAxck5YcFpNRlpyV1ZaSmVXRkZPVmRpVkZaRVZqSjRZV1JGTVZsYVJrNU9WbFJWZDFadE1UQmhNVnBJVTI1T1dHSkdjR0ZaVkVaV1pVWnJkMWRzWkd0U1ZGWlhWa2Q0YTFSc1duVlJhbEpYVm0xUk1GZFdXbE5qTVdSMVZHeGthR0pGY0ZsV1JtUjNWakZXUjFkdVJsUmhNMUpZV1d0a1UyVnNXa2hsUm1SWFRXdHdTbFZYTURWV01rWnlZbnBDV21WcmNGQlpla1poWkZaU2MxWnRiRk5pYTBvelZtMHhOR0l4UlhoVWEyUllZbXRhVlZsWGVFdGlNVkpYVjI1T1QxSnNWalZVYkZVMVZqRkpkMk5GYkZwV1ZuQjJWbXBLUm1WR1pIRlViRnBPVW01Q2FGZHNWbUZrTVVwelkwVmtWV0pYZUZSWlZFNUNUV3hhZEdORmRFOVNNRlkxVlcxNGExWkhTbk5YYkU1YVZrVTFSRll3V25OamJIQkhVMjEwVGxadVFYZFhWRTUzVWpGWmVWSnFXbGRpU0VKWVZtcE9iMWRHYkZaYVJYUlVWbXRhTUZReFdtdFdNbFp5Vm1wT1dHRXhTa2haVkVaS1pVWndTVlpzVm1sU01taDNWMWQ0WVZNeFduTlhiR2hPVmtaS2NsUldaRk5YUm10M1ZtMUdWMDFXY0VoV01uaGhWbFphYzFkcVRtRldiSEJoV2xaVk1WZFdjRWRhUjJ4WFYwVkthRll4V2xkaE1rbDRWMWhvV0dFeGNIRlZiR1J2Vm14c2MyRkhPV2hTYlhRMVdUTndSMVl3TVZoVmFrSmFZVEZ3VUZsVlZYZGtNVXBaWWtaa2FWZEhhRzlXYkZKSFUyMVdSMXBHYkdoU2JXaFpWV3BLYjFkc1pGaE5WRUpyVFZaYVNGWXlOVWRXVjBWM1RsWmFWVlpzY0ROYVYzaGFaVlUxV0dSR2FGTmhNMEkyVjFSQ1lXTXhXbGRYYms1VVlURktXRmxVUmxkT1JscHhVMnM1VTAxcmNFaFhhMlJ6VjBaSmVWcDZTbGROVm5CWVYxWmFUbVZXVm5KYVJtUnBZWHBXYjFaWE1IaFZNazVIVjFoa1lWSjZiSEJVVmxwM1ZteFdXRTFWWkZkTmEzQllWVzF3VTFZd01YRldhMmhYWWxSR1RGVnRjekZYVmtaelYyMXNVMDF0YUVaV2EyUTBXVlpzVjFkc1pGVmlhMXBYV1d0YVMxUXhXblJOVkU1T1VteHdlRlV5Y0VOaFZURnlWMnRvVmsxdVVuSlpWM2hMWkVkR1IyRkdjR2xTTW1neVZrWlNSMWR0VVhoYVNFNWhVak5DV0ZsVVRrTk9WbGw1WkVkMGEwMVdTbnBXTW5oelZXMUdjMU5zYUZwaVJrcEVWR3RhVTJOc1pITlhiWGhUWWxaS05sZFhkR0ZUTWtaWFUyNUthbEp0ZUZsV2FrNXZaR3hzY1ZKc2NHeFNiRnA2VmpKNGExZEdTWGxoU0doWFVteHdhRnBFU2xkak1rcEhWMjFHVkZKVVZsaFdSbHByVlRGSmVGWlliRTlXZW14WVZGWldkMlZzV1hsT1ZYUlhWakJXTkZadGNGTldNa1p5VjI1S1drMXFSa2hWYlhNMVZqRndSazVXVG1saE1HdzFWbTB4TUZsV2JGaFNXR2hYVjBkb1ZWWXdaRzlpTVZKVlUyeE9hVTFXV25wWGExcFBWMFphYzFkdWFGWldlbFp5Vm10YVlXUkhWa2RhUm1ST1lteEtVVlp0Y0V0VE1WcHpWMjVHVjJKSFVsaFVWRVpIVFRGWmVGZHRSbHBXTURFMFZqSjRjMkZHU25SVmJrSldZbFJXUkZVeFdtdGpiRnAwVW14U1RtRjZSVEJYVkVKWFlqSktSMU5ZYkd4U2JFcGhXVlJLVW1Wc1VsaGxSMFpyVWpGYVNGWkhlRTlVYlVWNFYxUkdWMkpHY0haWmVrWmhZekZ3Um1GSGFGUlNWWEJZVmtaV1lWbFZNSGhoTTJSWVlrWndjbFJXV25kV2JGWjBUVmhrYUZacmNIbFpNRnAzVmpGS2MyTkdVbGRXUlhCSVdrVmFUMk5zY0VoaVJrNVRWa1phV2xZeFpEQlpWazE0Vkd0a2FWSnRhSEZVVkVwdlYwWnNXV05HWkZoU2JWSjVWakkxYTFZd01WZGpTSEJYWWtkb2RsWnFTa1psVmxaVlVXeGFUbUZyV2xSWGExSkNUVlpaZUZkdVRsUmlWM2hWVld4V2QwMXNXbkpYYlhSUFVtczFNRlp0TlU5WlZrcDBWV3hrV2xaRmNGUldiRnBUVjBkV1JtUkdhRk5pV0ZGNlZtMHdNVlF4V25SVGJGcHFVbGRvV0ZSWGNGZFZSbGw1WlVkR1UySkhVakZaYTJSSFZURktWMk5JYkZoV1JXOHdXVlJLVTFJeFRuVlZiV3hUVmtaYVdWWnRkR0ZaVms1WFYyNUtZVkpHU21GV2JYaHpUa1paZVdSSE9WZFNNRlkxV2xWYVQxZHRSWGxWVkVKWFlXdGFlbGt5ZUhkU01VNXlUbFpPYVdFd2NFcFdiWEJLWlVaSmVWSnVTazVXYldoeVZXdGFkMWxXV25OWGJtUnFZa1p3U1ZSV1ZtRmlSa2wzVGxWa1dtRXhjSFpXYWtwTFVtMU9SMUpzYUdoTlZYQkpWakZhYTFSdFZrZGpSV1JwVWpKNFZGbHJhRU5rTVZwWVpVYzVVazFYVWxoV01qVlRZVEZLZEZWc1ZsVldiSEJNVlRCYVlWZEZOVlpQVm1oVFRVaENZVlpzWXpGU01WcFhWMWh3Vm1KWGFGZFpWM1JoWTJ4cmVXVkhSbGRXYTNCNlYydFZNVlV4U2xkalJYQlhUVlpLUkZsVVJrcGxSbVJaWVVab2FFMVlRbmRXVjNSaFV6RmFjMkpHVmxOaWJWSllWVzE0WVdWR1ZuUmtSRUpZVW14c00xa3dWbTlXTURGeFVtNWFXbFpzY0V4YVJscEhaRVpLYzFwRk5WZE5WVmw2VmpGYVUxSXhXblJXYTJSV1ltdHdhRlZxU2pSV1JteHpXa2M1VmxKc2NEQlVWbWgzVkd4YWMyTkZhRmRpVkZaVVZrZDRZVkpzVG5OUmJIQm9UVmhDYjFacVJtRmtNVnB6VjI1S1VGWnRVbGhVVldoRFUyeGFjMXBFUW1wTlYxSkpWVzAxUzFReFpFZGpSbWhWVmxkU1ZGVnFSbmRXTVdSelZHMXdWMkpHY0RaV2FrbDRZakpHUmsxSVpGUmlTRUpZV1d4U1EwMHhjRlpYYXpWc1VtczFNVlpYZUU5aFJURnpVMnhzV0ZZemFISlVhMlJLWlVkT1IyRkhlRk5OUm5CM1ZrWmFZV1F3TVVkaE0yUlhZWHBzV0ZSWGRGcE5iRlowWlVkMFYxWXdjRWxaVlZwRFZqQXhTRlZyWkdGV2JWSklWVzF6TlZZeGNFaGlSazVPVmxoQ1YxWnFSbE5UTURWSFYxaHNWbUV4Y0ZCV2JYaDNWbXhzY2xwSE9XcFNiRm93Vkd4V1QxWkdXbk5pUkZaaFVsZFJkMVpIZUV0ak1rNUpZMFprVG1Gc1dsRldiWEJMVWpKT2NrNVdaR0ZTYkZwWVdsZDRZVkpXV25GUmJVWllZbFpHTkZrd1ZtRmhNVXB6VTJ4U1ZWWldjRE5WTUZwclZqRmFkRkpzWkU1V2JYY3hWbFJLTkdFeFdraFNXR3hzVW0xb1lWWnFUbE5oUm14V1YyMUdVMVpyTlhwV1IzaFRWVEpLU1ZGcVZsZGhhMncwVkd0YVZtVldTbGxqUmtwcFVsVndXbFp0Y0U5Vk1XUkhZMFZXVWxaRldsUlVWbVJUVjJ4c1ZscEZaRlpOVlhCWFdUQm9ZVll4U25OalJtaGFaV3RGZUZacVJtdGtWbFp5VDFaa2FHVnNXbHBXYlRCM1pVWlZlRlJzWkdwU2JIQlpXVlJCTVZkR1VsaGtSMFpzVm0xME0xbFZaRWRYUjBZMlVtdG9XazFIVW5aV01uTjRWakpPUm1WSFJsTldia0pOVjFSS2VrNVdaRWhUYTJSVllrZFNWRmxyV25Ka01WcDBZMFZrYUUxRVJrbFZNV2h2Vmxaa1NHRkdaRmROUjFKVVZrUkdZV1JGTVZoUFYyeE9WbXh3TmxZeWRGTlZNVmw1VTJ0b2JGTkhlRmxaVkVaM1ZVWmFkR1ZGZEd0U01WcElXVlZhYjJGRk1WZGlSRTVYWWxoQ1ExcFZaRTlrUms1eVZteG9hVk5GU2xsV2JUQXhVVzFXYzFwR1pGaGlWVnBoVm0xMGQyVnNaSEpoUlRsV1RXdHdTVlpYZUZOWGJVVjRZMFJPWVZac2NHaFdNR1JQVW14d1NHRkZOVmRYUlVreFZtdFNSMWxYUlhsU2JHUlVZbXhLVjFsc1VuTldiRnB5Vm10MFZWSnNjSHBXTWpGSFZUQXhXR1I2U2xaaVZFWjZXVlZrVjJOc1pIRlhiR1JvWVRKME5GWlljRWRoTWs1eVRWVnNhVkpzY0hCVmJGWjNWMVprV0dSSFJsUk5WVFZJVm14b2ExZEhTa2xSYms1V1lXdEthRlV5ZUdGVFJURllUMVprVG1FeGEzbFdiVEV3WXpGWmVWSnVTbWhOTW1oWFZtdFdZV05zY0VaWGF6bHFZa2hDU1Zrd1drOVViVXBZWVVab1YwMVhVWGRYVm1SU1pVWldXV0ZIY0ZOV2JIQldWMVpTUzFVeFdrZFZiR1JvVWxVMVZWWnROVU5XTVdSeVlVVTVWMDFWY0hsWk1GcHJWMnN4U0ZWdVdsZGhhM0JNVldwR1QyTnRSa2RqUjJob1RWaENTVll5ZUZkWlZsVjVWV3hrVm1Kck5WaFpiR1J2VkRGc2RFMVhPVmhXYkd3MFYydFNVMkZWTVZaV2FsSmFZVEZ3Y2xsV1drOVNhelZZWVVaYWFFMVlRazFXYkZKSFZURlplR05GWkZWaVdHaFVXV3RhV2sxV1pGVlVibVJYVFd0YVIxUldXbUZoYkU1SlVXMUdWVlpYVW5aYVIzaGhaRWRXU0ZKck9XbFNXRUpoVmpKMFlXRXhVbk5UYmxaU1lYcEdXRmxYZEdGaFJsWnhVbTEwV0ZKcmNIbFhhMXB2WVVkV2MxZHNiRmhXTTFKMlZWUkJNVll4WkhWU2JFNXBWbFp3V1ZkWGVHRlpWazVIV2toS1YySllVbGhXYWtKM1pXeFplV1ZIZEZoaVZWWTBXVEJrYjFkdFJuSlhibkJYWWtad1NGcEdXbmRUUjFKSVlrWk9hV0V3V1hwV2JYUnJUa2RKZVZKWWJGTmlhM0JQVm14YVlWWkdiSEphUnpsWVVteGFlRlpITURWaFJrcHpZMGh3V0dFeFdYZFdha1phWkRKT1JtTkdXbGROTW1odlYxWldhMUp0VmtoVWExcE9WbTFTVkZsclduZGlNVmw0VjIxMFZrMVZjSGxVYkZwcldWWkpkMWRzVWxWV2VrWjJWbFZhWVdSSFZraFNiR2hvWld0YVdWWXlkRzlUTVZsNVUyeHNVbUY2YkZoWmJGSkdUVVpaZDFkc2NHeFdNVXBKVlcxNGIxVXlTa2xSYTJoWFZrVnNORmxxUm1Ga1JrNXpZa2RvVTAxdGFHOVdiWEJQWWpGa1IyRXpiR3hTTTFKeFdXdG9RMU5HYkZaWGF6bG9WakJXTTFrd1ZuTldNREZYVTJ0U1dGWnNjRmRhVlZwaFYxZEdTRkpzVGxkaWEwcFhWakZhYTA1SFVYaGFSV1JXWWtkb1VGWnRjekZYVmxaMFRWUlNiRkpzV2pCYVZXaHJZVlpLYzJOSWNGcE5SMmd6VmpKNFlWWXlUa2RWYkhCWFlsWktTRmRyVWt0VU1VbDRWbTVPWVZJeWVGbFZiRlozVkd4WmVGcElaRlJOVld3MFZURm9iMWxXU25SbFIyaFdZbFJHZGxrd1duTmpNV1J5WkVkNFUySklRa2xXYWtsNFRVWlJlRk5zVmxOaE1taFlWbTV3VjFWR1dYZGFSVnBzWWtaYU1GUXhXbGRXTWtwSlVXcGFWMUl6VW1oV2FrcFRVMFpTY2xwSFJsTmlWMmgzVm0xNFlWZHJNVmRhUm1SWFlsVmFjRlJXWkZObGJGbDVUbFpPVjJKVlZqWlpWVnB2VjJ4WmVsVnRhRnBOYm1oNVdsVmFhMlJHU25SalJUVlhZbXRKTWxadGRHcGxSVFZJVW10YVRsWnRhRkZWTUdRMFYwWnNXR1JJV210TlYxSllWakkxVDFkR1NuTlRha1pYVmpOb2NsbFdXa3BsVjBaSFlrWm9WMkpGY0VsV01WcGhXVlpKZVZOcmJGVmlSMUp3Vm14YWQxZFdXbGhOVkZKVVRWZFNTRll4YUhOVU1WbDNWMnhhV21KR1dqTlZNRnBhWlVaV2NtUkdaR2xTYlRoNVZsWmFVMUl4V1hsU2JrcFRZV3hLWVZwWGRHRmpiSEJIV2tVNVUwMXJOVWRVYkZwUFlWZEZkMkV6YkZkaVZFSTBWRlZhYzFkR1NsbGhSbEpZVWpKb2IxWlVRbUZaVmxWNFlraEthRkpWTlhGVmJYaGhUVVp3Vm1GSGRHaFdWRVpZV1RCV2IxWXlTbFZTYTJoYVZsWldORmt5YzNoV1ZsWnpXa1prYkdKR2NGcFdiVEV3WVRGSmQwNVlVbFJoTVhCUlZtMHhVMkl4YkZWVWEwNU9Za1p3VmxVeWNGTlhiRnB5VGxWc1YxWXpVblpaVkVaS1pWZEdSazlXWkdsU2EzQlpWa2N4TkZsWFRuTmpSVlpTWWtkU1QxWnRlSGRPYkZweFUycENXbFpzUmpSV01qVlRZa1pLZEZWdFJscFdSWEJVVm10YVlWSldTblZhUm1ScFVqRktObFpVU1hoT1JsVjVVMnhrVkZkSFVsaFZhMVpoWVVaYVZWSnNXbXhTYlZKNVYydGFiMkZXVGtaVGJHeFlWbXhLVEZaRVFURlNNa3BGVjJ4U2FFMXNTbGxXUmxwclZUQXhWMWRzYUd4U1ZUVllWRlpXZDJWV2EzZFhibVJYVFd0d1ZsWnRjRTlXYkZwR1VsaG9WbUZyV25KWk1uaGhZekZPYzJGR1RrNWlWMmhZVm0xNGFtVkZNVWhWV0d4WFltczFjRlZ0ZUhkWFZteFZVVlJHV0Zac1dqQmFSV2hyWWtkS1NHUkVUbGRpV0VKVVZtcEJlRll5U2paVGJHUnBWMFZLVVZadGNFdFNNazUwVkd0YVVGWXdXbGhXYWtaTFZGWmFWVkp0UmxaTmJFcElWVEkxVDFaWFNsaGxSbWhhVmtVMVExUlhlR0ZqVmtwMFpFVTVVMkpIZHpCWFYzUmhZVEZzVjFScldrOVdiWGhoVm10V2QyUnNhM2xsUm1SclVqQTBNbFZ0TVhOVWJGcDFVV3BhVjJKSFVYZFdSRVpTWlVaT2RWUnRiRk5TYkhCb1ZrWldZVmxYVG5OWFdHeHNVakJhY1Zsc1ZURlRSbVJ5VjJ4a2FGWnJiRFZaVldNMVZqSkdjbUo2UWxoV2JGVjRXWHBHVDJSV1RuUmtSazVPVW01Q1dsWnJXbE5UTWtsNVUxaG9ZVk5GY0ZsWmJGWmhXVlphY1ZKcmRGUldiSEJaV2tWa01GWXlTbFpqUldSVllrWndkbFp0TVV0U01rNUpZa2RHVjJKSVFtOVhXSEJIVmpKT2MyTkZaR0ZTVkZadlZGYzFhbVF4V25SalJXUnBUV3N4TkZZeGFITldSMHB5WTBaQ1YwMUdXbWhXYWtaell6RldjbGRyTlZOaVNFSTJWbXBLTkdReVJYZE5WbVJxVTBkNGFGVnNXbmRXUmxwSVpVZEdhazFYVWxwWk1GcHZWakpLUjJOSE9WZGhNVXBNVldwR1QxSXhVblZUYldoVFRUSm9WVlpYZUZka01rWkhXa1prVm1FeVVtRldiWGhMVTBaa2NsZHRkRmROVjFKSldWVm9SMVpXV25OV1dHaGhWbFp3V0ZZd1pGZFRSa3AwWVVaa2FWTkZTa3BXYlhCTFpERnNWMWRZYUZoaE1YQndXbGQwUzFZeFVsaGpSV1JZVW14V00xWXllRTloYlVwV1kwVnNWbUpZYUZCWlZtUkdaREpPUlZSc1pHbFdSVll6Vm0xd1IyTXhXWGhhU0VwaFVtMW9XVlZxVG05bFJscFlaVWQwVmsxV1ZqUldWM2hyVjBkS2RGVnNWbFppV0dob1ZGVmFVMk14WkhKUFZtaFRZVEozZWxacVJsTlRNVnAwVTJ4V1YyRXhTbGhaVjNSM1ZFWmFjMWR0Um1waVJscDZWbTE0YTFVeFduVlJhbFpYWWxoQ1JGWnRNVmRTTVZKellVWk9hRTFzU2xwWFYzaHJUa1prUjFkdVJsVmlXRUp5VkZaYWMwNUdXWGxsUlRsWFZsUkdlVlJXVWxOV01rcFpWVzVLVjAxSFVrZGFWV1JQVWpKS1IyTkhiRmhTYTNCT1ZtcEdZVmxYVFhsVVdHeFRZVEpvVVZadGVHRldSbXh5Vm01YWEwMVhVbnBXYlRGSFZsVXhWMVpxVmxaTmJsSnlWbXRrUzJSSFZrZGhSbHBvWVhwV01sWkdVa2RqTVZwelYyeHNhRkl6UWxoVVZWcHlaVlphV0UxVVVtaE5WbFl6VkZWb2MyRkdUa2hsUm14WFlXczFSRlpGV2xkalZrcHpZMGQ0VTJKclNrbFhWM1JyWWpGVmVWTnNaRlJpYlZKWlZtcE9VMkZHY0VWU2JIQnNVbTFTZWxsVlpEUlZNa3BKVVd4Q1YySlVSWGRhUkVaUFVqRmtjMkZIZUZOTk1VcG9WbTB4TUdReFduTlhibEpQVmxSc1dGUlhkSGRYYkd4V1ZXczVWMVpzY0hwWk1HaDNWMnN4ZFdGSVNtRlNiSEJVV1hwR2QxTkhSa2hsUjJoT1ZqTmpkMVp0TUhoTlJteFlVMWhzVmxkSGFGbFdNR1JUVkRGYWMxcEdUbGhXYlhnd1drVmtSMVl5U2tkalJFSmhWbGRvY2xscldtRmtWa1p6WVVaa1RtSnJNSGhYVmxKSFdWZE9jMXBJVm1wU2JIQlBXVzB4YjJWV1duSlpNMmhVVFZWd01GWkhkRmRXUjBwSVZXNUNWMkV4V21GYVYzaGhWMGRPUm1SR1ZtbFdiSEJaVm10ak1WWXhXbGhUYTJSWVlrZDRWMWxYZEdGVVJteHhVbTFHV0ZJd05VZFdSM2gzVmpBeFJWWnNiRmRpVkVGNFZXcEdWMlJHVG5WVmJGcG9aVzE0V0ZkWGVHOWlNREI0VjFoa1dHSnJOVmhaYTFwM1pWWlJlRmR0ZEZaTlJFWktWVmQwYjFZeFNYcGhSbWhoVWtWYVlWcFZXbXRqVm1SelZHMW9hR1ZzV2xwV2ExcHJaREZKZUZWclpGaFhSMUpvVlcweFUxWkdiSEpYYTNSc1lrZDRWMWRyWXpWaFJrcFZVbXR3Vmxac1NreFdha3BMVTBaV1dWcEdhRmRpU0VKTVYyeGFZVll5VG5OYVNFcFBWbTFTY0ZacVNtOU5iRnB6V1ROa2JGSnNWalZXUm1odllWWk9SbU5HYkZwaVZFWlVWbFZhWVdSSFZrbGFSM2hYWWtoQmQxWkdXbTloTWtaWFUyNUthbE5JUWxkWmJHaERWMFphY1ZKdFJrOWlSbkI2VmxkNGEyRldXa1pYYXpGWFZrVktjbFZxUmtwbFJrcDFWRzFHVTAxdGFGQldiVEF4VVRGU2MxZHVUbWhUUjFKVVZGWmFjMDVHV1hsbFIzUlhZbFZ3ZVZrd1drTldNa3BIVTI1d1YwMUdjSHBXTVdSUFVqRndSMkZHVG1sVFJVa3lWbXBLTUZVeFJYaGFTRTVZWW1zMVZGbFhjekZXYkZwMFpVaGthMkpIZUZkV01uUXdWMFpKZUZkcmFGZE5ibWd6Vm1wR1MxZFdSbk5XYkdoWFVsYzRkMVp0TUhoV01XUkhWMjVLV0dKSGFIQldNRnBMVlVaYWRHVkhPVkppVmtZMFZqSjBiMkpHU1hkWGJrcFZWbXh3VEZSVldsZGtSVFZXWkVab1UwMUlRa3BYYkZaaFlqRmFkRk5zYkdoU01taGhWRmMxYjJGR1duTlhhM1JyVWpGS1NGZHJWVEZXTWtWNVQxUlNWMkpVUWpSVWEyUkdaVlpLY2xkck5WUlNNVXBXVjFkMFlWbFdaRWRXYmxKc1VqQmFXRlZ0ZUhkTlJsSlhWMjEwVjAxRVJscFZWM1IzVm1zeGRXRklXbHBXYkhCeVZXMTRUMk14Um5OYVIyeFlVakpvVmxac1pIZFNNVkY0VjFob1lWTkZjRzlWYWs1RFZrWlNWbGR1Wkd0aVJuQklWako0YTJGck1VVlJhbEpYVm5wV1VGbFZXa3RXYXpWWFlrWndhRTFZUVhwWGJHUTBWMjFXV0ZWcmFGQldiV2h3Vm14b1ExbFdaRmRXYkU1VlRWZFNNRlp0TlV0WFIwcHlZMGRHVlZac2NETldNRnAzVW14d1IxUnNUazVYUlVwS1YxZDBZV0V4VW5SVGJHaG9VbFJHV0Zsc1VrWmtNV3hWVVZob1ZGSnJjRnBaYTFwUFYwWkplV0ZHWkZoV2VrWTJWRlphWVdNeVNrZFdiRTVwWWxaS2VGWnRNVFJXTURCNFYyNU9WbUV5VW05VmJYUjNaV3haZVU1WVpGaFNNRlkxVmtaU1IxWXdNVWRqUlhoaFVteHdTRmw2U2tkU01rWklZVVUxVjJKWVpEWldha1poWVRBMVIxUlliRlZpYXpWb1ZUQldZVlV4YkhKaFJVNVZUVlphZUZWdGREQlVNa3BIWTBoc1dHRXlhRE5aYTFwTFl6SktSVlpzV2s1V01tZDZWMVpXWVZNeVVraFNhMmhRVm14YVdGbHJhRUpsYkZwSFdrUlNXbFl3TlhwWlZFNTNZVVpLYzJORk9WZGlWRVY2VkZaYVlWZEhWa2hQVjNST1lURndXVlpVU1RGVE1WcElVMnRvYkZKdFVtRlphMlJ2Wkd4U1ZWSnVUbGRpUjFJd1ZXMTRUMVJzWkVaVGEyUlhWbTFSTUZscVNrZFdNV1IxVTJ4b1YxSlZjRmxYVmxKSFpESlNjMkpHVmxSaE1sSlVWRlphUzJWV2JISlhhM1JvVm14c05WbFZXbXRXTWtwWlVXeENWMVpGUmpOYVZWcFhZekZrYzJGSGJGTk5WWEExVm14a05GVXhXWGhhUldSWVlUSm9jMVV3WkZOWFJsSllaRWhrVkdKR1dsbGFSV2hyVmpBeFZtTkZaRmROYWxaSVZteGFZV015VGtsalJtUm9ZVEZ3VVZkcldtRldNbEpJVW10a1ZXSlhhRTlWTUZaTFpHeGFjVkp0UmxaTlZURTBWbXhvYjFZeVJYbFZiVGxWVmtWd1ZGbFZXbGRrUjFKSldrZHdUbFp1UVhkV1IzaFhWREZhUjFOdVVtdFNSVFZZV1d0YVMxTkdiRlpYYTNCclRXczFTRmt3V210V01rcEdZMFZXVjJKWVFrTmFWVnByVWpGV2RWSnNWbWxTYkhCWlYxZDBiMUV4WkZkYVJsWlVZbTVDVDFadE1WTlhSbHBJVGxaT2FGWnJjSGxVYkZwdlYyMUZlV0ZGVWxkaVdHaG9Xa1ZWZUZkV2NFZFZhelZYWWtacmVGWnRlR3ROUjBWNFdrVm9WR0V5VWxsWmExcGhXVlpzYzFWc1pGTlNiSEJHVlcxNFQxWXdNVmxSYTJoWFVqTm9VRlpIZUZwbFJrNTBVbXhvVjFKVmNGbFhWbEpIV1ZkTmVGUnVWbFZpV0VKVVZXeFdkMkZHV25SbFIwWmFWakZhZWxZeU5VOVpWa3BaVld4V1ZtSllhR2hhVjNoWFYwZFdTVnBHWkU1aE0wSlpWbFJLZW1WR1dYbFRiR3hTWVROb1YxUlhjRWRYUm5CR1YydDBhbUpJUWtsWk1GcFBWRzFLZEdGR2NGZGlSMUV3VjFaa1VtVkdXblZVYkdocFlUTkNXbGRYZEd0Vk1rbDRWV3hrVjJKck5WQlZiVEZUWlZaYWRFMVZaRmRpUlhCNldUQlNRMWxXV2xkalNGcFhUVzVvYUZWdGN6RldiRlp6V2tkb1RsZEZSalpXYlhCRFlURlplRlJyWkZSaWJFcHpWV3BLTkZaR1VsZFdibVJhVm14c05WcFZXbXRoUlRGRlVtdG9WMDFYYUhKV1IzaHJVbXMxVjJKR2NGZE5NVXBOVm0xd1IyTXlUWGxTYTJoUVZqTm9jRlZ0TlVOT2JGbDVaRVprVGxKc1ZqVlZNblJ2Vm0xR2NsTnNXbFZXYkhBeldUSjRjMVpzY0VaWGJYUk9WbTVDTkZac1pEUmlNa1pYVTI1V1VtSlViRmxXYlhoTFZFWmFTRTFXWkZkTlZUVXhWVEo0YjJGV1pFWlRiRlpYVW0xTmVGbHFSbGRTTVhCSFdrWmFhR1Z0ZUZSWFYzaGhVakExUjFkWWJFOVdhelZXV1d0V2QxSXhXWGxsUjNSWFZteHdNRlpXVWtOV01ERkhZMGhLV2sxdWFHaGFSVnBMWXpGYWNrNVdaRTVXV0VKTVZtMHhOR0Z0VmtkVFdHaFlWMGQ0VlZsclpEUldiRmwzV2taT2FGSnNjSGhXUnpBMVlXMUtTR1JFVWxkTmJrMHhXVmN4UzFZeFRuSmlSMFpUVm01Q1VWZFdXbUZVTVVwelUyNUdWbUpIVW5CV01HUnZaVVprYzFadFJsUmlWbHBJV1RCV1lWbFdTbk5UYmtKV1lsaG9NMVl4V210V01YQkpZMFUxVjJKV1NsbFdha2t4VXpGWmVGZHJXbGhpYXpWaFdWUktVbVF4VW5OWGJtUlhZbFZhU1ZWdE1YTlZNa3BKVVdwYVdGWkZTbWhhUkVacll6RmtjMkZHV2xkU1ZYQlpWMVpTUjJReFVrZGlSRnBVWVhwc1ZGbHNXbUZUUm1SeVYyMTBhRlpyY0ZwVlYzUmhWakpLU0dGRVRsWmxhMXBZV2tWYVlXTnNjRWhqUms1WFRUSm9XVll4WkRSaE1EVkhWMnRrV0dKck5XOVZiRlV4WTJ4U1YxZHVaRlJTYlZKNVZsZDBUMkZGTVVWU2ExcFdZbGhTZGxacVFYaGpWbHB6Vld4a1UxSldjRzlYVkVwNlRWWmtSMU51VG1GU01uaFlWV3hhZDFac1duTmFTR1JUVFZaV05WWkdhSE5WTWtWNVlVaEtWbUpVUm5aWk1GcFhaRVUxVmxSck9WZGlTRUpKVm0wd2QwNVhSbFpOVm1oV1lXdEtXRmxzVWxkVVJsbDNXa1ZrYW1GNlZsaFpWVnBYVmpGYWRWRnNhRmhpUmxwb1ZqSXhVbVZHWkhOV2JFNXBVakpvVlZaR1dsZGtNVTVYVjI1S1lWTklRazlXYWtKaFYwWlplVTVWZEdoV1ZFSTFXVlZhYjFkdFNraGhTRnBYVFVad2NsWnFSbXRqTVhCSVpFWk9hVkp1UW1oV2Frb3dXVlpGZUZkWWJGUmhNbmhUV1cweFUxZEdXbkZVYlRsb1VtMVNXRll5ZUdGaVJrcDBWV3h3V0dFeGNISlpWVlYzWlVaT2MxZHNaRk5pU0VKdlZtMXdRbVF5VmtoVGEyUllZa2RvYjFwWE1UUmtiRnBZWTBWT2EwMVZOVmhaTUZwaFZtMUZkMDVXYkZwaVJscFlWR3RhV21WWFVrVlZiR2hUWWtoQ05sWnRNWGRWTVZweVRWVm9WbUpIYUZkWmJHaHZZVVpzTmxKdGRHcE5XRUpKV2xWa2MxVXlTbkpUYldoWFlsUkdNMVZxUm5OV01rcEhXa2RzVTJKSVFsRldha0pXVFZaYVYySklVbXhTTUZwWVdXdGtOR1ZXYkZaV2F6bG9ZWHBHV1ZwVldtRldNVWw2Vld4Q1YxSkZjRXhWTUZwWFl6RmtjMWRzWkU1TmJXZzFWbTEwVTFJeFRuUldhMlJWWW1zMWIxVnRlSGRqUmxweVYyMUdWRlpzY0hwV1YzUXdWa1V4V0ZWc2FGWmlWRlpNVmxWYVlXUldSblZSYkZwb1lURndUVlp0ZUdGWlZrbDRZMFZXVm1KWGFFOVdha1pMVTBaYVIxZHNaR3BOYTFwSVZUSTFVMVp0UmpaaVIwWmFWa1ZhYUZSVVJsWmxSbVIwWkVaa1YyRXhiM2RXVnpCNFpERlNjMWR1VmxKaVNFSllWbXRXY21WR1ZqWlNiVVpVVW1zMU1WVXllRzloVmxsNVlVWnNXRll6YUZSVmFrWmhVakZXZFZWdGVGTmhlbFpaVm0weE1HUXdNVWRqUlZwWVlYcHNiMVp0ZEhOT2JHUlZWRzVPVjAxV2NEQldSM0JUVm0xR2NsZHNVbHBsYTFwUVZqRmtUMU5IUmtkVWJHaFRZVE5DWVZadGVHcGxSVFZIWWtab1ZXSnJOWEJWYlhoaFZrWnNkR042UmxoU2JFcFlWMnRhVDFkSFNraGtSRTVZWVRKTk1WWnRjM2hXYlU1RlVteGFWMDB5WjNwV2FrSmhWMjFXYzFadVRtRlNiRnBZV1d0b1ExUldXbGhqUlhSVFlsWmFlbGt3Vm10aFJrbDVaVWhDVjJKWVVqTlVhMXBoWXpGcmVtRkZOVk5pV0doWlZqSjBZV0V4V25OYVJXaG9VakpvVjFSVldsWmxSbXh4VW0xR2ExSXhXa3BYYTJRMFlWWkplbUZFVWxkaE1rNDBWRlZhV21Rd01WWldiRTVvWVRGd2FGWnRlR3RpTWtaSFYyNUdVMkV6VWxSWmJGVXhVMFpXV0dWSFJsVmlSWEF4VlZkemVGZEdaRWxSYTJoaFVrVmFVRlV3V2xOamJHUnlUMVprVjFKc2NETldiR1EwWWpGRmVWTllhRmhpYkVwUFZtdGFTMk5HVWxobFJXUlBVbXhzTkZsVmFFOVdNVmwzWTBWc1YxWjZWa1JXYlhONFVqRmtkR0ZHWkdsWFIyZzJWMVJLTkdReFNYaFZibEpxVWpKNFZGbHRkRXBOUmxweldUTm9UbEpVUmtoV2JHaHZWMGRLY2s1V2JGcGhNbEoyVmpCYVlXUlhUa1pUYXpWWFlraENOVll5ZEZkTlJsVjVVMnhhYVdWcmNGZFVWelZ2WTJ4c1YxZHRSbE5OVjFKNlZXMTRhMkZIUlhsa2VrSlhWMGhDU0ZaRVJrcGxSbVIxVm14V2FWWXlhRlZXUmxaaFpERmtWMXBJVG1GU1JVcGhWbTF6TVZkR1dYbE9WV1JXVFd0d1YxWXllR3RXVmxwMFZXeFNWMDFHY0dGYVZsVXhWbXM1V0dGSGJGTlhSVXBZVm0wd2QyUXdOVmRhU0ZKVVlUSm9iMVZ0Y3pGV2JGcHpWMjVrV2xadVFsZFdNalZMWWtkS1NWRnJaRlZpUm5CeVdWWmFTMlJGT1ZWVWJHUnBWMFpLZVZaR1ZtRmpNV1JIVTI1T1lWSnNTbkJWYWtwdlpXeGFWVkZzWkd0TlZtdzBXV3RhYjJFeFNsZGpTRTVXWWxSRmQxUlVSbHBsVlRWV1QxWmtUbEpGV2xsWFZFSnZZekZrU0ZKWWJGWmlia0poVm0xNGQxUkdXbk5YYlVacVRXdGFTRmRyWkc5VWJVcEdWMWh3VjJKWVVsUlZla1pMWkVaYWNscEhSbFJTYkhCWlYxZDBWMlF5VGtkV2JrWlZZbFJzV0ZSV1duZE5SbEpXWVVjNVYySlZXVEpWYlhSdlYyMUZlR05JV2xwV00wNHpXbFprUjFOV1RuTlhiV2hvVFZoQ2RsWnNVa3RPUjBWNVZHNU9ZVk5GTlZaWmEyUlRWREZhZEU1VlRrOVdiSEI0Vlcwd05XRXdNVmRpUkU1VlZtMW9XRlpYTVVabFYwWklVbXhrYVdKclNrbFdha0poV1ZkU1NGUnFXbE5pUjFKUFdWUkdkMU5zWkhOV2JVWlZUVlpLTUZVeU5WTmhSa3AxVVd4b1dsWkZXak5aVlZwclZqRndSMVJ0Y0dobGExcGhWbXRqZUZJeFZYbFRiR1JVWWtoQ1dWWnFUbTlXUm13MlVtMUdhazFXV25wWGEyUnZWVEZhVlZac1ZsZFNiSEJvVldwQmQyVkhTa2RYYkhCc1lrWndkbFp0TVRCa01sWlhWVzVPVjJKVWJGaFVWVkpIVFZaYVYyRkhkRmROYTNCYVdWVmtiMVp0U2xsaFJrSmFUV3BHVkZWcVJtRmtSMHBIVkcxc2FFMUlRbFJXYlRCM1pESldSazVWYUZaWFIyaFZWakJrYjJOV1ZuTmFSemxxVm14YWVsWlhlR3RoVlRGWlVXeHNZVkpXY0doWmExcExZekpPUlZGc1ZsZGlSWEJWVjFaV1ZtVkhUbk5YYmtaWFlrWndjRll3V2t0bFZscHhVVzFHYUUxVk5VbFZiWFJ6VlcxS1IyTklRbHBpV0ZKTVZqRmFZV1JIVmtoU2JGcE9WbTVDTmxkVVFsZFpWbEY0VjFod2FGSnNTbUZaYTJSdlpHeFNjMWRzY0d4V01VcElWMnRWTVZVeVNsZFRhMnhYVmtWcmVGWkVTa2RqTVU1eVYyeG9hVlpXY0ZkV2JYaHJWVEZhUjJORmFHeFNNRnB4Vm0xMFlWZHNiRlphUkVKWFRVUkdTRmt3VmpCV01WcDBWVlJDV2xaRldsZGFWbHBQWTJ4d1NHTkdUazVpVjJoaFZqRmFVMUl4VFhoVmEyUllZa1phVkZscmFFTmpNVnAwWkVoa1dHSkhkRE5YYTJoUFZtc3hjbFpxVGxwTlJuQjZWbXBHV21WdFJraGhSMFpUVWxoQ1ZGZHNWbUZrTVVsNVVtdGFUMVp0VWxSWlZFNURWbXhhY2xkdGRFNVNNVVkxVm0wMVQxZEhTbk5UYmtwV1lXczFWRll3V25OamJIQkhWR3hTVjJKSVFscFhiRlpYWVRGWmQwMVlTbXBTVjNoWVZtMTRTMUpHV25Sak0yaFhUV3MxU0ZaWGVIZGlSMFY0WWpOd1YxWXphR2hXYWtwVFUwWktjbHBIUmxOTmJtaFZWa1pTUzFRd01IaFhibEpPVjBkU1ZWUlhlRWRPUm14eVYyMTBXbFpyTlVkVWJGcHpWMjFLV1dGRmVGcGhhMXBZV1hwR1YyUldVblJoUms1cFVtMDVNMVl5ZUZkaU1rVjVVMnRrV0dKc1dsTlphMlJ2VjBac2NsZHJkRmhTYkhCNFZXMHhSMkZ0U2xaT1ZWcFdWak5vTTFsVlZYaGpNVTV4VjJ4b1YySklRbTlXV0hCSFYyMVdWMVJzYkdwU00wSlVXV3hhUzFkV1dsaGxSMFpyVFZkU1dGZHJXbTloYkVwV1kwaE9WbUpZVW5wVWJGcFhZekpHU1ZwSGFGZGhNMEkyVmxSSk1WRXhaSE5YYTFwVVlXczFXRmxVUm5kaFJuQkdXa1U1VTJKV1NraFdNbk14VmpGYVJsWllaRmRpVkVJMFZHdGFXbVZHV25WVmJFNVlVMFZLV0ZkV2FIZGpNV1JIWWtoT1ZtRXlVbGhWYlRWRFYxWndWbHBFUWxkTlZuQjZWVEp3UTFaVk1WaFZibHBYWVd0d1IxcFdaRkpsYlU1SFdrWk9hVk5GU2xaV2JURjNVakpGZVZWclpGUmlSM2h3VldwS2IxWkdXblJrU0dSWVZteHdXVlJWYUc5V2F6RlhVMnRvV2xaRk5YcFphMXBMVmxkS1IySkdaR2hoTUhCdlZsUkNZV050VVhoalJWWldZbGRvVkZaclZrcGxiRnBWVW0wNWFVMVdiRE5VVmxwdlZtMUdjazVXWkdGV00xSm9Wa1JHZDFZeFpITmFSM0JwVTBWS1NWZFdWbXRqTWtaWFUyNVdVbUpIZUZoVVZtUlNUVVphY1ZKdVRsZE5XRUpJVjJ0YWEyRlhSalpXYkdoWVZqTlNjbFpVUmxKbFJsWnpXa2RHVTJGNlZsbFhWM1JoWkRGT1YxVnVUbGRXUmxwdlZXcENkMVl4V1hoVmEzUlhUVlpzTmxWWGVGTldNREYxWVVkb1YyRnJXbkphUmxwcll6RndSMVJzVGxkaWEwcE9WbXBLTkZsV2JGZFhXR3hWWW14S1YxbFVTbE5YVm14WlkwWmtWMUp0ZUZaV1IzUlBWa2RLUjJKRVVsZE5ha1YzVmtSR1NtUXdNVlZXYkdSWFRURktNbFp0Y0V0U2JWWkhXa2hPWVZKdVFuQlZha3B2VmxaYWNWRnRSbHBXTURWWVZsYzFVMVZHV25KT1dFSldZbFJXUkZZeFdscGxSMFpKV2taT1RtRXhjRFZXUmxwaFlqSktSMU51VW1oU2JYaGhWbXRXWVdGR2EzbGxSMFpxWWtkU01GcEZXbE5WTURGSFkwVndWMVo2UlRCV2FrWmFaREF4U1ZwR1VtaE5WWEJhVjFaU1IxTXhUa2RpUmxaVVlYcHNXRlJXV2t0TlZsVjVUVlJDVmsxRVFqUlZNbmhYVjBaWmVsVnVXbFpXZWtaWVZXcEdhMlJXVW5OalJUVk9ZbGRvVmxacldtRmhNVlY0Vkd0a1YxZEhlSE5WYlRGVFYwWlNXR1JIUm14V2JFcDZWakkxVDFZd01YSmpSbkJhVmxaS1VGWnFTa1psUjA1SFZXeGthVmRIYUhsWGExcGhWREpTU0ZaclpHRlNNbWh6V1d0YVdrMUdXblJOU0dSc1VqRmFlVlJXV210WFJtUklWV3M1VjJKR2NHaFdNRnB6WkVVeFYxUnNhRmRpU0VJMFZtdGtORlF5UlhsVGEyaHNVMGRvVjFadE1XOWtiRnB4VVZob1YwMVhVakZaYTFwM1lVVXhjMU5xU2xoV00xSnlWWHBHUzJSR1VuSmhSa0pYWWxaS1ZWZFhkRzlSTVdSWFdraEtWbUV5VW05VVYzTjRUbFpWZVdSSGRGaFNNSEJaV1ZWYVUxWldXa1pYYTNoYVZsWndhRnBGVlhoVFYwWkhWMnMxVjFZelkzZFdNVnBUVkRKRmVWSnJaRlJYU0VKWFdXdGtORmxXYkhKWGJVWk9UVlpXTkZZeU1VZFhSa2w0VjJ0c1ZVMVdjRE5XYWtwR1pXeEdXVnBHWkdsU01VVjNWbXhTUjFsWFVrZFRiR3hvVWpOQ1ZGWnFTbTloUmxwSFYyMUdhMDFWTlVoWk1GWmhXVlpLV1ZWc1ZsWmhhMXBvVlRCYWEyTnNaSFJrUm1ST1lrWnZkMWRyVmxOWlZsbDVVMnhXVTJGck5WZGFWM1JHWlVaVmQxZHJPVmhXTUZwSVZtMTRiMVV3TUhsaFJtUlhUVmRPTkZwWGMzaFhSbEp6V2taa2FXSkZjSHBXVjNodlZURlplRlZzWkdGU1JrcFpWbTAxUTFJeFduUmpSVTVvVW14d1ZsVnRlRzlXTURGeFZtNWFWMkpVUmt4V01XUkhVMVpPYzJOR1pHbFdhM0JPVm14U1ExbFdXWGxVYkdSVFltczFXRmxyWkZOalJscHhVMjA1Vm1KR2JEUlhhMUpEVjJ4YWRGVnFRbGRXYldoeVZrZDRZV014WkhOaVJuQm9UV3hLVlZacVFtRmpNazE0V2toS2ExSXphRmhaYTJRelRVWmFjVk5ZYUU1U2JIQkhWRlphYjFadFJYbGxSbWhhWWtkb1ZGcFhlSE5YUjFaR1kwZDBUbFl4U2paV2JHUTBZVEpHU0ZKWWFHcFNWRVpZV1ZkMFlXRkdiRlZUYXpWc1VtNUNTbFpITVVkVk1EQjNVMnhDVjJKWWFGUldha1pQVmpGa2MxWnNVbGRTVm5CWlZrWmFZV013TlZkV1dHeHNVakJhV1ZWcVFuZFNNVkp6VjIxR1YwMXJjRWhaTUdSdlZsWlplbUZFVGxaaVJuQk1XWHBLVDFOSFZrZFViV3hYWVRKM2VsWnRkRk5TTVd4WFZGaHNVMkpIVWxWWlYzaDNZakZ3V0dSSFJsaFNiSEI1Vm0weFIyRXlTa2hrZWtwV1lsUkZkMVpVUVhoWFJsWnpZMFp3YUUxWVFtOVhWbHBoVjIxV1dGSnJhR2hTYldoWVZGUkdTMlZXV25OYVNIQnNVbXRzTkZadE5VOVpWa3AwWVVoQ1YwMUdjRXhhVlZwclYwZFNTRkp0ZEU1V2JrSTJWbTB3TVZVeFVuTmFSVnBQVm0xU1ZsWnNXa3RUUmxWNVpVWmtXRkl4V2twWGExcHJWRzFGZWxGc1pGZFdiSEIyV1dwR2MxWXhUbkpYYlhCVFZqSm9XRmRXWkRCWlZUQjRWbTVTYkZJelVuRlpXSEJ6VjBaa2NsWlVSbFZpUlhCYVZWYzFZVll5Um5KWGJrcFZZVEpTUjFwV1dtRmtWazV5VGxaa1YwMVZjRFJXYkdRMFlUSkplVlJ1VGxkWFIxSllWbXRXWVZkR1duUmxSMFpPVW14S1dGWXljelZoVmtweVkwaHdWMDF1UWtSV2JGcGhaRWRHUjFGc2NGZFdia0p2VjFod1MxUXhTWGhhU0U1aFVtMVNUMVJWVm5kVmJGcDBZMFZPV2xadGVGbFdSbWh6VmxkRmVXVkdVbHBoTVhCb1dUQmFWMk5XU25Ka1JtUlhZa2hCZDFaR1ZtOWlNVnBHVFZaYWFsSkZTbGRaYkdoVFkyeHNWbGRyY0d4V01WcEpWREZhVjFZeFdYbGhSVlpYVW14S1NGZFdaRTVsUmxwMVUyeFdhVk5GU2xsWFZtaDNVbXN4VjFkdVNsaGlWR3h3VkZkMFlWSXhVbFpoU0U1cFVtczFSMVl5ZUdGV01rVjRWMnBPWVZJemFIcFpNVnBMWXpGd1NHTkdaR2hOV0VKWVZteGplRTVHVVhoWFdHeFVZa2Q0YjFWdE1XOVhSbXh5V2taS2EwMVhlRlpWTW5SclZrWktjbU5JYUZkTmJtaFFXVlprUzJOc1RuTmlSbVJUWWxVeE5GWldVa2RoTVVsNFdraFdWR0pIVWxsVmFrcHZWMVprVjJGSVpGZE5WbXcwVmpKNGIySkdTblJWYlRsV1lXdEtXRlJyV25Ka01WWnlaRVprVGxadVFraFdWRW8wWVRGYVYxZHVUbXBTYTBwWVdWZDBZVTB4VlhoWGF6bHFZWHBXV0ZkclZURlViVXBZWVVkR1YySlVRalJVYTFwelYwWldXVnBGTlZkaVZrcGFWMWQwWVZsV1drZGlTRXBoVW1zMWNWVnRlRXRYUmxwellVYzVWVTFXY0hwV2JYQlhXVlpLV0ZSVVJsZGhhM0JNVm0xNFlXTldXblJTYkdSWFltdEplVlp0Y0VwbFJrMTRWMnhrVkdKR1dsTlphMmhEVkRGV2RFNVZUazlpUm5Bd1dUQldhMWRzV1hkT1dIQmFUVVphZGxsVVJrcGxWMVpIVld4V1YySkdiM3BXYWtvMFdWZE9WMVJ1UmxKaVIxSnZXbGQ0WVZkc1dsaE5WRUpwVFZaV05GZHJWbk5WYlVwVllrWmtXbUV4Y0ROWlZWcGhZMVpLZEZKdGRGZE5SRlpJVmpKMFZrMVdVbk5YV0hCb1VtMVNXRlp1Y0VOT1JsSldWMnhhYkZack5YcFdNakYzVlRGa1JsTnNjRmhXYkVwSVdrUkdZVkl4WkhWU2JFNXBWbFp3ZUZkWGRHdFZNV1J6WVROa1dHSlZXbFpaV0hCRFRURlZlV1JHWkZoU2JWSktWVmQwYjFZeFNrWlhia3BXWVd0YWFGcEdXazlrUjBaSFZHMXNVMkpyU1hwV2JUQjRaREZSZVZOWWJGWmlhelZaV1cxNFMyTnNWbkZVYkU1cVVtMTRlbFl5TVVkWFJrcHpZMGh3V2xaWFRURldha0Y0WTJ4a1ZWTnNjR2hOV0VKUlZtcEplRkp0VmxkVmJGWlRZa1phV0ZWc1duZE9iR1JWVTJwU1dsWXdNVFJXVnpWUFYwZEtXR1ZHYUZkTlJscExWRlphWVdNeFZuSmpSM2hUVFVkM01GWXlkRzlVTVdSSVUyNUtUMVp0ZUdGV2ExWjNaR3hzVmxkc1pHcFdiRW93VkRGYVlWVXlTa2xSYWxKWFZucEJlRmxVUmxabFZrcHhWMjFzVTJKV1NsZFhWM1JoWkRKT2MxZHJhR3hTV0ZKVVZGWmtVMWRzYTNkWGJYUm9VbFJHZWxWc2FHdFdNa3BIVTJ0b1YxWjZSbGhXYWtaUFpGWk9kRkpzVG1sV01tZ3lWakZrTUdJeFJYaGFSbVJoVW0xU2FGVnJWa3RaVmxwMFRWWk9XRkp0ZUhsWlZWWXdWMnhhY21KNlNscGhNWEJZVm14YVlXUkhSa1pWYkZwT1VtNUNlVmRVU2pSWlYxSklWV3RrYUZKck5XOVVWRUpMVjBaYWRFMUlhRTlTTURFMFYydG9TMVJzV2xoaFJtUmFZbFJXUkZZd1duTldWa3AxV2taV1UySllZM2xXVkVwNlRsWmFSMWRZWkdwU1YyaFpXVlJHVm1WR2JGZGFSWFJZVW0wNU5sbHJXbXRoVm1SSFUyNW9XR0pHV21oV1JFcFRVakZrZFZSdFJsTmlWa3AzVjFab2QxWXlVWGhYYkdoT1ZrWktZVlpxUVRGVFJsbDRZVWQwV2xacmJ6SlphMmhQVm0xS1ZWSnNVbGROUm5CaFdsWmtWMUpyT1ZkYVJUVlRVbFp3U0Zac1kzaE9SMGw0V2tWb1UxZEhhSEZWTUZaM1YwWlNXRTVWT1U1TldFSllWMnRXYTFaR1duSlhibkJYVFdwR2VsWlVRWGhrUjBaSFYyeGthVlpGVlhkV01WcHJWRzFXUjFwSVRtRlNiRnB3V1d0V2QyVldXbGhqUlhSUFVteHdTRll5TlV0V01rcFdWMjFHVjJKVVJsUldNRnBoWkVkV1JrOVdXazVTUlZwWlYxUkNZV0l4V1hoVFdIQldZbXh3WVZadWNFZFhSbXQ1WlVVNWFrMXJjRWhaTUZwclZHc3hWbU5GTlZkTmJtaHlWR3RhV21WV1VuVlViVVpVVWxoQ2IxWlhNSGhpTVZwSFlraFNhMUpZVWxWVmJURlRWbXhXV0UxVlpGZFNWRVpZVlRJMWQxWnJNWFZoU0VwYVZqTm9URlZ0ZUd0ak1rWkhZMFprVGsxVmNIWldNVnBYV1ZkTmVGZHNaRlJpYXpWVldXeG9iMWRHYkZWVWEwcHNVbXh3VmxVeGFHOVVNVXB6WTBWb1ZrMXFWbEJaVjNoTFl6Rk9jMkpHWkdsV1JWcFVWMnRTUjJFeFdYaGpSVnBRVm0xU1QxWnRlSGRPYkdSWFZteGFUbFpzYkROVVZXaHZWa2RLZEdWR2JGZGhhelZVV1RKNFlWWldTblJTYlhCT1ZqRktOVmRXVm10T1JsVjNUVWhvVkdKdFVsaFdibkJHVFVad1JWSnRkR3BOYTNCSVZqSjRZV0ZGTVhOVGJIQlhWak5DUkZacVFURldNa3BIVjJ4a2FWSlVWbHBYVjNSaFpEQXhSMWRzYUd0U1JrcFlWRmQwZDFOR2EzZGFSemxhVm10d2Vsa3dXbE5YYlZaeVkwWkNWbUpZVFhoV01HUkxVakpHUjFSck5XbFdWRkY0Vm0wd2QyVkhVWGhUV0doWFYwZG9WbFl3Wkc5V2JGbDNXa1JTVjJKSGVGWlZiVFZyVm14YWMyTkljRmhoTVVwVVZqQmFZV1JIVmtkWGJHUlRUVEZLVVZadE1YcGxSbGw0Vkc1T1lWSnRVbkJXYTFaaFUxWmtWMVZyWkZwV01ERTBWakkxUjFadFNraFZia0pYVFVaV00xcFZXbUZqTVhCSlkwZDRVMkV6UWxwV1ZFb3dZVEpHUjFOdVZsSmlSMmhZV1d4b2IwMHhVbGhsUjBacVlrWmFlVmRyV2xkVWJGcFlaSHBHVjJFeVVYZFhWbHBTWlVaa1dWcEdhR2xTTW1ob1YxWlNSMlF3TUhoV1dHaFlZbGhTV1ZWc1VrZFdiRnBZWlVaa1ZXSkdjREZWVjNCaFZqSktTRlJZYUZabGExcG9WVEJhVDJNeFpITmhSMmhzWWxob2IxWnRjRU5pTVVWNFYxaG9hbEpXV2xSWmJGWmhZMnhXYzFWclpGaGlSMUo1VmpKME1GWlhTbFpXYWxKWFRWWktSRlpxUVhoa1ZsWnpZVVpvVjJKV1NrbFhXSEJIVkRKT2MxcElUbWhTTW5oVVdXdG9RMWRzV1hoYVJFSm9UVlpXTkZZeWRHdFdNV1JJVld4c1dtSllUWGhXTVZwWFkxWktkRkpzVW1sU2JrSktWMVJPZDFZeVJrZFhiazVxVTBkNFlWUlZXbUZOTVZweFUydGFiRlpzU25oV1YzaDNZa2RGZWxGcmJGZFdNMEpJV1ZSS1QyUkdTbkpoUms1b1pXeGFVRmRYTUhoaU1XUlhWMjVLV0dKVldtRldiVEUwVjBaYWRHUkhkRmROYTNCSldWVm9UMVpyTVVkalJFNWFaV3RhYUZwRlZYaFdNVkowWlVkc1UySnJTbUZXYTFwaFZURkZlRmRzYUZSaVJuQnhWVzB4YjFZeFVsaE9WemxPVFZad2VGVnRkREJoYXpGeVRsVm9WMVl6YUdoV2FrWkxWMVpHYzFWc2FHbFNiSEJ2Vm0xd1MxUXhXWGhqUld4VllrWmFjRlpxU205a01WcFlaVWM1VWsxRVZsaFdNalZUVkd4YVIxTnVRbFZXTTFJeldsWmFVMVl4WkhSa1JtUnBVakZLU2xac1kzaGlNVnAwVW01S1QxWnNTbUZVVlZwM1lVWndSbHBHWkZSV2JrSkhWR3hhYTJGV1pFaGhSbXhYWWxob2NsUlZaRVpsUm5CR1drWlNhV0V6UW5oV1Z6QjRUa1prUjFadVVrNVdlbXh5V1d0YWMwNVdVbGRXYWtKWFVtdHdlbFl5TlhkV01WbDZZVWhLVjFJemFFeFpla1poWTFaV2MxcEhhR2hOU0VJMVZtMTBVMUl4VVhoVWEyUlhZbXR3YUZWdGVHRmlNWEJZWlVkR2EwMVhVbGxhVldRd1ZtMUdObEpzYUZkTmFsWklWbFJLUzFkV1JuVlViRnBvWVRCWk1GWkhkR0ZXTWsxNVVtdHNWV0pIVWxSVVZXaERVMnhrVjFadFJsWk5WMUl3Vld4b2MxWnRTbk5qUm1oWFlrWndNMWxWV25KbFJtUnpWRzF3VGxacmNEWldNblJyWXpGVmQwMUliR0ZsYTNCWVdXeG9RMU14Y0ZaWGEzQnNVbXhhTVZaSGVGTmhWMHBHWTBab1dGWjZRWGhWVkVaelZqRmtkVlJzYUdsU2JrSlFWbTB3ZUU1R1pGZGpSbHBYWW0xU2IxUlZVa2RTYkZwMFpFZEdWMkpWY0ZwWlZWSlBWakpHY2xkdGFGcE5ha1pRVlcweFMxSXlSa2RhUjJ4WFlUSjBOVlpxU2pSV01rVjRWVzVTVjJFeVVuRlZiR1EwVmtac2NscEdUbXBTYkZvd1drVm9hMVpzU25OalJFSmhWbFp3VUZacVFYaFdiVTVIWVVaa1RtSnNTakpYVm1RMFV6RmtSMVp1VmxKaVJscFlXV3RhVjA1R1dsaGpSV1JXVFdzeE5GWXlOVk5WUmxwMVVXeG9XbFpGTlVSWFZscGhWakZ3UlZWc1pFNVdia0YzVmxSS05GWXhXWGxTV0doVVlsZG9WMWxYY3pGa2JHdDVaVWRHYWsxWFVubFVNV1F3VmpKS1JtTkVXbGRXUlhBMlZGWmtSMUpyTVZkaFJrSlhVbFJXV1ZkWGRHRlRNVTVIWWtoR1ZHSkZjSE5WYlRGVFYyeHNjbGRzVG1oV01Ga3lWbTE0ZDFkR1dqWlNXR1JoVWtWYVlWcFZXbGRqTVdSellVZHNVMDFWY0ZKV2JHTjNaVVUxUmsxVlpHcFNiSEJaV1d4b1UxWXhVbFpWYTJSWVVteFdOVlJzYUU5V01ERldZa1JhVjFKdGFIWldha3BIWTJ4S2NWVnNXbWxTYmtKTlZtMTRZVk15VFhoalJXaHBVbTFTVkZac1duSmtNVnB4VW0wNWEwMVZiRFJXYkdodldWWktXRlZzV2xwaVdFMTRXVlZhVjJSRk1WaFBWbWhYWWtad05GWnJZM2RPVm1SSVUydG9WbUpIZUdoVmJHUlNaREZhYzFwRmRGZE5WMUo1V1ZWYWExWXdNSGxoUnpsWFRWWndhRlY2Um1GWFJrNXlXa1pLYVZJeFNuZFdWekV3WkRGa1YxZHVSbE5pVlZwWFZGWmFjMDVHYTNkV2JUbFdVbXh3TUZaWGN6VldiVVY0VjJ0MFZWWnNjR0ZhVm1SVFVqRlNjMVpyTlZkaVdHUTJWbXRhWVdJeFdYbFNhMlJWWVRKU2NWVnRNVk5XYkZweFZHdE9WRkpzV1RKVmJUVnJWakF4V0ZWdWJHRlNWMUl6VmtjeFJtVnNSbkppUm1ScFZrVkpNRmRYY0V0VE1VNUhWRzVPYVZJeWFGUlZiRkpYVjFaa1YxVnJaR3ROVm5CSVZtMDFSMVV5UmpaV2JrNVdZbFJXUkZVd1dtdGpiSEJKVkd4YVRtRXpRbGxXVkVsNFlqRmtTRk5yYUZaWFIxSlpWbTB4VTFWR2JEWlNiWFJyVm14YWVWUXhXbXRXTVZwSFYyMUdWMDFYVVhkWFZscGFaREExVmxwSFJsTmlXR2g0Vmxjd2VGVXlTWGhXYms1V1lUSlNXVlp0ZUhkWFZuQkdXa1JDVjAxV2JETlpNRlp6VjJ4YVYyTkZVbGRoYTBZMFdrWmFVMk5XVm5SU2JFNVhUVlZ3V2xac1VrZGhNVTE0VTFoc1ZXRXhjRkJXYlhNeFkwWldjVlJzU214aVJuQjRWVEp3UTFZd01WZGpSRUpYWWxoU2NsZFdXa3RYUjBaSFZXeHdWMUpZUWpKWFZFWmhWakpTU0ZWcmJHRlNiRnBQVm1wT2IwNXNXWGxrUjNCT1ZqQldNMVJXV210aFZrcEhWMjFvVm1KSFVsUlZNRnB6Vm14d1JscEZPV2xTV0VJMlYxZDBZVmxYUmxkWGEyUllZa1phV0Zsc1VrTk9SbFowVFZaa1dGSnJjSGxaYTFwTFlWWktkVkZzUWxkV2VrRjRWVmN4VjJNeGNFZFdiRXBwVmxad2VGWkdXbUZqTURWSFYxaHNUMVpZVW1GV2JYUnpUbXhhV0U1VlRsZGlWVnA1VmpKME5GWnRSbkpYYldoYVRXNW9NMVZzV2tkamF6VlhWR3MxVTJKclNtRldiWGhUVTJzeFYxZFlhRmRpYkVwVldXMTRTMVl4YkhOV2JVWllVbTE0VmxWdE1VZFVhekZZWkVSV1lWWlhhRkJaVnpGTFVqSk9SMk5HY0ZkV2JrSXlWbTF3UW1WR1NYbFVhMXBoVW0xU1dGcFhkRlprTVZwelZXdGtXR0pXV2toWGEyaFBWakpLU0ZWdE9WVldiRm96VmpGYVlWSXhiRFpTYkVwT1ZsaENTVmRYZEZOWlZsVjVVbXBhYVZKdGFGWldiVEZ2VWtaVmVXVkhSbGhTVkVaWlZERmFZVlJzU2taVFdIQlhWa1ZyZUZkV1dscGxWazV6WWtkb1UySlhhR2hYYkdRd1VtMVdSMkpFV2xOaWJWSlVWRlpvUTFOR2JGWmFTRTVZVW10d1Yxa3dXa2RXTWtwVlVtcE9WbUZyV2s5YVZWcDNVbXh3U0dGRk5VNWlSWEJoVmpGamVHVnJNVmRhUldSWFlteEtjMVV3VlRGVlJscDBaVWhrV0ZadVFsZFdiWEJEVmpBeFJWSnNhRnBOUmxweVZtMXplR1JXVmxWUmJHUk9ZV3RhVFZaWGNFdFVNVTVZVTJ0b1UySkhVbkJWYlhoeVpERmFkRTFZWkZOTmJFWTBWa2QwYjFaSFJYbFZiV2hXWWxSR2RsWnJXbE5YUlRGWFUyczFVMkpJUVhkWFZFSlhUVVpTYzFOWVpHbFNSa3BYV1d0a2IyVnNXbFZUYTNSVVVqQmFTRlp0ZUhkaFJURlpVVzA1VjJGclNtaFpla3BUVTBaU2NWZHNUbWxUUlVwWlYxZDBWMlF4WkhOWGEyaHNVbTFTVlZSWGRGZE5NVkpYVjIwNVYySlZjRWhaTUZwclZsWmFObFpzVG1GU1JWcDZWakJrVjFKdFVraGpSMnhUVFZWdk1sWXhaREJaVjBsNVVtdGFUbFp0VW5CVVZFNURWMFpzY2xwR1RrOWlTRUpYVmpKME1HRXhTbkpPV0doWFRXNW9VRmxXV2twbFJrNXpVV3hvVjJWclNUQlhWM0JDWlVkTmVGcElWbFZpUm5CdlZGVm9RMlZzV2xoTlNHaFdUVlUxU0ZZeWVHOVVNVnAwVld4b1dtSkdXbUZVVjNoelkyeGtjMVJzWkZkaVIzY3lWMVpXVjA1R2JGZFhiazVxVWpKb1YxbFhkR0ZsVm5CWVRWVmtVMkY2YkZoV1IzaHJWVEZhZFZGdFJsZGhhMXB5VkZWa1NtVkdXbGxoUmxwcFlYcFdXbGRYTVRSVE1WbDRZa2hTYW1WcldsbFZiVEUwWlZaWmVXUkVRbWhOYTNCSVZUSTFjMVl3TVhGV2JrcFhZV3R3VEZadGVHdGpiVVpIWVVkb1RsZEZTbFpXTVZwaFdWWk5lRmRZYUdGU2JYaHhWVzB4VTFkR1ZuTlhibVJYVm14d01Ga3dWbXRYYkZweVkwaHNWVlpzY0hKV01HUkhUbXhhYzFac1dtaGhNMEl5VjFkd1IxbFhVa1pOVmxaV1lsaFNUMVZyVmtwTlJscHhVbTA1YUUxWFVrbFZNblJ2Vm0xS2NsZHNhRnBpUjJoVVZGUkdkMWRIVmtsVGJYUk9WbTVDVjFaWE1IaGlNVmw1VWxod1VtRnNjRmxXYWs1RFZVWnNObEpzY0d4V2EzQXhWVEl4YzFVeFNsVldiR1JYWWxSRk1GcEVSbk5XTWs1SFdrWm9hVkl4U25oV1JscHZVVEZPVjJKR1dsZFdSVnBXV1Zod1IxSXhhM2RYYms1WFRVUkdXVlpIY0ZOV1ZscFhZMFU1WVZac2NGUlpNbmgzVWpGa2RHSkdUazVpVjJjd1ZtMTRhbVZIVm5KTlZtaFZZVEpTY0ZVd1ZuZFhSbGwzV2tjNVZVMVdTbGhYYTFwUFlrWmFjMk5FUWxWV2JGcHlXVlZhU21ReFpGVlRiRnBwVjBaS05sWXhXbUZaVmxsNFdraFdhbEp0VW5CV01GVXdUVVphY1ZGdGRGTk5WWEI2Vm0wMVQxZEhSalpXYmtKYVlrZFNkbFpYZUdGak1WWnlXa1p3VjJKSGR6RldiR1F3WWpGYVdGSlliRlppYTFwWFdWZDBkazFHV1hkWGJFNVhWbXMxTUZReFdrOVdNa3BKVVdwU1YxWkZhM2haVkVaWFkyc3hXVk5yTlZkU2EzQllWa1pqTVZVeVRuTlhiRlpVWVROU2NWUldaRk5OVmxaWVpVZEdhRkl3VmpOWk1HTTFWakpHY2xkdGFGZGhhM0JVVlRCYVYyTnRTa2RXYldoc1lsaG9WbFl4WkRSWlZrMTRWMWhvV0dKR1dsUlpiRkp6WWpGU1YxZHJkR3hpUmxZMVZHeGFUMVpzU25OalJXaFdUV3BHU0ZZeWVHRlNiR1J4Vkd4a2FFMVlRbTlXVjNoaFV6Sk5lVlJyYUd4U01uaFVWbTB3TlU1R1duTlhiWFJQVW14c05GWXhhR3RVYkU1SVZXeFdXbUV5VVRCV01WcGhZMnhhZEZKdGFGTmlXR2hYVmxjeE5HUXlTa2RYYmtwcVUwZDRXVmxVUm5kV1JteFhWMnh3YkdKVldraFZWM2hyWVZaa1JsTnNSbGhXTTBKRFdrUktWMUl5VGtaYVIwWlRUVzFvVmxaWGNFZFRNbEp6VjJ0a1dHSllVbGRVVm1SVFUwWmFjMkZJVG1oaVJXd3pWako0YjFkdFNrZFhhazVYWWxob2FGcEZaRmRTTVhCSFdrVTFhRTB3U2t0V2JYaHFUVlpOZUZkc1pGaGhNWEJaV1cwMVExWnNiSE5oUnpsVVVtNUNTRll5ZUU5aGF6RlhVMjVzVldKSFVucFdWRVpyVW14T2NtVkdaR2xXUlZWM1YxWlNRbVZHU25KT1ZscGhVbTFvY0ZsclZuZFhWbVJZVFZod1RsWnRVbGhXTWpWTFZqSktWbGRzYkZaaVdHaE1WakZhVTJNeGJEWldiV2hwVmxoQ1NWZFVRbUZaVmxwelYyNVNhRk5HY0ZoWlYzUkhUa1pyZVdWSFJtcFdiVko2V1RCa2IxUnNaRVpUYWxaWFlsUkdNMVY2UmxwbFZsWnlZVVprYUUxdWFHOVdWekI0WWpGa1IxVnNWbFJpVkd4d1ZGWmFjMDVHV1hsbFIwWnBVbXR3ZVZsclVsTlhhekZIVjI1d1YySkhVa3hXTUdSSFVqRldjMXBIYUU1aVJWWXpWako0VjFsV2JGZGFSV2hWWVRGd1ZWbHNhRzlXUmxweVZtdHdUbEpzY0hoVk1uQkRZVlV4VjFKcVVsZE5WMmh5VmpCa1MxWlhTa2RYYkdScFYwZG5lbFpHWkRSVk1XUklWbXRvVTJKWVFrOVpWRVozVTJ4a2NsWnRSbWhOVm13MVZXeG9kMVZ0U2toaFJtaFdZV3MxZGxZd1dtRldWa3AwWkVaT1RsWXhTbUZYVkVKcllqRmFSMU51VmxKaVIzaFpWbTE0UzFSR1dsVlNhemxUVFZaYU1WWlhNVFJXUmtsNFUyeFdWMUp0VVhkYVJFWlBVakZrY21GRk5WZFNhM0IyVm0weE1HUXdNVmRXYkdocVVtczFXRlJYZEdGbFZsbDVUbFZrV2xac2NGbFdWM00xV1ZaYVYyTkZlR0ZTYkhCVVdrVmtTMUpyTlZaT1YyeHBWakpvWVZadGNFZGhiVlpHVGxWa1ZWZEhhRmxaVkVwVFkwWlZkMWRyZEZWTlZuQjVWakowTUZZeFduTlRiR2hYVFdwR1NGWkhlR0ZrUjFKRlZHeGtUbUZyVmpOWFZsWnJVakExYzFOdVRtbFNNRnBZVm1wS2JtVnNXbkZSYlhSVFlsWmFTVlpIZEhOV1IwcEpVVzA1VlZZemFFeFdSbHBoWkVVeFZWVnRhRTVoZWtVeFZsUktNR0V5Um5OVGJsSldZa1pLV0ZSVldtRlVSbEp6VjIxR2ExSXhXa2xWYlhoM1ZqSktTVkZZWkZkaVJuQjJXV3BHWVZkR1RuVlViR2hwVW10d2FGZFdVa3RpTVVwSFlraEdVMkpyTlZsV2FrRXhVMFprY2xkdE9WZE5hM0JZVlRKd1YxWXlSbkppUkZKVlZsWndhRmt5YzNoV01XUnlUMVprYVZZeWFGcFdiVEYzVkRKSmVWWnVUbGhpYTFwVldWUk9VMWRXV25Sa1IwWk9WbXhhV1ZwVlpEQmhSbHAwVld0c1dHRnJOVE5XTUdSTFVqSk9TR0ZHY0ZkU1dFSlJWMWh3UjJReFRsZFdibEpyVW1zMWNGVnROVU5WVmxsNFYyeE9WVTFWVmpSV1IzUnJXVlpPUm1OR2FGcGhNbEpVV1RCYVUxWXhaSEphUlRsVFlrZDNNRmRXVm05aE1rWkhVMjVLVDFaWFVsZFVWelZ2Wkd4WmVXVkdjR3hpUmxvd1dWVmFkMVl4V25WUmJGWllZVEZhY2xacVJrOVdNVloxVkcxR1UxWkdXblpXUmxwdlVURk9WMWR1U2xaaE1sSmhWbTB4TkZkR1dYaGhSM1JWWWtad1dWWlhOVWRXYlVwVlZtdFNWMDFHY0hwV2JGcFBZMnMxV0dWR1RtbFNiWFExVm14amQwMVdVWGhYV0dST1ZtMTRVMWxVU2xOWFJsSllZMFZrYkdKR2NIbFdNbk0xVlRKS1JrNVljRmROYm1oeVdWWmFhMU5IUmtoUFZtaG9UV3MwTUZac1kzaFdNVWw1Vkd0YWFWSnNTbkJWYWtaTFpHeGtWMVZyVG10TlYxSllWakkxVTJGc1NsaFZiRlpWVm14VmVGWXdXbHBsVjFKSVQxWldhVkl4U2toV1IzaHFUbFpaZVZOc2JGVlhSMmhYVkZaYWQyTnNhM2hYYkU1clVsUnNXRmRyWkc5aVIwVjRZMFp3VjJKWVFreFVhMXBHWlVaa2RWUnNhR2hOV0VKNFZsY3hNRk14V1hoaVJtaHJVMGRTVjFWdGVGZE9SbGw1WkVkMGFHRjZSbGRVYkdoM1YwZEZlVlZVUWxwV2JIQnlWVEJhZG1WdFRrZGFSMmhvVFZoQ05WWnJaREJaVjAxNFYxaHNWR0V5VWxsWldIQlhWMFphY1ZKcmRHbE5WbkJXVlZkNFlWUnNXWGRpUkZKWFlsUldVRlp0TVV0amF6VlpVbXhrYVZkSGFHOVhiRlpoVmpGa1JrMVdXbUZTYlZKUFZtMDFRMDVzV2xWVFZFWnJUVmRTZWxZeWVHdFdNVnBHVjJ4b1ZWWjZWblpaVlZwelRteE9jbVJGT1dsU1ZGWTJWakowYTJNeFdYaFRiazVxVW01Q1dGbFhkR0ZoUm1SWFYyczFiRkp1UWtkWGExcHJZVmRLUjJOR2JGaFdNMUp5V1dwS1NtVkhTa2RXYkU1cFlsWktWVlp0TVRSa01ERkhZMFphV0dKVlduQlZiWFIzWlZacmQxZHVUbGRoZWtZeFZsY3hiMWRzV1hwaFJYaGFUVzVOZUZacVJsZGpNWEJJWWtaT2FXRXdXVEZXYWtvMFlUQTFSMkpHWkZoaVIxSlZXVzF6TVdGR1ZuRlRhbEpWVFZaYWVWWnRNVWRXUmxwMFZXeG9WMVl6VFRGWlYzTjRWakpPUm1KR1drNWhiRnBOVm0xMGExTXhTbkpPVm1Sb1VtNUNXRlJVUmtwbGJGcDBaRWRHVjAxRVZucFZNalZQV1ZaS2RGVnNhRnBXUlZvelZHeGFhMk5zV25OWGF6bFhZa2QzTVZaVVNqUmhNVnBJVW01T2FsSnRlRmhaYkdodllVWnNWbGR0UmxOV2EzQjZWa2N4ZDFSc1dYaFRiVVpYVFc1U1YxUnNXbHBsUms1elYyMXdVMkpXU2xwV2JURTBVekZTUjFkc1ZsUmhlbXh4VkZaa1UxZHNiRlpYYlRsb1VsUkdXbFZYTlhOV01VcDBWV3BhVlZac2NGQlZha3BMVTFaT2MyRkhiR2xXYTNBeVZteGtkMUV4V1hkT1ZtUnFVbFp3VjFsWWNITlhSbEpXVld0a1RsWnNXbGxhUldNMVYyeGFjbU5GWkZkTmFsWk1WbXBLUjJOc1pIRlViRnBPVm01Q1dWZHJWbXRXTVVsNFZXNUtUMVpVVmxSV01GWkhUbXhhZEdORlpHaE5SRlpKVlRGb2MxVXhaRWhWYXpsV1RVZFNkbGxWV2xka1JURlhWR3hvVTJKWWFEWlhWbFpoVkRKR2MxZHVUbFJpUjNob1ZteGFXbVF4V1hkWGEzUnJVakZhU2xsVldtdFZNbFp5VWxob1dGWnNXbGRhVlZwTFZqRk9kVkpzU21sV1ZuQlpWbTB3TVZFeFRsZFhibEpzVWpCYVlWWnFSa3RUVmxaMFpFaE9XRkl3Y0VoV01uaHZWMjFGZVdGRlVsZFdiSEJvV2tWVmVGWldWbk5YYXpWb1pXeFpNbFp0ZUdwTlZsRjRWbTVTVkdFeWFGZFpiWFJMVjBac1dHUklaR3RpUmxreVZXMHhSMkZ0U2tsUmExcFhWbnBHZGxaSGVHRmpiR1JWVW14a1YyVnJWWGRYVjNCSFZtMVdWMVJ1U21GU00wSlVXV3RXZDJGR1pGaGtSMFpVVFZkU1NGZHJXbXRYUjBwR1RsWnNWbUZyUlhoVmFrWnJZMnhrZEU5V1drNWhNMEpJVjFSQ1lXSXhXWGROV0ZaV1lsZG9XRlZyVm1GamJGWnhVbTEwYTFack5YbFVNVnByVlRGYWRWRnNjRmROVjFFd1dXcEdWbVF3TVVsaFJtaHBVbXh3VmxkWGRHdFZNazVYVld4a1lWSnJOVTlXYlRFd1RURlplVTFFVmxkTlJFWkdWVmR3VjFkc1dsaGhTSEJYWVd0d1RGWXhXa2RqYlZaSFdrZG9hRTB3U2xaV2JHUjNVakZSZVZWc1pGWmliRXB2Vlcxek1WUXhiSE5hUnpsV1ZteHdlVll5TVVkWGJGbDRVbXBXVjFadGFIWldNR1JMWXpGT2RWSnNXbWxTYkZZMFZqRmFZVmxYVFhoV2JrcFZZWHBzVkZscmFFTlRWbVJYVm0xMFRsSnRVbnBXTWpWTFlWWktSazVXYUZWV2VsWlBWRlphWVdOV1RuSmFSM0JwVWxSV05GWnJaRFJXTVZsNFYyNVdVbUpVYkZoV2ExWkxZMnhhUlZKcmRHcE5WbG94VmxjeGIxVXlSalpXYm1SWFZucFdNMWxxUVRGV01XUlpZVWRHVTFKVmNGaFdSbHBYWXpBMVIxZFliR3RTTTFKWlZXcENkMU5HYTNkWGEwNVhUVVJHU0Zrd1VrOVhiRnBYWTBab1lWSlhVbGhWTVZwM1VtczFWazVXWkdsWFIxRXlWbTB3ZUU1SFNYbFRXR2hoVWxkU1ZWWXdaRzlYVm14VlUycFNXbFpzU2xkV01uaGhZa1pLZEdWR2FGZE5ha1YzVm10YVMyUkhVa1ZYYkhCb1RWaENlVlpxUW1GVU1VcHpWRzVLYVZKdFVtOVVWbFozVTFaYVdFMUlhRlppVmtZelZHeGFZV0ZXU1hsaFJsSlZWbnBHZGxac1dtRmtSMDVHWkVkc1RsWnNjRmxXYWtvMFlqSkdjMU5zYkZaaVIxSldWbTE0VjA1R1VuSlhiVVpyVWpGYVNGZHJXbUZoVmxwWFYxUkdWMkpIVFhoVlZFWnJaRVpLV1dKR1dsaFNNVXBYVjFkMFlXUXhXa2RYYmtaVFlsaFNjbFZxUmt0VFJscDBUVmhPVmsxV2JEWlhWRTVyVmpKS1IxTnJlRlZoTWxKVFdsVmFhMlJXVG5KT1ZtaFRWbTVDV2xZeFpEQmhNa2w0VjFob1ZtSkhhRkJXYm5CelZteFdkR1ZGZEU1U2JrSlhWMnRXYTJGRk1WZGpTSEJXVFdwV00xWXljM2hUUmxaMVkwWmtWMUpWV1RCV2JUQjRWREZKZVZSclpHRlNWRlp3V1d4a2IwNUdXWGxsUm1SYVZtczFNRlp0ZEd0aGJFcFlWVzFvVm1KWWFETlpNRnBYWTFaU2RFOVdhRmRpVmtwYVYyeFdhMDFHVVhoVFdHUlBWbGRvV0ZSWGNGZFZSbGwzV2tWMGFrMXJOVXBWTW5oWFZqSktTVkZxV2xkU00yaG9Xa1JHWVdNeFpITldiR1JwVW01Q2QxWnRlRzlSTVdSSFYydG9iRko2YkhGVVZtUlRUVVpXYzJGSE9WaFNNSEJJVlRKNGIxWldXalpXYkVKVllURndNMVZ0ZUd0ak1YQklZMGRvYkdFeGNGcFdiWEJMVGtkRmVGWllhR0ZTVm5CVldXdFdkMWRHVWxkYVJUbFBVbXhLZVZZeWVFOWhNVXB6WTBSR1YxWXphRlJaVlZWNFYxWkdjMXBHYUZkTk1tZ3lWbXhTUjJFeFNYbFRhMnhXWWxoU1ZGWXdXa3RYYkdSWVpFZEdhMDFWTlVoV01XaHpWR3hhUmxOc1dsVldiRnA2VkZSR1dtVlZOVmxVYkdSWFlraEJkMWRXVm1GVk1XUjBVbGhvYWxKWWFGZFpWM1IzVlVaV2NWSnRkR3BOVjFJd1dXdGtjMkZGTVVsUmEzUlhZbFJGTUZacVJuTlhSbFpaWVVaV2FFMVlRbEJXYlRCNFZURmFjMkpJU21GU2VteFlWVzE0ZDJWV1dYbE5WV1JYVFVSR1dGa3dXbTlYUjBWNFUydFNXbFpGUmpSV2FrWnJaRmRLUjFac1pGZE5iV2cxVm0xMFUxSXlSWGhUV0doaFUwVTFhRlZ0ZUdGWFJsSlZVV3QwV0ZadFVucFhhMUpUWVcxS1YxZHNiRmRpV0ZKNlZqQmtTMWRXVm5KUFZuQllVMFZLV1ZaWGNFZFpWMDVYVkd4c2FGSlVWbFJaYTFwYVpXeGFSMWRzWkZkTlZtdzFWVEkxVTFadFNraGxSbWhhWWtkb2RsUlVSbHBrTVdSeldrZHdWMkY2VmpWWGExWnJaREZTZEZKcVdsZGhNMUpZV1ZSS1VrMUdXbkZUYTJSWVVtdHdXbGt3V2t0aFZrcFhZMFpzVjFaNlJUQmFSRXBQWXpKS1NWSnNUbWhsYlhoWlZrWmFZVmxWTVZkWGEyaHNVakJhYjFacVFscE5iRnAwWlVoa1YwMXJjRlpWYkdocldWWkplbFJxVWxwbGExcHlXa1phVjJOck5WZGhSazVPVmxoQ2FGWnFSbXRPUmxsNVZWaG9XR0pyTlZoWmJYaExWREZhZFdOSVRsaFNiSEF3V2xWb2ExUnNTbk5qUm14aFVsWktWRll5ZUdGamJVNUhZVVp3VGxKdVFsVldha3A2WlVaWmVWUnJXbWhTTUZwVVZtcEdTMU5XV2xoalJXUnJUVlUxU1ZadGRHOWhWa3AwWVVaU1ZWWnNXbGhVVkVaaFpFVXhWVlZzV2s1V1YzY3dWbXBHYjJJeFpFaFRia3BxVWxSc1dGbHNVa2RrYkZwelYyNU9WMVpyTlRCVU1WcHJWakpLV1dGRVZsZE5ibEp4Vkd4YWExSXhUblZWYlhoVFVsVndWMWRYZEdGWlZsWkhZa1prVjFkSGFGaFVWM1IzVW14YVNHVkhkR2hXYTJ3MVdWVlNTMWRHV25OVGEzaFdaV3RhVUZWcVJtRmtWazV6WVVkc1UwMVZjRlpXYTFwVFVqRkpkMDFJYUdGU2JWSlpXV3hXWVZaV1VsaGxSWFJZVW14YU1GUnNXbXRoUmtweVkwaHdXazFHVlRGV2FrcEhZMjFPU1Zkc1dtbFNia0p2Vm0xNFlWUXlUbGRXYms1WFlYcFdXRlpyV21GWGJGcDBUVWhrVGxac1ZqVlZiVFZQVmtkS2MxZHNUbHBpV0ZKTVZqQmFjMWRIVGpaU2JYUnBVbXh3TlZacVNqUmtNa3BIVjFoa1QxWlhVbWhWYkZwM1lVWmFTRTFWZEZOaVZUVkhXV3RhYTFZeFNsaGtSRkpYWWxoQ1RGVnFSbHBsUmxKMVZHMXNVMkV6UW5kV1Z6RTBaREZrUjFwR2FHeFNlbXh3VkZWU1IyVnNXbGhsUnpscFVtdHdNVlZYTlU5V01rWnlWMjFvVmsxV2NGTmFWVnByWXpGU2RHRkdaR2hOYW1nMVZqRmFiMlF4UlhoWFdHaFlZbXhLVjFaclZrdFhSbHB5Vm0xR1dGSnVRa2RXTW5NMVlXc3hXVkZyYkZwTlJuQlVWbFJHWVdSV1JuUlBWbVJPVmpGR00xWXhXbXRWYlZaWFUyNUtZVkl6UWxSV2JUVkRWMnhrV0dSR1drNVdiVkpZVm0wMVIxVnRTa2xSYXpsYVlURndhRlJWV25KbGJVNUdXa1prVGxKRldrZFdWekV3V1ZaYWRGTnJaRlJoTW1oWVdWZDBkMVJHV25OWGEyUllWakJhU0Zrd1pEUmhSVEZaVVd4d1YySkhUalJhVnpGWFVqRmtXV0pHVW1oTmJXaDJWbGN4ZWsxV1drZFhibEpQVmxVMVlWWnRlSGRsYkdSeVZXeE9hRkpVUmxoVk1uQkRWakZhZEdGSVdsaFdiSEJRVlcxNGEyTXhVbk5qUjJ4WVVsUkZNRlp0TVRSWlZteFlWV3RvVldGc2NGUlpXSEJYVmtac2RHUkZkRmhTYkd3MVdrVmFUMVZyTVZkaVJGSldUV3BXVEZsWGVFOVRWa1owVW14d2FWWkdXa1ZXVkVKaFYyMVJlRnBJVWxOaGVteHdWV3hvUW1WR1pGVlJiVVphVm14c05GVXllR3RoYkVwMFlVWnNXbUV4Y0doWk1uaGhVbFpLY21OSGVGZGhNMEkxVmpKMFlWWXlSbGRYV0hCb1VtNUNXRlpxVG05WFJuQkZVVlJHVjAxWFVqRldSM2h2WVZaYVNHVkliRmRTYkhCb1dYcEJNVll4WkhKaFIzaFRUVEZLZGxaWGVGTlJNRFZYWTBaYVYxWkdXbGhVVjNSM1ZteFdkR1ZHVGxoaVZWcDVWako0YjFkck1WZGpSWGhhVFdwR1ZGVnFSbGRqTVhCSVlrWlNVMVpXYkRaV2JYQkxUVVpaZVZKWWFGUlhSM2hVV1ZSS1UxZFdiSFJrU0dScVVteGFlVll5ZERCWFJrcHpVMnhzVldKR1dsQldWRVpMWXpKS1JWUnNhR2hOVm13elZtMTBZVk15VFhoVWJrNXFVbTVDV0ZadE5VTlhWbHAwWTBWa1dsWXdNVFZWTW5SWFZsZEtTRlZzYUZWV1JVcE1Wa1phWVdNeGEzcGhSbVJPVmpGS1NWWnJZekZUTWtaSFUyNUtUMWRGU2xkWmExcExWMFphVmxkdGRGaFNWRVpLV1ZWYVlXRkhWbkpYYkd4WFlXdHJlRlZxUmxka1JrNXlZVVphYVZKdVFsZFdiVEUwVm0xV1IxVnNXbGhpVlZwVVZGZDBZVk5XY0VaYVJ6bFhUV3RXTmxWWGVIZFhSMHBIVjI1YVZtRnJXbWhXYWtaclkxWmtjMVJ0YkZOaE0wSmhWbTB3ZUU1SFVYaFhhMlJZVjBkU1dGWnJWbUZYVmxaelZXNU9XRlp0ZUhsV2JGSkhWakF4UlZGcVZsZFNNMEpZVm1wS1MxZFdWblZUYlVaWFRUQXhORlp0Y0VkaE1rMTRXa2hLVDFadFVuQldha3B2VG14YWMxa3paR3hTVkZaSVZqSTFUMWRIU25OVGF6bFhZbGhTTTFaRVJsZGtSMVpKV2taa1RsWXhTalZXYlRCNFRVWlpkMDFZU21wU1YxSldXV3RhUzFKR1dYbGpNMmhUVFdzMVNGWlhlR3RoUjBWNlVXeHNXRlpGYnpCVmVrcFBWakZhZFZSdGFGTmlWa3BRVmtaYVYyUXdOVmRYYms1b1UwZFNWRlJYZEZkT1JsVjRZVWM1V2xack5VaFdNbmh2VjIxS1NHRkZVbGRoTVhCVVZqQlZlRmRGT1ZkaFIyeFRZbXRLWVZZeWVGZFpWbEY0VjFoa1RsZEZjRkJXYlRGdlYwWnNjbHBIT1d0aVIxSllWakp6TlZVeVJqWldiR2hYVWpOb1dGWnFSbUZqYlU1RlYyeGthVmRGU2tsWGExSkhXVmROZUZwSVZsVmlSbHB3VlcwMVEyUXhXblJsUnpsU1RWZFNTRll5ZEc5aVJrcDBWV3M1Vm1KVVJsUmFWM2hyWTJ4YWRWUnNXbWxXV0VKS1YxWldhMUl4YkZkWFdIQldZbGRvYUZacVRtOWxiRkowWlVWMGExWnVRa2hXUjNNeFYwWktWbU5GZEZkTmJtaFlXVlJLVG1WR1pGbGhSbWhwWWtad1ZGZFhlR3RpTVdSSFlraE9hRkpyTlc5VmJYaDNWbXhXZEU1Vk9WZE5SRVpZVlRKd1IxWXhTWHBoUmxKYVZtMVNURlZxU2s5VFJUbFhXa1prVTFaWVFscFdiR2gzVWpGc1dGUllhRmhpYkZwV1dXdGtVMWRHVm5OWGJtUlhWbXh3V1ZSVmFHOVVNVWw0VjI1d1dHRXlhRXhXYWtwTFYxWldjMkpHV21sWFJrbDZWbTB4TkZsWFVraFdhMnhWWWtoQ1dGbFVUa05YVm1SVlVXMUdhVTFYVW5wV01qVlBZV3hKZVdGSFJtRldNMUl6VlhwR2QxZEhWa2xhUms1T1YwVktTRlpIZUd0ak1rWlhWMWhzWVZKR1dsaFpiRkpHWkRGYVZWSnJOV3hTYkZwYVdWVmFWMkZGTVhOVGJHaFlWbnBGZDFkV1dtdFNNa3BKVkcxR1UyVnRlRmxXVnpFMFdWZFdjMWRZYkU5V00xSndWVzEwZDJWc2EzZFdiVGxZVWpCV05GVXllRk5XTURGMVlVZG9WMkpHY0doWmVrcEhVakZ3UjFSdGJGZE5iV1ExVm0wd2VFNUhSWGhVV0d4VllteEtWbGxVU2xOVk1XeHlWMjFHV0ZKdGVIcFdNblF3VkcxS1IyTkdXbFppVkVaSVZtMXplR05yTVZWVmJHUnBWa1phV1ZadGVHdFRNVTVJVW10a2FGSnVRbGhWYkdSNlpERmtjMWR0UmxwV01VcEhWRlpXYzJGR1NYcFZhemxYWVd0YVMxcEVSbUZXVms1eFZXeGtUbFpzYjNkV1Z6QXhWREZhU0ZOc2FHaFNiVkpoVm1wT1RtVkdjRWhsUms1WFZtdHdlbFl5TVRSVk1rcFhVMWhrVjFaNlFqUlVWVnBhWlZaT2NsZHRiRTVOYkVwWlZtMDFkMUpyTVVkYVJtUmhVbGhTVlZWdGN6RmxWbVJ5V2toa1ZrMVZjREZWVjNoelZqRktkRlJZYUZwaGExcHlWV3BLUzFOV1NuTlViV2hPVjBWS05sWnRNSGhPUm14V1RWWmtXR0pIYUhOVmJURlRZakZhY1ZGdVpGUlNiWFF6VmpJd05WZEdTbk5pZWtwV1ZtMW9kbFp0ZUdGU2JHUnlUMWRHVjFadVFtOVhhMXBoVkRKTmVGcElVbWhTVkZaVVZXMTRkbVZzV25GU2JYUk9VbTE0V1ZaV2FHOVdWMHBJVld4a1dtRXlVbFJXTVZwell6SkdSMVJ0YkU1V2EzQlpWbTB3TVdFeFVuTlhiazVZWWtkNGFGWnNaRzlqYkZweFVWaG9WMkpWYnpKVk1uaHJZVlprUjFOc1ZsZGhhMjh3VjFaVk1XTXhUblZVYldoVFRVWndWVmRYZEc5Uk1XUlhXa2hLVjJKWVVsWlVWbFp6VGxaYVNHUkhPV2hXYTNBd1ZsZHpOVlpXV2xkVGEyUmhWak5vYUZreFdrOWpWa1owWVVVMVUxSldjRXRXYlhSaFlqSkZlRlZZYUZoaWJFcFhXV3RhUzFsV2JITmhSemxvVW0xME5GWXllR3RoYkZweVRsaG9WMVl6YUZoV1IzaGhZMjFPUjJKR1pHaGhNblEwVmpGYVlWVXlUWGhhU0ZaVllsZDRWRlZ0ZEhkWFZscDBZMFU1Vm1KV1JqUldNalZIVld4a1NHRkdhRlZXYkZWNFZGWmFjbVF4WkhWYVIyaFRWa1ZhWVZaV1pIZFpWbGw1VTJ0b1ZXRnNTbGRhVjNSM1ZrWldjVkp0Um10V2JGcDZWVmQ0YTJGV1duSmpSRTVYVFZkT05GUlZXazVsUm5CSFdrZEdWRkpZUWxwWFYzaFhXVlpzVjFkdVJsSlhSMmhRVlcweFUyVldiRlpXYWtKb1VsUkdWMWt3YUhkV01ERjFZVWhhVjAxdWFHaFZiWGhQWTFaU2MxcEZOV2xpVjJoMlZqRm9kMUl5VG5SV2JsSlRZVEpvY0ZWc1VsZGlNVkpYVjI1S2EwMVdjSHBXVjNScllWVXhjbFpxVWxkTlYyaDJWakJrUm1WSFRrbFNiRnBwVmtWVmQxWnFRbUZqTWsxNFZtNUtZVkl6VW5CVmJYaDNUbFphY1ZOVVJtaE5WbFkwVmpJMVMxUXhaRWhsUjJoV1lrWndNMVpyV21GV1ZrWlpZVVpTVjJFeGNEVlhWRUpoWWpGWmVGTnNXbXBTZW14WldWUkdTMU5HYkZWU2EzQnNVbXhLTVZadGVGTmhWbVJHVTJ4V1YxWXphRlJXYWtacll6RmtkVlZ0Y0ZOV1IzaFVWa1phVm1WRk5VZFhiR2hzVWpCYVlWWnRkSGRsVmxKellVVjBWMkpWY0ZwV1YzQlBWbFphYzJOSGFHRlNWMUpZVldwR2QxTkhSa2RhUlRWVVVsVndUVlp0ZUdGaGF6RllVbGhvWVZKWFVsbFpiWGhMVm14WmQxcEhPVmhTYkhCNVZtMDFhMVpzU25OWGJtaFdZbFJXY2xaVVFYaFhWa1p5WWtad1YxWnVRbEZXYlhCSFUyMVdkRkpyVmxWaVIxSndWV3BHUm1ReFduTlZhMlJZWWxaYVdGWXlOVXRaVmtwMFlVaENWbUZyV2t4YVIzaGhWMGRXUjFSdGNFNVdNMmhaVm1wSk1WVXhVbk5YYmtwUFZteGFXRmxzVWxkU1JscHhVbTFHYTFJd05VaFdSM2hyVkd4YWRWRnFXbGhXTTFKVVYxWmFhMk14WkhOYVJsSnBVbFZ3V1ZkV1pEQlNNRFZIVjI1R1ZHRjZiRlJVVmxaaFRVWldkR1ZGT1doV2JIQjVXVEJhUzFZeVNrZFRhMUphVmtWYVMxcFZXazlYVjBaSVkwWk9WMDF0YURaV2JHUjNVekExUjFwR1pGZGlhMXBVV1ZSR2QyTnNVbGRYYm1ST1VtNUNWMVl5Y3pWV2F6RkZVbTVzVjJKWVFsaFdha1poWkVkR1NXTkdaR2xXUlZwTlYxaHdSMVF5VFhsU2EyUnFVako0V1ZWdGRITk9iRmw0WVVoa1UwMVdiRFZXUm1odldWWk9SbU5JU2xaaVZFWlVWakJhYzJNeVJraFBWVGxwVW01Q05sWXlkRk5STWtaR1RWaEtXR0pIVWxaV2JYaDNZMnhzV0dWRk9WUlNNRnBJV1ZWYVlXRlhTbkpUYTFKWFVteHdhRmw2Um10VFJsSlpZMGRvVTJKV1NuWlhiR1EwV1Zaa1YxcEdhR3RTTUZweVZGWmFTMlZzVlhoaFNFNW9VbXR2TWxsclduTldNa3BaWVVkb1dsWldjSEpXYWtaclpFZFNSMXBGTldobGJGcEpWbTB3ZUU1R2JGaFNiR1JVVjBkb1ZWbHRNVk5YUm14ellVWk9hRkpzYkRWVVZscHJZV3N4V0ZWc2NGcFdWbkIyV1ZaYVlWWXlUa2xYYkdSVFlraENXVmRyVWtKbFJrbDRXa2hLYUZJelVsUlpiRnBMVjJ4YVdHTkZUbXROVlRWSVZqRm9jMkpHU25KT1ZtaGFZa1phTTFVd1dsWmxWMVpJVDFaa2FWWllRa2xYVkVKdlV6RlpkMDFWYUZaaVJVcFhXV3hTUjFaR1ZuRlNiRTVxWVhwV1dGZHJWVEZXTVdSR1Uyc3hWMkpVUWpSVWExcHpWMFpPV1dKR1dsaFNNbWh2VmxkNGEySXhXbGRpU0VwaFVrWktXRlJXWkRSWGJHdDNZVVU1V0dKR2NIcFpNRkpIVjJzeFIxZHRhRnBoTWxKTVZXcEdUMk15UmtkYVJUVm9ZVEZaZWxadE1YZFJiVlpJVkc1T1lWTkZjSEZWYlhoM1ZERnNkR016Wkd4U2JIQXdXVEJXTUZaRk1YSk9XSEJYVW5wV1NGWXdaRXRUUjBaSFlVWndhRTFXYjNwV2JGcGhZVEZrV0ZScldtdFNhelZQVm14a00wMUdXbk5aZWtaVVRWZDRXRlV4YUhkVmJVcEhVMnhvV2xaRldqTlpWVnB6Vm14a2RHUkdhRk5OVlhCS1ZsY3hOR1F4V1hkTlZXUnFVbGQ0V0ZsclpGSk5SbVJYVjIxMFZGSnJOWGxXTW5NMVZqSktSbU5HYkZoV00yaDJWa2N4VjFJeFZuTlhiR2hwWWxaS1ZWZFhkR0ZrTVZwelZtNVNiRkl6VWxaWmExWjNVakZaZVdSSVRsaFNiSEJIVlRJeGIxbFdTa1pYYmtwV1RVWndVRmt5ZUhkU01rWklZa2RvVGsxRmNGbFdiVEI0VGtac1dGVllhRmhoTWxKWldXMTRTMk5XVWxWVGJUbFhWbXh3TUZSc1ZrOVZNREZYVW1wU1YwMXFSWGRXYlhONFkyMU9SbU5HV2xkbGExcEpWbTF3UzFNeFpGZFNia3BXWWtoQ1dGVnNhRU5YVm1SVlUyNXdiRkpzYkRSWk1GWnZZVlpLY2s1WVFsZGhhM0IyVmxaYVlXUkZNVlZWYld4T1ZsWlpNVlpyV205aU1XUklVMjVLVDFadFVtRldhMVozVmtaWmVGZHVUbXBpU0VKSVZrY3hORll5U2xkVGFsWllWbXhhVjFSc1dscGxSbVJaV2tkd1UySldTbGxXUm1SM1ZqQXdlRmR1UmxKWFIyaHhWbTE0ZDJWR1draGxSM1JWWWtWd01WVlhNRFZXTVVvMlVsUkNWbUZyV25KV01GcExZMnh3U0ZKc1RtbFdhM0JXVm0xd1ExWXhUWGhhU0U1WVYwZG9WMWxVVGtOak1WWjBaVWRHVGxKc2NEQlViRnBQVmpGSmQxWnFVbHBOUm5CSVZtcEtTMVpXU25OVmJHUlRVbFp3VlZacVFsWmxSbVJHVDFaYVQxWlVWbGhaYlhSSFRURmFjbGR0Um1sTmExWTBWbXhvYTFSc1duUmhTRTVXWWxSR1ZGWnRlSE5qYkhCSVQxWmFVMkpZYUZsV2Frb3dUVWRGZUZOdVRsaGhhMHBXVkZaYWQyRkdiRmRYYTNScVlsVTFTRmxyV205V01VcFlUMGhrV0ZkSVFreFdSekZYVWpGd1NWWnNXbWxTVkZaM1ZsZHdTMkl4WkZkYVJtaHJVbTFTY2xSVlVsZGxiRmw0WVVoT2FFMVZjSGxVYkZwUFZsWmFkRlZzVW1GV00yaGhXbFpWTVZZeFVuTmFSMnhYVm14cmVGWXllRmRaVjAxNFdraE9XR0V4Y0ZsWlZFNXZWakZTVmxkdVpGcFdia0pZVjJ0YWExWkdTbkpqU0d4VlRWZFNlbFpVU2t0amJFNVZVMnhrYVZKdVFubFdSM1JoVjIxV1YxTnVTbGhoZWxaWVdXeGFTMlZHV2xoa1IwWnJUVmRTV0ZZeU5VdFdNa1Y2Vlc1R1dtRXhjRE5XTVZwVFZqRmtkR1JHYUZOaE0wSTFWa2Q0YjJNeFpITlhiR2hXWVdzMVdGWnJWbUZoUmxaeFVtMTBhMVp0VW5wWlZWcHJWR3N4ZEZvemJGZGlXR2h5V2xjeFYxSXhUbGxoUjBaVFlsaG9kbFpYTVRSa01rbDRWV3hXVW1FelVuTlphMXAzVjFaU1YxVnNUbFpOUkVaR1ZtMTRiMVl5U2toaFNIQmFWa1ZhVEZSdE1VdFNNa1pIV2tkb2FFMUlRblpXTW5oclRrWmtkRlpzYUZkaE1sSm9WVzB4VTFReGJGVlNiSEJPVW0xU1ZsVlhlRTlXVlRGWFlrUk9WVlpzY0hKWlYzaExVbXMxVjJGR2NGZE5NVXB2VjFaV1lXUXhTWGhhU0U1VllsaENiMXBYZUdGWGJHUllaRWRHVlUxcldsbFZiR2hyWVVVd2VXVkdhRnBXTTFKb1dWVmFZV05XU25SU2JYQm9aV3hhV1ZkV1ZtRlVNa1pYVTFob1ZHSkdjRmhaVjNSTFkyeGFWVkpzWkZOTlYxSXhWVEo0YTJGV1dsZGpSbkJYVm5wRk1GZFdWWGhTTVZaeldrWndiR0pHY0haV1Z6RXdaREF4UjJOR1dsaGlhelZoVm0xNGQxZEdXWGxqUlRsWVlsVldORmt3WkVkWlZrcEdWMjVLV2sxcVJsQlZha3BIVTBkR1JrNVdhRk5XVm10NVZtMXdSMWxXV1hoWGJsSlhZVEpTVlZsclpGTldSbXh5V2tSU2FVMVdXakJVVmxwUFZqRktkR1ZJYkZkaVZGWnlWbXhhWVdNeVRrZFhiRnBPVmpKb01sWnRjRUpsUjA1eVRWWldWbUpIVWxoYVYzaGhWMVphZEdORmRGUk5WV3cwVmtjMVUxVkdXWGRYYkdoVlZrVmFURmxxUm1Gak1WcDBVbXh3VjAxVmNFcFdiR1F3WWpKRmVGTnNWbWxTYkVwV1ZtMTRkMDB4VlhoWGJIQnNWakZLU1ZWdE1XOVViRnAwWkhwR1YxWkZiekJaZWtaWFpFWk9jbGRzVW1sU01VcG9WbTF3VDFVeVJrZFhhMXBZWWtoQ2NsUldaRk5OVmxwSVRWaGthRlpyYkRSVk1XaHJWakZLUmxkdGFGZGhhM0JJVm1wR1QyTXhXbk5hUjJoT1ltMW9ZVlp0TVRCV01VMTVWRzVPYVZORldsUlpiRlpoVjBaU1YxcEdUbXhXYkd3MVdsVmpOV0ZHV25OaVJGWmFWbGROTVZacVJscGxiRlp6WVVab1YySldTbGxYV0hCTFVtMVdkRk5yYUd4U2JFcFVWRlpXZDFac1duSlhiVVpYWVhwR1YxUldWbXRoYkVwWFkwZG9WazFHVlhoV01GcFRWakZrZFZwR1RrNVdia0kyVjFaV2IxUXhXWGROV0VwcVVsZG9WMVJYTlZKa01XUlhWMjFHV0ZKc1ducFdSekZIVmpGYWRWRnNiRmhYU0VKSVdWUktUMk5yTlZkYVIyaFRZWHBXV2xaWGVGZGtNVlY0VjI1U1RsTkhhRTlWYlhoelRsWmFWMkZIT1doV2EzQXdWbGMxUTFack1VZFhhazVhVmxad1dGcEdaRTlUVmxKeldrWk9hVkp0T1ROV2EyUTBWakZSZUZkclpGaGlhelZWV1d0a2IxZEdiSE5oUlU1VFVtMTRWMVpzYUc5V01rcFdUbFZ3V2sxR2NETldSM2hMWTIxT1JtSkdaR2xYUlVwTlZsaHdSMWxXV1hoVWJrNXBVakJhVkZsc1drdGtiRnBIVjIwNVVrMVdTbGhXTWpWVFlrWkpkMWRzVmxWV2JWSlVWakZhVm1WWFVraGtSMmhUWVROQmQxWnNZekZVTVdSelYydGFWR0p0ZUdoVmExWmhZVVp3UmxaWWFGaFdia0pJVmxkek1WWXlTa2RoTTJSWFlrWktTRmxxU2s1bFJtUnpZVVpPV0ZJemFGaFhWekV3VXpGWmVHSklUbWhTZW14dlZXMHhNRTB4V1hsT1ZUbFhUVlp3ZVZZeWNFZFhSMFY1VlZSQ1YxWkZjRXhXYWtaUFkxWmtjMXBIYUdoTmFtZ3pWbTEwVTFNeFNYbFVia3BPVm0xNFZsbHJWVEZpTVd4eVZtNWthRkp0VWxoV1YzUXdZVlV4VjJORmFGZE5ibEoyV1d0YVNtUXhaSFZTYkhCWVUwVktXVlpxU2pSV01XUklWbXRvVTJKWGFGUlVWVnBhVFVaa1ZWRnRjRTlXYkd3MFZqRm9kMkZHU1hsaFJtaFhZVEZhTTFaRVJuZFdNV1J5WkVkd2FWSXhTWGRXVnpFMFZERlNkRk5zYUdoU1JYQllWRmMxYjJOc1VsWlhhemxxWVhwR1dGZHJXbTlYUmtsNllVaHNWMVo2VmpOWmVrWldaVVpXYzFwSFJsTmhlbFpXVmxjeE5GWXdOVmRWYms1WFlXdEtXRlpzVWtkV01WSnpWbTVrVjJKR2J6SlZiWFJ2VmpKR2NtTkZlRmRpUm5CTVdYcEdWMk14Y0VkVWJHUnBZVEJaTWxadGVHcGxSVFZJVWxoc1ZXSnNTbGRaVkVwdlkyeFdkRTFXVG1wU2JGb3dWRlZTVjFSck1WZGpTSEJZVmtVMWRsWkVSa3BrTWtwRlZXeGthVkl5YURKV2FrSnJVbTFXU0ZSclpHbFNia0pZVkZSQmVFNUdXbkZSYlVacVRWWndXRlV5TlV0aE1VcHpWMnhTV21FeFdqTlViRnBoWkVkV1NFOVhiRTVXYkZsNlZrWmFiMU14VVhoWGJHaFdZa2RvVmxacVRrTlNNVkpXVjIxR1YxWnJjREJWYlRGM1lWWmFWVlpyYkZkaGEyOHdXV3BHV21WV1duVlRiR1JZVWpGS1dWWnFRbTlSTVU1SFlrUmFVMkpJUW5OVmJUVkRVMFpzY2xwRlpGWk5hM0JZVlRJMVlWWXhTbk5UYTJoV1pXdGFXRlZxUm10amJIQkhZVWRzV0ZKcmNGSldiR04zWlVaVmVGUnJaR0ZUUlhCWldXMXpNV0l4YkhKV2JtUllWbXh3V1ZSVlVsZFdNREZ5VjI1c1ZrMXVRbEJXYWtwSFkyeGtjMVZzY0U1aWJXaFpWMVJLTkdReFNYaGpSV2hvVWpOb2IxUldhRU5aVmxwMFpVWk9WR0pXV2tsVk1XaHZWMGRLY21ORk9WZE5SbHBvVm10YWMxWldUbk5VYldoVFlrWndOVlp0TUhoU01rWjBVMnRvYTFKR1dtaFdiRnAzVlVac1dHTXphRmhTYkZveFdUQmFiMkZGTVhOVGFscFhZa1pLVEZWNlNrOWpNVkoxVTIxd1UySldTblpYVmxKSFpEQXhjMXBJU2xaaE1sSlZXV3hhWVZOR1draGxTRTVvVW10d01GbFZhRU5YYkdSSlVXeG9WMkpZYUhKV01GVjRWbFpHZEdSRk5WZGlhMHBhVmpGa01HSXhUWGhpUm1SVVlXeHdjRlZ0TVc5V2JGcDBaVWhrVlZKc2NEQmFWVnBoWWtaYVZWSnJXbGRpV0dob1ZrZDRZVmRXUm5GWGJHaFhVbFZ3YjFkWGNFZFhiVkYzVFZac1YySlhhRlZWYkdoRFYxWmFkR1JHWkZOTlJGWklWakkxVTFSc1dsVmlSbEphWVRKb1JGVXdXbUZrUjA0MlVteGtUbUV4V1RKV1ZtTXhXVlpaZDAxV1pHcFNiRXBYV1ZkMFlWUXhjRlpYYlhSclZteGFlbFp0TVc5VWJVcEdZMFpvVjAxWFVYZFpWRVpXWlZaU2NscEdaR2xpUlhCUlZtMTRWazFYVGtkVmJHUmhVbXMxV0ZscldtRlhWbEpYVm0xMFYwMXJXVEpWYlhoclYyc3hTR0ZFVGxkaGEwWTBXVEZhWVdNeVJrZGFSMnhUVFZWd1RsWnNZM2RsUmxGNFZHeGtVMkpyTlZsWmJHUTBWa1pzZEdSRlpFOWlSbkF3V1RCV1QxZHNXWGRXYWxKWFRWZG9kbFpxU2t0amJVNUhVbXhrYVZkSGFHOVdhMUpIV1ZkU1NGWnJiR0ZTVkd4d1ZXMDFRMDVHV2xWVGJtUldUVmRTZWxZeU5WTldiVVY1WlVaa1dtRXlVblpaTW5oaFVsWktkRkp0ZEZOaVJuQTJWbXBLTkdFeVJrWk5WbVJwVFRKNFdWbHJaRkpOUmxwVlVtMUdhazFZUWtwV1YzaFBZVlpKZVdGR1ZsZFNiSEJvV2tSR1QxSXhaRmxpUjNSVFRVWndkbFpHWkRCWlZtUkhWbGhzYkZORk5WZFpiRlpoWld4WmVXVklUbGROYTNCYVdWVmtiMVl5Um5KWGFrNVhZbGhvY2xsNlJtdGtSMVpIVkcxc1YyRXlPSGxXYlhCTFRVZEZlVlZZYUZkWFIyaFpXVzEwZDJOV1ZuUk5WRkpZVW0xNGVsWlhkR0ZVYkVwMVVXdGFWbUpZYUROWmExcExZekZrY1ZKc1drNWhhMXBKVm14U1IxbFdTWGhhU0ZacVVtMVNXRnBYZEZaa01XUnlWV3QwVjAxck1UUlhhMXB6WVZaSmVtRkdVbGRoTWxFd1drZDRZVmRIVmtkVWJFNU9WbFJXTmxadE1UUmlNa3BIVTI1S1QxWnRlRmRaVjNSTFRURlZkMWR1U210TmExcEpWVzE0YjJGV1dsZGpSRlpYWVd0dmQxbFVSbk5XTVdSeldrZHdVMDF0YUdoWGJHUXdXVlV3ZUZadVJsTmliVkpWVldwQ1lWSXhVbk5hU0U1V1RWZFNSMVV5TVVkV01rcFZVbFJDV2xaRlJYaFZNRnBQVjFkS1IxVnNhRk5OYldoWFZtMXdRMkV5U1hoYVJXUnBVMFpLYzFWc2FGTmpWbXh5VjIxR2JHSkhlRmRXTW5NMVZqQXhSVkpzYkdGV1YyaDZWbXBCZUdOV1duVlRiR1JvWVRCWk1GWnRjRWRVTWsxNVVtdGthbEp0VWxoVVZ6RnZUbFphZEUxWVpGUk5WVEUwVlRGb2MxWlhSWGxsU0VaV1lsUkdWRlpFUm5Oa1IxWkdaRVUxYVZKdVFYZFdSbHBUVlRGa1NGTnNaRmhoYTBwWFdXeG9VMkZHYkZaWGEzUnFUVmRTTVZWWGVHdGhSVEZYWTBjNVYySllhR2hYVmxwclVtc3hWMVpzV21sU2JIQlFWMVpvZDFKck1VZFhia3BhWld0YVZsUldaRFJYUmxWNVRsWk9WMkpWY0VsWlZWcHJWMjFGZUdOSGFHRldiSEF6Vm1wR2EyUkdTblJrUms1T1ZtNUNTMVpzWTNkbFIwbDRWVzVTVTJGc2NGUldNR2hEVjBaV2NWUnRPVmhTYlhoV1ZXMHhSMWRHU25KT1ZFWldUVzVOTVZacVNrdFNiVTVJWVVab1YySkZjRWxYYTFKQ1pESldSMXBJVmxSaVIyaHdXVmh3VjFkV1duUk5WRkpVVFd4YVdGWXlkRzlpUmtwMFZXMDVWMkpZVWpOYVYzaHlaREZXZEZKc1pFNWhNMEpYVmxaa2QxVXhXblJTYmtwWVlrZG9ZVlJYTlU5T1JscHhVbTVrVTAxcldrbFphMXBQVkcxS1dHRkhSbGRpV0ZKb1dWZHplRmRHVGxsaVJrNW9UV3hLZDFaWE1IaGlNazVYVld4V1ZHSlViRmxXYlhoaFpVWldkRTFWWkZkU2EzQXdWbGMxYzFZd01YRlNhMmhhVmxad2FGcEZXbGRqYlVaSFYyczFhV0Y2VVhkV2JURjNVekZOZUZOWWFGVmlhM0J6VlcweFUySXhiRlZTYm1Sc1ZteHdlRlZYTVVkV1JURnlUbGh3V0dFeWFGQldha3BMVjBkV1IxVnNjR2xYUmtwTlZtcEtORmR0VmtkalJWWlNZa2hDV0ZSV1ZscE5SbHB5V2tSU2FFMVhVa2xWTWpWTFZERmFkR0ZIUmxwV1JYQlVWbXRhWVZac1pITmFSM1JUVFZWd1MxWnJaSHBPVmxWNVUydGtXRlpGV2xoVmFrNXZWMFpTVmxkc2NHeFNhelZhVjJ0a2QxVXhXWGhUYldoWFVteGFhRnBFU2xOak1XUjFVbXhTYUUweFNsVldSbHBXVFZkV1YySkdXbGhpUjFKdlZtMHhVMU5XYkZaWmVsWlhUV3R3V2xWWGRHOVhiRnBHWTBVNVlWWlhVbEJWYlhoM1VqRmFkR0ZIZUdsU2JrSmhWbTB3ZDJRd01WZFNia3BPVjBVMVdWbHRkR0ZXVm14WVpFVjBXbFpzY0RCYVZWcHJWREZhYzFacVZtRlNWMUYzVm1wR1NtUXlUa1poUm5CT1VqSm9TVlp0TUhoVE1XUlhWV3hzYUZKdFVrOVZiVFZEVG14a1ZWTnFVbWhOYkVwSVZUSTFVMkZHU25KT1dFSldZbFJXUTFSWGVHRmtSMDVHWkVVNVUySkZXVEJXYlhodll6RmFTRkpZYkZaaWExcFhWRlZrVWsxR1dYaFhiazVYVm10d01WZHJXbGRWTWtwWllVWnNWMkZyYjNkVVZWcGFaREF4V1ZOck9WZFdNbWhvVm0xNFlXUXlUbk5pUmxwWFYwZG9XVlp0ZEdGbGJGcDBaVWM1VjAxcmNFZFpNRlp6VmpKS1dWRnJhRlpsYTNCUVdUSnplRll4Y0VkaFIyeFRUVzFvTTFac1pIZFRNa2w1Vlc1T1dHRXlVbGhaYTFVeFYwWlNWMXBHVGxSU2JWSjVWakl3TldGRk1WWmlSRnBYVm5wV1JGWnNXbHBsYkZaMFlVWmFUbEp1UW05WGExWldUVlphZEZWclpHRlNWRlp2VkZab1FrMXNXbk5WYTNSUFVteFdORll5ZUd0WFIwcHlUbGhHVm1KSGFIWlpWVnBoWkVkV1NWcEdaRTVYUlVwWlZqSjBZV0V4VlhsVGJHUlVZVEpvV1ZsVVJsWmxSbXhXVmxob1dGSXhTa1pXYlhocllWWkpkMDVFUWxoaE1VcElXWHBHV21WR2NFZGlSMmhUWWxkb2QxZFdhSGRXTWxaSFYyeG9UbE5IYUhCVVZscHpUa1pzY2xkdE9XaE5WV3d6VmpKNFYxWnRTbFZTV0hCVlZqTm9XRnBGVlhoV1ZrWjBZVWRzVTJKclNUSldNVkpEVlRGRmVHSkdaRmhpUjFKeFZXMTBTMWxXV25STlZrNVRUVmhDUmxVeWN6VlZNREZYWTBod1dHRXlVbnBXYWtaTFZqRmFjVlJzWkdsV1JWbDZWbGR3UzFSdFZrZGFSbXhvVW14YWNGbFljRmRpTVZwWVRWUlNhMDFyYkRSV1YzaHJZVVpLVms1V2JGZGlWRVpVVmpCYVlWZEhVa1ZSYkdSb1pXdGFXVlp0TVhkVk1XUjBVbGhzYUZKWWFGaFpWM1IzVkVaYWRHVkhkR3BOYTFwSVZtMTRhMkZXV25KV2FrNVhZbGhDVEZSclpFOWtSbFpaWVVkd1UxWnNjRlJYVjNocllqRmFSMkpJU21oU1ZUVlFXV3RrVTFac1ZsaE5WV1JvVWxSR1dWWlhOWE5XVmxwelYyNUtWMDFIVWt4VmJYaFBZekpHUjJOSGJGTk5iV2Q1VmpGYVYxbFdXWGxWYTJoWFlURndjbFZ0TVc5WFJteDBaRVYwVkZadFVsWlZWekV3VkRGSmQxZHJaRlZXYkhCNlZsY3hSbVZzUm5OaFJuQnBVbXR3UlZaSGRHRlZNazV6V2toS1QxWXphRmhaYTFaMlpVWmFjbHBFVWxkTmExcFpWVzF3WVZZeVNraGhSbXhYWVdzMWRscEhlSE5qVmtwMFpFWmtUbFp1UVhoV1Z6RTBWVEpHVjFkcmFHeFNiV2hZVlcxNGQyRkdjRVZUYkdScVRWZFNXbGxyVlRGV01WbDRVMnhzVjFKc1dsUlZha1phWlVkS1NWTnNXbWxTVkZaWlYxWm9kMUl5VmtkWGJsSnJVa1pLV1Zsc1ZsZE9SbXQzVm1wU1YwMXJXbmxaTUZwRFZtMUdjbGRzYUZwbGEzQlFWV3BHZDFJeFVuTmFSbVJzWWxoT05WWnRNSGRsUlRWSFZsaG9WRmRIYUZoV01HUnZWMVpzY2xwR1RsZFdiWGd3V2tWb2EyRnRTa2RYYWtKYVRUTkNTRlpxUmt0a1IxWkpZa1prYVZaR1drMVhWM1JoV1ZkTmVWUnJaR2xTYkZwWVZtcEtiMDFzV25KYVJGSlVUV3N4TkZkcmFFZFZiVXBIWTBVNVdtSllhRXhaYWtaaFkxWkdkR1JHVWs1V1ZGWkpWbTB3TVZReFpFaFRhMlJZWWtkb1dGbFhkR0ZVUmxKWVpVZEdhazFXY0RCVmJYaDNWakpLVjFOcmNGZGhNWEIyV2tSS1IxSXhUblZUYXpsWVVsVndXRmRXWkRCWlZsSkhWVzVPV0dKVlduRlphMmhEVW14YVdHVklaRmROYTNCWVZUSjBjMVl4V2taWGJscGhVa1ZhY2xreWMzaFRWMHBIVjIxc1UwMXRhRnBXTVdRMFZURkplRlpZYUZaaVJuQlpXV3RrVTJOV1duUmtTR1JPVW14YU1GUldhR3RXVjBwSFkwWmFWMkpIYUhaV2FrWmhVbTFLUlZWc1ZtaE5XRUpZVjJ4V1lXRXlUbk5hU0U1b1VqSjRWRmxyYUVOWGJGbDRXa1JTYVUxV1ZqUlhhMVpyV1ZaS2RGVnNiRnBXUlRWVVZtdGFVMVl4Y0VkVWJYaHBVakZLTlZacVNYZE9WMFpIVjI1S2FWSkdTbGRVVnpWdlkyeFpkMWRzY0d4aVZWcElWMnRrUjFZeFduTldhbEpYVmpOQ1NGZFdaRk5XTVZwMVZXMTRVMkY2VmxCV1Z6QXhVVEZrVjFkdVNsaGlXRkpQVlcxNGMwMHhVbFpoUnpsb1VsUkNOVlpYZUhOWGJVcEhWMjFvVjAxR2NGUldha1pyWkZad1IxUnJOVmRoTTBFeVZqRmFWMkV4U1hoWFdHUk9WbTFTY1ZVd2FFTlpWbEpXVjI1a2EySkdjSGhWTW5ScllXMUtTRlZxUWxwV1ZuQXpWa2N4UzJSR2IzcGpSbVJYVFRCS1NWWnNVa3RVYlZaSFZtNVdWV0pYYUZSWldIQlhWVVprV0dWSGRHbE5WVEUwVmpJMVUxUnNXa2RUYlRsYVlrWndhRlZxUmxOV01WcDBaRVprVjJKV1NrcFhWbFpoWWpGa2RGTnNiRlZYUjJoWVZGWmFkMlZzY0VaYVJrNVVWbTVDU0ZsVldrOWhWbVJJV2tST1YyRXlVVEJXYWtaU1pVWndSbHBHVW1saGVsWjRWbFJDYTA1R1pFZGlTRTVvVW10d2NsUldXbmRsVmxsNVpFUkNhR0Y2UmxsV1Z6VjNWMjFGZVZWcmFGZGhhMXBvV1hwS1QxTlhTa2RhUjJoT1ZsaENTbFp0Y0VwbFJsbDRVMWhvYWxKWGVGVlpiRlpoVmtac2NtRkZUbFpTYlZKWlZGVm9iMkZWTVZkVGJHaFhUV3BXVkZsWGVFdFhSbFowVW14a2FWZEhhRFpXUjNoaFdWWk9TRlZyYUZOaVYzaFVXVlJPUW1ReFduTmFSRkpXVFZac05WVXllSE5oUmtwR1RsWm9WVlpzY0ROWlZWcFhZMVpLZEZKdGRGTmhNMEkyVm10a2VrMVhSa2hXYmtwWFYwZFNXRmxzYUZOalZsSlhWMnh3YkZKdFVucFpWVnBUWVZaS2RWRnNjRmhXYldneldYcEdZV014WkhWVWJHaG9UVEZLV2xaWE1UUmtNbFpYVjFoc1RsWlhVbTlVVmxaelRrWlplV1JIT1ZoU01GWTBXVEJTVDFZeVJuSmpSV1JoVmpOb1NGbDZTa3RTTWtaSFdrWk9WMWRGU2pKV2FrWnJaREZOZUZOdVVsZGhNbEpXV1cxek1XTkdWblJrU0dScVVtMTRWbFZ0Tld0V01ERlhZMFJDVlZac1NsUldNbmhhWkRGa2NtRkdaRTVoYkZwSlZteFNTMU14VGtkV2JsWlVZa1p3YjFsVVJuZFVWbHBZWTBWa2EwMVZjSHBYYTJoVFlURktkRlZyT1ZaaE1WcG9WakZhYTFaV1JuUmtSazVPVmpGS1NWWnFTVEZVTVdSSVUydG9hRkp0YUZkWlZFWmhZVVpzVmxkdVRrOWlSWEF3V2tWa01GWXlTa1pqUkZwWVZteGFjbGxxU2t0VFJrNXpZa2RvVTJKWGFGbFdSbHBoWkRGYVIxWnVSbFJpUlhCelZXMTRTMlZXWkhKYVJ6bFZZWHBHZWxVeU1EVldNVm8yVVdwU1YxWkZXbWhWYWtwTFUxWk9jMXBHWkZOV2JrSTJWakZrTUZsV1dYZE9WbVJxVW14d2FGVnJWa3RYUmxKV1ZXdGtXRkp0ZEROV1YzUnJWakpLUjJKRVdsZFNNMEpVVm1wS1IyTnRUa1phUjBaWFZtNUNlVmRZY0V0U01VbDRZMFZvYUZJeWFFOVdNRlpMVkd4YWNWTnFVbGROVjNoWVZrWm9jMVp0U2toVmJHUmFZbGhOZUZadGVITmpNWEJGVld4a1UySllaM2RYYTFaWFRVWmtSMU51VG1wU1JVcGhWRlZhWVZWR1duRlRhMlJQWWtWd2VsbFZXbXRoVmtsNVlVUktWMkZyU25KVmVrcFBZMnMxVjFwSGFGTmlhMHAzVmxjeE5HUXlTWGhYYms1V1lUSlNWMVJXV25OT1JtUnlZVVpPVmsxcmNFbFpWV2hEVm0xR2NrNVlXbFZpUm5Cb1dYcEdkMUpXVm5OV2F6VlhZbXRHTTFac1VrdE9SbXhZVW01T1ZHSkhhRmRaYTJSdlZteGFkV05HWkd0aVIzUTFXbFZrUjJGc1duSmpTR3hoVWxkUmQxWlVRWGhTTWs1R1pFWmthR0V5T0hkWFZsSkhWMjFXVjFkdVZsUmlSMmh3VldwT2IxZFdaRmRhUkVKYVZqQTFlbFp0TlVkVk1rVjZWVzVHVlZac2NHaFVWbHBoVTBkV1NFOVhhRmRoTW5jd1ZsUkpNV0V4V1hoWGFscFNWMGRvVjFaclZtRlZSbXcyVW0xMGExWnNTakJWYlhoUFZURmFXVkZzY0ZkaE1YQllWbFJHV21WR1VuSmFSbVJZVWpOb1VWWnRlRk5qTVdSSFZtNUdVbUp0VW5OV2JURXdUVEZaZVdWSGRGaFNNSEJYVm0xd1UxWXdNWFZSYkVKWFlXdGFURlZ0ZUd0ak1rWklVbXhPYVZacmNGSldiRkpIV1ZaVmVWUnVTbEJXYldod1ZXMXpNV05HYkZWUmJtUmFWbXh3TUZSV2FHdFdSVEZGVm10c1ZtSkhhSFpXYWtaclUwWldjazlXWkdsWFIyZDZWbXBHWVdNeVVrWk9WbHBWWWtkU1QxWnFUbTlPYkdSWFZteGtWVTFyV2toVk1qVlRZa1pLZEdWR1dsZGlXR2d6V1RKNGMxWldTbkprUjNCT1ZqRkplRmRVUW1GWlYwWlhWMnRhV0dFeWVGaFpiR2hEVkVaYWNWTnJOV3hTYmtKS1ZrZDRhMkZXU1hoVGJHeFlWak5TV0ZwRVJrOVdNV1IxVlcxd1UxWXhTbHBYVjNoaFdWWk9SMXBJU21oU2JWSllWbXBDZDFZeFdYbGxSazVZWWtkU1NsVlhlRzlXTURGWFkwZG9XazFXY0VoYVJXUlRVMGRLUms1V1pGZFNiSEJoVm0weGQxTnJNVmRVV0docFVtMVNWVmxVUm5kV1ZteHlWMjFHVjJKR2NEQmFWV2hyWVVaS2RWRnNiR0ZXVm5BeldXdGFZVlpXV25OYVIwWlRWbTVDV1ZkV1dtRlRiVlpIVkc1S2ExSnRVbGhaYkZwR1pERmtWMVZyWkZoaVZscFlWa2MxVDJGV1NYbGhSbEpWVm5wR2RsWXdXbUZTTVZwMFVtMTBUbFl4U2tsV2FrWnZZVEZzVjFOdVVsWmlSbHBYV1ZkMFlWUkdWWGRYYlhScVlrZFNlVlF4V2xkaFZrcDFVVmhvVjFadFVYZFVWVnBhWkRBeFYxcEhjRk5pVjJoYVZtMHhOR1F4VVhoalJscFlZbGhTV1ZacVFtRlRSbXhXV2toT1ZrMUVSbGRaTUZKVFZqSktTRlZVUWxoV2JWSlRXbFZhZDFKc2NFZGFSMnhvWld4YVlWWXhaRFJXTVd4WFdrWmtWMkpzU25OVmFrSmhZekZXZEdWSFJrNVNia0pIVjJ0U1EyRkdTWGRYVkVwV1lsaG9jbFl5YzNoVFIwWkZWR3hrYUdFd1dUQlhhMXBoVlRGa1dGSnJaR0ZTTW1oUFZqQldTMVJzV25STlZGSmFWbTE0V1ZaR2FITlZNa1Y1Vlcxb1ZtRnJiekJXTVZwWFkxWk9kRTlXYUdsU2JrSTBWbGN3ZUZJeFpITlhia3BxVWtWS1dGbHNhRk5qYkZsM1drVjBhazFYVW5wV01uaDNZVVV4V1ZGdE9WaFdNMEpJV1hwS1QyTXhaSFZXYlVaVFlsWktWVmRYZUdGVE1XUnpXa2hLVjJKVldtOVVWbVJUWld4WmVVNVZPV2hXYTNCSVZUSjRiMWR0U2tkVGJHaFhZVEZ3ZWxac1drdGphemxYVld4T2FWSnVRVEpXYlhCTFRrZEZlVkpzWkdGU1YxSlZWakJvUTFkR2JITlZhMXBPVW14d2VGVXllRTlXUmtwelYyNXNWMDF1YUVSV2FrcExWakZPZFZwR1pGZGxhMFkwVmxaU1FrMVhUWGhhU0ZaVFlrWktiMWxyVm5ka2JGcEhWMjEwVmsxRVJraFdNalZUVkRGYVdWVnNiRlpoYTBwWVZHeGFjMVpzWkhSUFZtaHBWbGhDU2xkV1ZtOVpWbGw0VTJ4a2FsTkhlR2hXYlRGVFYwWldjVkp1WkZSU01VcElWa2R6TVZVeFNuTmpSWFJYWWxSRmQxbFVRVEZUUmtwWllVWm9XRkl5YUZaWFYzUnJWVEpKZUZWc1ZsUmhiRXBaVlcweE5HVnNiRlpaZWxab1VtdHdNRlpYZUc5V01ERjFZVVJPV21FeGNFeFpNbk14VmpKT1IyTkdaRmRpYTBwU1ZqRmFZV0V4U1hkT1dFNVlZbXMxV1ZsclpHOVhSbEpWVW10MGFVMVdiRFJXTWpFd1ZsVXhjazFVVWxkTmFsWllWbXhrUzFJeVRrbFJiRnBvWVRGd1RWWnFRbUZaVmtsNFdraFNVMkpZVWs5WmExcDNUbXhhY1ZOVVJsWk5Wa3A2VmpKNGIxWnRTa2hoUm1SYVlURndURlV3V2xwa01XUnpWMjE0VjAxVmNFcFhhMVpoWVRGU2RGSlljRkppVlZwWVdXdGtUbVZHVmpaU2JIQnNVbTFTZUZZeWVFOWhSVEI1WVVab1dGWXphSFpaYWtwUFl6SktSVmRzVG1saVZrcFZWa1prZWsxV1RrZGFTRXBZWVhwc1dGUldWbmRsYkd0M1YyczVWMDFyY0ZaVlYzQlRWbGRGZUdOSGFHRlNWbkJvV1RKNGQxSXhWblJpUjJoc1lrWndNbFp0ZUZOUk1WbDVWVmhvV0dKck5YQlZNRlozVjFac2RFMVdUbXBXYkZvd1ZGWlNVMkpIU2tobFJtUllZVEpvY2xsVlZYaFNWa3B6WVVad1RsSnVRakpXYWtKclVtMVdSMVJ1VGxaaVIxSllWV3hXV2sxR1duUmpSWFJWVFZVMVdWWkhkR3RYUjBZMlZtMDVXbUV4Y0ROV1IzaGhaRVV4U1ZwSGVGTmhNbmQ2VmtkNGIxUXhXa2hUYmtwUFZtMVNZVmxVU2xOV1JtdDNWMnh3YTAxWVFrbFViR1EwWVZaS2RWRnNjRmhoTVZweVZXcEdhMk14WkhWVWJXeFRVbXR3V2xkV1VrdGlNVlpIV2taa1dHRXpVbkZVVm1SVFRWWldXR1ZIZEdoV2EzQjVXVEJXYjFZeFNuTlhiV2hZVm14d2NsVnRjM2hXTVZwelYyMXNWRkpWY0ZwV01XUXdXVlprY2sxV1pGaGlSMmh6Vlc1d2MySXhVbGhrUjBac1lrWldOVlJzVlRWWFJrbDNZMFZzV2xaV2NIWldNbmhoVW14a2MxcEhSbGRXYmtGNlZsUkNhMVl4VGtkVGJrNVZZWHBXV0ZSV1ZuWk5iRnB4VTJwQ1dsWXdWalJXVnpWUFYwZEtjMWRzVGxwV00yaG9WakJhVTFkRk5WZFViV2hUWWtoQ1IxWlhNVFJaVjBwSFUyNVdVbUV5VW1GV2JHUlRaR3hhVlZKc2NHeFdNRnBJV1d0YWEyRldXa2RYV0hCWFZucENORlpYTVZkU01XUjFVbXhvYVZKVVZuZFdWM0JIVXpKV1IxZHJaRmhpV0ZKWFZGZDRZV1ZzV1hsT1ZrNXBVbXR3V2xaWE1EVldNa1p5VTJwT1lWWnNjRmRhVm1SWFUxWlNjMXBGTldoTk1FcFlWbXhrTkZVeFJYaGFSV1JZWW1zMWNWVnRkRXRXTVd4WVpFZEdhRkp0ZHpKVk1uUnJWa1pKZUZkcmFGZFNNMmgyVmxSS1JtVnNSblJTYkdScFYwZG9lVmRyVWtkVGJWWklVMnRrWVZKc1NsbFZha3B2VjJ4a1dHUkhkR2xOYXpFMFZtMDFUMkZHU25KT1ZteFdZbGhvVEZZd1dscGxWVFZZWkVab1UyRXpRWGRYYTFaVFZERlplVk5zVmxOaE1taFlXVmQwUjA1R1duUk5WVGxUVFd0YVNGZHJWVEZoVjBwWVdqTnNWMkpVUWpOYVZWcEtaVlpTZFZSdFJsUlNXRUoyVmxjd01WRXlUWGhpUmxaVFltMVNWbFp0TVZOWGJHdDNWbTEwYUZKVVJubFViR2h6VmxkS1IyTklTbGRpVkVaTVZXMXpNVll5UmtkWGJXeFlVakprTmxadGNFdE9SbXhZVld0YVRsWlhlRzlWYkZKelZrWnNjbHBFVGs1U2JWSlpXa1ZrUjJGRk1WZFdhbEpZWVRGYWRsbFZXa3RrUjBaSVVteHdhVkl5YUZCWGJGWmhXVmRTU0ZacmJGVmlSMmhVVkZaYWQxTkdaSEpXYlVaYVZteEtlbFl4YUhkaFJrcEhWMnhvV21KR1NrUlVhMXBYWTFaS2MyTkhkRTVTUlZwWlZqSjBZV0l5UmtoU1dHUnFVbnBzV0ZacVRtOWpiR3h4VTJzNWFrMVhVakZXUjNodllWWmFWMk5JYUZoV00yaFhWRlphVDFJeGNFbFRiR2hwVjBaS1YxZFhlRmRrTWxaelZsaHNiRkpYVWxoVVYzUjNWbXhXYzFWclRsaFNiSEF3Vmxkek5WbFdXbGRqUkU1V1RWWndVRmw2Umtkak1YQklZa2RvVGxORlJYbFdiWEJIV1ZaVmVGTlliRlpYUjJoV1dXdGtVMWRXYkhSbFJYUlZUVlp3ZVZZeWREQldNVnB6VTJ4c1drMHpRa2haYTJSTFVqSk9SbUpHVm1sU2JGVjRWbTF3UjFOdFVYbFVhMlJxVW01Q1dGWnROVU5PYkZwMFRVaG9VMDFyTlRCV1IzUnpWMGRLUjJOSVFsWmlWRlpFV1dwR2ExZFhUa1phUjJoT1lrVndTVlpVU1RGVU1XeFhVMnhXVjJKSGFGaFpWM014WTFad1JWSnRSbXBOVmxwNVdrVlZNVlV5U2xsaFJuQlhWa1Z2ZDFsVVJtRlRSazV5WVVaYWFXRXhjRmhYVjNodllqRlNSMXBHWkZoaVZWcHhXV3RhZDJWV2NFWldWRVpWWWtad01WVlhjRmRXTWtaeVlrUlNWbUZyY0VoYVJWcFBZMnh3U0dOR1RsTldXRUpaVmpGa05HSXlTWGhXYTJSWVltdGFWVmxVVGxOV1JteHlXa1pPVjJKR1ZqVmFWV00xVmpBeFZtTkdaRnBOUm5CWVZtcEdZV014VG5KaFJtaFhZa2hDZVZaWGNFZFZNbEpYVkc1T2FGSXllRlJVVnpGdlRURmFjMXBJWkZOTlZURTBWMnRXYTFsV1NuUmhTRTVXWW01Q2VsWnFSbE5XYkZaeVZHczVVMkpIZHpGWGExWnJUVVprUjFOWVpGZGhiSEJZVm1wT2IyUnNXWGxOVlZwc1ZteGFlbFpYTVVkV01rcEpVVzA1VjFaRlNuSldha1pQVWpGT2RWUnRSbE5XUmxwMlZrWlNRMU14VG5OWFdHaFdZVEExVjFSV1duTk9SbVJ5Vm0xMFdsWnJjRmxhVlZwUFYyeGFSbU5JV2xkTlJuQm9XVEo0WVdSR1NuUmhSazVwVjBkT05WWnNZM2hsYXpWWVVsaG9XR0pyY0ZCV01HaERWMFphZFdORlpHeGlSbkJXVlcweFIxVXdNVmhWYm5CYVlURndjbGxWVlhoWFZrWnpWbXhrV0ZORlNrMVdWRWw0VmpGSmVGVnVWbFJpVlZwVVdXeGtiMlF4V2xoalJXUlVUVmRTZWxkcldtOWhNVWw2Vld4a1ZWWnNjRE5hVjNoaFYwZFdTR1JHYUZOTlNFSktWbXhrZWs1V1dsZFhibEpvVWxaS1dGbFhkR0ZoUm5CR1ZsaG9WMkpJUWtoWGEyUnZZa2RGZUdKNlJsZGlWRUkwV2tSR1VtVkdjRWxUYXpWWFZqRktlRlpYTVRCVE1XUkhZa1pvYTFOSFVsWlZiWGhYVFRGWmVXVkhkR2hpUm5Bd1ZsYzFkMVl5U2xsaFNFcFhWa1ZhYUZwR1drZGtWbVJ6V2tkc1YxSldWak5XYWtaaFdWWk9kRlpzWkZaaWJGcFdXV3hvUTFaR1duRlNhM1JYWWtkU1dWcFZaREJVTVVwelkwVm9WMDFxVmxSV1IzaGhVbXhPYzFGc1dtbFhSMmcyVmtkNFlXUXhXbk5hU0ZKclVtMVNUMVZyVm1GWFJscEhWMnhPVmsxV2JEVlZNbmhYVmpKS1JsTnNhRlZXVjFKVVZrVmFWMk5XVG5KUFZrNU9ZVE5DU1ZkVVFtRmlNVnBIVTJ4YWFsSllRbGhaYkZKRFRrWlNjbGRzY0d4V2JFcGFXVlZrUjFaR1NuTmpSemxYVm5wRk1GcEVSbUZTTWtwSlUyeG9hV0pXU2xwWFYzUnJWVEpXYzFkdVVteFNNMUp2Vld4U1IxZEdiSEpWYkdSWFlYcEdNVmxWWkc5V01rWnlZMFZvV21WcmNGQlZha3BIVWpGa2RHRkhhR3hpUm13MVZtMHhNRll4YkZkaVJtaFZZa2RTVlZsdGVFdFdSbXh5V2taT1ZVMVhlRnBaTUZwclZrWktjMk5JY0ZoaE1VcFVXVlZWZUZZeVNrVldiRnBPWW0xb01sZFdWbUZUTVVsNVZHdGthRkpzY0c5WldIQlhWbFprVjFadFJsZE5helZZVmtjMVMxUXhXWHBoUmxKYVYwaENWMXBWV21GamJIQkZWVzFzVG1FeGNGbFdWRW8wVmpGWmVWTnVUbXBTYldoWFdXeG9iMDB4V1hkWGJtUlRWbXR3ZWxVeU1UUlZNa3BYVTJwYVdGWnNXbkpVYTFwV1pWWk9jMXBHVW1sV01taFpWMWQ0VTFKdFVYaFhia1pTVmtWYVZGUldaRk5OVmxwWVRWUlNWazFyY0ZoVk1uaHpWakZaZWxGclVtRlNSVnBvV1hwS1MxTldUbk5oUjJoc1lsaG9XbFp0TUhoT1IxRjRXa1ZrVjFkSGVGQldha0poVjBaYWNWRnNaRTlTYlhReldWVldNRmRIUmpaU2FrWmFWbGRTZGxZeWMzaGpWa3B6Vld4YWFHRXhjSGxYYTFaclV6RkplRlZ1VW1sU01taFBWVEJXUzFsV1duUk5XR1JUVFZkNFdGWXhhSE5XUm1SSVpVWmtWMDFIVW5aV01WcHpaRWRPTmxKc2FGZGlXR2QzVjFST2QxSXhaRWRYYmxKc1VteHdWMVJYY0VKTlZscHhVVmhvVjAxck5VcFpWVnByVlRKV2NsSllhRmRpV0VKSVZYcEtUbVZXVW5KaVIyeFRZbGRvZGxaR1dtOVJNbFpYVjI1T1ZtRXpVbFZVVmxaM1pWWlNjMWR1VG1oaVJYQjZXVEJWTlZkdFNsVlNibHBoVm14d2FGcEZaRTlTYkhCSFkwWmtUbFpZUWxwV2JHTjNUVlpOZUdKR1pGUmliRXBYV1d4U2MxWnNXblJsU0dST1RWWnNORll5TVVkaE1VbDNUbFZrV0dFeGNGUlpWbHBoWXpKT1JtSkdaRmRTVjNRMFZtMXdSMWxXWkVkVWJrcFlZWHBzV0Zsc2FHOVhSbVJYV2tod1RsWXhTbnBaTUZwdllrWkpkMWRzYkZaaGExcG9WVEJhV21WWFRqWlNiR1JPWVROQ1NGZFVRbE5aVmxsNVUyeFdVbGRIYUZoVmExWmhXVlp3VjFkck9XcE5WMUo2V1ZWa2MxVXhXa2RYYkdoWFlsUkNORlJyWkZKbFZrcHlXa1pvV0ZJeFNscFhWM2hYV1ZkT2MxWnVUbFpoTWxKWldXdGtVMlZXWkhKWmVsWm9VbXRzTkZZeU5YTldNREYxWVVoYVYyRnJjRWhaTWpGTFRteEdjMk5HWkZOV2JrSjJWakowVjFsV1VYbFVXR3hVWVRKU1dWbHNaRFJYUmxKWVRWYzVXR0pHY0RCVVZsSkRWakF4V0dWR2FGZFdNMUp5Vm1wR2ExTkhSa2RpUm5Cb1RWWldORlpxUW1GWlYxSklWbXRhYTFJemFIQlZiVFZDWkRGYVIxZHNUbFpOYTFwSVZUSjRWMVV5U2tsUmJHUlhZV3MxZGxaRldtRmpWazV5WkVaT1RtRjZWa3RXVkVvMFZqSkdSazFXYkZKaE0yaFpXV3RhWVdGR2JGVlRiRTVYVFZaS01WWkhlRXRoVmtsNFUyeHNWMUpzU2t4WmFrWnJVakZrV1dGSFJsTlNWWEJaVmtaa05GSXdOVWRhU0VwWFlsaFNXVlZxUW5kbFZsSnpWMjVPV0dKVmNGWlZiWGhUVmpKRmVHTkdhR0ZTVjFKWVZURmFkMU5IVmtkYVIyeFRUVEpPTkZacVJsTlVNbEY0VjFob1dHSkdjRTlXYlhoM1kxWlZkMkZGVGxoU2JFcFpWR3hhVDJFeVNrZGpSRUpWVm14WmQxWXdXbHBrTVdSeVlrWndWMVp1UW5sV2JYQkhVekZrVjFKdVNtaFNiV2h3VlcxNGQySXhXbkpWYTNSVlRXczFlVlJzV210WlZrcDBZVWhDVjJGck5YWldiRnByVjBkU1NFOVdTazVpUlhBMlZtcEpNVlF4WkVoVGExcFBWbXhLVmxadGVIZGxiRkp5VjJ4d2JGSXdXa2xVTVZwdlZUQXhTVkZyY0ZoaVJscHlXV3BHWVdSR1NuVlRhemxYVm10d1dWWlhkRmRaVjBaSFkwVmFZVkpyTlZSVVYzTXhVMVp3VmxwSVRsWk5hM0I1VlRJeFIxWXlSWGhqUjJoWFZrVmFSMXBWV210amJHUnlUbFprYVZacmNHRldNVnByVFVaTmVGcEZaR2xUUlRWdlZXNXdjMk14YkhKYVJGSlhUVlpzTlZwRlVrTlhSa3B5WTBod1YwMXFWak5XTUdSR1pVZE9TVk5zY0ZkaVNFSjVWbFJDYTFJeFRrWlBWbVJoVW0xU1ZGWnNhRU5rYkZwMFRWaGtWRTFXVmpSV1IzUnJWakpLY21OR2FGcGhNWEF6V1RCYVYyTXhWbk5hUjNST1ZtNUNXbGRzVm1wT1ZsWnlUVlZXVjJKSGFGaFVWelZ2VjBaYWNscEZaR3BOVlRWNlZtMTRWMVl5U2tsUmFscFhVak5TYUZZeU1WZFRSa3B5WWtkR1UySldTbmRXYlhoaFpEQTFjMXBHVmxKaVZWcHdWRlprVTJWc1dYbGtSMFpZVWpCYWVWUnNXbTlXVmxwWFkwUk9WMDFHY0hsYVZWcHJZMjFTU0dOSGJGUlNWWEJMVmpGU1ExWnJNVmRYV0doWVlUSlNXVlpyVm5kWFJteHpZVWM1YWxadVFsZFdiRkpIVlRBeFYyTkdjRnBXVm5CMldWWmFTbVZ0UmtkVmJHaFhUVEZLYjFaWWNFZGhNVWw1VTJ0c1ZXSlhhRlJhVnpFMFYyeGFXRTFJYUZaTlYxSklWakZvYzJGdFZuSlhia0pXWWxoU00xcFhlRnBsVlRWWlZHeGtUbEpGV1hoWFZsWnZVekZaZDAxVlpHcFNXRkpvVm0weFUxTkdWbkZTYkdScVRXdGFTRmRyVlRGVWJGcFpVVzFHVjJKWVFraFhWbHB6VmpGd1NWVnNaR2hOYkVwdlZsUkNZVmxXV25OaVNFNWhVbnBzV0ZWdGVIZGxWbVJ5Vld4T1dGSnJjREJXVjNoeldWWktXRlZyYUZwV1JVWTBWbXBLUzFKV1ZuTmFSVFZYVFcxbk1sWXhXbE5TTVUxNFYyeG9WR0V5VW05VmJUVkRWMVpWZDFacmRGTldiSEJKV2xWa1IyRXdNVlpPVm14WFVqTlNhRlpzWkV0VFJsWnlUMVprYVZaR1drVldha1poWVRGYVYxSnVUbUZTTW5oUFZtMHhNMDFXV2xWVGFsSnFUV3RhU0ZVeWVITmhSa2wzVjJ4YVYySnVRbGhhUjNoeVpWZFdTVk50ZUZkTlJFVXlWMVpXWVdFeFVuTlhia3BxVWtad1dGUlhOVk5oUm14VlUydGtXRkpyY0ZwWGEyUjNWVEZaZUZOc2JGaFdNMmhVVlcxemVGSXhjRWRhUm1ocFlYcFdXVlpHV210Vk1XUnpZa1phV0dKVldtOVdha0ozVWpGcmQxZHRkRmROYTFwNVZUSTFTMWR0Um5KWGJXaFdZV3R3VEZVeFdrOWpNa1pJWWtkc1YyRXpRbUZXYlhocVpESldSazVWWkZoaWF6VllXV3RrYjFWR1duRlViRTVZVW14S1dGWnROV3RpUjBwSVpFUk9WMDFxUmtoV2FrRjRWbTFLTmxOc1dsZGlSWEJKVm0xd1IxZHRWbk5WYmtaV1lrZFNiMWxVUm5kbFZtUlpZMFYwVTAxVmJEUlpNRlp2WVZaS2RHRkdVbHBXUlRWRFZGWmFZV1JGTVZWVmJGcE9WbGQzTUZacldtOWlNV3hYVTI1U2FGSnNTbUZXYTFaaFRURnNWbGRzWkd0U01WcEtWMnRrZDFVeVNraGtNM0JYWVd0dmQxUlZXbUZXTVdSMVZHMXdWRk5GU2xwWFZsSkhVekZhUjFkWWJHeFNNRnB4VkZkek1WTnNiSEpYYkdSWFRXdHdTbFZYY0dGWFJscDBWVlJDVm1WcmNFOWFWbHBUWTJ4d1NHRkdUbWxoTUhBeVZtdGFZV0l4Um5SV2JrNVlZa1phVkZsc1ZtRlpWbHAwVFZaT1ZGWnNjRmxhUldNMVlVVXhWbU5JYkZWaVJsVXhWako0YTFOV1JuTmhSbFpwVjBkb2IxZHJWbFpsUmxwWFZtNVNhbEpVVmxoWmJYUkxXVlphYzFWcmRFNVNiWGhaVlcwMVQxWkhTbk5UYlRsV1lsUkdkbGRXV25OV1ZrcDFXa1UxVGxacmNGZFdWekUwWVRKR2RGTnJhRlpoYTBwWFdXeG9iMk5zV2toTlZWcHNVakExUjFwRldtdFViVXB6VTI1c1YxSXpVbkpWYWtaUFVqRmtkVlpzVm1sU2EzQmFWbFJDVjFNeFpGZFhiR2hyVW0xU1ZWUlhlRXRsYkd4eVYyeGtWazFyY0VoWk1HaFBWakpLV1ZWcVRsZE5ibWh5V1RKNGQxTldjRWRYYXpWb1RUQktTVll4VWtOWlYwMTRXa1ZrV0ZkSVFsZFpiR1J2WVVaV2NsWnRSbFpTYkZwNFZUSnpOVlV3TVhKWGEyeGhWbFp3VUZaSGVFdGtWa1p6WTBaa2FWWkZTVEJXUmxaaFl6RmtSMWR1VG1GU01GcFZWV3hvUTFkc1pGZFZhemxXVFd0c05GWXlOVk5oTVU1SVZXNU9XbUV5VVRCV2JYaGhVMFV4UlZac2FGTmhNbmQ2VjFSQ1YySXhXWGROV0Zab1UwWndXRmxzVWtkWFJtdDVaVWQwYWsxcldraFpNR1EwWVVVeFdWRnFWbGROVjJnelZXcEtSbVZXVWxsaVJrNW9UVzFvZDFaWE1IaFZNVnBIVld4V1ZHSlViRmxXYlhoM1RVWndWbHBFUWxWTlZXd3pWbTF3VTFZeVNraGhTRnBYWVd0d1IxcFdXbGRqTWtaSFkwZG9UbUpGYjNsV01XaDNVakZaZVZSWWFHcFNWMUpXV1d0a2IxWkdiSE5oUnpsUFZteHdlRlV5Y0VOVWJFcDBWV3RzVmsxdVVuSlpWM2hMVjBkV1NHRkdaR2xTYmtKb1YydFNSMWxYVGxkU2JHeG9VbTFTVDFsWWNGZFRWbVJYVm0xR2EwMVdTbnBWTWpWUFlXeEtjMWRzYUZwaVIyaEVWa1ZhVjJSRk1WZGFSbWhUWVROQ05WZFhkR3RrTVZWNVUydGthbE5HY0ZoVmJYaDNaR3hXVlZOcmNHeFNiVko2V1ZWa2QxVXhXWGhUYkZwWFVtMVNObHBWVlRGU01YQkpVMjFvVTFaSGVGbFdiWEJEWkRGa1YySkdXbGRXUmxwWVZGVlNSMU5HV1hsa1JGSlhUVlp3V0Zrd1pHOVhiVlp5VjJwT1ZtSkdjRmhaZWtaM1VtczFWMXBGTlU1aVYyaG9WbTB4TkdFd05VaFRXR3hVVjBkb1dWWXdaRFJXVm14VlUyMDVWMDFYZUhsWGEyTTFWMFpLZEdWR1dsWmlWRlp5Vm14YVMyTXlUa2RhUm1ST1ltMW9VVlp0Y0VKbFJtUkhWbTVXYVZJd1dsUldiVFZEWlZaYWNscEVVbHBXTURFMVZURm9kMWxXU25SaFJ6bFZWbXh3TTFscVJtRmpiRlp5WkVaT1RsWlhkekJXYTJRMFl6RnNWMU51VWxaaVZHeGhWakJvUTFkR1duRlNiVVpyVWxSR1NsbFZaSE5VYkVwR1UxUkNWMkZyYTNoV1ZFcExVakZPV1ZwR2FHbGhNWEJYVm0wd2VGVXhXa2RqUm1SWVltczFXRmxyWkZOTlJsWjBaVWQwVldKRmNFZFZNVkpIVjBaYWMxZHRhRmRoYTFwaFdsVmFUMWRYVGtoaFJsSlRWMFZLV2xZeFdtdE5SbXhYVkZob2FsSnNjRmxaYTFVeFkyeGFkR1ZGZEd4aVJuQlpWRlpvVDFack1VVlNiR1JhVFVad00xWnFTa3RXVmtaeFZHeFdWMkpJUWtoWGJGWmhWREZrV0ZKclpHaFNNbmh2VkZSQ1MxZHNXWGhhUkVKb1RWWldORmRyVm10V2JVcElWV3hvV21KWVRYaFdWVnBYWkVkV1NGSnJOVk5pUlhBMlZtMTRVMVl4V1hsU2FscFRZbTE0WVZSVldtRmtiRmw1WXpOb1UwMVdjRlpWYlhocllWWmtSazVFUWxkV00wSklWMVphYTFkR1NuSmFSMFpUVmtaYVZWZFhNVEJUTVZwelYyNVNUbE5IYUZCVmJURTBWMVphV0dSSGRGZFNNSEI1Vkd4YVYxZHNaRWxSYkdoWFRVWndlbGt5ZUd0a1ZrNTBaVVprYVZJelkzZFdha293VlRGRmVGZHVTazVXYlZKWVdWZDRTMWRHYkhOVmJHUlhVbXh3ZVZkclZtRmlSa2wzVGxWb1dtRXhjRE5aVlZWNFl6Rk9jMVpzWkdsWFJVcEpWMWh3UzFSdFZsZFRia3BoVW14YWNGVnFSa3RXVm1SWVpFYzVVazFYVWtoV01qVlRZa1pLTm1KSVFsVldiVkpVVlRCYVZtVkhSa2hQVm1oVFRVWlpNVlpzWkRSaU1WcDBVbTVLVDFkR2NHRldiRnAzWVVacmVGZHJkR3BpVmtwSVdWVmFhMkZGTVZsUlZFcFhZbGhvY2xSclpFcGxSbkJHV2taV2FFMVlRbFpYVmxKTFRrWmtSMWR1UmxWaE1EVlZWVzB4VTFkR1pISldWRVpwVW10d2VsVXljRWRXTWtwWllVWlNXbFpzY0V4Wk1qRlBVMVp3UjFwR1pHeGhNVmw2VmpKMFUxSXlSWGhUV0doaFUwVndhRlZ0ZUhkaU1WSlZVbXQwYTAxV2NFaFdNakZIVmtVeGMxZHVjRmROVjJoNldXdGFTbVZzVm5OaVJscG9ZVEJ2ZWxaVVJtRlpWbVJJVm10b2ExSnRVbGhaYTJoQ1pERmFjMXBFVWxaTlYzaFlWakkxVDJGc1NrWk9WbWhhWWtkb2RsbFZXbmRTYkdSeVpFZHdUbFl4U2pWV1IzaHJZakZTYzFkdVVtdGxhM0JZV1ZkMFlWWkdWbFZTYms1WFRWWmFXbGxWV205aFZrbDRVMnh3V0Zac1NraGFSRXBQVmpGYVdWcEdhR2xpVmtwWlZrWmFhMDVHV25OV2JsSlBWak5TV0ZSV1ZuZGxiRmw1WTBWT1dsWnNjRmxXVjNSdlYyeGFObEpyZUZaTlZuQklXVEl4UjFJeFpISk9WMmhvVFZjNGVWWnRNVFJWTVVsNFlrWm9WbUpIVWxSWmJYTXhZMFpXZEUxV1RtbE5Wa3BZVm0wMWExVXhXblJWYkd4YVRVWmFjbFp0TVV0V01XUnlZVVprVG1Gc1dsbFdiWGhyVXpGT1NGSnJiRkppUm5Cd1ZtdGFZVkpXV25GVGFsSm9UVlpzTkZadE5VdFdSMFkyVm14b1dtSkdjRXhWTVZwaFpFVXhSVkpzV2s1aE1XOTNWbTB3TVZNeFdraFNhbHBwVW0xU1lWbHJaRzlrYkd4V1YyeHdiRkp0VWpGWGExcHJZVlpLZFZGWVpGaGhNVnBvV1ZSR1UyUkdTbGxqUmtwb1RXMW9XbFp0ZEZkVE1sSnpZMFZXVTJKVlduRlVWbVJUVjJ4cmQxZHNaR2hTTUhCSFdUQmFjMVl5U2xsVmJHaFlWbTFTU0ZWcVJtdGtWa3B6Vlcxb2JHSllhRlpXTVdRd1dWWnNXRlp1VG1GVFJYQlpXV3hvVTJJeFduUmpla1pUVFZaV05WcFZhR3RXTURGeVkwWndWMVo2VmtoWFZscGhWakpPUjFWdFJsTldia0p2VjFSS05HUXhTWGhXYmxKcFVqSm9jMWxyV25kaFJscHhVbTEwVGxKc2NIbFVWbHB2Vmtaa1NHRkdaRnBoTVhBeldXcEdWMk14V2xWU2JHaFRZa1p2ZDFaR1dtRlVNa3BJVTJ0a2FWSkdXbFpXYkZwTFYwWnNWbGR0UmxkV2EzQjZWMnRhYTJGV1pFWlRiRlpYWWxoQ1RGVjZSbXRYUmtweVlrWlNhVkl4U25aWFZsSlBVVEZPVjFkcmFFNVRSMmhWVkZaV2QyVldVWGhYYlhSb1lrVnNOVmxWVlRWV01rcFZWbXRTWVZJemFHRmFWbVJYVWpGd1IyTkdaRTVXVm10M1ZteFNTazFXVVhsU2JrNVVZa2RvYjFWdGRHRlhSbXh6WVVjNVRrMVhkRE5XTW5ocllURktWVlpzWkZkU00yaDJWbFJLUzFOV1JuRlZiR1JYVWxoQmVsWnNVa3RTTVVweVRWWmtZVkl6UWxSWmJHUnZWMFphUjFsNlJtbE5helY2VmpGb2ExbFdTbGRqU0U1WFlXdEthRlV3V210amJHUjBaRWRvVTAxR2EzbFdiVEYzVXpGWmVGZHJXbFJpVjJoWlZtMHhVMVpHVlhkWGJFNXFWbTFTZWxkclpITlZNa1Y2VVd4d1YwMVhVWGRXYWtwU1pEQTFXVlJzYUdsaE1YQldWMVprTkZNeVNYaFZiR1JZWW1zMVVGVnRlSE5PVmxKelYyMTBWMkpWY0ZkV2JYQlRWakF4ZFdGSVdsZE5ha1pIV2xWa1QxSldVblJTYkU1T1RXMW5NbFpyWTNoT1JrbDRWMnhrVkdKck5WWlpXSEJYVjBaWmQxWnJaRTlTYkhBd1drVmtNRlF4U25OU2FsWldZbGhvY2xaclpFdGpNV1J6Vkd4d2FFMVlRbTlXYWtaaFdWZFNTRlpyV210U2JFcFVXV3RhY21WV1dsaE5WRkpWVFd0YWVWUldXbXRoYkVwR1YyeG9WbUZyTlhaWk1uaHpWakZrZEZKc1pFNWhlbFpKVm14a05HRXhWWGxUYTJ4U1lsUnNXRlJXV25kaFJteFZVbXR3YkZKdVFrcFdiWGhoWVZaa1JsTnVjRmhXYkVwSVdrUktVMk14Y0VkYVIyaFVVakZLVlZaR1dtRmpNRFZIWWtoS2FGSllVbGhaYkZaYVRXeHNjbGR0T1ZoaVZYQklWakp3VDFZd01YVmhSMmhYVFVkU1ZGVnNXbGRqTVhCR1RsWmthVlpIWnpGV2JYaHFaVVUxU0ZOWWFGaFhSMUpQVm0weGIxWXhiRlZUYlRsWFRWZDRlbGxWWXpWV01VcDBaSHBLVm1KVVJYZFpWM040VjFaR2NtSkdjR2hOV0VKUlYxWmFhMUp0VVhsVWExcHNVbTFTY0ZaclZrcE5SbHBIVm0xR1dHSldXa2hYYTFweldWWktWV0pHYUZkaGExcE1WbTE0WVdOV1JuUmtSMnhPVm01Q1dWZFhkRzlWTWtWNFZHdG9WbUpIYUZoWmJGSkdUVVp3VjFkdFJtdFNWRlpaV2tWYWIxVXlSWHBSYWxwWVZrVktkbGxxUm1Gak1XUjFWR3hTYUUxdGFGbFdWM1JYWkRGU1IxWnVSbFJoZW14VVZGZDBZVk5HWkhKV1ZFWm9WakJ3V1ZsVlVsZFdNa3BaWVVaU1ZsWjZSbGhWYWtaclpGWlNkRkpzVWxOaVNFSTBWbXhqZDJWR1ZYaGFSV1JXWWtaYVUxbFVUbE5YVmxwMFRWWk9XRlp1UWtkWGExWnJWakZLVlZKdWJGVmlSa3BFVm1wR1NtVnNWblZUYkdScFVqRktUVlpVUW1GV01sSlhVbTVPV0dKWGVGbFZha3ByVG14WmVGcElaRk5OVjNoWVYydFdiMVl5UlhsaFJsSmFZVEZ3TTFaRVJtRmpNa1pHVkdzNWFWSnVRalJXVkVaVFVqRmFSazFXYUd4U2JXaFhWRmR3VjFSR2JGaGxSVGxUWWtVMWVsZHJXbmRoUlRGWlVWaHdWMUpzU2toV01qRlNaVVp3U1ZWdGRGTmlWa3BaVjFkMFYyUnRWa2RYV0d4clVqTlNjRlJXV2t0bGJGbDRZVWM1VjFJd1ducFdNbmh2Vm0xS1dXRkVUbGROUm5CeVZtcEdhMlJIVWtkVmJFNW9UVEJLYUZZeFdsZFpWMGw1VW14a1ZHSnNXbE5aYTJSdlYxWmFkR1ZGZEZSU2JWSllWako0VDFVd01WZGpTR2hYVFc1b1VGbFdaRWRPYkZwelVteG9WMDB4U2xsWGExSkxWakZaZUZwR2JHbFNWRlpZVld4V2QxWXhaRmhrUjBaclRWZFNlbFp0ZUc5aGJFcDBWV3hvVlZZelVqTldiWGhYWXpGV2NsUnNaRTVoTVhBMVZtcEtOR0l4WkhKTldGWlZZV3hLVjFSV1pGTlVSbFYzV2tWa1UwMVdTbnBYYTJSdlZHc3hSbU5IYUZkaVZFSXpXa1JLVjFKck5WWmhSbHBZVWpKb2IxWlhlR3RWTVdSSFlraFNhMUl3V2xoV2JURTBaVlprY2xkck9XaGlSbkI2VlRKNGIxWXlTbFZXYmtwYVlURndURmw2U2s5U1ZrWnpWbXhrYVZKWVFsWldiVEI0WlcxV1IxZFliRlZoTWxKeFZXMTRkMWRHVWxWVGJUbFhWbXh3TUZrd1ZqQldSVEZZVld4c1ZtSllVbkpYVmxwS1pERmtjMkZHWkdsWFIyaFpWa2QwWVdFeFpGaFVhMXBoVW01Q1dGUlZVa1pOVmxwVlUycENhVTFyV2xoVk1qVkxWREZhYzFOdFJsZGhNVlY0Vld0YVlXTXhaSE5qUjNoVFltdEtSMVpXWkRSaE1WSnpWMWh3YUZKdGVGaFpWM1JoWkd4c2NWSnNjR3hXYXpVeFZrZDRVMkZYUmpaV2JHaFlWak5TYUZadE1WZFNNV1IxVlcxNFUwMUdjSGxXVjNCSFV6Rk9jMXBJU2xoaVdGSldXV3RhZDAxR2NFbGpSV1JZVWpCV05GWXllR3RXVjBwSFkwZEdZVlpzY0ZCWk1uaDNVMGRPUjFWc1VsTldXRUpoVm0xMFlXRXlVWGhYV0d4WFltczFXVll3WkRSVU1WcDBUVlpPYWxadGVIbFhhMXBQWWtaYWRHVkdaRmROYWtWM1dWVmFZV1JHVm5KaVJuQlhWbXhaTUZacVFtRlpWa3AwVTJwYVVtSkhVbFJWYkdoRFZVWmtjMVp0Um1oTmJFcFlWbTAxVTJKR1NuSk9XRUpYWVd0d2RsWnRlR0ZqYkdSMFkwZDRVMDFIZHpCV1ZFa3hWREZrU0ZOdVRsUmlhelZYV1ZkMFMyRkdaRmRYYlVaclVqRmFTbFpIY3pWVk1rcEhWMVJDV0Zac1duRlViRnBhWlVaT1dWcEdaR2hpUlhCb1ZrWldhMkl4VmtkWGJsSk9WbGhTVkZSWGN6RlNiRnBJWlVkMGFGSlVSbHBWVjNCaFZqSktXV0ZIYUZaaGEzQlVWbXBLVDFKc2NFZGhSMmhzWWtad1dsWXhZM2hOUms1eVRWaE9XR0pzU2s5V2ExcExZMFpTV0dSSVRrOVdiRlkxV2tWak5WWXhTWGRXYWxaWFZqTm9lbFl5TVVabFZsWjFWMnhrVGxKdVFqWlhXSEJMVWpGSmVGVnVVbXBTTW5oVVdXMTBTMWRHV25OWk0yaE9VakZHTlZWc2FHdFViRnBYVjJ4b1dtRXlhRVJYVmxwelZsWktkVnBIYUZOaVNFSktWMnhXYTFJeVJuUlRiRnBQVmxoQ1lWbFVSbmRqYkd4V1drVmFiRlpVYkVwWGExcHJWR3hhZFZGdE9WZE5WbkJ5VmtjeFYxTkdVbkpYYld4VFlrVndkMVpYTVRSa01sRjRWMnhvYWxKWFVsVlVWM2hIVGtaWmVXVkhPV2xTYTNCNVZHeGFhMWR0U2tkalJXaFZZVEZ3WVZwV1pGZFRSMUpIWTBaa2FFMHdTa3BXYkZKTFRrWlZlRmRzWkZoaWF6VnhWV3RWTVdGR1duRlViVGxYVFZoQ1dGWnNVa2RXTWtZMllrWm9WMDFxUm5wV2FrWmhaRWRTUlZac1pHbFNNRFF3VmtkMFlWWnRWa2RqUld4VllrZG9iMVJXYUVOWGJHUlhXa2h3VGxac2JEUlphMXBYVlRKS2RGVnRPVlppV0dneldsVmFWMlJGTVZWUmJXaG9aV3RhWVZaV1pEQmlNVmw1VTJ4V1UySnVRbGhaVjNSaFlVWldkR1ZIUmxoV2JrSklWMnRrYzFVd01VVlZXR1JYWVRKUmQxZFdaRTVsUm1SWllVWm9hVkl6YUhkV1Z6RjZUVlprVjFadVJsTmhNMUp6VlcxNGQxZFdVbGRoU0dSVllrWnNNMVl5ZEc5V01ERnhWbXhTVjFJemFHaFViVEZMVTFaT2MyTkhhRTVYUlVwMlZtMHdlRTVHV1hsVmEyaFhZVEpvY2xWdE1WTlVNVlp5Vm0xR1dGWnRVbFpWVnpBMVlXc3hXRlZyYkZaaVIyaDJXVmQ0UzJOc1RuTmhSbVJvVFZad2IxZFVTalJXYlZGNFkwVmFZVkpyTlhCV2JGcDNVMVpaZVdSR1drNVdNRnBaVlRKMFlXRnNTblZSYkdoYVlUSlNkbFJVUmxkalZrcHpZMGQ0VjJKRmNHRlhWbFpyVWpGYVIxTnNWbGRpU0VKWlZtMHhiMDB4V25GU2JYUlhUVlp3V2xkcldtdGhSVEI0VTJ4d1YxWjZSVEJhUkVGNFVqRldjMXBHV21sU1ZGWmFWMWQwWVdReVZsZFZiazVYWWxSc1dGUlhkSGRYYkd4V1lVZEdXR0pWVmpSWk1GWTBWakpLU0ZWcmVGWmhhMXBJV1hwR2QxTkhSa2hoUlRWWVVsVnZlVlp0TVRSVk1VVjRZa1prWVZOR1NsaFphMlJ2VjBac1ZWSnVaR3BpUmxvd1ZGWmFUMVpWTVZkalJFSlZZa1phVUZZd1dtRmtSbFp6VjJ4YVYwMHlhRzlXYTJRMFdWZE5lVk5yVmxaaVJuQlBXVzB4YjJWV1duRlJiWFJVVFZVMVNWVnRkR3RaVmtwMVVXeG9WVlpGV2t4WmFrWmhWbFpHZEZKdGNFNVNSbG8yVmxSSk1WTXlSWGhUV0hCU1lYcHNXRmxYZEdGVVJsSjBaVWRHVjAxWVFrWldWM2hoVkd4YWMxZFVRbGRoYTI5M1dWUkdhMU5HVG5KaFIzaFRZbGRvYUZkWGRHRlRNVWw0Vld4YVdHSlZXbkZXYlhSM1RWWmFTR1ZIZEZWaVJuQmFWVmN4UjFkR1duTlhiV2hhVmtWd1NGWnFSazlYVjA1SVlVWlNVMDFWY0ZwV2JURjNWREZWZVZKclpGZGhiSEJVV1d0YWQyTXhWbkZSYm1SVVlrWldOVnBWWkRCaFJscHpZMFpvV2sxR2NIcFdha1pMWXpKT1NHRkdhRmRpUmxrd1ZsZHdTMVF4U25OYVNFNVlZbGQ0VkZacldtRlhiRmw0V2tSQ1YwMXNSalJXTWpWUFZqSktjMU51VGxaTlJsVjRWMVphWVdSSFZrbGFSbWhUWWtkM01WZHNWbGRVTVZsM1RWaEthbEp1UW1GV2JHUlRaR3hhZEUxVmRGZFdhM0I1VjJ0a1IxWXlWbkpYYTJ4WFZqTkNTRmxVU2xOVFJrcHlWMnM1VjJKV1NuZFdha0poVWpBMWMxZHVVazVXUmtwdldXeGFZVkl4VW5OV2JYUlhWbTFTU1ZwVldtRlhiVXBaVkZob1YySllhSHBhUldSUFRteEtjMXBHWkdsWFIyY3hWbXBLTUZsV1VYaGFSV1JVWW1zMVZWbHJXbmRXTVd4ellVWk9UazFXY0VsVVZsWXdWVEF4Y2s1VmNGcE5SbkF6Vm1wR1dtVlhSa2xpUm1ScFVqRkpNbGRzVm1GWlYxSkhWRzVLVjJKR2NIQlZiVFZEVlVaa1dFMUlhR2xOYkZwWVZqSTFVMkZzU2xsVmJGSmFZa1p3YUZVd1dtRlRSVFZYV2taa1YwMUlRa2xYVkVKdlVURmFkRk5zYkdoU1JYQm9WbXBPYjJGR2JEWlNiR1JxWWtoQ1NGa3dXbXRVYkVwR1ZsaGtWMkpZUWt0VVZscFNaVlpLZFZSc1VsaFRSVXAyVmxSQ1YxTXhXWGhpU0U1b1VucHNUMVJXWkZOWFJsbDVUVlJDV0ZKcmJEUlZNblJ2VmpGSmVtRkhhRmRTTTJob1dYcEtTbVZzY0VkYVJtUlRWbnByZWxacVJtRlpWMFY0Vkd0a1ZXSnJjRzlWYlhoM1kwWldjVk50T1ZoU2JWSlpXbFZqTldGVk1WZFRhMmhYVFc1b2FGWXdaRXRXYkdSellrWmFhVkpyY0VsV2FrSmhZVEpPYzFwSVVsQldiVkpQVld0V1lWTldaRlZSYkdScFRWWnNOVlZzYUhOV2JGcEdVMnhzVjJKWWFETlhWbHAzVmpGa2NrOVhjR2xUUlVwS1YxUkNZVlF4V1hkTlNHeG9VbTVDV0ZSV1pGSmtNV1JYVjI1T1YwMVlRa2RYYTFwaFlWZEZlbEZzY0ZoV2JFcFFWbFJLVDFZeFZuTmFSbVJYVWxad1VGWnRNVFJXTURWWFkwWmFXR0Y2Ykc5VmJYaDNaVlpyZDFkdVpGZGlSbXcyV1ZWb2QxWXlSbkpqUlhoWFRWWndXRmw2U2tkU01XUjBaVWRvVGxKc2EzZFdha1p2WkRGSmVWSlliRlZYUjJoeFZXeGtVMkl4Vm5GVGFsSlhVbXhLV0ZadE5XdFdNa3BIWTBoc1YwMXFSa2hXYWtGNFYwZFdSMkpHWkdsV1JscFJWbXBDYTFNeFRraFNhMnhUWWtad2NGWnJWbUZXVm1SVlVXMUdWMDFzU2tsV1YzUnpXVlpLZEZWck9WZGhhelZUV2xkNFlXTldUblZqUlRsWFlrZDNlbFpHV205VE1rWnpVMnhvYUZKdGFGWldhazVEVTBad1NHVkhSbXRTVkVaWFdrVmFUMVJ0UmpaV2EyeFhZa2RSTUZkV1pFZFdNWEJHWVVkb1UyVnRlRnBXYlhSWFpHc3hSMk5GVmxOaE0wSnpWVzE0UzAxV1dsaE5XRTVXVFd0Wk1sWnRlSE5YUmxvMlVsaGtWbVZyV25KWmVrWnJaRlpXY2s1V1pGTldXRUp2Vm0weGQxRXlUWGRPVldSWVlrZFNiMVZ1Y0hOWFJsSllaRWhrYkZac1NucFdNalZQVjBkS1ZsWnFVbHBOUmtwUVZtcEJlRll5VGtsalJtUnBVbTVDVFZkclZtRlRNazE0WTBWb2FWSnJOWEJaVkVKYVpXeGFjVk5xVWxkTmExWTBWVEZvYjFkSFJYaGpSVGxYWWxSR2Rsa3llSGRYUjFKSldrWmtUbFl6YURaWFZsWmhWREpHZEZOclpHcFRSMmhYVkZjMVVtUXhXbFZUYTNSWFlYcFdWMWt3V25kaFJURlpVVzA1VjJFeVRqUlZla3BUVTBaS2NscEdUbWxTTW1oWlZrWlNSMU15U1hoYVJtUldZVEpTVmxSV1ZURlRSbFY1VGxWMFdGSXdjRWhaTUdoRFZtMUdjbGRyZUZkTlZuQnlWakJrVTFORk9WZFRhelZYVFZWd1dsWnRjRXBOVmxWNVVtNU9WR0pIYUZkWmExcGhWbXhhZEdWSVpFNU5XRUpZVmpKNFMySkdTblJWYm5CWVlURndkbFpVUVhoVFZrWjBVbXhrVjJKVk1UUldhMUpIWVRKU1IxUnVTbUZTTTBKVVZqQmtiMWRXV2tkV2JVWnJUV3RhU0ZadE5VZFZNa3BXVjI1R1ZWWnRhRVJWTUZweVpERmtkR1JIYUZkaGVsWklWbFJHVTFNeFdYZE5WbVJVWVRGS1dGbFhkSGRTTVhCV1YyMTBXRll3Y0VoV1J6RnZZVlpPUmxOc2NGZE5WMDQwVkZWYWMxWXhaSFZVYkdocFlrVndlbFpYY0VOWlYwbDRWbTVTYkZOSFVuTlZiWGhoVFVad1ZscEVRbWhTVkVaWFdXdFNVMVpyTVhWVmJscFhZV3RhVEZSdGVFdGtWbVJ6V2taT2JHRXhjRWxXTW5oWFdWZEZlRnBHYUZWaE1sSm9WVzF6TVdOR1ZYZFdhM0JzVm14c05WcEZXazlWTURGWVpVWnNWMUp0YUhaWFZscFBVakZrYzFkc2NHaE5iRW95VjFkd1IxVXhaRVpOVm1oUVZtMW9XRmxyYUVKa01XUlZVV3hhVDFZd1dsZFVWbHByWVd4S1dHRkdhRmRpYmtKWVZsVmFhMVl4WkhKa1IzUlRZa1p3Tmxac1pEUmtNa1pHVFZaa1YyRnNTbGxaYTJSU1RVWmFkRTFXWkZoU2JIQjVXVlZrTUZVeVNsZFRiRUpYWWxSQmVGVlhNVmRTTVdSeldrZEdVMUpyY0ZkV1JscGhZekExVjFadVRtaFNlbXhaVldwQ2QxTldiRlpYYlRsWVlrWnNObFpYTVc5V2JWWnlWMnBPVjJKWWFISlpNakZUVTBkU1IxcEhiRk5YUlVWNVZtMHhNR0Z0VmtoVVdHaFhWMGQ0VlZsdGRIZFdWbXh5V2tjNVdGSnRlSHBaVlZaUFZURktjMk5FUWxwbGF6VjJWbXBCZUZZeVRrZGpSbkJYVm01Q01sZFdXbXRTTURWelYyNU9hVkp0YUZoVVZFcHZWMVpaZUZkdFJscFdhMncwVjJ0b1YxWnRSalpXYkdoV1lsaFNNMVl5ZUdGa1JURkZVbXhLVGxaWGR6Qldha2t4VlRGUmVGZFljRlppVkd4WFdWZDBTMWxXVWxobFJtUnJVakZhU1ZwRldtdFViRXBHVjFob1dGWnNXblpWZWtaYVpWWk9jMVpzVG1oTk1taFpWa1phWVdReFpFZGhNMnhPVm0xU1ZGUldhRU5UUm1SeVdrUlNhRkpVUmxwVlZ6RkhWakpLVlZKcVRsWmhhM0JIV2xWYVQxZFhSa2RWYld4b1pXeGFXVll4WTNobGF6RlhXa1prYVZORmNHaFZiWE14WTFaV2RHVkhSazVTYkVwNlZtMXpOVmRHU1hkalJXaGFUVWRvTTFZd1pFWmxSazV6Vld4a2FHRXdXVEJXVjNoaFdWZE9kRkpyWkZoaGVsWnZXV3RhZDFWc1duUk5WRUpvVFZVeE5WWkhOVk5XVjBWNVZXeG9XbUV5YUVSWmFrWlRWakZrZFZkdGVHbFNia0kwVmxaamVGSXhXWGROV0VwUFZtMW9XRlZ1Y0ZkV1JscFdWMjFHYW1GNlZsZFVNVnByWVZaYVIxZHJWbGRXUlVwb1YxWmtVMUpyTVZkV2JGcHBWakpvVUZadE1UUlhiVlp6VjJ0a1dHSlZXbUZXYlRGVFUxWlZlVTVXWkZaaVZYQkpWbGN4UjFkdFJYbFZibHBXWVRGd2VsWnRlR3RrVmxKeldrVTFWMDFWYnpGV01uUlhXVmRGZUZWdVRsaFhSMmhWV1ZkNFlWZEdWbkZVYlRsb1VtMVNXRmRyVm10V01ERldUbFJHVjFKNlJqTldWRXBYWkVkV1IySkdaR2xXUlZWM1ZsaHdSMVF4U1hoYVNGWlRZa1UxY0ZVd1ZrdGxiRnBZVFZSU2EwMUVSbGhXTW5odllrWktWV0pIT1ZkaVdGSXpWako0VjFkSFZrWlViR1JPVm01Q1NGWlVTVEZUTVdSMFVtNUtXR0pGU2xkWlYzUmhZMnhzTmxOclpGTmhlbFpZVjJ0YVQxWXhaRVpUYkdoWFlsaFNhRmRXV25OV01rcEhWMnMxVjFZeFNscFhWekUwVXpGV1IxZHVVbXBsYTFwWlZXMHhOR1ZzV25SbFIzUlZUVlZ3ZWxadGNGZFpWbHBZVld0b1YyRnJjRXhXYlRGUFVtMUdSMk5GTlZOTlZXOTVWbTB3ZUdWdFZrZFRXR3hWWVRKU2IxVnRNVk5VTVZaeFVtdDBXRlpzY0ZsVVZsSlRZVEF4Vm1KRVVscE5SbHB5VjFaYVNtVlhSa2xVYkhCb1RWaENOVmRzVm1GWlYxSkdUVlpXVW1KWGFFOVphMXAyWkRGYWRFMVVRbWhOVm13MFYydFdiMkZHU25SbFIwWmFWa1Z3VkZaclduSmxSbVJ6V2tkd1RsWXhTalZYYTFaaFlqRlZlVk5yYkZKWFIxSllWVzE0ZDJOV1VuTlhiRTVxWVhwR1dGZHJaSGRWTVZwMVVXeG9XRll6YUhaV1ZFcEhVakpLUjFac1NsaFNNbWg0VmtaYWExVXlWbGRhU0VwWVlsaFNWbGxzVm5kTlJteFdWMnRrV0ZKc2NIcFdNbmhyV1ZaYVYyTkdRbGRoYTFwTVdrWmFVMk14WkhSaVJrNU9WbGhCZWxadE1YZFJNV3hYVkZoc1ZGZEhhR2hWTUZaM1ZqRnNWVk5zVGxkV2JFcFlWakkxVDFReFNuTmpSRUpWWWtaWmQxWXdXa3BrTWs1R1lrWmtWMlZyUlhoV2JYaGhWMjFXZEZKcldteFNiVkp2VkZab1EyVldXbkZSYlhSV1RWVnNORmt3Vm10aFJrbDVZVWhPV2xaRldqSlVWM2hoWTFaT2NWRnRiRTVXVkVVd1ZtcEdiMk14V2toU1dHaHFVbXRLV0Zsc2FHOU5NVmwzVjI1T2FrMXJXa2hXUjNNeFZHeGFkVkZxVWxkV2VrVXdXa1JLUzFJeFpGbGhSbEpvVFd4S1YxWkdXbUZrTWs1ellrWmtXR0V6VW5KV2JYUmhaVVpaZVdWSGRGZE5WWEJaV2tod1ExZEdXWHBSYTJoWVZtMVNUMXBWV25kVFZrNXpZVWRzVTJFelFscFdiR1EwVmpKUmVGcEZaR0ZTYldoelZXNXdjMk5HVWxkWGEzUlVVbTE0VmxaSE5VOWhWa3B5WTBaYVdtRXlhRWhXYkZwaFl6RmFXV0ZHVmxkV2JrRjZWbTB4TkdReFRsZFZiazVoVWxSV2IxUldXbkpsVmxwelYyMTBUbEl3VmpSV01XaHpWa2RLU0dWR1pGcGhNbEoyVmpCYWMxZEhVa2hTYkhCWFltdEtXRlpxU25wT1ZtUkhWMWhrV0dFeWFGaFZibkJIWld4c1ZscEdaR3BOVjFKNlZqSjRhMVJzV1hoU2FrNVlWbXhLU0ZadE1WZFNNWEJKVTIxR1UySlhhRnBXVjNCSFV6RmtWMWR1VW10U2JWSmhWbTE0YzA1R1dsaGxSM1JZVWpCd01GWlhOVTlYYlVWNFkwUk9WVlpXY0ZSV2FrWmhaRWRTUjFwSGFHeGhNWEJhVmpGU1EySXlVWGhhU0VwT1ZsZFNjVlV3YUVOWFJsSllZMFZrVTAxWVFsZFdNbk0xWVdzeFYxZHVjRmhoTVhCeVdXdGtSbVZIVGtaT1ZtUnBVakEwTUZaSGRHdFNiVlpYVld4c2FGSXpRbFJXYWtaTFYyeGtXR1ZIZEU5U2JWSklWbTAxVTJKR1RraFZiRnBhWVRGd00xUlZXbmRXYkhCSldrZHNVMkV6UWpWWFYzUlRWVEZrU0ZKWWFHcFRSbkJZVm10V2QxSXhjRlphUlRsVFRWZFNlbGt3Wkc5VWJHUkdVbXBhVjJKWVFrUlhWbVJPWlZaU2RWUnRSbFJTYkhCdlZsY3hOR1F4WkVkaVNFNVlZVE5TWVZadE1WTldiRlpZWlVkMGFGSlVSbGhXYlhCUFZsWmFkR0ZGZUZkU1JWcG9WakJrVjFJeVJrZGpSMnhUVFcxb1ZsWXhXbGRaVm14WVZHNU9hbEpXY0hKVmJYTXhZMFphYzFWc1pGUldiVkpZVm0weFIyRkZNWEpYYkdoV1RXcFdXRlpYZUd0VFZrWnpZa1prYVZkSGFHOVhWbFpoWVRGWmVGcElTbXRTTTBKUFZtcEdTbVZHV25KWk0yaFRUVlpXTlZWdGNHRldNa3BHVTJ4b1dtSkhhSFpaVlZwM1VsWkdWVkp0Y0U1V01VbzJWMVpXYTA1R1ZYbFdibEpzVTBkU1dGVnRNVkprTVdSWFYyeHdiRkpzV25wV01qRnZWVEF3ZUZOc1pGZFNiSEJvV2tSS1YxWXhWblZVYkdocFZrZDRXbGRYZUZkV01EVkhZVE5rWVZKNmJGbFphMXAzVjBacmQxZHRPVmROYTNCSVdUQldORmR0Vm5KWGJrcGhVbGRTV0ZWcVJsTmtSMHBIVkcxc1YxSXpUak5XYlRGM1VqRlZlRkpZYUZoaWEzQlFWbTB4VTFZeGJIUmpla1pYVm0xNFZsVXlNRFZoYkZwelUyeGFWazF1UWxSV01GcGhZekpPU1dKR1pHbFNhM0JKVm10a2VtVkdaRWhXYTJSWVlrWndjRll3Wkc5bFZscDBaRWRHVkUxck1UVldSM1JYVlRKS1NGVnVRbGROUjFKMlZqRmFZV1JIVGtaYVJsSk9WbTVDV1ZacVNURlVNV3hYVTI1U1ZtSkdTbUZaVkVaaFRURmFWMWR0UmxkTlZscDVWVEp6TVZZd01VVlNWRUpYWWxSQmVGWnFSbFpsVms1eVYyMXdVMkpYYUZoWFYzaHZZakF3ZUZkc1pGaGlXRkpaVldwR1lWTldWblJsUms1VllrWndXVnBJY0VOV01rcFpZVWhhV21WcmNFeFZha1pQWXpKS1IxZHRiRk5OYldoWVZtMHdlRTVIVVhkTlNHaHFVbTFvYzFVd1ZuZGpiRkpYVjI1a1dHSkhlRmRXTWpFd1ZsZEtSMk5HY0ZaV00yaDZWbXBLUjJOdFNrVlZiSEJvWVRGd2FGZHNWbUZVTWs1eldraE9hRkl5YUU5WmJHUnZZakZaZVdWSGRFNVNiWGhZVmxkMGEyRldTa2RqUmxKYVlsUkdWRlpyV2xOV01XUjFXa2Q0YVZJemFGaFdha3A2VGxaWmQwMVdXbXBUU0VKaFZGVmFkMkZHV25GVGEzUlhWbXRhZUZaWGVGZGhSVEZaVVcxb1dHSkdXbkpWZWtaS1pVZE9SbHBHVm1sU01taFZWa1pqZUdJeGJGZFhXR2hhVFRKb1VGVnRNVFJYVmxwSVpFZDBWMDFyY0hsWk1GcHpWMnhhUms1V1VsZE5WbkJvV2tWVmVGWldWblJsUm1ScFUwVkdNMVpyV21GV01rVjRWMWhrVGxaV1dsUlphMlJ2VjBaU1dFNVZUbE5TYlZKWVZqSjBNRll3TVhKT1ZXaFdWak5vY2xsV1drdGtWa1owVDFab1YxSlhkekJXYTFKSFUyMVdTRlJyV21GU01GcFVWbXRhWVdReFpGaGtSbVJyVFZaYWVsWXlOVk5VYkU1SVlVWkNWbUpVUlRCV01WcGhVakpHU0U5V2NGZGhlbFpKVm1wSk1WRXhXblJUYkd4b1VqSm9ZVmxYZEdGbGJGcHpWMnQwYTFadVFraFhhMXByWVZaT1JsSnFUbGRoTVhCb1ZsUkdWbVZHWkhKWGF6VllVbGhDVVZacVFtOVJNV1JIWWtoT1ZtSkhVbGhWYlRFMFYwWlplV1JJWkdsU2JHd3pWakowYTFaVk1WZGpSMmhhVmxkU1NGUnRlR0ZqVmtweldrWk9hVlpyVmpOV2FrWmhZVEZTZEZaclpHcFNWM2hYV1d0Vk1XTkdWbkZTYTNSV1VteHdNRnBWWkRCVWF6RkZVbXRvVjAxdWFIWldSM2hMVW14a2MxZHNWbGRpU0VGNlZrWldZVlp0VmxoVmEyaHJVbTFTVkZSVmFFTk9WbHBJWlVkR2FFMVhVbnBXTVdoM1ZsWmtTR0ZHWkZwV1JWb3pXVlZhWVdNeFpISmtSM1JUWVROQmQxZFVRbFpOVmxsNVUyNUtVMkZyTlZoWmEyUlBUa1pTY2xkdVRsZE5WbG94VmtkNGIyRlhSWHBSYm1oWFZqTm9jbGxxUm10U01rcEpWR3hhYUUxWVFubFdSbHByVGtaYWMxWnVVbXhTTTFKdlZGWldkMlZXVW5OaFNFNVhUVVJHTVZsVmFHRlhiRnB6WTBWMFlWWldjRkJaZWtaM1VqRndTR0pHYUZOTmJXY3hWbXBHYTJReFNYaFhXR2hVVjBkb2FGVXdXbUZXYkd4eVdrWk9XRlpzV25oVk1qQTFWakZhZEZWc2JHRlNWMUYzVm0xemVHTXhaSE5oUm1ST1lteEtNbGRYZEdGVGJWRjRXa2hPYVZKc2NIQldNRnBMVG14YVNFMVVVbWhOVm5CWVZsYzFVMkV4U25SVmF6bFhZbFJXUTFwRVJtRmpNV1J6Vkd4S1RsWnVRWGRXVnpBeFV6RmtTRk5zYUdoU01GcG9WbXBPVTJGR1dsWlhibVJUVFZkU2VWUXhaSGRoUjFaMFpVWnNWMDF1VW1oWlZFWldaVVprZFZac1NtbFNNVXBaVjFkNFUxRXdOVWRWYkZwaFVsWndjbFJWVWxkV01XUnlWMnhPYUZKVVJucFZNbmgzVjBaWmVsVnVTbGRXUlZweVZtcEtTMU5XVG5SU2JFNW9aV3hhV2xZeFpEQmhNRFZJVm01T1dHSnJOVzlWYm5CelZteFNWMVp1Wkd4aVJtdzFXVEJXVDFkc1duTmpSbXhYVmpOU2RsWnFTa3RYVmxKeFZXeHdUbUp0YUc5WFZFWmhWVEpOZVZScldrOVdhelZ3V1ZSQ2MwNVdXblJqUldSYVZtMTRXRmxyV205V2JVVjVZVVpTV2xaRmJ6QldNVnB6WTJ4d1NFOVdhRk5pV0dnMVYxWldWMVF4WkVkWGJrNXFVa1ZLWVZSVldtRmpiRmw1WlVad2EwMUVWbHBaTUZwM1ZHeEtjMk5JYkZkaVdHaHlWWHBHUzJOck5WZGFSMnhUWWtoQ2RsZFdVazlSTURGelYyeFdVMkpWV21GV2FrRjRUa1pzVlZSdVpHaFNhM0JXVm0xNFUxZHNaRWxSYTJSVlZsWndhRnBGVlhoU1ZrcHpWbXMxVjAxVmNFdFdiRkpMVFVkSmVWSnJaRlZoTVhCeFZXMHhVMVpzV25OYVJrNXJZa1phZVZZeU1VZGhiRnB5WTBSQ1ZtSlVSWGRXVkVGNFZqSk9SbU5HWkZkbGExVjNWbXhTUjFadFZsZFVia3BoVWpOQ1ZGbHRkRXRYYkdSWVpFZEdXbFp0VWtoWmExcFhWVEpLUm1OSVRsWmlWRVpVVmpKNGMxWnNaSFJQVjJoVFZrVmFObFpVU2pSaU1WbDRVMjVTVlZkSGFHRlpWM1JoVmtaV2NWSnRkR3RXYTNCNlZrY3hjMVl4V25WUmJIQlhZVEZ3Y2xwWGMzaFdNVTVaWVVab1dGSXphSHBXVjNCUFZURlplRlZzWkZoaWJWSnpXV3RrTUUweFdYbE5SRlpYVFVSR1YxbHJVbUZYYkZwWVZXNWFWMkpVUmtoWk1qRlBVbXM1V0ZKc1pGZGlhMHBTVmpKMFlWbFdWWGxVV0d4VFlUSm9jRlZ0Y3pGalJsVjNWbXQwYUZKc2NEQmFWV1F3VkRGS2MxWnFVbGROVjJoMlZqQmtSbVZXVm5OaVJuQnBWMGRvVFZkWWNFZFdNbEpHVFZaa1ZXSklRbGhaYTJoQ1pERmtjbFp0Um1oTlZrWTBWVEkxVDJGc1NrWlRiRnBhWVRGd00xa3llSE5XYkdSMFVtMXdhVlpVVmtoWFZsWmhXVlpTZEZKdVNsTlhSMmhZV1ZkMGMwNUdWblJOVm1SVFRWaENTbFpYTVc5Vk1rcFhVMjVhV0Zac1NraGFSRVpyVmpGd1NWTnNaR2xYUmtwWlZrWmFWazFXU1hoVldHaFlZbGhTV0ZSWGRIZFRWbHBZVFVSV1YxWnNjRWRWTW5RMFZqQXhWMk5IYUdGU1YxSlFWVzB4VTFKck5WZFViV3hUVm0xME0xWnRNWGRUYXpGWFZWaG9ZVkpYYUZWWmJYUjNWVVphZEUxVVVscFdiWGg2VmxkMFlWUnNTbk5qUkVKaFZsZG9VRll3V2twbFJrNXlZa1phYVZkSGFESldiRkpMVXpGT1YxSnNiR0ZTYldod1ZXMTRkMWRXV2tkV2JYUlRUV3hLU0ZaSE5VdFpWa3AwWVVoQ1dtSkhhSFpXYWtaaFpFVXhWVlZzWkdsV2JIQkpWbXBLTkZZeFdraFNXR2hxVTBVMVYxbFhkRXROYkZKWVpVWmFiRll4V2tsYVJXUnZWakpGZWxGWWFGZFdiVTR6Vkd4YVdtVldUbk5pUmtwb1RXMW9XRlpHWkhkU01XUkhWbTVHVTJGNmJISldiWGgzWld4YWRFMVlUbFpOYTNCNVZUSndUMVl5U2toVWFsSlZWbGRTVTFwV1dtRmtWbEp6WVVkc1UwMXRhRkZXYlRFd1dWWk5lRmRzWkZaaVIxSlpXV3RrVTFWR1ZuUmxTRTVQVm14S2VsWnNVbGRXTURGRlVtNXNXazFHY0hKV2FrRjRaRmRHUjJGR1pHaGhNMEpOVm1wR2ExSXhTblJXYTJSWVlsZG9iMVJXYUVOa2JGbDVaRVprYUUxV1ZqUldSM1J2Vm0xRmVWVnNiRnBpUjFFd1ZqQmFXbVF4V25Ka1JsSlhZa2hCZDFkVVFsZE5SbEY0VTFoa1YyRnNTbGxaVkVwdlZVWlpkMXBGV214U01EVklWVmQ0YTJGV1pFZFRhekZYWVd0S2FGbDZSbUZXTVU1MVZHMUdVMVpIZUZWWFYzUmhaRzFSZUZwSVRsZGlXRkpQVldwQ1lVMUdWWGxrUjNSWFVqQndNVlZYZUc5V1ZsbzJWbTVhWVZJemFHaFdiRnBIVjFad1NHVkdaR2xTV0VFd1ZtMTBhMDVIUlhsU2JHUlVZbXhhVTFsdE1UUlhSbFp4Vkd4T2FGSnNWalZVVmxwclZUQXhXVkZyY0ZkaVdHaFlXVlphUzJOdFRrbGFSbWhYWWtWd1VWWldVa2RXTVZsNFdraFdWbUpZYUZSWldIQlhWbFphUjFkdFJtdE5WVFZJVmpGb2MxUXhXbFZpUm14V1lXdEtNMVJWV21GWFIxWkhWR3hrYVZaWVFtRlhWbFpUVkRGWmQwMVZaR3BTTUZwb1ZtMHhVMWRHVlhkYVJrNVRUVmhDU0ZkclZURldSa3BXWTBad1YySllVbWhYVmxwV1pVWmFXV0ZHYUdsaVJYQldWMWQwYTA1SFNYaFdia1pVWWxSc1dWVnRlSGRsVmxwMFRsZDBWazFFUmxwVlYzaHJWakF4ZFZSVVJscFdSVnBvV1hwR1QyUlhUa2RqUlRWVFltdEtOVlp0ZUZOU01XeFhXa1prVTJKR1dsUlphMlJUWWpGU1YyRkZUbGRXYkhCWldUQldhMkZyTVZoVmEyaFhWbnBXVUZkV1drdGphelZaVVd4d1YxSlVWa1ZYVjNCSFdWWmtSazFXYkdwU1ZGWllXV3RXV2sxR1duRlRWRVpXVFZaS2VsVXlkR3RXUjBweVRsWmtXbUpHU2toV2ExcDNWMGRXU0ZKdGRGTk5WbkJLVjJ0V1lXRXhWWGhYYTFwWVlrZDRXRmxYZEhKbFJuQkZVbXh3YTAxRVJscFdiVEZ2VlRBeGRHRkdiRmRTYkZweVZsUkdTbVZIVGtkaFIzaFRZbFpLZUZaR1dtdFZNbFp6VjFoc1RsZEZOVmRVVjNSM1pWWlZlVTVYUmxkTmEzQklWVEowVTFkR1duTmpSMFpoVmxad00xVnRNVWRTTVhCSVlVVTFXRkpWY0RKV2JYaHFaREpXU0ZOWWFHRlNWMUp3VlRCV2QxZEdiSFJOVms1V1VteHdNRnBWYUd0aVIwcElWVzVzV2xaWGFISlpWbHBMWTIxT1NXTkdaR2xYUlVwVlZtMXdRbVZIVWxoU2EyeFVZa2hDV0ZSVVNtOVVWbHAwWTBWa1ZVMXJNVFZWYlhScldWWkplV1ZHYkZaaGEzQnlWRzE0V21WR1ZuSmtSVGxUVFVSRk1GWnFTalJoTVZwSVUyNUthbEp0ZUdGWmEyUnZWa1phUlZKdVRtcGlSMUl4VjJ0YVUxVXlTa2xSYWxKWFZrVndNMVpVUm1GV2F6RlpVMnhvYUUxc1NsZFdiVEUwV1ZkV2MxZHNhRTVXV0ZKVVZGWlZNV1ZzYkZaWGJVWm9WbTFTU1ZsVlZYaFdNVmw2Vlcxb1lWSkZXa3hXYWtaUFpGWk9kR05HVGs1TmJXaFdWakZrTUZsWFVYZE9WbVJZWW10YVZWbFhlRXRpTVZKWVpFZEdVMDFXU2xoWlZWVTFWakZKZDJORmFGWk5ibWg2Vm1wS1IyTnJOVmRWYkdST1VtNUNiMWRVUm1GU01XUlhZMFZvYkZKck5YQlZiVFZEWVVaYWNWTnFRbWhOYTJ3MFZteG9iMWRIUlhsaFNFNVdZbFJHZGxZeFdtRmpWbEp6Vkcxb1UySnJTa2RXVnpFMFpESktSMU51VWxaaVNFSmhXVlJLVW1ReFdsVlNiVVpVVWpGYVNGbHJXbXRWTWtwSlVXeHNXR0V4U2t4V2FrWmFaVVphZFZac1VtbFNia0oyVmtaV1UxWXhaRmRhUm1oclVqQmFjVlJWVWxkbGJHeHlWMjFHVjAxcmNGWlphMXB2VmxaWmVsVnFUbGROYm1oNlZtMTRZV05XVm5OaFIyaHNZVEZzTkZZeFdsZFpWMGw0V2toS1RsZEdXbFpaVjNoTFYwWnNXR1JIUmxkU2JYY3lWVzAxYTFVd01WbFJhMnhhWVRKU2RsWkhlRTlTYkU1eVlrWmthVlpGU1hwWGJGWldUVlpKZVZOclpHRlNiVkpaVldwS2IxWXhXbkZSYlhScFRXdGFTRlpzYUd0WFIwVjZWV3hvV21FeGNIcFVWRVpyWTJ4c05sWnNaRTVXV0VGM1YyeFdiMk14V1hkTldFWlhZbXR3V0ZsWGRHRlVSbkJHV2taa1UwMVhVbnBXTW5ocllrZEtSMk5FVmxkaVZFSTBXbGN4VjFJeGNFZGFSazVwWVhwV2QxWlhNVFJaVjA1SFZtNVNUMVpWTlZkV2JYaDNUVVp3VmxwRlpGaGlSbXd6VkZaU1UxZEhSWGxoUmtKYVZsWndURnBGV2xka1ZrWnpXa1UxVTJKclNrNVdNbmhoV1Zac1dGUllhRmRpYTNCb1ZXMTRTMVF4V25GU2EzUllZa1p3V1ZSV1VrTlhiRnAwWlVab1ZrMXFWbEJaVjNoUFVteE9jMkZHVmxkV2JrRjZWbXRXWVZsV1NYaGFTRkpUWWxoQ1QxWXdWa3RTTVZweldrUlNhMDFXYkRWVk1uUnpWVzFLU0dWR2FGZGlia0pEV2xWYVlXTldUbkphUjNCT1ZsUlZlRlp0TVRSVE1rWlhVMWhzYUZJeWFGbFdiWGhMVTBad1JWRllaR3hTYlZKNVYydGFiMkZXV2xkalJteFhVbXh3ZGxWVVJrdGpNV1J6WVVkNFUxWkhlRmRYVjNSaFpEQXhSMk5GYkdwU1ZUVlpWVzE0ZDJWc1ZYbGxSVTVhVm10d1IxWXlNVzlXTURGSFkwWkNXazF1YUhKYVJXUlBVakZTZEdKR1pFNWlWMmhvVm0xd1IyRXdNVWRpUm1oV1YwZFNUMVV3Wkc5WFJteDBaRWhrV0ZadGVIcFdiVEZIVjBaS2MxTnNiR0ZTVjFKSVZtdGtTMUl5VGtaaVJuQk9UVEJLV1ZadE1YcGxSMDV6V2taV1ZHSkhVbkJXTUZwTFRteGFkR05GWkZwV1ZGWjZWVEo0VjFWdFNraGhSbWhhWVRKb1JGWXdXbXRqTVdSMFVteFNUbFl4U2xwV1Z6RXdZakpHYzFOdVNrOVdiV2hYV1d4b2IwMHhXWGhYYkhCc1VtNUNSbFZYZUhkV01rcFpZVVp3VjFaNlJYZFpWRVphWlZaT2NscEdhR2xTYTNCb1YxWlNTMVV4V2tkWFdHUllZa1UxV0ZSV1pGTk5WbVJ5V2tSU1YwMXJjRWRaTUZKaFZqSktXV0ZHVWxkaGExcG9WakJhVDJOc2NFaGpSazVUVmxoQ2RsWnNaREJXYXpGV1RVaG9XR0pyV2xSWmJGWmhWVVpzY2xadVpGaGlSMUo1VmpJeE1GWXdNVlpqUm1oYVRVWkthRlpxU2tkamJFNTBZVVphYkdFelFsQlhiRnBoVkRKT2RGSnJhR2hTYXpWdldsZDRZVmRzV25STlZFSmFWbTE0V0ZkcldtdFhSMHB6VTJzNVZrMUhVblpXVlZwWFpFVXhWVlZzYUZOaVNFSktWMnRXYTAxR1dYZE5XRXBxVTBkNFlWUlZXbmRrYkZsNVpVWndiR0pWV2tkYVZWcHJZVVV4V1ZGcVdsaFdSVzh3V1ZSS1UxWXlUa1poUjNoVFlsWktkMVpYTVRSamJWWkhWMWhzYkZKdFVsaFVWVkpIVTBaWmVHRkhkRlZpUm5Bd1ZsYzFSMVp0U2xsaFJFNVhZV3RhZWxsNlNrZFNiRkowWVVaT2FWTkZTVEJXYkdOM1pVWkplVkp1U2s1WFJYQlFWbXhrYjFsV1duTlhibVJvVW0xNFYxZHJWbUZpUmtsM1RsVmtXbUV4Y0haV01GcFBVbXhPY21KR1pHbFhSVXBOVm10amVGWXhTWGhhU0ZaWFlrWndjRll3Wkc5V1ZtUlhZVWhrVjAxc1NucFdNblJyVmpKS1ZXSkdUbFZXYkhBelZqQmFXbVZWTlZkVWJGWnBVbTVDU1ZaVVNYaFNNVmw1VTJ4c1ZXRnNTbFpaVkVaM1lVWndSbFpVUmxkaGVteFlWMnRrYzFZeFduTmhNMlJYVFZaS1JGZFdaRXBsUm5CSlZHeG9hRTFZUW5oV1Z6RTBVekZrUjFkdVNsZGlWVnB6V1d0a01FNVdjRlphUldSb1RWVndlVmt3YUhkWGJGcFhZMGhLV2xac2NHaFpNakZMVG14S2MxcEhiRmRTVld0M1ZqSjRhMlZyTVZkWFdHaGhVMFUxYUZWdE1XOWpSbXhWVkd0T2JGSnNjRmxVVldodlZtc3hXRlZyYUZkV00yaDJWa1JHWVdOck5WZGFSbHBwVjBkbmVsWkdWbUZrTVZwelkwVmFZVkpzY0U5WlZFWnlaVlphZEUxVVVtdE5WbXd6VkZab1YyRkdTWGxoUm1oYVZqTlNhRlpGV21Ga1JURldWMjE0YVZORlNrbFdNblJoWVRKS1NGSllhRmRoYXpWWVdXdGtiMDB4VmpaU2JFcHNWbXhLV2xsVldtRmhWMHBIWTBaa1dGWXpVbWhWZWtwUFVqRmFkVkpzVG1oTk1VcFlWbGN3ZUZVeFpGZGpSVnBZWWxoU2IxUlZVa2RXTVd0M1lVaGtWMDFFUm5oV2JYUTBWakpHY21ORmVGWk5SbkJZV1hwS1IxSXhXbk5hUjJ4VFltdEZlVlp0ZEd0TlJteFhWMWhzVm1FeGNGQldiWGgzVlZaYWRHVklaRlZOVjNoV1ZrZDBUMVpHV25SVmJGcFdWbnBHU0ZZeWVHRmpNa3BGVkd4V1YySkdjSGxXYlhCSFlURk9TRkpyWkdoU2JWSnZWRlphZDJJeFpGZFdiVVpxVFVSV2VsVXlOVk5WTWtwWlZXeFNXbFpGTlVSVWJYaGhWbFpPZFdORk5WZGlSM2N4VmxSS01HTXhWblJUYkdob1VtMW9WbFp0TVZOVk1YQkZVbTFHVjFacmNIcFdNakUwVlRKS1NWRllhRmRpUjFFd1ZsUktSMUpyTVZkaVJrcHBVMFZLV2xadGNFOVZNazV6VjJ4V1UySklRbk5WYWtKM1UyeGFTRTFYT1ZaTmExa3lWbTE0YzFZeFdqWlNWRUpoVWtWYVVGVnFSbXRYVjBwSVpFWk9VMVpZUWxwV2ExcHJUVWRSZUZSc1pGaGlSMmhRVmpCVk1WZEdVbGRXYms1UFlrZDRWMWRyWXpWV01ERnlWMjVzVjAxdVVUQldha3BMVWpKT1NHRkhSbE5XYkZWNFZtMXdSMlF4U1hoalJXaHBVbXMxV1ZWc1ZuZFRSbHAwVFZSQ2FFMUVSa2haYTFwclZsWmtTR1ZHV2xkTlIxSjJWbTE0YzJSSFZraFNiR1JYWWxob05WWnFTakJOUjBaelUyNU9XR0p1UW1GV2JGcGhWVVpaZDFkdFJtcE5helZHVlZkNGQxUnNTbk5qUlRGWVZteEtRMXBWWkU1bFJuQkpWbTF3VTJKV1NsQlhWekI0WWpBMWMxcEdaR0ZTUmtwVlZGWmFkMlZXVW5OWGJYUlhZbFZ3U0ZZeWVHOVhiVVY0WTBST1dtRnJXbkpaZWtaM1VsWldjMXBIYkZkaVNFSmhWbTB3ZUUxSFJYaFhiR2hVWWtkb2MxVnRlRXRaVmxweVZsUkdVMUpzYkROV01qRXdWakZhY2xkcVFsWmlXR2hZVmtkNFlXUkhValpTYkdSWFVsYzVNMWRXVWtkaE1VNUhWRzVPYUZJeWFGUlpiRnBMWVVaYWRHTkZPVlpOYTFwSVZqSTFTMWRIU2toVmJrcFdZV3RhYUZVeFdsZGtSVEZaV2tkb1YyRjZWa2hXVkVvd1l6RlplRmRyV21sU1JrcGhXbGQwWVZZeGNGWlhiWFJyVm14d2VsVXlNWE5WTURCNVlVWndWMDFYVVRCWmFrWldaVlpLY2xwSGJGUlNWbkJWVjFkMFYyUXlUWGhXYmxKT1ZtczFjMVp0TVZObFZsbDVUVVJXYUZKc2NIbFpNRkpIVm14WmVtRkVUbGROUm5Cb1dYcEdUMk5zVW5OV2JHUnBVMFZLYjFZeWVGZFpWMFY0V2taa2FsSlhhRlJaYTFVeFZrWmFjbGR0UmxaV2JIQjZWMVJPYjFReFNuUmxSbWhZWVRGd2NsbFhlRXRqTWs1SFlVWndhVkl5YUZWV2FrSmhWVEZrU0ZWcmJHRlNhelZQVm1wT1VtVnNaRmRXYlRsVlRWWnNORll4YUd0aGJFcFlZVVpvV21KSGFFUldhMXBoWTFaS2RGSnNUbWxTTVVsM1YxWldZVmxXVW5OVFdHaFVZa2Q0V0ZadWNFWk5SbHB4VTJzMWJGSXdOVWRYYTJSSFZUQXhkV0ZHV2xkV00yaFlXa1JHYzFZeFpIVlZhelZYVWxWd2RsZFhlR0ZaVms1SFYyeG9UMVpyTlZoVVYzUlhUbFphV0dWR1pGaGlWWEJhVmtab2IxWXdNVmRqU0hCYVRXNW9hRlpzV2t0a1IwcEdUbFprYUUwd1NscFdha1poVmpGWmVGVllhR0ZTVjJoVldWUktVMk5XVlhkaFJVNVlVbXh3ZUZaSGN6RlViRnAwWlVab1YySkhhSFpaVnpGSFRteGFjMkZHY0ZkV2JrSjVWMVphWVdFeFRraFNhMnhwVW0xU2NGWXdWa3RVVmxwWVRVaG9WMDFXYkRSV01qVlhWbGRLUjJOSVFsWk5SbHBNVmpGYVlWZEhWa2RVYkdST1VrVmFObFpxU2pSaU1rWnpVMnhvVm1KSGFGWldhazV2VkVaVmVGZHRSbGhTTVVwSlZXMHhiMVJzV2xsUmFscFlWa1ZLZGxWVVJtRmtSazV6Vm14a2FFMVZjRmxXUmxwaFpESkdSMk5GV2xkWFIyaFVWbTEwZDAxR2NFWldWRVpYVFd0d2VWVXhVa3RXTWtwWlVXdDBWVlpzY0ZOYVZWcDNVbTFHUjFSc2FGTk5NbWd5Vm14amQyVkdWWGhhUldScFVtMW9jVnBYZEdGamJHeHlWMnhrVGsxV2JEVmFWVlUxWVVkR05sSnNjRlpXTTFKMlZqQmtSbVZIVGtkUmJIQlhZa2hDVFZadGVHRlpWMDVYV2toT1lWSnRVbFJXYm5CdlRURlplRmRzVGxOTlYxSXdWbTEwYTFsV1RrZFhiR2hhWVRGYU0xbHFSbE5YUjFaR1pFWm9WMkpXU2xsV2JHUXdZVEZrYzFkdVVsWmhNbWhZVkZkd1YxTkdXbFZUYTFwc1lrVmFNVlpIZUdGaFZtUkhVMWh3VjFKc2NHaFhWbHBQVTBaYWNscEdWbWxXTW1oWlYxWlNTMDB3TVZkYVJtUlhZbFJzY2xSV1duTk9SbGw0WVVoa2FGSnJiRFZaVlZwcldWWlplbFZ0YUZkaE1YQjZWRzE0UzJSR1NuUmtSbVJwVWxoQk1sWnFTakJoTWsxNFYxaG9XR0pzV2xOWmExcGhWMFpzVlZKdVpHaFNiVkpZVmpJMVQxWXdNVmxSYTJSWVlURndkbGxXWkV0U2JVNUpZMFprVjAwd1NrVldNVnBoV1ZkTmVGWnVUbGhpUm5CdlZGZDRTMVpXWkZoa1IzUlBVbXhzTkZZeWVHOWhiVlp6VjJ4b1ZWWnNjRE5hVjNoeVpESkdTVnBHWkU1U1JWbDRWbXhhVTFFeFdYbFNia3BZWWxWYWFGWnVjRWRUUmxWM1drVmtVMDFZUWtkVWJGcFBWR3hhV1ZGc1pGZGlXR2hVVldwS1JtVkdWbGxoUmxKWVVqSm9iMVpVUWxaTlYwWkhWbTVHVkdGc1NsaFZiVEUwVFVad1JsWnFRbGRTVkVaWVdUQlNRMWxXV2xoVmEyaGFWbFpXTkZWc1dtRmpiVVpIV2tkc1UwMXRhRFZXYlhSVFVqRnNXRlZyYUZOaE1sSnZWVzAxUTFkR1ZuTmhSVTVYVm14d2VGVnRNVWRoYXpGeVRsaHdWMDFxVmxoWFZscExaRWRHUjFWc2NHaE5iV2hGVmtjeE5GbFhUbGRVYkZaVFlsZG9UMVp0TlVOVGJGcFZVMnBDYUUxclducFZNbmh2Vm0xS1NHRkhSbHBoTWxKMldrZDRjbVZYVmtoU2JHUlhZVEZ3WVZkV1ZtRmhNa1pYVTFob1ZGZEhhRmxXYTFaTFlVWmtWMXBGWkZkTldFSkhXVlZrYjFVeVZuUmxSbXhZVm14S1RGWlhjM2hTTVdSeVZteE9hRTB4U25oWFZtaDNWakZrUjFwSVNsaGlWR3h2Vm0xMGQyVnNhM2RYYms1WFRXdHdWbFZzVWtOWlZrcEdZMFYwWVZaV2NISlpla1ozVWpGa2RHRkZOV2xTV0VKaFZtMTBZVmxYUlhoV1dHaGhVbTFTV0ZZd1pEUmpiRlowVFZaT1dGSnRlSHBXYlRWclZUQXhXR1JFVGxwV1ZscFFWbXBLUzFadFRrWmhSbkJPVW10d1VWWnRjRUpsUmtsNVZHdG9hRkp0VWs5VmJYaGFUVVphY1ZKdGRGVk5WWEI1Vkd4YWExbFdTWGxsUmxKWFRVWmFURmRXV21Ga1IxWkhWR3hTVGxKR1drbFdha1p2WXpGVmVWTnJhRlppUmxwaFdWUkdkMDB4V2xaWGJVWnJVbFJHV0ZaSGVHOVZNa3BaWVVSYVdGWnNXbkZVYkdSSFVqRk9kVlJ0Y0ZOV2JrSllWMWQ0VTFZeFZrZFhhMVpVWVROU1ZGbHNWVEZUYkd4eVYyMDVhRkpVUmxwVlZ6VnpWMFphYzJOSGFGWmxhMXB5Vm1wR1MyUldTbk5hUjJ4VFRWVndXbFpzWkRSaGF6VklWVmhvWVZORmNGZFpWRXBUV1ZaYWNWRlVSbXhXYkVwWVZtMDFUMkZHV25KaVJGWmFWbFp3V0ZadGMzaFNNV1J5WlVaa1RsWnVRbTlYYTFaV1pVWmFWMVp1VW10U1ZGWllWRlpXZDFOc1duUk5TR1JPVm10c05GWnNhSE5WTVdSSlVXeGtXbUpZVW1oWFZscHpZMnhrZFZwSGFGTmlSbkEwVmxjeE5HUXlTa2RYV0doWVlUSlNWbFJXWkZOa2JGcFZVbTFHVTJKSFVubGFSVnByVmpKS1YxSllaRmRpUmtwSVZqSXhWMVl4VW5WVWJXeFRUVzFvVlZaR1kzaGlNV1JYV2taa1lWSkZTbkpVVm1SVFUwWnNjbFZ0UmxaTmEzQlhWakkxUjFaV1duUmhSVkpXVFVad2Nsa3llSGRUUlRsWFZtMXNWMWRGU2tsV01WSkRXVlpaZUZkWVpFNVdiV2hYVmpCa1UxZEdiRmhrUjBacVlrZDBOVmw2VG05V01ERlpVV3RzV2sxR2NGQlpWbHBQVW14T2MyTkdaRTVXYmtKVlZtdFNSMVp0VmtkYVJteG9Vako0VlZWc2FFTlhiR1JZVFVob1ZrMVhVa2hXVjNoclYwZEtjazVXUWxkaVZGWkVWV3BHV21WVk1WVlJiR1JPVWtWYVdWZFVRbTlqTVdSeVRWVmthbE5HY0ZoWlYzUkhUa1p3UjFkc1pHdFdiVko2VjJ0a2MxZEdTWGxoUnpsWFRXNW9jVnBWV2twbFJrNTFWV3hrYUUxc1NtOVdWM0JMWWpGUmVGZHVVbXhTYlZKUVZXMTRkMDFHVWxaaFJ6bFZUVlZ3ZWxsclVsZFdNVXAwWVVoYVYxWkZjRXhaZWtaUFpGWlNjMWR0YUdoTmFtZ3pWakZTUTFsV1dYbFVXR3hUWVRGd1ZsbHJXbmRqUmxaMFRsVkthMDFYVW5wV2JURXdWVEF4V0ZWdWNGZE5hbFpRV1ZaYVMxSXhUbk5hUmxaWFlsWktNbGRyWkRSWlYwMTRZMFZhYTFJelFuQldiRkpYVXpGYWNscEVVbHBXTUZwWVZUSTFWMVZzWkVsUmJHaGFZa2RvVkZsVlduTk9iRXAwVW14a1RsWllRWGhXYlRCNFVqRlZlVk5yYkZKaVJVcFlXV3hTUW1WR1ZsVlJWRVpxVFZkU01WWkhlSGRVYXpGelUyeEdWMkpZUWtSYVJFWlBWakZhV1dKSGRGTk5NVXAyVjFkMFYyUXdNVWRpUmxwWVlsUnNXVmxzVm5kVFZteFdWMnhPV0dGNlJqRlpWV1J2VmpBeFIxWnFVbGRpVkVaVVZXcEdVMlJIU2tkVWF6VlhWMFZLV2xadE1UUmhiVkY1Vm10a1ZGZEhhRmxXTUdSdlYxWnNkR042Um1wV2JGcDZWbGQwYTFkR1NuUmxTR3hZWVRGd1RGWkhlRXRrUmxaellVWmtUbUZyV2tsWFZtUjZaVVprVjFKdVNtcFNiSEJQV1cweGIxSldXblJqUlhSVVRWVnNOVlpIZEd0V01rcElWVzVDVjJFeFdraFVhMXBoVmpGV2NtUkdaRTVXYlhjd1ZqSjBiMVF4YkZkVFdHUllZa1pLVjFsc2FGTk5NVnB6VjIxR1UwMVhVakJWYlRFd1ZHeEtSbGRyYkZkaGEyOTNXVlJLUjFJeFVuSmhSbHBwVWpKb1dWZFdaREJUTURCNFZtNUdVMkpyY0hKVVZtUlRUVVpSZUZkdGRGVmlWVlkyVlZkMGMxZEdXa1pUYkZKWFVrVmFhRnBGV2t0WFYwWklZMFpPVG1KWGFGcFdNVnByVFVkUmVGUnJaRmRYUjJoWldXdFZNV05XYkZsalNFNVlVbXh3U1ZSV1l6VmhWa2wzWTBWb1drMUdXWGRXYWtwTFYxZEdTVkp0UmxkV2JGWTBWbGR3UzFNeFNYaGpSV1JoVW0xb1ZGUlVTbTlXYkZwMFkwVk9hRTFyYkRWV1IzaHJWakpLY2s1V1pGcGhNbEpVVmpCYVUxWXhjRVZWYlhoWFlrZDNNVlpHV2xkaE1rWkhVMjVLYWxOSVFsaFVWelZ2WVVaYWRFMVZkRmhXTUZwS1ZUSjRhMkZIUlhoalJ6bFlWMGhDU0ZaRVNrOVdNVXAxVkd4a2FHVnNXbGxYVnpFd1V6RlNjMWR1VW10U00xSlFWVzF6ZUU1R1draGtSM1JvWWtWd1NGa3dXazlYYlVWNVZXeFNWMUpGV25wYVJXUlhVbTFTUjJGR1pHbFRSVXBvVmpGU1ExWXlSWGhYV0dST1YwVndUMVpyV2t0WFZteFZVMjA1VmxKc2NIaFZNblF3VjBaSmQxZHJhRmRpV0dob1ZrZDRTMk15VGtaTlZtUm9ZVEJ3YjFZeFdtdFZNVXB5VFZaa1YySkdjSEJWTUZaTFYxWmtWMkZJWkZkTlZUVllWakkxVTFSc1drZFRia0pWVmpOU00xVXdXbUZUUjFKSVpFZG9hVkpVVmtoWFZFSmhXVlpaZVZOc2JHaFNiVkpvVm14YWQxbFdjRmRhUm1SVVVtdHdlbFpYZUU5VWJGcDFVV3RzVjAxdVVsaFhWbVJHWlVaV2RWUnNhR2xpUm5CVVYxZDBhMDVHWkZkWGJrcFhZVE5TV1ZWdGVIZFdiRlowWlVoa2FWSnJjREJXVjNCSFZqRmFObEp1V2xkaE1YQlFWVzE0VDJNeGNFZGhSbVJwVWxoQ1NsWXlkRk5TTVZGNFUxaHNWR0V4V2xsWmExVXhZakZTVlZKcmRHeFNiSEJJVmpJeE1GWnJNWE5YYm5CWFRXcFdWRmxyV2twbGJGWnpXa1pXVjJKSVFYcFdSbHBoVmpGa1NGWnJaR0ZTYlZKUFZXdFdZVmRXWkZWUmJYUnBUVmRTTUZWdE5VdGhiRXBaVlcxb1YySkdjRE5XUlZwYVpVWndSbHBHVGs1WFJVcEtWMWQwWVZReFVuTlhiR3hTWWxWYVdGbFhkR0ZoUmxwVlVtczFiRkpzY0ZwWlZWcHZZVlpKZUZOc2JGaFdla1kyVkZaa1NtVkdXblZXYlhCVVVsUldXVlpYTVRSVE1XUkhWMWhzVGxaWFVsWlphMVozVFZaV1dHUkhkRmROYTNCYVZWZDBVMVl5Um5KalJXaFZZbGhvVEZsNlNrZFNNazVHVGxaT2FXRXdiRFZXYlRCM1pESldSMVJZYUZSWFIyaFdXVzF6TVZVeGJISmFSazVxVW14YU1GcFZXbmRpUjBwSVZXNXdXR0V4U2xSV1ZFRjRWMFpXYzJGR2NFNVNiSEI1VmpGYVlWTnRWbGhTYTFwUVZtMVNUMVZ0ZUhkVVZscFZVMnBTV2xZeFNrZFVWbFp6WVVaS1ZXSkdVbHBYU0VKSFZGWmFZV05zWkhSUFYyeE9WbXhaTVZaVVNURlRNa1p6VTJ4V2FWSnRhR0ZaYTJSdlZERndWbGRzY0d0TlYxSXdWVzB4TUZVeFdrZFhiR2hYWVRKUk1GWkVSbHBsVms1eVlrWkthR0pJUWxsWFZtUXdZekExUjFadVJsTmlTRUp6Vm0xMGQyVkdXWGxsUjNSb1VsUkdNVmxWV25OV01WbzJVV3BTV21GcmNGUlpla1pyWkZaS2MxVnRhRTVOVlhCV1ZtdGFhMlZyTVZkVWEyUllZa2RvYzFVd1pGTlhSbEpYVm01a1YwMVhlSGhXUnpWclZqQXhjbU5GYUZaTmJsSjJWMVphUzFKc1pIUlNiVVpYWWtoQ1RWZFVTWGhTTVVsNFVtNU9ZVkl5YUU5VVZWWjNWV3hhZEUxSVpHeFNWRlpKVmxab2IxbFdTblJWYkd4YVlsaG9URlpFUm1GamJGcHlaRWRzVGxacmNGbFdha2t4WVRGYVIxTnVUbGRoYkZwb1ZteGtiMVZHYkZaWGEzUnFZbFUxU0ZsclpFZFdNVnAxVVdwS1YySlVRalJWYWtwUFkyczFWMXBHV21sU01VcFZWbTB3TVZFeVNYaFhia1pTWWxoU1dGUldWVEZUUmxWNVRsWk9hRTFWY0hsVWJHaERWbTFLU0ZSVVJsVmhNWEJoV2xWYVYyTnNVbk5qUm1ScFYwZG9XbFp0Y0VkaU1rMTRWMnRvVTFkSGVGZFpiWFJoVmpGc2NscEdTazVTYkd3elZqSXhSMkV4U2xWU2JHaFdUVzVOZUZaVVNrdFRWa1p6V2taa1YySklRbFZXVjNCSFlURkplRlJ1VmxWaVdFSlZWV3BPYjFkc1pGZFZhMlJyVFd0YVNGbHJXbXRYUjBWNlZXeHNWMkpZVW1oYVYzaHpZMnhrZEdSSGFGZGlWa3BLVjFaV2FrNVdaRWhTV0doVVlUSm9XRlZyVm1GVE1YQldWMjVrVkZack5YcFpWV1J6VlRBeFZtTkVUbGRpUjFJelZXcEdUbVZHWkhOYVJtaG9UV3hLV2xkWGRHdFZNV3hYVjI1R1UySlZXbk5aYTFwM1RVWlNjMVpVVm1oU2EzQjVWR3hXYzFZeFdYcGhTRXBYVFdwR1RGVnFSbXRqTWtaSFZtMW9UbGRGU2xsV01uaGhZVEZaZUZOdVRtcFNWMUpvVlcweFUyTkdWWGRXYTJST1RWWndNRnBWWkRCVU1VcHpWbXBTVjAxcVZsQldNR1JHWlVkT1IySkdjR2hOYkVveVZtcENZV014WkVoVmEyaFRZbGRvVkZscmFFTk9iRnB4VTJwU2FFMXJWalJWTVdoclZERmFXRlZzV2xwaE1YQXpXVEo0WVdOV1RuSmtSM0JwVWxSV05sZFVRbUZoTWtaWFdrVm9hRk5IYUZsWmExcGhWakZ3VmxkcmNHeFNiRnA2V1d0a2IxVXlTbGhoU0dSWFZqTkNURmxxUm10V01YQkhZVWQwVTAweFNsRldWM0JEWXpBMVIxZHVVazlXYXpWdldXeGFZV1ZXV1hsbFJ6bFhWbXh3ZWxrd1VrOVdWbHBYWTBST1YySllhRE5WYlhoM1VqRndSMVJ0YUU1TlJXdDVWbTB4ZDFOck1WaFVXR2hZVjBkNFZWbHJaRFJWTVd4eVYydDBXRkpzY0hsV2JUVnJWbFpLYzFkcVFsVldiRlV4Vm10YVdtUXlUa1poUm1ST1ltc3hORmRXV210VE1XUklVbXRhVDFadFVuQldhMVphWld4YVdHTkZaR2hOYkVwSVZqSTFWMVpYU2toVmJrSmFWa1ZhTTFZeWVHdFhSMUpJWkVaYVRtRXlkekJXYkdRMFlURlplVk51VWxaaVJrcFlXV3hvYjAweFdYaFhia3ByVFZad01GcEZXbUZVYkVwR1YycFdWMUpzY0ZSV1ZFWmFaVVpPY1Zkc1pHaE5iV2haVjFaa01HUXhVa2RYV0doaFVsZFNWRlJXV21GbGJHUnlXa2hPVmsxRVJqQlpWVlpoVmpKS1ZWSllaRmhXYkhCNlZqQmFWMk50UmtkYVIyaE9Za1Z3ZGxac1kzZE5Wa1Y0V2tWa2FWSnRlSEZWYkZwM1ZERldkR1ZJWkd4aVIxSjVWbGQwVDFkSFNrZGpTSEJhWVRGS1ZGWnFRWGhrVmxaMVUyeGtUbEl4U2sxV1Z6RjZUVlprUjFOdVRtcFNiVkpVVm0wMVEyUnNXWGhYYkdSYVZtMTRXVlpIZUd0V1IwcHpVMjVLVm1KVVJsUldNRnB6WTJ4YWRWcEZPVmRpU0VKSFZsY3dlRkl4WkhOWFdHUllZa2RvVjFSWGNGZFhSbHBZVFZWMFZGSXdXa2haVlZwM1ZqQXdlRk5ZYkZoaE1VcElWMVphUzFZeFRuVlViWEJUVFRKb1ZWZFhkRmRrTURWWFdrWmtWMkpZVWs5VmFrSjNVMVpXYzJGSGRHaGlSWEF3V2xWYWIxZHRTa2hoUlZKWFZsWndlbGt4V2t0amF6bFhWR3MxVjAxVmJEUldiWGhxWlVVMVIxWllhR0ZTVjFKVldXMHhiMWRXV25GVWJFNW9VbTFTV0ZkcldtdFdNREZYVjI1d1dHRXhjSFpaVldSWFpFZFdSMkpHWkZOaVNFSnZWMnRTUW1WR1dYaFhiazVvVWpOU1ZGbHNXa3RYVmxwSFdrUkNhMDFWTlVoWlZFNXJXVlpLTm1KR2FGVldNMUpvV2xaYWNtUXhaSFJQVm5CWFlUTkNXVmRVUW1GVk1WbDNUVlpvVm1FeWFGZFpWM1JoVFRGVmQxcEZkRk5OVmtvd1dXdGtiMVJzVGtaVGJHeFhZbFJHTTFWcVNrWmtNRFZXV2taa1dGSXlhRlpXYWtKclRrWmFjMkpHVmxSaVJUVnhWVzE0WVUxR2NGWmFSV1JYWVhwR1dWcFZVa05YYXpCNlVXdG9XbFl6VGpSV01HUlhVMWRLUjFwRk5XaGhNWEJLVm0xd1ExbFdUWGxVV0d4VllURmFVMWxzVm1GV1JscHhVbXRrVGsxV2NEQlVWbWgzWWtaS2MyTkVRbFpOYmxKWVZtMHhTMU5HVm5KUFZuQlhUVEpvYjFaSE1UUlpWMUpHVFZac2FsSXphRlJaYkZwTFUyeGFXRTFVUW1oTlZsb3dWVEowYjFadFNraGhSbHBYWVRGYU0xcEhlSE5qVmtwMFVtMTBVMVpGV2xkV2JHTjRZakZTZEZOcldtcFNWMmhZVld0V1lXRkdiRlZUYTJScVRWVTFXbGxyWkRSVk1rcEdZMGRvV0Zac1NreFpha1pMVWpGa2NscEdhR2xUUlVwNlZsZHdRMWxXVG5OYVNFcFlZWHBzVmxsclduZFhWbkJKWTBWT1YwMXJXbmxaVkU1dlZqRktSbGR0YUZaTlJuQlFXa1phVDJSSFRrZFViV3hYWVROQ2RsWnRNWGRSTWtsNFVsaHNWMkpyTlZsWmJYUjNWMVpzYzFadFJtcFdiRXBZV1ZWV1QxVXlTa2RqUm14YVRUTkNXRmxWV21GamJVNUZVbXhhVjAweWFEWldiWEJMVWpKT2RGTnFXbEppU0VKWVZXeGFkMWRHWkhKVmEwcHNVbXhzTkZkcmFFOWhSa2w1WlVoQ1dsWkZTak5XTW5oaFl6RndTVnBHVms1aE1uY3dWbXBLTUdFeVJsZFVhMXBxVW0xNFlWWnJWVEZXUmxsM1YyNU9hazFXY0ZaVmJYaFRWVEpLU1ZGcmNGaGlSbHB5VkZWa1IxSXhaSFZUYlhCVVUwVkthRlpHVm10VWF6RlhWMjVHVTJKSVFuTlpiRlpoVTFac1ZsZHRkRmROVlhCWVdUQlZlRmRHWkVsUmEyaGFWa1Z3VkZacVJsTmtWbFp6Vkcxc1UxWkdXakpXYTFwVFVURk5kMDFJYUZoaWF6Vm9WV3RhUzFsV1duUk5WazVzVm14S1dGWXlNVEJYUmtsM1ZtcFdXbFpYYUZCV2JURkxWbFpLYzFWc1pFNVNia0pWVm0xd1IyRXlUblJWYTJSb1VtczFjRlZ0ZUhKbFJsbDVaVVprYUUxVmJEUlhhMVpyVmtaa1NGVnNhRnBXTTAxNFZtMTRjMk5zWkhWYVIzQnBVbTVDTkZaVVNqQk5SbVJIVjFoa1dHRXllR0ZXYkZwM1kyeGFWVkpyZEZkTmF6VkdWako0YTFVeVZuSldXR1JYVjBoQ1RGWkVTazVsVmxKeVYyMUdVMDFHY0ZWV1JtTXhZakZhVjFkdVJsSmlSMUpWV1Zod1IxZEdXWGxPVlRsWFlsVldObFpYZUVOV2JVcFpWR3BTVldKR2NGZGFWbVJUVTBkU1IyTkdaR2hOTUVwaFZqRmFWMkZyTlZkWGJsSlVZVEpTY1ZWc2FHOVhSbEpXVjI1a2FGSnVRa2RYYTFwclZrWmFkVkZyYUZwV1ZuQlFXVlphVDFKc1RuSmhSbVJwVWpBME1GWkhkR0ZWYlZaSFdrWnNhVkpzU25CVmFrWkxWMnhrVjFWcmRGWk5WMUpJVmxkNGIxUXhXalppUm1SV1lsUkZNRlpxUm1Gak1rWklUMVprVTJKSVFqVldha2t4WkRGWmVGZFljR2hUUlhCaFZtMTRkMk5zVlhkYVJXUlRUV3RhU0ZsVlpHOVViRnBaVVd0V1YwMXVVbFJWZWtaYVpVWk9XV0ZHYUdsaGVsWjNWbGR3VDFFeFdrZFZiRlpTWVROU1dGbHJXbmRXYkZaWVpVZDBWMUpVUmxoV01uaHZWakF4ZFZWdVNsZE5SMUpNVlRCYVYyUkdTbk5hUjJ4WVVqSm5NbFpyWkRCWlZteFlWV3RhVDFadFVsWlpiR1J2VkRGYWMxcEVUbXhpUm5CNFZUSndVMkZGTVZkalJtaFhUV3BXVUZZd1pFdFRSMFpIVjJ4d2FWSXlhREpYYkdRMFdWZFNTRlpyYUd0U00wSlBWakJXUzFOV1dYbGtSM1JxVFZaV05WVXlOVXRXUmxwR1kwWm9XbUpIYUVSV1JWcFRWbXh3Um1OSGVGTmlWa3BoVjFkMFlWUXhaRWRUV0d4b1VtNUNXRmxzYUZOWFJsWTJVbXh3YkZJd2NFcFdSekZ2VlRKV2RHVkdaRmRXZWtJMFZGVlZNVll5VGtkWGJHUlhVbXh3ZGxkV2FIZFNNVmw0Vlc1T2FGTkhVbGxWYWtKWFRrWnJkMkZGZEZkTlZuQkhWVzF3VTFsV1NsZGpTR3hoVm5wR1RGVnFSbmRUUjBwSFdrWk9WMkpHYkRaV2JURjNVakZzVjJKR1pHRlRSa3BZV1ZSS1UxWnNiSEphUkZKcFRWWmFNRmt6Y0VkaGJFcDBaVVp3V2sxR2NISldha1poWkVaV2MyRkdhR2hOVlhCVlZtcEtORmR0VVhkTlZsWldZa2RTY0ZacldtRlZWbHAwWTBWMFZFMXNTa2hXYlRWUFdWWktjMWRzYUZwaE1taERXbGQ0YTJNeGNFVlZiSEJYVFZWd1NGWkdXbUZaVm14WFUyNVNWbUpIYUdGWlZFcHZVa1pTZEdWSFJsZFdhelY0VlZjeGIxUnNXblJrZWtaWFZrVnZkMWxVUm1GVFJrNXlZVWRvVTJKWGFGbFhWekF4VVRGT1IxZHJXbGhpUjFKeVZXcEdZVk5XY0VaYVNHUlZZa2RTUjFVeWRITldNREYxVlc1S1dtVnJXbGRhUkVGNFYxWldkR0ZHVG1oTk1FcGFWakZrTkdJeVNYbFViazVXWW10d1dWbHRjekZYUmxKWFdrWk9UbFpzY0VsVVZsWnJWakZLY21OR2NGWldNMmg2VmpCYVdtVnRSa2RoUm1oWFlraENlVlpYY0VkaE1sSlhWbTVTYkZKc1NsUlVWbFozVjBaYWMxa3paR3hTYkZZMFYydG9UMkZGTUhsVmJHaGFZa2RvVkZacVJsTldiRlp5V2tab1UySllVWHBYVmxadllURlplVkpxV2xOaWJXaFlXV3hvVWsxR1duRlRhMXBzVm14YWVWcFZXbUZoVm1SR1RWUlNWMkpZUWt4VmFrWktaVVp3U1ZOck9WZGhlbFozVjFaU1EyUXhVWGhYYmxKT1ZrWktXRlJXWkRSWFJteHlWMjEwV0ZKdFVrbFpWV1J2Vm1zeFIxWllhRnBXVm5CWVdrVmtUMDVzU25OV2F6VlhZbXRKTWxadGVHdE9SMFY0VlZob1dHSnNTbGRaYlRWRFYwWnNjMkZIT1dwaVJtdzFXbFZrUjJGck1WZGpTR2hYWWxob2FGbFdXa3BsVjBaSllrWm9WMkpXUlhkV1dIQkxWREpPY2s1V1pHRlNNbWhVV1cxMFMyUnNXa2RhUkZKVVRWWndTRmRyYUV0V2JVVjVWVzVLVlZadFVsUlZNVnBoWkVkU1NFOVdXazVoTTBKSVZrZDRZV0l4WkhOWGExcFlZV3MxVmxsclduZFpWbkJYV2taT1ZGSnJjSHBXVjNNeFlVVXhXVkZzY0ZkaVJrcE1WR3RrU21WR1duSmFSbFpvVFcxb2RsWlhNSGhPUm14WFlrWldVMkp0VW05VmJYaHpUVEZaZVdWSGRGVk5hM0JIV1RCb2QxZEhSWGxWYWs1WFVqTm9ZVnBWV2s5alZtUnpXa2RvYUUxcWFETldNV1IzVXpGSmVGUnJaRmhpYkZwVldXdGtiMk5HVm5GU2EzUllWbXh3TUZrd1ZUVmhWVEZ5VjJ0b1YwMXFWa2hXVjNoaFVteGtjMVZzVmxkaVNFRjZWMnhrTkdNeFduTmpSVlpXWWtad1QxWnRNVE5OUmxwVlUycFNhazFYVWtoV01XaDNWbTFLV0dGR1pHRldNMUpvV1RKNGMwNXNTblJrUjNCcFZsWndTbGRzVm1GVU1XUkhVMjVLYWxKdVFsaFpWRVozWVVaa1YxcEdTbXhTYmtKSFYydGtiMVJyTVhOVGJHeFlWak5TVjFSV1dtdFNNVlp6V2tab2FXSldTbFZXUmxwaFl6QTFWMk5HV2xkaGVteFlWRlphYzAweFduUmpSazVZWVhwR1NGWXlOV0ZXTURGeFVteG9XazF1YUhKWk1qRlhVakpPU0dWSGFFNVhSVWt4Vm1wR2IyUXhTWGhXV0d4V1lUSm9WRmxVUm5kVlJscDBUVlpPV0Zac1ducFdiVFZyVm0xS1IyTkVRbFZXYkVwVVdWVlZlRkpXV25KaFJtUk9WakpvTWxkV1dtRlRNbEpIVm01T1ZtSkhVazlWYWtaTFRXeGFjVkZ0Um1wTmJFcEpWa2R3WVZVeVNsaGxSVGxYWWxob01scEVSbXRXVmxKMVdrWk9UbFp1UWpWV1JscGhZVEZhU0ZOcmFGWmlSMmhZV1cwMVExZEdXa1pYYlVaVVVsUkdWMXBGV2xOV01rVjRZMFJXVjAxdVVtaFpWRVpUWkVaT2RWVnRhRk5oTVhCWlYxZDRVMUV3TlVkV2FscFRZVE5DYzFadGVFdGxWbVJ5V2tWa1ZrMXJjRmhWTW5oRFYwWmFObEZxVWxwaGExcFFWbXBHYTJSV1ZuUmxSazVPVW01Q1YxWnJXbUZaVjAxM1RsVmtZVk5GY0c5VmJHaFRZakZXZEdSSVpHeGlSM1F6VmpJd05WWXhXbk5qUldSYVRVZG9hRlp0YzNoV01rNUlZVWRHVTFac1dUQldWRVpyVWpGSmVGZHVVbWxTYlZKd1ZUQldSbVZXV25STlZGSm9ZWHBHV0ZaV2FHOVhSbVJJWlVaV1dsWkZjSFpXYWtaelkyeHdTRTlXYUZOaVdHZzJWbXhrTkdFeFZYaFRiazVZWW01Q1dGUlhjRWRUUm14WVl6Tm9XRkpzV25oVlYzaFhWR3haZUZOWWNGZGhNbEV3VlhwR1NtVkdjRWxUYld4VFlsWktXVmRzWkRCU01EVkhWMjVLVm1FeVVsaFpiRnBoVjBaYVNFNVZkRnBXYTJ3MlZWZDRVMWR0UlhoWGFrNWFWbFp3Y2xZd1pGTlRSMUpIVjJzMWFWSllRVEpXYlhCTFRVZEplVk5yWkZSaWJFcFhXVzEwWVZkR2JITmhSazVvVW14d01GcFZXbXRoTVVsNFYydGtZVkpXY0ZoWlZscExaRlpHY1Zkc2FGZFNWWEJ2VjFod1IxZHRWbGRVYms1WFlrVTFiMWxyYUVOV01WcDBUVWhvVmsxVk5VaFpWRTV6WVdzd2VXRkdhRlZXYlZKVVdsZDRjMVpzY0VsVWJGcE9Va1ZhV0ZkVVFtRmpNVmwzVFZab1ZsWkZTbUZaVjNSaFZqRndWbGRzWkdwaVNFSklXVlZrYzJGRk1IZFRibHBYWWtkT00xcFZXbFpsUm5CSFdrWm9hV0V4Y0ZSWFYzaFhXVlphVjFadVVteFNNRnBQVlcwMVExWXhaSEpXYlhSWFRVUkdSbFZ0TlhOWGF6RkhWMjVhVjAxdVRqUlZha1pyWkZkT1IxcEhhR2hOV0VKMlZtdGplRTVHVFhoYVJtUnFVbGRTV0Zsc1pHOVVNVmwzVm10MFZXSkdiRFJaVldoclZUQXhjbFpxVmxkV00yaHlWbXhrUzJOck5WZGFSbkJwVWpGRmQxWnRkR0ZYYlZGNFYyNUthMUp0YUhCVmJUVkNaREZhUjFadE9XbE5Wa1kwVlRJMVUySkdTblJWYkZwYVlUSlNkbFpWV2xwa01YQkdaRVpTVTJKR2NEWlhWM1JoWkRKR1JrMVlUbFJpUmxwWVdXeG9VMkZHV2xWU2JIQnNVbTFTTVZaWGVFOWhWbVJJWVVoa1YxWjZRWGhWVnpGU1pVWndSMVpzU21sV1ZuQjJWa1prTUZsV1pFZFdXR3hQVmxoU2IxbHJWbmRTTVZWNVRWVmtWMDFyY0VoWk1GSlBWakZhVjJOSGFGcE5WbkJRV1RJeFUxSXhVbkpPVm1ST1ZsZDNlbFpxUm1GV01XeFhZa1pvVTJFeWFGUldNR1J2WTFaV2RHVkhSbGhTYkhBeFdUQldZVlJzU25SVmJHaFlZVEZWTVZsWGMzaGphelZXV2tab2FFMVlRbFZYVmxwaFYyMVdkRkpyWkZkaVIxSndWbXRXUjA1R1dsZFZhMlJvVFdzeE5GZHJhRmRXYlVwWlZXeFNWVlpXY0ROYVJFWmhVakZrZEZKc1RrNVNSbHBKVm1wSk1WVXhVWGhYYkZacFVtMTRWMWxYZEV0Tk1WVjNWMjVLYTAxWFVqRldSM2h2WVZaS2RWRnJhRmRXTTJoMldXcEdXbVZXU25WVGJHaHBZbXRLYUZaR1l6RmlNa1pIVjI1T1dHRXlVbkZaV0hCWFYwWmFTRTFZVGxoU2EydzFXVlZhZDFZeVNsVlNhazVXWld0R05GVXdXa3RYVjBaSFlVWm9VMDB5YUZkV01WcFRVakpSZVZSc1pGZFhSMUpvVld0YVMxZFdWblJsUlhSWVZteEtlbFpzVWxkV1ZURldZMGh3V2sxR2NHaFdiVEZMVmxaS2NtRkdaR2hoTUZrd1YxUktlazFXV25OalJXUmhVbTFTVDFSWE1XOU9WbHAwVFZoa1ZFMVZNVFJXUjNoclZUSktjMU5zUmxkaVZFWjJWakJhYzJNeFdsVlJhelZUWWtoQ05WWXhVazlpTVZsM1RWWmFUMVpYYUZoVmJuQlhWRVprVjFkcmRHdFNNRnBLVlZkNFlXRldTbkpqUm14WVlUSlJNRmRXV2twbFJtUjFWV3hDVjJFelFsQldiVEF4VVRGa1YxZHVSbFJXUlZwV1ZGWmFkMDFHVm5SalIwWm9WbXMxUjFVeWVHRldNa3BaWVVkb1YwMUdjRlJaTW5oclpFWktkR1JHVGs1V2JrSkxWakowVjFsWFJYaFZibEpUVjBkb1dWWnJWbUZYUm14eVdrWktUbEp0ZHpKVmJURkhZVEZLY2s1WWJGcFdWMUoyVm10YVMyUldSbk5oUm1SVFlrWndiMWRyVWt0V01rMTVVbGh3YVZJemFGUlVWVnAzWlVaa1dHVkhSbFJOVlRWSVZqRm9jMVJzWkVaT1ZtUlZWak5TTTFwV1dsWmxWMVpKVkd4a1RtRXhXVEJYVkVKcllqRmtkRkp1U21wU2F6Vm9WbXhhZDJOc2NFZFhiRTVxVFd0YVNWbHJaRzlpUjBwSFkwZG9WMkZyV21oV1ZFWk9aVlpPV1dGR2FGaFNNbWhhVjFjeE1GbFdXbk5pU0U1V1ltczFXRlJXV21GTlJuQldZVWQwYVZKc2NEQldWelZ6VmpBeGNWSllaRmRpV0U0MFdUSXhUMUpzY0VkV2JXeFRUVzFrTmxadE1IaGxiVlpJVld4b1UyRXllRlZaYTJSVFlqRnNWVkp1WkdsTlYxSjVWakl4UjFVd01YSk9XSEJhVFVaYWNsZFdXa3BsVjBaR1QxWmthVlpHV2tWV2FrbzBXVmRTUmsxV2JHRlNhelZQVm14U1ZtUXhXblJOVkVKb1RWWndTVlV5TlU5WFIwcEhZMGRHV2xaRldsZGFWVnB5WkRGa2MxcEhkRk5XUmxwWVZtdGtOR0V4VW5OWGJsWlNZV3hLV0ZadE1WSk5SbVJYVjJ4T2FrMVhVakZXUjNocllVZEtSbU5HYkZkU2JWSXpWbXBHVjFJeFpIVlNiRkpvVFRGS1dWZFhkR3RWTWxaelYydG9iRkp0VWxoVVYzUjNVMnhXV0UxRVZsZE5hMXA1V1c1d1ExZHRWbkpqUmtKYVpXdGFhRnBHV2xOak1WcDBZa1pPYVdFd2IzcFdiVEI0VGtkSmVGSllhRlZoTWxKWldXMTBZVlpXYkZobFJYUnBUVlpLV0ZZeU5VOVVNVXB6Vm1wV1ZXSkdWVEZXYWtaS1pESk9SbUpHY0ZkV2JrSXlWbTF3UzFKdFZrZGFTRVpWWWtad1QxVnROVU5oUm1SelZtMUdhMDFWY0hwWk1GWnJWbGRLV0dWR1VscFdSVFZEVkZkNFlXUkhUa1prUlRsVFRVWlpNVlpYTVRSaE1WcElVMjVPV0dKRk5XRldhMVV4VWtaWmQxZHVUbXBpU0VKSVZUSXhNRlJzV25WUldHUllWa1UxTTFWcVJscGxWa3B4VjJ4a2FWTkZTbGxXYlhCUFlqRmtSMkpHV21GU1dGSlZWbTEwWVUxR1VYaFhiWFJYVFd4YWVWWnRjRTlYUjBWNFUydG9XbFpGV2t0YVZWcDNVMVphYzFadGJGTk5iV2d6VmpGa05GbFdUWGhYYms1WVlrZG9UMVpyV2t0amJGSlhXa1pPV0ZKdGRETldiVEZIVmpBeFYyTkZhRmROYm1ob1ZteGFZV014WkhGVWJVWlhZa2hDYUZkc1dsWk5WbVJYWTBWa1lWSXllRmhXTUZaTFlVWlplRmRzWkdoTmEydzBWakZvYjFkSFJYaGpTRVpXWWtkU2RsWnRlSE5qTWtaSVQxZG9VMkpZVVRGWFZFNTNVakZaZDAxV2FGWmhhMHBoV1ZSR2QxVkdiRlpXV0dSclRWVndXbGxyV210aFZtUklZVWM1VjJKR1NraFZNakZYVWpGd1IySkhhRk5pVjJoYVZsZHdTMkl4WkhOYVJtaE9Wa1ZLY2xSV1dtRlRSbGw1VGxWa1YxWXdWak5VYkZwaFZsWmFjMk5FVG1GV00yaGhXbFpWTVZkSFVrZGhSazVvVFRCSk1sWXhVa05aVjAxNFYyeGtXR0pyTlZWWlZFWkxWMFpzVlZKc1pFOVNiSEI0VlRKek5WVXdNWEpqUldoWVlUSlNlbFl3V2twbFZuQTJVMnhrVGxadVFsbFdNVnBoVkcxV1YxWnVTbUZTYlZKd1dWaHdWMkl4V2xoTlNHaFdUV3MxU0ZZeGFHdFpWa28yWWtoQ1ZWWnNjRE5XYlhoWFYwVXhWbHBHWkU1aE0wSlpWbGN4ZDFVeFdYZE5XRVpYWVRKb1dGbHNVa2RVUmxaMFkzcEdXRlpyV25wV01qRnpWVEF4ZEdGRldsZGhNbEV3VjFaYWMxWXhaSE5hUmxacFlURndXRmRYZEdGVE1WRjRWMjVTVGxaRk5VOVZiWGgzWlVaVmVXTkZUbWhXVkVaNVZqSjBiMVpyTVhWVmJrcGFWak5vVEZwRlpFZFNNa1pIWTBkc1UwMXRaM2xXYTFwVFVqRmtkRlZZYUdGVFJUVm9WV3BPUTFkR2JGVlVhMDVQVm14c05WcEZaREJoTURGWFUyNXdWMDF1YUhwV1Z6RkhZekZPYzJGR2NHbFNhM0JGVmtkMFlWVXlUbk5hU0U1WVlsaG9WRmxzV2t0T2JHUllaRWRHVkUxcldsaFZNalZMWVd4S2RHVkdiRmRoYXpWMldrZDRjMk5XU25OalIzaFRZa1p3TmxacVNqUmhNV1JIVTFoc2FGTkhhRmhWYlhoM1lVWndSVk5zWkdwTmEzQklWakl4UjFaR1NsVldiR2hYVW14d2NsWlVSa3BsUmxwWllrVTVWMlZ0ZUZsV1JscFhaREpXYzFkWWJFOVdXRkpZVm1wQ1YwNUdXblJqUms1WFRXdGFlVll5TlV0WGF6RnhVbXRvVm1KWVRURldha1ozVW1zMVYxUnRiR2hOUjNjeFZtMHdlRTFHYkZkaVJtaFRWMGRvV0ZZd1pHOVdWbGwzV2tjNWFVMVdTbFpWTW5oUFlWVXhWMWR1Y0ZoaE1YQlFWakJhWVdNeFpIVmhSbHBYWld4YWVWWnRkR0ZaVjFKSVZtdGtZVkp0VWs5WmJYaExWVlphZEdORmRGUk5WbkI2VmpJMVIxWXlTa2hWYkdoVlZrVmFTRlJVUmxwbFJtUjBVbXh3VjAxRVJUQldha28wWXpKR1IxTnVVbFppYTBwWFdXeFNWMUpHVlhoWGJYUnFZa1p3TUZWdGVGTlViVVkyVWxSQ1dGWkZTbGhaYWtwTFVqRk9XV0pIZUZOaVJYQm9WMVpTUzFWdFZuTlZiR2hzVWpCYWNsVnFSbUZUUmxwSVpVVTVWV0pWVmpSV01WSkhWakpLUjJOSVdscGxhMXBvV1hwR2QxSnRSa2hoUmxKVFZsaENXVlpyV2xkWlZteFdUVWhvYUUweVVsbFphMXAzWTJ4U1YxZHVaRmRpUmxvd1ZGWm9hMkZHV25KalNHeGFUVVp3TTFacVJrdGpNazVIVld4a1YxSllRa2xYYTFaaFZESk9jMk5GYUdsU2F6VlVWbXRhWVZkc1dYaGFSRUphVm1zeE5GWkhkR3RoVmtwMFlVaEdWVlpGY0haV01GcHpWMWRPUjFwR2FGTmlWa28xVm1wSk1XRXhXWGROVm1ScVUwaENXRmxyWkc5a2JGcHhVMnRhYkZac1dsWlZWM2hoVkcxR2NsZHNVbGhoTVVwRFZGWmFXbVZHWkhWVWJGSnBWak5vVmxaWGVGZGtNREZ6VjI1S1dHSllVbEJWYlhNeFRVWmFkRTVWT1ZwV2EzQXdWbGQ0YTFkc1drWmpSbEpYWWtad1ZGWXdaRmRTYlZKSFlVWk9hVmRHUmpaV2JUQjNUVlpSZUZkdVVsUmlSbkJ4Vld4a2IxZEdVbGhqUm1SV1VteHNOVnBWWkVkVk1rcElWV3BHV21FeVVraFdWRVpMVmpKT1NXSkdhRmRTVnpoM1YxWlNTMVV4U1hoVWJsWldZbGQ0VkZacldtRlhWbHAwWkVkR1dsWnJOVmhXTWpWTFdWWktSMU50UmxkaVdHaDZWR3RhV21WWFVraFBWbVJUVFVaWk1WZHNWbUZVTVdSMFVsaHNWbFpGU2xoWlYzUmhaV3hyZVdWSVpGTk5WVFY1Vkd4YVQyRlhSWGRqUlhCWFlsaENTMXBWV2twbFZrcDFVMnMxVjJKWGFIbFdWM1JoWkRGc1YxZHVUbGhpYlZKeFdXdGFkMU5XVWxkV2JVWnBVbXRzTTFSc1ZtdFhiVVY0WTBoYVYyRnJjRXhWYlRGUFVqRktjMkZIYUU1V1dFSktWbXBHWVdFeFVuUldhMlJxVWxkU2NGVnFTalJXUm14eVlVVk9hMDFXY0ZsYVZXTTFWV3N4V0ZWc2FGZE5hbFpVV1ZSR1MyUkdWbk5XYkZaWFlraENUVlpVUW1GWlZtUkdUbFphVUZadGFGUlVWV2hEV1ZaYWMxbDZSbE5OVm5CWVZqRm9kMVp0U2xoaFJtUmFWak5TYUZreWVISmxWMVpJVW14a1YyRXpRalpXTW5SV1RWWlZlRk5zWkdwU1dFSllWRlphUzFKR2JGVlNhM0JzVW0xU1dsbFZXbTloUlRGWlVXNWtWMVl6VW1oVmVrWmhZekpLUjFac1RtbGlWa3BaVmxjeE5GbFhWa2RXYmxKclVrVktXVlZ0ZUhOTk1XdDNWbTA1VjAxRVJuaFZiVFZoVjJ4YWMyTkZlR0ZTYkhCSVdrVmFTMk14Y0VaT1ZtUk9WbFpzTmxacVJtRlZNVWw0VjI1U1YyRXlVbGRaYlhSM1lVWldjVk5xVWxkU2JYaDZWMnRqTlZac1NuTmpSRUpWVm0xb00xWkhlR0ZqTWs1R1lVWmthVlpHV2xWV2EyUTBXVlpLYzFSdVRsSmlTRUp2VkZab1EySXhXbkZTYlVaclRWWndlbFl5TlV0VlJscDBWV3hvVlZaWGFFUlZNbmhoWXpGd1JWRnRjRTVXTVVwS1ZsY3dNVk14VVhoYVJXUnFVbTFvVmxac1pGTldSbFp4VW01a1YwMVhVbnBXUnpGM1ZqSktSMk5FV2xkaGEydzBXV3BLUjFKck1VbGFSbEpwVTBWS1dWZFhlRk5STURCNFkwWmFXR0Y2Vm5OVmJYTXhUVlphV0dWRk9XaFNWRVo2VlRKNGMxZEdXWHBoU0VwVllUSlNTMXBWWkU5U01rWklaVVpPVGxKdVFqTldhMXBoV1ZkUmQwMVZaR2hOTWxKWVdWaHdjMWRHVWxoa1JuQk9Za1phTUZwVlpEQldNVmwzWTBWc1dsWldjRVJXYWtGNFUwWldjbHBIUmxkaVZrcEpWbGN4ZWs1V1dYaGpSV2hwVW1zMVQxWnNhRU5XTVZweFVteE9WRTFFVmtoV01XaHpWbTFGZUdOR1FsZGlXR2d6Vm0xNGMyTnNjRWhQVjNCVFlrWnZkMVpIZUZkVU1WcEhWMjVPYVZKR1dtaFZiR1JTWkRGYVNHVkZkR3BOYXpWS1dUQmFhMVJ0Um5OWGJFWlhZbGhDVEZWcVNrOWphelZYV2tkR1UySkdjRmxYYkdRMFdWWktWMWR1UmxKaVZWcFpXV3hhUjA1R2EzZFdiVVpvVFZWd2VsVXllRk5XVmxwWFkwUk9WazFHY0hKV2FrWmhaRVpLYzFwRk5WZGlXR040Vm14U1MwNUhSWGhYYTJoVFYwZDRjMVZ0TVc5WlZscHhWR3hPYUZKdGVGZFdNakZIVlRGYWNrNVljRmRTTTJoVVZsUktTMU5XUm5GV2JHUm9ZVEozTUZaSGRHRldiVlpYVTJ4c2FsSnJjSEJWYkZaM1YyeGFkR05GT1ZaTlYxSklXVEJXVjFWc1drWlhiRkpWVm0xU1ZGWXllSE5XYkhCR1drWmFUbFpZUWxoWFZFSnZXVlpaZUZOdVRtcFNiV2hoV2xkMFJtVkdXbkZTYlhSclZteGFlVlF4V210aFIxWnpWMnh3VjJKVVFqTmFWVnBXWlVaU2MxcEhjRk5pU0VKYVYxWlNRazFXWkVkVmJHaHJVakJhYzFadE1UQk5NV3hXV2tWa1dGSXdXVEpWYlhSdlYyc3hTRlZ1V2xkTmJrNDBWbXBLVDFKdFZraFNiRTVYWW10S1RsWXhVa3RsYXpWWFdrVm9WR0V5VWxaWmEyUlRWa1pzY2xkdVNtdE5WbkF3V1RCV2EyRkZNVVZTYTJ4V1RWZG9kbFpzV210VFIwWkhXa1prVGxJeFNsVldhMUpIV1ZkU1JrMVdhRkJXTW5oUFZtMTRkMDVzV1hsa1JrNVdUVlpzTlZVeWRHOWlSazVJWlVac1dsWkZXak5XVlZwaFpFZFdSbVJIZEZOTlZuQkpWMVpXWVdJeVJrWk5WbVJwVWtVMVdGbHNhRU5STVhCV1drVTVhMUpyTlhsV2JYaHZZVlpPUmxOc2JGZGlWRUY0VlZjeFYyTXhjRWRhUm1ocFZsWndhRlp0TVRCa01sWnpXa2hLYUZKVWJGZFVWM1IzVTFaYVdHVkdUbGhpVlZZMFdUQlNUMWxXV25OalIyaFhUVWRTVUZWdGVIZFRSMFpHVGxaa1dGSlZhM2hXYlhSVFVqRnNXRkpZYkZOaVIxSlZXVzE0UzFZeGJITlZiazVYWWtad2VWWnRkREJXVmtwelkwaHdWMDFxUmtoV1ZFRjRWMGRTTmxOc1dtbFdSVm8yVjFaV2ExWXlUbk5hU0VaWVlrZFNiMWxVU2pCT1JscFpZMFZrYUUxck5YbFVWbFp6WVZaS2MyTklRbFppUmxvelZqRmFhMWRIVWtoU2JGSk9WbFJXU1ZadGVHOWhNV1JJVTJ0c1VtSnJOVmRaVjNSTFlVWlZlV1ZIUmxSU1ZFWlpWREZhYTFSdFJYaGhNMnhYWWxSRmQxbDZSbHBsVmtwMVUyMW9UazF0YUZoV2JYUlhXVmRPYzJORldsaGhlbXh4V1d0b1ExTldhM2RYYXpsVllsVndXVmxWV205V01ERllWVmhrV0ZadFVsTmFWVnBYVjFkR1NHTkdUbGRpU0VKWFZqRmFVMU14VlhoWGEyUldZa2RTYjFWc1ZURldWbHAwVGxWT1YwMVhVbmxaVlZVMVZqQXhWbU5JYkZwTlJuQnlWakp6ZUZOR1ZuVlhiR1JvWVROQ1RWWlhjRWRVTWs1MFVtdGthbEl5YUc5VVZtaERVMVpaZVdWR1pGcFdiRlkxVmxkNGExWnRTbkpPVm1oYVlrZFNkbFpFUm5Oa1JURllUMVpvVjJKSGR6QldNblJUVlRKR1ZrMVdXbGRoYkVwaFdWUkdkMk5zYkZkWGF6bFRZWHBXV1ZsVldtRmhSVEZaVVdzeFYySkdTa2hXVkVaYVpVZE9SbHBHVm1sWFIyaFZWMWQwWVZkck1WZGFSbFpWWW0xU1dGUlhkR0ZTTVZKWFYyMUdhR0pGTlVwVlZ6RkhWbFphV0ZWdVdtRlNNMmhvV2tWa1YxTkdTbkpQVjJ4VFYwVkthRlpxU2pCWlYwVjRWVzVPVkdKc1dsTlpXSEJIVjBac1dHUkhSbWhTYkZwNFZXMHhNRmRHU25KalNHeFlZVEZ3ZGxsVlpGZGpNV1J6WWtab1YwMHhTakpXVmxKQ1RWWlplRnBJVmxOaVJUVndWbXhhZDFkV1pGaGxSMFphVm1zMVNGZHJhRXRXTWtwWlZXeG9WMkZyU2pOYVYzaGFaVmRXU0dSR2FHbFdWbGt3VjFSQ2EySXhaSFJTYmtwWVltNUNXRmxyV25kVFJuQkhWMjVrVkZJeFNrbFphMXBQWVZkRmQxZFljRmRpV0ZKeVZHdGtTbVZXU2xsaVJrNXBZVE5DVUZadGVHRlpWbHBIWWtoS1lWSjZiRmxWYlhoaFpVWmFTRTFFVm1oU2EzQjZXVEJvZDFkSFJYaFhXR1JYWVd0YVlWcEVTazlTYlU1SFYyeGtUazF0YUhaV01WcFhZVEZLZEZacmFGVmhNWEJQVm0weFUxWkdiSEpYYm1ScFRWWnNORll5TVRCV2F6RldZMGhzVldKR2NISlhWbHBLWkRGa2MxVnNWbGRsYTFveVZteFdZVmxYVWtoV2EyaFRZa2RvYjFwWGRHRlhWbGw1WkVjNVZFMVdiRFZWTW5oelZXMUdObUpHYUZwaVJrcEhWRlZhV21ReFpITmpSM2hYVFZWd1NsWlhNVFJpTVZWNVUydHNVbUV5YUZoV2ExWnpUa1pzY1ZKdFJtdFNhelY2V1d0a2IxVXdNWFJoUnpsWFlsaENVRmxxUm10U01rVjZZa2Q0VTAweFNuaFhWM1J2VVRGT1IySkdXbGhoZW14dlZtcENWMDB4YTNkV2JrNVhUVVJHV0ZVeWRGTlhSbHB6WTBaa1lWWldjR2hXTVdSSFUwWktjMVJzWkdsaE1IQllWbXBHWVdFd05VaFZXR2hoVWxkU1YxbHJaRzlWUmxwMFkzcEdXRlpzV2pCVVZsSlRZa1pLYzFkcVFtRldWMmh5V1ZaYVMyTXlUa2xqUm5CT1VqSm5lbFpxU2pSWlZsbDVWR3RrVm1KSVFsaFpiRnBMVTBaa2NsVnJkRlZOVld3MFZtMDFUMWxXU1hsbFJteFdZa1phTTFaSGVGcGxSbkJKV2taU1RsWlhkekJXVkVadllqRnNWMU51VW14U01taFhXV3hTUjJSc2EzZFhiazVxVFZkU2VWcEZaRFJWTWtwSlVXdHNWMkZyYkRSVVZWcFNaVVpPYzFac1RtaE5iV2haVm0wMWQxWXhWa2RYV0dSaFVsWndjMWxyV21GTlJsRjRWMnhrVjAxcmNFcFZWM0JoVmpGSmVsVnRhRmRoYTNCVVZUQmFVMk5zY0VoU2JFNXBWakpvTTFadE1UUlpWbVJ5VFZaa1lWSnRVbGhaYkZaaFkwWlNWMXBHVG14aVJtdzFWR3hhVDFZeVNsWldhbHBhVmxad2RsWXllRnBsYkZaMFlVWndUbUp0YURWWGJGWmhZVEpTUjFOdVVtcFNWRlpZV1cxMFNrMXNXblJrUjNCc1VsUldTVlZ0ZEdGVWJGcDBZVVpHVmsxSFVUQldNRnB6VjBkU1NWZHRkRTVXTVVwWlZtcEpNVlF4WkVkVGJrNVVZV3RhV0ZacVRtOWpiR3hYVjJ0d2JGWXdXa2haYTFwdlZqSktSbU5GYkZkTlZuQm9WMVphU21WV1RuSmlSbFpwVWpGS2QxWnRlR0ZrTVdSWFYyeG9UbFpHU2xWVVZtUlRVMFpaZUdGSVRsVk5WbXd6VmpKNFlWZHRTa2RYYWs1V1RVWndZVnBWV2xkamJWSkhXa2RzVTJKVWFEVldiRnBoVlRGSmVGZFliRk5pYTNCVVdWZDRTMWxXY0Zoa1IwWnFZa2hDU0ZkclZUVlZNREZ5VGxWa1ZXSkdjRkJaVm1SR1pESkZlbUpHWkdsV1JVa3dWa1pXWVdNeFpFZFRiR3hvVW14S1dWVnFTbTlpTVZwVlVXMUdXbFpzVmpSWmEyaExZVVpLVms1WVJsWmlXR2hvVkZWYWQxWnRSa2hrUjJoWFZrVmFXVmRVUWxkaU1WbDVVMnhXVTJFeWFHRldiRnBYVGtacmVXTXphRmRXYkZwNlYydGFhMkpIU2tkalJuQlhZbFJGZDFsVVJrcGtNRFZaVld4U2FFMVlRbEpXYlRCNFZUSkplR0pHVmxWaE1EVlBXV3RhZDFac1ZYbGpSazVZWWtad2VWUnNWbk5XTVZsNlZXNWFXbFpGV2t0YVZtUkhVbXM1VjFwSGJGTmhNMEphVm10amVFNUdiRmhVYms1cVVsWmFVMWxyWkZOVU1WcDBaVWhrVDJKR2NIaFZNbkJEVjJ4YWMxSnFVbGROYWxaVVdXdGFTMlJHVm5SU2JIQlhVbGhDVlZadGRHRlpWa3BYVTI1V1lWSnRVbkJWYWtaTFRteGFWVk5ZYUU5U2JGWTFWVEo0YTFaR1pFaFZiR2hXWVRGYWFGbFZXbUZXVmtwelYyMTRVMkpXU2pWV01uUmhZakpHVjFScldsUmlSM2haVm0xNFMxUkdXa1ZSVkVaVFRXdHdSbFl5ZUZOaFJURnpVMnhzVjFKc2NISldWRUY0VmpGa2MyRkhlRk5XVkZaWlZrWmFWMlF5VmxkaE0yUllZbTFTV0ZSWGRIZFdiRnAwWTBVNVYySkdjRWRWYkdodlZtMUdjbGR1U2xwTmJtaG9XWHBHVDJNeVJrZFVhelZwVmpKb1dWWnRNVFJoYlZaR1RWVm9WbGRIZUZoWmJYTXhZMFpXZEdWSVpGaFdiWGhXVlZaU1IxZEdXbk5YYWtKaFVsZG9jbGxyWkV0VFIxSkZWR3hrYVZkRlNsVldiWEJDWlVaWmVWTnFXbFJpUjFKd1ZqQldTMVZXV25SalJYUlRUV3MxTUZaSGRHRlZSbGwzVjJ4b1YyRnJXa3hXUmxwaFZsWktkRkpzV2s1aVJYQkpWbFJKTVZReFdsaFRiR2hzVW0xb1lWWnJWVEZSTVZKWVpVZEdhbFpyY0RCYVJWVTFWVEpLU0dSNlFsaFdNMUpvV1ZSR2MxWXhVbkpYYXpsWFlsaG9hRlp0ZEZka01sSnpZVE5zYkZKdFVuSlZha0V3VFd4V2RFMVlUbFZpUm5BeFZWZHdZVll5U2toVldHUlhVa1ZhVTFwVldrOWtWbEowWWtaT1UySklRbTlXYTFwWFdWWnNXRlJ1VGxoWFIzaHpWV3BDWVdOV2JITldWRVpVVW0xU2VWWXllR3RoUmxweVlrUldXbFpYVFRGV2FrcEhZMjFLTmxGc2FGZGlSbFkwVjFod1IxUXlVbGRVYmxKclVtczFUMVZ0TlVOWGJGcHlWMnhPVkUxcmJEVlZNV2h2V1ZaT1JtTkdiRnBpUmxwb1YxWmFZV05XU25Ka1JsSlhZa2hDV2xkclZtdE5SbGw1VTJ4YWFsSlhVbFpaYTFwM1pHeGFkRTFWZEZOTmF6VktXV3RrUjFZeVNrbFJiVGxZVjBoQ1NGWnFTazlqTWs1R1drZEdVMVpHV25aV1JtTXhZVzFSZUZkdVVtcFNWMUp3VkZkemVFNUdXWGhoU0U1WFVqQndlVmt3V2tOV01ERkhWMjFvVjJGclducFpla1pYWTJ4a2NrNVdUbWxUUlVreVZtMXdTMDVIVVhsU1dHUk9WbTFTY1ZVd1pEUmhSbFp6VjI1a1YxSnNjRWxhVldSSFlXc3hXRlZzY0ZwTlJuQjJWbXBLUzFJeVRraFBWbVJvVFZWd1RWWlhjRWRVTVVsNFZXNVdWR0pYYUZSVVZFcHZWbFphV0dWR1pHdE5hMXBJVjJ0YWExWnRSWGxWYlVaWFlsaG9URlV3V210amJHUjBaRVprVGxZeFNrcFhWbFp2VWpGYVYxZHVUbGRYUjJob1ZteGFkMWRHV1hkYVJtUlVVbXR3TUZsVldtdGhWazVHVTJ0d1YySllRa3hhUkVaelZqRmtXV0ZHYUdoTldFSjNWMnhrTUZNeFdYaFZiR2hxVWxkU1dWVnRlRmROTVZsNVpVVTVhR0pWY0ZkWk1GWnpWbTFLV1dGR1FscFdiVkpIV2tSS1QxSldVbk5hUjJ4WFVsWlplbFp0TVhkU01rMTRWMWhvWVZORmNHaFZiVEZ2VjFaV2NWUnRPV3hTYkhCWldsVmtNRlpyTVZkV2FsSlhWak5vY2xZd1pFdGtSbFp6Vm14YWFWZEhhRzlXUmxaaFZUSk5lRnBJU2xCV2JXaFVXVlJLTTJWc1duRlNiRTVVVFZad01GVXllRmRXTWtWNFUyeG9XbFl6VWpOV1JWcGhZekZrZEZKdGNHbFNiSEEyVm0weE5HRXhWWGhYYmxaU1lXeGFXRmxzYUVOU1JscDBUVlprVTAxV1NucFpWVnBQWVVVeGMxTnNjRmhXTTJoeVZHdGFhMUl4WkhWU2JGWnBWMFZLZVZaR1dtRmpNRFZIVjFoc2JGSlViRmhXYkZKSFpWWlNWMVZzVGxkTmEzQmFWbGMxUzFZd01VaFZhMlJoVmxkU1VGVnFTa3RTTWs1SVlrWm9VMkV6UWs5V2JYQkhXVlpzV0ZSWWJGVlhSM2hVV1ZSS2IxVldXblJsUjBaWFVtMTRlVlp0TldGaE1ERllWVzV3VjJKVVJraFdiRlY0VmpGYWNWWnNXazVpYkVwNVZtMTBhMU15VWtoV2EyUm9VbXh3YjFsWWNGZE5iRnBIVld0a2FrMVdjSHBXTW5oellVWkplbEZzYUZWV1ZuQjVXbFphWVZkRk1WVlZiV2hPVm14WmVsWkdWbTlqTWtaSFZHdG9iRkp0ZUZoWlYzTXhVa1phUmxkc1pHcFdhM0I2V1RCa05GVXlTbkpUYTJ4WVZqTlNjbGxxUmxabFZrNXpXa1pTYVdKV1NscFdiWEJQVlRKR1IyTkZWbE5pU0VKelZXMHhVMlZzYkZaYVJGSldUV3R3U2xWWGVFTldNa3BWVWxoa1lWSkZXbEJWYWtacll6SkdTR1ZHVGs1TlZYQnZWbTB3ZUUxSFVYaFhiazVZWW14S1VGWnNVbk5YUmxKWVpFaGtXR0pIZUZkV1YzTTFWakZhYzJOSWNGcE5SMmd6VmpKemVHUlhSa2xUYlVaVFlraENWVmRZY0Vka01VNUlVbXRvYkZJeWFFOVdhazVxWkRGYWRFMUlhRTVTYlhoWlZURm9jMVpzWkVoaFJteFhUVWRTVkZaRVJtRmpNWEJIVkd4b1YySllaM2RYYTFaclVqRlplVk5yWkdwU1JVcG9WbXhrYjJOc2JISlhiVVpyVm10YWVsbFZXbXRVYlVweVRVaG9XRlpzU2toWFZtUlBZekZ3U1ZadGNGTmlTRUpRVjFjd2VHSXlWbGRYYmtwYVRUSm9WVlJXVm5kTlJscElaRVprVjFJd2NFbFdWelZEVmpKRmVGZHRSbUZXTTJob1ZqQmtUMUp0VWtkV2JXeFhZa2hDV2xadGRHcE5WbGw0VjJ4b1ZHRXlVbGxaYTJRMFZqRnNXR1JIUmxWU2JYaDRWVzB4UjFkR1NYZE9WV1JYVWpOb00xWnFRWGhTVmxwellrWmthVlpGUmpSV1YzQkhWakpTUjFSdVZsWmlSbkJ2V2xjeE5GZEdaRmhsUnpscFRVUkNORll4YUd0WFIwcHlUbFpvV21FeGNETmFWbHBTWlVaa2RHUkdXazVTUlZwTFZsWmtNR0l4V1hoVFdIQm9VbTFvYUZWclZtRlpWbkJXVjIxMGFsWnRVbnBXUnpGdllVZFdjMWRzY0ZkaE1YQnlXa1JHU21WR1ZuSmFSbWhZVWpGS2IxWlhNSGhWTVZwSFlraEtXR0V6VW5OWmEyUTBWakZrY2xsNlZtaFNhM0JXVlcxMGQxWnNXbk5UYTNoWFlXdHdURlV3V2xkWFZuQkhZVVprYVZORlNrMVdNbmhoV1ZaWmVWUnVUbUZUUlhCUVZtMHhVMk5HV25GVGJUbE9Za1p3ZWxkVVRtdGlSa3B6Vm1wV1YxSnRhSFpaVmxwUFVtMU9SMkpHY0dsV1JWcFZWbXhXWVZsWFVraFdhMnhoVWpOb1dGbHJhRUprTVZwSFYyMDVhRTFyV2xoVk1qVkxZV3hPU1ZGc1pGcGlSMmhFVmpCYVlXTldTblJTYXpscFVtNUNObFpzWkRSaE1rWlhWMnRhV0dGNlJsaFdhMVpMWTJ4V2NWSnJjR3hTYTNBeFZrY3hSMVV3TVhSaFJrSlhZbFJCZUZWVVJsTmpNV1IxVkcxb1ZGSXhTbFZXUmxwaFl6QTFSMWRZYkd4U00xSllXV3hXZDJWV2EzZFhhMDVYVFd0d1NGVXlOWGRXTURGSFkwaHdWMDFYVWxCVmFrWjNVakpHUjFSdGJGUlNWV3Q1Vm0xd1MwMUdWWGhTV0doaFUwVTFXVmx0Y3pGV1JteFlZM3BHVjJKR2NEQmFWV2hyWVRKS1NHVkdaRmROYmxGM1ZqQmFTbVZHWkhKaFJtUk9ZbTFuZWxadGNFZFRNV1JYVW01T1YySkhhRmhWYkdNMFpERmFkRTFJYUZkTlYxSklWakkxUzFkSFNraGhTRUpYVFVad1RGWlZXbUZrUjFaSVQxWkthVlpyV1RCV2Frb3dZakpLUjFOWVpGaGlhM0JXVm0xNGQxUkdVbFpYYkdSclVsUldWMXBGV205Vk1ERkpVV3R3V0dKR1dtaFpha1poWkVaT2MySkhhRk5OYldob1ZrWmpNV0l5UmtkWGJrNVlZVE5TY2xWcVJrdFRSbVJ5VmxSR1YwMXJWalZVTVZKVFZqSktWVkZxVWxWaE1sSkhXbFphUzJOc1pISk9WbEpUVFZWd1YxWXhaREJaVm14WFdrVmtWMkpzU25OVmFrSmhWMFpXZEdWSVpFNVNiRXBZVmpJeE1GWXdNVVZTYkhCV1ZqTlNNMVp0YzNoa1YwWkpWMnh3VjJKSVFubFdWekUwVkRKTmVGSnVUbUZTTW5oWlZXcEtiMVpzV25OYVNHUlRUVlpHTkZZeGFHOVpWazVHWTBjNVZtRnJOVVJXYTFwVFZteGtkVnBIZEdsU2JrSkpWbXBLTkdFeVJuSk5WVlpTWVd4S1dGWnVjRmRWUm14V1YydDBWMkY2VmxoWmExcDNZVVV4V1ZGWWNGaGlSMUV3VmpJeFYxZEdWbkpoUmtKWFlsZG9kMVp0ZUc5Uk1XeFhXa1prVjJKRk5WWlVWbVJUVFVaYWRFNVZkRmhTTUhCNVdUQmtSMVpXV25OalJFNVhUVVp3TTFWdGVIZFNNVkp6VkdzMVdGSlZjRXRXTVdRd1dWZEZlRlZ1VWxSaVIyaHZWV3hTUjFkR2JITlZhMXByVFZkNFZsVldhRzlXUmtweVkwWndXbUV4Y0ZCV01GcEtaVmRHUjFwR2FGZGxhMWt5VmtaYVlWbFhUWGxUYTJSWFlrVTFjRmxzV2t0bFJscDBUVlJTVjAxRVFqUldNalZQVm0xRmVWVnRPVlppV0ZJeldsZDRXbVZWTlZsYVJtaFRUVVpaTVZacldsTlNNVmwzVFZWa2FsSllhR2hWYlhoM1UwWnNObE5yWkZOTmExcEpXVlZWTVZZeVNsbGFSRnBYWVd0YWFGbFVRVEZTTVZKWllrWldhV0Y2Vm05V1ZFSlhXVlpWZUdKSVNtaFNWVFZXVkZaYVlXVkdWblJrUkVKVlRXdHdTRmt3YUhOWFIwVjVZVVJPV21FeGNFeFpla3BMVWxaYWMxZHJOVmROYldRMlZqRmFWMWxXVFhsVmEyaFRZVEpvVVZadGVHRlhSbXh5WVVWS2JHSkdjRWhYYTFKVFYyeFpkMDVZY0ZwV1JUVXpXVlZhUzJNeVRrWlBWbVJwVmtWV05sWkdXbUZaVm1SSVZtdG9VRll6VWs5WlZFWjNWMVphVlZOVVJsUk5WbkJKVlRKMGIySkdTblJWYlVaYVlUSlNkbHBIZUZOV1ZrcDFWR3hrYVZJeFNYZFdWekUwVkRGU2MxcEZXbFJoTWxKWVZtMHhVazFHYkhGVGEyUlhUVmRTTVZVeWVHOVdNVXBXWTBac1dGWnNTa2hhUkVwVFl6SktSMVpzVW1oTmJFcFZWa1phWVZNeVZsZGlTRXBZWVROU2IxWnRlSE5PVm14V1YyMTBWMDFyY0ZwVlYzaERWakZhUmxKcVRtRldWbkJZV1hwR2EyTXlSa2hpUms1T1ZsaEJNVlp0ZUd0T1JsVjRWMWhvWVZKWFVsbFpWRXB2WXpGVmQxcEdUbGhTYkVwWldrVm9hMVpIU2tkWGJHeGhVbGRvY2xacVFYaFdiVTVHV2taa1RtRnNXa2xXYlhoaFdWZE5lVlJyYkdwU2JWSnZXVlJHZDFWV1pISlhiVVpYVFd4S1NWVnRkR3RXVjBwWVlVVTVWazFHV2t4YVIzaGhZMVpLZEZKc1drNVdWRVV3Vm0xNGIySXhXWGxTV0d4V1lsUnNWbFpyVm5kV1JteFdWMnhrYTFJeFNrcFhhMlIzVkd4YWRWRllaRmRTTTJoWVZrUkdZVkl4VG5WVmJYUlRVbFJXV1ZkWGRHRlRNVTVIWWtaYVdHRXpRbkpVVjNNeFUwWnJkMWR0ZEZkTmEzQkhXVEJXVjFZeVNsbFJhMDVoVmxad2NsVnFSbGRrVmtwelZtMXNVMkpJUWxwV01XUXdZakZGZUZwR1pHRlNiRnBWV1cwMVExUXhXblJOVms1WVVteHdTVlJzV2s5aFJscHlZMGhzVldKR2NIWldNakZHWlZkR1JsVnNaR2xYUjJodlYydFdWbVZHWkZkalJXUldZWHBXV0ZsclduSmxSbHAwWlVkMFRsSXdWalJYYTFadlZrZEZlVlZzYkZwaE1YQm9WMVphYzJNeFZuTmFSazVUWWtoQ1IxWlhNVFJVTVZsM1RWWnNVbUV5YUZoVmFrNXZWVVphU0dWR2NHeFNhelV3VlcxNGIxWXhTbFpqUm14WVZteEtTRmRXWkU1bFJsSjFWbXhXYVZkRlNsVldWM2hYWkRKR1IxZHVVbXhTTUZwaFZtcEdZV1ZzV1hsT1ZUbGFWbXR3V2xaWGVGZFdiVXBaWVVkb1lWWXphRmhXTUdSWFUxWndSMXBGTldoTk1FcGFWbXhTUzJWdFZrZFhXR3hVWWtkNFUxbFVUbTlXTVZKWVkwVmtXRkp1UWtkV01uUXdZVzFLU1ZGcmJGcE5SbkJRVmtjeFMyUkhSa2RqUm1ScFVqRkZkMVl4V210VmJWWkhWMjVXVldKSGFIQlpWRTVEVjJ4a1dHUkhkRlpOYTJ3MFZsZDRhMVl5U25KT1ZrSldZbFJHVkZwV1dtRmtSVEZXV2taa2FWSllRalpYVkVKVFVURnNWMWRzWkdwVFJuQllWRmMxYjJGR1ZuUmpla1pYWWtaYWVsZHJaRzlVYkdSR1VtcGFWMkpZUWtSWlZFWmFaVVpTY2xwR1VtbGlSWEI2Vmxkd1MwNUdXa2RWYkdSWFltMVNZVlp0ZUhOT1ZuQldWMjEwYUZKVVJrWlZiWFJ2VmpBeFdHRklTbGRTTTJoeVZXMXpNVll5U2tkalJtUk9UVlZ3VGxadE1YZFNNazE1VkZoc1UyRXlhRkZXYWs1dlkwWldkRTVWVGs5aVJtdzFXa1ZhYTFSc1NuTldhbFpXVFc1U2RsWnRNVWRqYkU1elYyeFdWMkpJUVhwWFZFbzBZekZhYzJORldsaGlXRkpQVm0wMVEwNUdXbk5hUkZKcFRXdGFXRlV5TlZkVmJVcFZZa1pzVjJKWWFFeFdSVnBoVTBVeFYxcEdaRTVXVkZWNFZsUktOR0l5UmxkYVJWcFVZa1phV0ZWdE1VNWxSbXh4VW14a1UwMVlRa2hYYTFwaFlVZFdkR1ZHVWxoV00yaG9WV3BCTVZJeFpGbGlSVGxYWVhwV1YxZFhkRmRrTVVsNFYxaHNiRkl6VWxoV2JYaDNUVVphVjFWclRsZE5SRVpJV1RCb1MxZHJNWFZoUjJoaFVsWndURmw2Um1GamF6VlhXa1UxVjFkRlNrMVdiVEI0VGtkR2RGWnJaRlJYUjJoWlZqQmtORlpXYkhKYVJGSlhZa1pzTTFkcldrOWhSa3B6WTBob1YxSjZRVEZaVnpGTFUwZFNSVlZzWkU1aWF6QjRWMVpqZUZNeFdYaFVia3BwVWpCYVZGWnROVU5WVm1SWFYyMUdWVTFWY0hwVk1qVkhWbTFLU0ZWdVFsZE5SMUoyV2xWYWEyTXhXblJTYkZKcFZteHdTVmRVUWxkWlZteFhVMjVPVkdKclNsZFpiR2h2VFRGWmVGZHRkRmROV0VKS1dUQlZNVll5U2xkVGJHeFhZV3RyZUZWNlJscGxSbVJ5VjJ4b2FXRjZWbWhYVmxKTFZXMVJlRlZ1VGxoaWJWSllXV3hXWVZOV1ZuUk5XRTVXVFd0d1NsVlhjR0ZYUmxwR1UyMW9ZVkpGV25KWmVrWnJZekpHUjFkc1pGTldXRUphVmpGYVUxSXlVWGhWYTJScFVrWndWVmxZY0hOV1JteHpWMjFHVkZKdFVubFdNakV3WVVaYWNtTkdjRlpXTTFKb1ZtcEtTMU5IUmtWVWJGcHNZVEZ3V1ZkclZtRlpWMDV6WTBWb2FsSnJOVmhVVkVwdlYxWlplRnBFVW1oTlJGWklWakowYTFkSFNuSk9WemxXWWtaVmVGa3llRk5XTVdSMVdrWlNVMkpXU2pWV2JHUXdWREpHUmsxVlZsTmhNWEJYV1d4b1UyUnNXbkZSV0docVZteHdlbFpYZUd0Vk1VcFhZMGM1V0ZaRmNEWlVWbHByVWpGT2RWUnRSbE5OYm1oWlZsZDRZV1F4V25OWGJrNWhVMGRTVkZSV1dsZE9WbHBIWVVoT1ZrMXJWalZaVldoTFZtMUtWVkp1V2xwTlJuQllXa1ZWTVZac1VuSlBWbVJwVTBWS1NsWnRNSGRrTURWWVVteGFUbFp0YUZkWlYzUkxWMFpzYzFWc1pGVlNiR3d6VjJ0V2EyRnRSalpXYkdoYVZsWndXRlpxUm1Ga1ZrWnpZVVpvYVZKc2NHOVdha2w0VlcxV1IxcElUbGRpUlRWd1ZXcEtiMVpXV2tkWGJHUnJUVlUxV0ZZeU5VdFpWazVKVVdzNVYyRnJTbWhXTUZwYVpWVTFWbVJIYUZkV1JVa3hWMVpXWVdJeFpIUlRhMmhvVTBad1dGUlZXbmRqYkZweFVtMTBhazFZUWtsYVJWcFBZVlpLZFZGdGFGZGhhMjkzVjFaYVJtVkdaRmxpUmxKb1RXNW9WRmRYTUhoVk1XUkhWMjVHVldKVWJHOVZiVEZUVjBaWmVXVkhSbWxTYTNBd1ZsZDRkMWRIUlhoalNFcGFWbFpXTTFwVldrOWpNV1J6V2taT2FWTkZTblpXYlRGM1VXMVJlVlpyYUZSaE1sSlpXV3RrYjJJeGNGaE5WRkpyWWtad1dWa3dWazloTURGV1RsWm9XazFHY0doV2JURkdaREExVjJKR2NHbFNiSEJaVmtkMFlWZHRWbGhWYTFaV1lrZG9WRmxyYUVOT2JGcDBUVmhrVmsxV2NIbFVWbFp2Vm0xS1NHRkdaRnBpUjJoMldWVmFjMDVzU25Sa1IzQk9WMFZLU2xkc1ZtdGpNVlY1VTI1S1ZHSlhhRmhaYkZKSFRURldjVkp1VGxkTmEzQklWMnRrYzFVeVNrbFJiRVpYWVd0S1YxUldXbUZXTWtwSlZXMTRVMDFHY0ZsWFYzUnJUa2RXVjJKR1dsZGhlbXh2V1Zod1IxZFdjRlpYYlVaWFRWVnNObFpYZUVOV01VcEdZMFY0VmsxR2NGaFpla1pyWXpGa2MxcEZOVTVpVjJjeFZtMHhNRlV4U1hoVWJsSlhZVEpTVmxsdGN6RmlNVlowWlVoa2FsSnNjSGxXTWpGSFZrWmFjMk5JY0ZkV00xRjNWbXRWZUZkR1ZuTmhSbHBwVmtaYVRWWnNWbUZaVjFKWFVtNVdVbUpHY0c5WlZFWjNWRlphZEdWSFJscFdhMncwV1RCV1YxWnRTbGhoUlRsWFlXdGFURlV3V21GU01XUnpXa2R3VG1FeGNFbFdWRWt4VlRGYWRGSnFXbWxTTUZwaFZtdFdZV0ZHVWxWU2JGcHNVbTFTTUZwRldtdFdNa1Y0WWpOa1YxWjZRalJhUkVaVFl6RmtkVlpzU21sVFJVcFpWbTEwVjJOdFZrZFdhbHBUWWxWYVZWVnRjekZOVmxWNVpVYzVhRlpzYkRWWlZWcHpWMFpaZW1GR1VsWmhhMXBvVldwR1YyUldWblJsUms1b1pXeGFXbFp0TUhoTlIxRjNUVlZrYWxKV2NGbFpXSEJ6WWpGYWRHUklUazlpUjFKV1ZrYzFUMVl3TVZkalJFSlhVak5DVkZadE1VZGpiR1J6Vld4d2JHRXhjRkZXYWtaclZERk9TRkpyWkZWaVIyaFVXVlJPUTFsV1duUmxSM0JzVWxSV1NGbHJXbTlXVjBweVRsaENWbUpZYUdoV2ExcHpaRWRPTmxKc2FGTmlSWEJaVmpKMFlWUXhaRWhUYTJoclVrVTFXVmxVU2s1TlZscDBZek5vVjJKVk5VWlZiWGhoVmpBd2VWb3pjRmRoYTBwb1ZqSXhWMk14V25WVWJVWlRZa1p3V1ZkWGRHOVJNVkpYVjJ4b2FsSllVbFJaYkZwaFpXeHJkMVp0ZEdoU2EydzFXbFZvUTFZeVNsbFZhazVWWVRGd2FGbDZSbkpsYlVaR1RsWk9hVmRIYUZwV2Frb3dXVmRGZUZkdVRtRlNWMmh2VldwS2IxWXhVbFpYYkZwc1VtMTRlRlZ0TVVkaE1VbDRWMnR3V0dFeVVUQlpWbHBLWlcxR1JWVnNaR2hOYXpRd1ZrWldZVmR0VVhkTlZscFhZa1UxYjFsVVJuZGhSbHAwWlVkMGFVMXJXa2hXTWpWSFZUSkZlbFZzVWxwaVJsVjRWVEJhVjFkSFZraFNiRlpwVWxoQmVGWldaSHBsUm1SSFdrVnNVbUV5YUdoVmExWmhWVVpWZDFkc1RtcGlSMUo1VkRGYWExWXhTbk5qUkU1WFlrZFJNRmxxUmtabFZrNVpZVVpvYVdKRmNGQldiWFJoVXpKT1IxVnNhR3hTVjFKUVZXMTRjMDVHYkZaaFJUbFhUVlpzTTFrd1ZuTldNVm8yVm10U1YySllUalJWYWtaclpFZEdSMXBIYkZoU01tY3lWakZTUzA1SFVYaFRXR2hXWW14S2NWVnFTalJXUm14MFpFVndUbEpzY0hwWFZFNXZWR3hLVlZKcmFGZGlSMmgyVmpCa1MyTnJOVmRpUm5Cb1RXeEtNbFpxUW1GWlYxSllWR3RhVkdGNlZsaFphMmhEVGxaWmVXUkdaRTVTYkZZMVZUSjRZV0ZYVm5KalJtUlZWbnBXZGxreWVITldNV1IwVW14T1RsWXhTalpXVnpFMFlUSkdTRkpZYkd0bGEwcFlWakJvUTFOR1drVlNhM0JzVW0xU01WWnRlRmRoVmxsNVlVWldWMUpzV21oYVJFWnJWakZ3U1ZSdFJsTlNWWEJvVm0weGVrMVdaRWRYV0d4UFZsZFNWMVJYZEhkV01WbDVaVWQwVjFac2NEQldWM2hUVmpBeFIyTkhSbUZXYkZWNFZtMXpOVmRIUmtoaVJrNVlVbFZ3V1ZadE1IZGtNbEYzVGxaa1lWTkdTbFZaVkVwdllqRldkR042UmxkaVJuQjZWakkxYTFkc1duVlJiR1JYVFdwV1RGbHJaRXRUVmtaeVdrWldhVkp1UW5sWFZscGhVekpTUms5V1ZsVmlSMUp3VmpCYVMyVldXa2RXYlVacVRWZFNTRlV5TlU5WlZrcHpVMjVDVm1GcmNIWmFWM2hoVmxaR2MxcEhkRTVXYlhjd1YxZDBZV0l5UlhoVGJHUnFVMFUxVjFsc1VrWmtNVkpWVW14d2JGWlVWbGRVTVZwclZHeEtSbGRzYkZoV1JVcDJXWHBHYTFOR1NsbGlSbHBwWW10S2FGWnRNVFJrTVZKSFYyNU9XR0pWV25GVVYzUmhVMFprY2xwSE9WVmlWWEJIVmpGb2QxWXlTbGxWYkZKV1pXdGFURnBGV21GamJIQklVbXhTVTJKSVFscFdNV1F3VmpKUmVWUnJaRmRpYTFwV1dXeFNjMWRHVWxkWGJtUk9VbXhLVjFsVll6VldNa3BXVjFSS1ZtSllVblpXTWpGR1pVZE9TVmRzY0ZkTk1EUjZWMnhhYTFJeFRsZFViazVZWWxkb2IxUldhRU5rYkZwelZXdDBUMUl3VmpWV1J6VlBXVlpPUms1V1dscGhNbEpVVmtSR1lXUkZOVlpVYXpsWFlraENORlpYTUhkT1YwVjNUVlprYVZKRk5WWldiVEZ2VjBaYVdFMVZXbXhXTUZwSlZXMTRhMkZYU25KVGEyeFhZV3RLYUZkV1pGTlRSbEp4VjJ4T2FWSXhTbEJYVmxKSFpERk9jMXBJVGxkaVZWcFdWRlphUzAxR1ZYbE9WazVvVW10d01WVlhlRzlYYkZwR1YycE9XbFpXY0hKV2FrWjNVakZTZEdOSGFHeGhNWEJvVm0xMGFtVkdTWGhXV0d4VVlrZFNWVmxyYUVOWFZscHhWRzA1VjFKdGR6SlZiVEZIWVdzeFYxZHVjRmhoTWxKMlZsUkdZVlpXV25OV2JHUlRZa2hDYjFaWGNFSmtNbFpJVTJ0a1dHSklRbk5aYTFwM1pHeGFkRTFVUW10TmJGcFlWbGMxVDFZeVNsVmlSbWhWVmxaS1NGUldXbUZXTWtaSVpFWmtUbUV6UW1GWFZsWnJZakZhZEZOc2JHaFNhMHBoVkZkd1IxWkdWbkZTYlVaclVqQndTRlpITVhOaFJURkpVV3hTVjJKVVFqTmFSRXBYVW1zMVZtRkdXbGhTTW1oV1ZtcENhMkl5VGxkV2JrNWhVbnBzY1ZadGVHRmxiRnBZWlVkMGFGWlVSbHBWVjNoeldWWktWMk5IYUZwaE1YQk1XWHBLVDFKV1JuTldiR1JwVWxoQ1ZsWXhXbGRXYlZaSVZHNU9XR0pyV2xoWmExcDNZMFpaZDFkcmRHeFdiSEI0VlZjeFIyRkZNVlpPVld4V1lsaFNlbFpYTVV0U01rNUpVV3h3YVZkR1NrMVdha1poV1ZkU1NGWnJhRk5pUm5CUFZtMDFRMDVzWkZWUmJHUmFWbXhHTkZZeGFIZGhSa3B6VTIxR1dtRXlVblphUjNoVFl6RmtjMk5IZUZkTlZYQkpWakowVmsxV1ZYbFRiR1JVWVRKNFdGWnJWbkpsUmxwRlUydGthazFWTlhsV01uaHZZVlphVjJOR1pGZGlXR2h5VmxSR1lWSXlUa1poUjNoVFRVWndlRlp0TVRCWlZtUnpZa1phWVZKRlNsaFVWVkpIVTBacmQxWnFRbGROVm5Bd1ZsWlNRMWRzV2taWGJHUmhWbXh3VUZreWVIZFRSMDVIVkdzMWFWWXlhR2hXYWtaaFZURkplRlJZYUZaaE1sSlpXV3RhWVZaR2JISmhSVTVxVFZad01GcEZhR3RYUjBwSVpFUk9XR0V5YUZCV2JYTjRZMnhhY1ZSc2NFNVNia0kyVm0xd1IxZHRWblJTYTJob1VqQmFWRlZzYUVOV1JtUnpWbTFHYTAxVmJEVlZiWFJoVkRGYWRGVnNVbHBXUlRWRVZtMTRZV05zWkhSa1JUVlRUVlZaTVZadE1ERlVNV1JJVTI1T1ZHSnJjRmRaVjNNeFZrWlpkMWR1VG1waVNFSklWa2Q0VTFZeVNrbFJiSEJZWWtaYVdGbFVSbHBrTURGWlUyMXdVMVl6YUZsV2JURTBVekZLUjFkdVVtcE5NbWhZVkZkek1WTkdXbGhsU0dScFVqQldORmxxVG5kV01WbDZZVWRvVjJGcmNGUlZNRnBMWTJ4d1NGSnNUazVpYldoV1ZtdGFVMU14VVhkTlNHaFlZbXhLVDFZd1pGTldWbEpZWlVWa1QxSnRlSGxXTWpFd1YyeGFjazVWWkZWaVJuQjZWakl4UzFkWFJrWmxSbkJvWVRGd1dWZFljRWRXTWxKWFZXNVNhRkpyTlhCVmJUQTFUVEZaZVdWR1pHbE5hMVkxVlRKMGExZEhTbk5YYkU1YVlUSlNkbFl3V25OamJHUnlaRVpvVTJKSVFqUldWekI0VWpKR2RGTnNXazlXVm5CWFZtcE9iMDB4YkZaV1dHaHFUVlUxZUZZeWVHOVdNa3BKVVcwNVYxZElRa2hXTWpGWFZqRlNjMkpIY0ZOTk1FcFZWMWQ0WVZNeFpGZFhiR2hzVWpCYWNsUldaRk5YUm1SeVYyMDVhR0pGY0ZkWk1HaFBWbTFLV1ZWdWNGVmlSbkJZV1hwS1IxTldjRWhoUm1Sb1RUQkpNbFpzVWtwTlZrVjRXa2hPV0dFeGNGVlpWM014VjBac1ZWSnVaR2hTYmtKSFYydFZOVlV5U2xkVGEyaFhUVzVOZUZacVJtRlNiRnBaV2taa2FWWkZTVEJXUjNSaFYyMVdSMWR1VmxaaVJUVlpWVEJXUzFkR1pGZGhTR1JxVFZkU1NGbHJhRTlXYlVWNVZXeG9WbUpVVmtSV01WcDNWbXh3UlZGc1pFNVdia0kyVmxSS2QxRXhXbFpOVm1oV1lteHdXRmxYZEhkU01YQlhXa1pLYkdKVk5VaFhhMXBQWVZaT1JsTnNXbGRpVkVZelZXcEtSbVZXVm5KYVJsSnBVak5vZDFaWGNFdGlNVnBIVjI1U2ExTkhVbGxXYlhoM1YxWlNWbUZIT1ZkaGVrWllWVEowYjFkc1drWk9XSEJhWVRGd1RGWnNaRXRTTWtwSFdrZG9hRTFJUW5aV2JGSkRXVmRPZEZWWWFHcFNWbHBYV1d4a2IxWkdXbkpXYTNCc1lrWndWbFZ0TURWaFZURlhZa1JPVlZac2NIWldiVEZIWTJzMVYxcEhSbGROTVVwdlZtdFNSMlF4V1hoYVNFNWhVak5DY0ZVd1ZrdFRWbVJYVm0xMGFrMXJXbGhWTWpWWFZXMUtTR1ZHYUZWV2JWSlRWRlZhWVdOV1NuVlViR1JPVjBWS1NWWXlkR0ZoTWtaWVVtcGFWMkpIYUZsV2FrNVRZMnhhVlZKc1NteFNiRnA2VjJ0a1IxVXlSalpXYkd4WVZqTlNhRnBFUms5V01WWjFWR3hrVjFKc2NIWldWM0JEWkRGWmVGZFlhRlpoTTFKWVZGWmFjMDVzVmxobFJrNVhUVVJHTVZsVlpHOVdNa1p5VjI1S1lWSnNjSEpaZWtaM1VqRlNjMVJzWkdsaE1IQlBWbTF3UzA1R2JGZGlSbVJZVjBkNFZsbHRlRXRXTVd4VlUyeE9XRlp0ZUZwWk1GcHJWakZLZEdWR1dsZFNNMUpRVm10a1MxSXlTa1ZWYkdST1lXdFdNMVpyVWtkVGJWRjNUVlpXVjJKSFVsaFVWRVpMVFd4YWRHTkZkRk5pVmxwSVYydG9UMWxXU25WUmJrSldZV3R3ZGxac1dtRmpWa1owVW14d1YwMUVWbGxXYkdNeFZURldSMWR1U2s5WFJVcFhXV3hTVjFKR1dYaFhiSEJzVWpCYVNsZHJXazlVYlVWNFkwUldWMUpzY0doWmFrcExVakZPZFZWdGFGTmlXR2hvVm0xMFYxbFhSa2RoTTJ4c1VqQmFjVmxyWkZOTlJuQkdWMnhPVmsxRVJraFpNRlozVmpGYU5sSlVRbGRoYTFwaFdrUkJlRk5XY0VkVmJXaE9WbGhDWVZZeFdsTlNNVTE0Vkd0a2FWSnNXbFZaV0hCelYwWlNWMWRyZEU1V2JGWTFWRlpTUTFack1VVlJhbEpXVFc1b1dGWXdXbHBsYkZaMVYyeGFWMlZyV2xsV1YzQkhZVEpTVjFWdVRtcFNWRlpQV1d4a2IxWnNXbkpYYlVab1RWWldORlpIZEd0V01XUklaVWhPVm1KVVJsUldNRnBUVjBkU1NGSnRlRmRpUlhBMlZtcEpNVlF4V1hkTldFcHFVbTVDWVZac1drdFZSbHB4VTJ0YWJGSXdOVWhXVjNocllWWmtTR0ZJYkZoaE1YQm9Wa1JLVTFOR1duSmFSMFpUVFcxb2VsZFhkR0ZYYXpGSFYyNVNUbE5IVW5OVmFrWmhaVlpTVjFkdGRGaFNiVkpKVmxkek5WWXlTa2RqUjJoWFRVWndlbHBGVlhoV01WSnpZVVprYVZORlNUQldiWFJyVGtaUmVWSlliRlJoTW1oelZUQmtiMVl4V25STlZ6bHJZa1p3ZUZWV2FHOVdNREZZVldwR1dtRXhjRE5aVlZWNFl6Rk9jVk5zYUZkTk1VcDVWbGh3UjFNeVVrZFZia3BvVW10S1dGbHNXa3RXVm1SWVpFYzVVazFYVWxoWGEyaExWbTFGZVZWdE9WVldNMDQwVkd4YVZtVlhVa2hrUm1oVFRVaENXbGRXVm1GVk1WcFhWMnRhV0dFemFHRldiRnAzWVVad1JsWllhRlJXTUZwSVZqSnpNVll4V1hwWk0yUlhUVlp3VkZaRVNrWmxWa3B5V2taU1dGTkZTbGhYVjNSclRrWnNWMkpJU2xoaVZWcFBWRlphVjA1R1dYbE5WV1JZVW10c05GWXlkSE5XVlRGWFkwUk9WMkZyY0VkYVYzaEhWMVp3UjFwSGJGTk5WVll6Vm0xNFUxSXhiRmhWYTJSVVlrZDRiMVZxVGtOV1JscHhVMjA1YUZKc2NFaFdNakZIWVRBeFZrNVZhRnBOUmxwb1YxWmFTMWRXVm5OV2JGcG9ZVEZ3YjFaVVFtRmhNazV6V2toU2ExSnRVazlaYTFwMlpERmtjbFpzVGxwV2JHdzFWVEo0VjFVeVJuSk9WbVJoVmpOU1IxcFZXbFprTVdSeVQxWm9WMDFHY0VsV2JURTBZakZWZDAxSWJHaFNiVkpZVkZaa1QwNUdjRmhqTTJoWVVteEtlbGRyV210aFYwcEdZMGh3VjFZemFIWldWRVphWlVaV2MxcEhSbE5TYTNCYVZtMHdNVkV4U1hoWGJsSnFVbFUxYjFWdGVIZFdiRlowWlVjNVYwMUVSbmhXYlRWaFZqSktWVkpyZUZkTlYxSklWVEZhVDJNeVRrZGFSMnhYWVROQ1QxWnRlRk5STVd4WFYxaHNWV0pIVWxSWmJYTXhWMFpzY2xwR1RtcFNiSEI0VlRJd05WWnRTa2RpUkZKWVlURktSRll5ZUdGa1JsWnhVV3hrVjJKWGFIbFdhMlEwV1ZkTmVGcElUbWxTYmtKdlZGZDRTMVpXV25GUmJVWnFUV3N4TkZkcmFFdGhNVWw2WVVab1dtRXlVWHBVVlZwaFkxWk9XV0ZGTlZOaVNFSklWa1phWVdJeFduUlNXR3hzVW0xb1lWbHJaRzlXUm5CWVpVaE9XRkl4V2tkWk1HUXdWR3haZUZOcVdsZGlSMUV3V1ZSS1IxTkdTbGxoUjNCVFZrVmFXVmRXWkRCWlYwWkhZa1pXVkdGNlZuTlZiVFZEVTJ4YVNFMVZaRlpOUkVJelZUSjRRMVl5U2xsaFJsSlhZV3RhVUZacVJtdGpNVnB6Vld4a1UxWnVRbHBXYTFwaFdWZE5kMDVXWkZkWFIzaHpWV3BDWVZkV1ZuRlJibVJUVFZaS2VsWXlNVWRXTURGeVkwVm9XazFIVW5aV2JGcGFaVzFHUlZSc1dtbFNia0pOVjFod1MxUXhUa2hXYTJSVllsZDRXRmxVU2pObGJGcDBaRVpPVTAxWGVGaFdSbWh6VlRKS1NGVnNWbHBXTTJneldXcEdkMWRIVWtoU2JHaFRZa2hDTlZadE1IaFNNa1Y1VTJ0b2EyVnJjRmRaYkZKR1pERmFWVkZZYUZoU2JGcDZXVEJhZDJGRk1WbFJiVGxZVm14d2FGWXlNVmRYUmtweVlVZG9VMkpYYUZsV1JsSkhVekpXVjFkdVRtRlRTRUp6VlcxMGMwNUdXblJPVlRsYVZtdHdNRmxWYUVOV01ERkhZMFY0WVZaV2NISldNR1JUVTBaS2RHUkZOVmRpYTBreVZtMHdkMDFXVlhoVmJrNWhVbFp3VUZadE1WTldiRnB6VjJ0MFZGSnNWalZhVlZwclYwWkplRmRyY0ZoaE1YQnlWa2N4Um1Wc1JuTmFSbVJYWWtoQ01sZFhjRWRqTVZsNFZHNUtXR0pZUWxSV2FrcHZWMFprVjFwRVFscFdWRUkwVm0wMVUySkdTWHBWYmtaYVYwaENlbFl3V210amJGcFZVbXhXYVZKWVFtRldWbU14V1ZaWmVWSnVTbGhpYTNCV1dWUktVMUl4Y0ZkWGJVWnJWbXMxZVZSc1dtdFdNREZXWTBSU1YySkhVVEJaVkVwS1pWWlNkVlJzWkZoU01VcFpWbTEwVjFsV1pFZFhibEpzVWpCYVQxVnRlRXRYUmxsNVkzcFdhRlpyY0hsWk1HaDNWakF4ZFZGclVsZGlSbkJvV2tWa1IxSXhSbk5qUm1SWFltdEtkbFl4YUhkVE1WRjRVMWhvWVZORk5XaFZiVEZUVkRGU1ZsWnVaRlppUm5Bd1dUQldUMWRzV25SbFJteFhVbTFvZWxac1pFWmxWMVpIVld4d2FFMVlRbTlYVkVKaFZqSk9WMU51U210U2JWSllXV3RvUW1ReFdrZFdiVGxwVFZad1IxUldXbUZoYkVwR1UyeGtXbUpIYUZSWk1uaHpWbXhrY21OSGVGZE5WbkJLVmtSR1lWWXhXWGhYV0d4b1VsWmFXRlZ0ZUV0VFJtUlhXa1UxYkZKc2NERlZNbmhYWVZaT1JsTnNiRmhXYldnelZXMXplRll4WkhWVGJHaHBWa2Q0ZDFaR1pEQlpWa2w0Vld4YWFGTkZOWEJWYlhNeFVqRlplV1ZIUmxkTmExWTBWakp3VDFsV1NYcGhTSEJhVFZad1RGbDZSbmRUUjA1SFdrZG9UbGRGU2xsV2JYaHFaVVUxUjFWWWFGaFhSM2hWV1d0a05HSXhWblJOVnpsWVVtMTRlVmRyV2t0aE1ERllaVVphVmsxdVVuSldhMXBMWTIxT1NXRkdaRTVpYldoUlYxWmFhMU15VG5OVWJrNXBVbTFTVkZsc1ZYaE9SbHBYVld0a2FFMVZiRFJYYTJoWFZrZEtTRlZzYkZaaGEzQjJWakZhYTFZeVJrbGFSbVJPVm0xM01GWnFTalJpTWtwSFUyNVNWbUpVYkZkWlYzUkxWMFpTY2xkdVNtdE5WbHA1V2tWYWExUnNXblZSYTJoWFZrVnZNRmxVUm1GV01XUjFWRzF3VTJFd2NGbFhWbVF3V1ZVd2VGWllhRmhoZW14eFdWaHdWMWRHWkhKV1ZFWlZZbFZ3V1ZsVlpFZFdNa3BWVVdwU1ZXRXhjSHBXTUZwWFYxWndSazVXWkdsV2EzQmhWakZrTUZsV2JGZFhhMlJwVTBWd2FGVnRjekZqVmxaMFpVVjBXRkpzY0hwWlZXTTFWbFV4VjJOSWNGZGlXRUpZVjFaYVMxZEdVbFZTYkdSb1lUTkNUVlp0TVRSWlYwNVhWMjVTVTJKSFVsaFpiWFJLWlZaYWRHTkZjR3hTYXpFMFZqSjRhMVpIU2tkWGJFNWFZVEpvUkZaRVJsZGtSVFZXVkdzNWFWSnVRWGRYVkVKWFlURmtjMWRZWkU5WFNFSmhWRlZhWVdSc2JGVlNhM0JzVmpGYVNGWlhlRmRXTWtwSFlqTndWMkZyYnpCWFZtUlBWakZTZFZKc1NtbFNNVXAyVjJ4a05GbFdaSE5YYkdoT1ZrVktjRlJXV2xkT1JtUnlWbTVPVm1KVmNGWlphMXByVjIxRmVHTkVUbHBXVm5Cb1dURmFTMlJHU25Sa1JtUk9Va1phU1ZacVNqQldhekZYVlc1T1dGZElRbTlWYlRGVFYwWmFkV05GVGs5U2JFcFhWako0WVdKR1duSk9XSEJYVFdwR00xWlVSbXRTYkU1elkwWm9WMkpGY0VsWGExSkhXVlpKZUZwSVZsTmlSVFZ3Vm14YWQyVkdaRmhrUjNSV1RWZFNlbGxVVG10WFIwcFdWMnhhV2xkSVFrUlVWRVpXWlZkU1IxcEdhRk5pVmtwTFZsWmtNR0l4V1hoVGExcFlZbXR3VjFsWGRHRmhSbkJIVjJzNWExSXdXa2hXUnpGelZUSktjbE5ZY0ZkaVZFSTBXa1JHVW1WV1RsbGlSbHBwWVhwV1dsZFhNVFJUTWs1elZtNUdWV0pGTlhGVmJURTBaV3haZVUxVlpGaFNhM0I2V1RCb2QxZHNXbGhVVkVaWFlXdEdORmt5ZUd0V1ZrNXpZMGRvVGxkRlNsSldiWEJLWlVaS2RGWnNaRlppUmxwVVdXdGFZVmRHVm5OWGJtUlBZa2RTVmxVeWNGTlhiRmwzVFZSU1YxWjZWbEJXTUdSTFYwZFdSMkZHWkU1U2JIQk1Wa1phWVZsWFRYaFdia3BxVWpOb1ZGUlZaRE5OUmxsNVpFYzVWVTFYVWtsVk1qVkxWREZhZEdWSFJsZGhNVm96V2tkNGMxWnNaSE5hUjNCWFlrVnZkMVpFUm1GWlZsVjVVMnRzVW1Gc1NsaFdibkJDWlVac1ZWSnNXbXhXYTNCNFZqSXhjMVV5U2xkVGJHUllWak5TYUZwRVNrOWpNV1J5WVVkNFUxZEdTbFZXUmxwclZURmtjMkV6WkZoaVdGSnZWV3hTUjJWc1ZuTmhSM1JYVFd0d1NGVXlkRzlXTVZvMlVteG9WMkZyV2xCYVJscFBaRVpLYzFSdGJGZE5iV2Q1Vm1wR2EwMUhTWGhTV0doaFVtMVNhRlZ0TVZOaFJsWnlWbXQwV2xac2NEQlVWbHBQVjBaS2RHVkliRnBXVmxsM1ZqSjRZV050U2paVGJIQm9UVmhDV1ZadGVHRlpWMUpJVW10YVZtSkdjRTlWYlRWRFpWWmtWVk5xVWxwV01VcEpWbGQwYTJGR1NuSk9WemxWVmtWS1RGWXdXbUZrUlRGSllVVTVVMDFFUlRCV01uUnZVekZTYzFkc2FHaFNiVkpoV1d4U1YxSkdXWGRYYms1WFZtdHdNVmRyV2xkVk1rcFpXVE5zVjFaRmNEWlViRnBoVWpGa1dWcEhjRk5XTW1oYVYxWlNSMVp0VmtkaVJtUmhVbGhTV1ZWdE1EVk9iR3h5VjIxMGFGWnRVa2hWTWpWdlYwZEtSMWR0YUZkU1JYQlVWV3BHYTJSV1VuUlNiRTVwVm10d00xWXhXbTlrTVZsNVZWaG9XR0pIYUU5V2ExcExXVlphY1ZGVVJsUlNiR3cwV1ZWa01GZHNXbkppZWtwYVlUSm9VRlp0TVV0V1ZrcHpWV3hrVGxKdVFtaFhiRnByVmpGS2NrOVdaR0ZTVkZaVVZXeGFkMU5HV25OWk0yaFBVakJzTkZkclZtOVZNV1JJWVVoR1ZrMUdXak5XTUZwVFYwVTFWazlWTlU1WFJVcFpWakowVjJFeFdrZFhia3BZWW01Q1dGUlhjRWRsYkZwVlVWaG9hMUl3V2toV01uaHJZVlphUmxaWVpGZE5WbkJ5VmtjeFYxSXhjRWxVYlVaVFlrWndkMWRYZEZka01sWlhWMnhvYWxKWVVsQlZiWGgzVTBaWmVVNVZkRmROYTNCWFZqSXhSMVl5U2xWU2JGSlhUVVp3YUZwRlpGZFNhemxYVjJzMVUxSldjRnBXTVZKRFdWZEplRmRZYUZSWFNFSlhXVzE0ZDFsV1duVmpSV1JZVW0xME5WcFZWVFZoYXpGeVkwVm9XazFHY0hKV1IzTjRWbTFPUms1V1pFNWliV2g1VmtkMFlWZHRWbGRWYmxaVllsVmFWVlZzYUVOaU1WcFlUVWhvYVUxV2NFaFphMmhUWVRGS1dWVnNWbFppVkVaVVZtMTRWMWRGTVZaYVJtUlRWa1ZhV1ZaVVNURmtNVnB5VFZoV2FGTkZjR0ZXYWs1dlZFWldkR1ZIZEdwTmExcElXVEJhYTFSck1WWmpTRnBYVFZad1dGZFdaRTVsUm1SeldrWlNhV0Y2VmxaWFYzaHZZakZrUjJKR1ZsVmhNSEJ6VlcxNGQxWnNWWGhoUnpsVlRWVndlbGt3Vm05V2F6RnhWbXhDV2xZemFFeFpla1pQWXpKS1IxcEhiRmRTVm5CVlZqSjBVMUl5UlhoWFdHaHFVbFp3VVZadE1WTlVNVnAwWlVoa1QySkhVbGhXYlhoaFZHeGFjMkpFVGxWV1YyaDJWbXRrUzJSSFZrZGlSbVJvWVhwV1ZWZFVTalJaVmxwWFUyNVNVMkpZUWs5V2FrWkxUbFprVjFadGRFOVNiRll6VkZWb2IxWkhTblJWYkdoWFltNUNSMVJWV25kU1ZrcDBaRWR3VG1FelFrbFdha28wV1ZkR1JrMVlUbFJpU0VKWVZtcE9RMUpHV25GUlZFWlhUV3R3U0ZZeWVHdGhWa3BWVm14d1dGWXpVbWhhUkVGNFVqRmtjMkZIZEZOU2EzQlpWa1prTUdReFRrZGhNMlJoVW5wc1lWWnRkSGRsYkd0M1YyeE9XR0pXV25sWk1GcERWbTFLV1ZSWWFGZE5SMUpNVldwS1IxSXhVbkpPVjJ4WFZrWkdORlp0TUhka01sWklWVmhvVkZkSGFGaFdNR1J2Vm14WmQxcEhPVmRpUm13elYydFNVMVl5U2tobFJscFdZbFJXY2xadGVHRmpNazVKWTBab2FFMVZjRlZXYWtKaFdWZFNTRlpyWkZoaVIxSlVWRlJHUzFWV1duUk5XSEJzVW14c05GWkhOVTlaVmtwMFZXNUNWMkV4V21oVk1WcHJWakZXY2xwR2NGZE5SRVV3Vm1wSk1WSXhXblJUYTJoV1ltdEtXRlJWV2xkTk1YQldWMjFHYWsxWVFrcFpNR1EwVlRKRmVsRnNjRmRXUlc5M1dWUktSMUl4VG5WV2JFcHBVakpvV1ZkWGVHOWlNREI0Vld4b2JGSXdXbkZaYTFwaFpWWmtjbGRzWkZWaVJuQlpXa2h3UjFZeVJYbFZXR1JZVm14d1UxcFZXbXRYVm5CSFlVZHNVMDF0YUc5V01WcFRVakpSZDAxSWFGZFhSMmhaV1d4b1UxZFdWbk5WYTJSWFlrWndXVnBWV210V1YwcEhZMFJHVmxZelFtaFdha3BMVTBaU1dXRkdXbXhoTVhCdlZsUkNZVlF5VFhoYVNFNW9VakpvYzFsc2FHOWlNVnAwWTBWT2FVMVZWalJXTVdodllXeEtWMWRzVWxwaVJscG9XVEo0VjJNeFZuSmFSbWhwVWpGS05WWnFTakJOUmxwWVUyeGFWMkZzU2xoVVZscExVa1phY1ZGWWFHdFdiRnA2V1ZWYWIxWXlTbGRUYTJ4WVYwaENTRlpFU2s5ak1YQkpWRzFvVTAxdWFGVlhWM1J2VVRGa2MxZFlhR0ZTUlVwdlZGWmFWMDVHV1hsa1IzUlhUVmRTU1ZaWGVITlhiVXBaVkZob1YwMVdjRmhaTVZwTFpFWktjMVZ0YkZOaWEwcExWakZTVDJReFdYbFNhMlJZWW1zMWNWVXdaRFJaVmxKV1YyMUdUazFXY0hoVk1uUmhZa1phYzFOdWFGZFdNMmd6V1d0a1JtVnNSbkppUm1SWFRUQktTVmRXVWt0VU1sSkhVMjVLYUZKck5XOWFWM2hoVlVaa1dFMUlhR2xOVjFKWVZqSTFTMWRIU2xaWGJVWlhZbFJGTUZZd1dtRmtSMUpJWkVaa1RtRXpRa3BYVmxadlZERmFjazFWWkdwU1JUVmhXbGQwWVdGR2NFWldXR2hYVFZaS01GcFZaSE5WTWtweVUyMUdWMkV4Y0doV1ZFWkdaVVprYzJGR1VtbFNia0o0Vmxjd2VHSXhXWGhWYkdoUFZucHNUMVJXV25kbFJsWjBaRVJDYUdGNlJubFViRlp2VmpGWmVtRkhhRmRoYTFwTVZqRmFSMk14Vm5OaFIyeFRZa2hDZGxadE1YZFRNVkY0VjFob2FsSlhlRlpaYTFwaFkwWmFjVk50T1d0TlZuQlpXbFZqTlZWck1VVldiR2hYVFdwV1ZGWkhlR0ZTTVU1MVVXeFdWMDB4U1hwWGJGcGhWVEZaZUZwSVVtdFNiVkp3VldwR1MxTnNXbk5aTTJocFRWWndNRlZ0TlV0VU1WcHpVMjFHVlZaV2NETlpWVnAzVW14d1IxcEdVbGRpYTBwSVZrZDRZV0V5UmxkYVJXaG9VbTE0V0Zsc2FHOWpiRkpXV2tWYWJGSnVRa2RYYTFwVFlWZEZlbEZ1YUZkV2VrSTBWR3RhYTFJeFduVlZhelZYWlcxNGVWZFhkR0ZqTURWWFZXeGtWMkZyU2xoVmJYUjNaV3haZVU1WVpGZE5WbXcyV1ZWb1MxWXhTWHBoUlhoYVpXdGFhRmt4V2xkak1YQklZVWRvVGxORlNURldiVEV3VlRGSmVGVllhRlZoTWxKWVdXMTBkMkZHVm5SbFIwWnBUVmhDV1ZwVlpFZGhNREZZVld4c1lWWlhVWGRXYlRGSFRteEtjMkZHWkU1aGJGcEpWbXhTUzFNeFpGZFNibFpWWWtad2IxbFVRbHBOUmxwSVpFZEdWMDFyTVRWVmJYUnpWbGRLU0ZWc1VsVldWMmhFVlRKNGExWXhXblJTYkZwT1ZqRkpkMVpYZUc5ak1WcDBVMjVPYWxKdGFGaFphMXAzVFRGc1ZsZHVTbXhTYlZKNlZrY3hkMVJzV25KalJGcFhUVzVTY2xsNlJsWmtNREZKWWtkR2JHRXpRbGxYVjNodlVURk5lR05HV2xoaE0wSnpWVzE0WVUxV1draGxSazVvVmpCd1Ixa3dXbTlYUmxvMlVWaG9WbFpGV25wV2FrWnJaRlpTYzJGSGJGTmlhMHBSVm0wd2QyVkZOVWRhUm1ScVVteHdXRmx0TVZOaU1WSldWV3RrVTJKR2NEQmFSV1JIVmpKS1ZtTkdjRnBXVmtwUVZtcEtSMk5zWkhSaFJuQk9ZV3RhVVZaWE1IaFRNVWw1VW10a1lWSXllRmhaVkVvd1RsWmFjVk5xVWxkTmExWTBWbGMxVTFZeVJYbFZia1pXWWtkUk1GWnJXbk5qYkhCSFZHMXdVMkpHYjNkWGExWnZZVEZhYzFOdVRtcFNSVXBvVm14YWQxVkdXbkZSV0doWFlsVTFTRmxWV210VWJVcHpVMnBLV0ZadFVUQlZla1pyVWpGYWRWWnNTbWxTYkhCWlYxZDBZVll3TlVkWGJHaHFVbGRTVjFSWGMzaE9SbGw1VGxaT1ZsSnNjREZWVjNodlYyeGFSazVWVWxoV2JIQm9WbXBHZDFKV1ZuTmFSVFZYWW10R00xWnNVa3RPUmxsNFYxaHNVMWRIYUZWWmJHUnZWakZzV0dONlJtdGlSM1ExV2xWa1IyRnJNVmhWYm14VlRWZFJkMVpxU2t0U2JVNUZWMnhrVjFKWVFUSldSbHByVWpGS2NrMVdaR2hTYTBwWVZXeFNWMWRXWkZoa1IwWlVUVlUxU0ZscmFFZFdSMHBHWTBoT1ZtSlVSbFJXTW5oelkyeGtjMVJ0YUZkTlJtdDVWbTB4TkdReFpFZFhhbHBUVjBkU2FGVnJWbUZaVm5CV1YyeGthazFYVW5wWlZXUnpWVEF4Vm1OR1NsZGlSMDR6V2xWVk1WSnJNVlphUjNCVFlraENXbGRYZUc5Vk1WbDRWV3hhVm1FeVVsbFZiWGhYVGxaU2MyRkZPVmROUkVaWFdXdFNZVll4U25SaFNGcFhZV3R3U0ZreWVFdGpWbFp6VjIxc1UySnJTazVXYlRFMFdWWk5lVlJZYUdwU1YyaHdWVzB4VTFaR1duTlhia3ByVFZad2VGVnRNRFZoTURGV1lrUlNWMkpIYUhaWFZscExWMFpXYzFkc2NHbFhSVEUwVjFaV1lWWXlVa1pOVm1oUVZtMW9XRmxyV25kT1JscHlXVE5rVDFadFVrbFZNblJ2Vm0xS1NHVkhhRlppUjFKVFdrUkdZV014Y0Vaa1JtUk9WakZLTlZkV1ZtRmhNVmwzVFVoc2FGSjZiRmhVVmxwM1lVWldObEp0UmxoU2F6VjVWMnRhUzJGV1NYaFRibVJYVm5wRmQxcEVSbXRXTVdSMVVteE9hVlpXY0ZoV1JscGhZekExUjJFelpGZGlWR3hYVlcxNGQwMUdXbGhqZWxaWFlsVldORll5ZERCV1ZscHpZMGRHWVZadFVsUlZha1pUWXpGYWNrNVdaR2xYUjFFeVZtMTBZVmxYU1hoWFdHeFRZVEpTVmxsVVNsTmpWbFowVFZaT1YySkdjSGhXUjNSUFZrWktjMWRVU2xaaVZGWnlWbXBCZUZkR1ZuVmlSMFpUVmpGSmVsWnJZM2hTYlZaelVtNUthVkp0VW5CV2ExWktUVVprV0dORmRGUk5WVFZJVmtjMVQyRldTWGxoUmxKV1lrWktXRll4V210V01WWnlXa2QwVGxadVFrbFdiVEF4VWpGVmVWSnFXbGRpYXpWWFdXeFNWMUpHVlhkWGJYUnFZa2hDU2xaSGVHRlViVVY2VVd4c1YxWkZiRFJaYWtaclUwWk9jbUZHV2xoU01VcGFWbTB3ZUZVeFZrZGlSRnBUWWxoU2NsWnRlR0ZsVmxGNFYyMTBWMDFXY0VoV01qRkhWakF4V0ZWWVpGaFdiSEJoV2tSQk1WWnNjRWhTYkU1cFYwZG9ORlpzWTNkbFJsVjVVMWhvVjJKck5WZFpWRXBUVjFaYWRHVklaRmhXYmtKSFYydFNRMVl3TVZkaVJFNWFUVVphZWxZeWVHRldNazVHVld4a2FHRXdXVEJYYTFwaFZUSk9WMVp1VWxOaVJUVllWRlpXZDFkc1duTlZhMlJvVFZVeE5GVXhhSE5XVjBWNFkwWkNWMkpZVFhoWk1GcFhZMVpTYzFOdGVHbFNia0kwVmxSS2QxRXhXWGROVm1ScVVrVktXRmxzYUZOamJHUlhWMnQwV0ZJd1draFdWM2gzVmpGS1dWRnFTbGhXUlZwb1ZtcEtVMU5HVm5KaVIwWlRZa1p3VUZadGNFOWlNRFZ6VjFoc2ExSXpRazlXYWtKWFRURlNWMWR0ZEdoV2EzQklWakl4YjFadFNraFZiRkpXVFVad2VsWnRlSGRTYkhCR1QxZHNVMWRGU1RKV01XUXdXVlpzV0ZKc1pGaGhNbEpaV1d0YVlWZEdiSE5WYTA1UFVteGFNRlJXV210WFJrcHlZMGhzV21FeGNFeFpWbHBMWkZaR2MxRnNaRmRsYTBZMFZsWmplRll5VFhoalJXUlhZa1Z3Y0Zac1duZGxSbHBIVjIxR2FrMUVWa2hXTVdoelZERmFXVlZ0UmxkaVdGSjZWRzE0WVZkRk5WWlViR1JwVmxad05WWnFTakJPUmxwMFVtNUtXR0pYYUdGVVZ6VnZUVEZXYzFkclpHcGhlbFpZVmtkek1WVXlTbkpUYlVaWFlsaG9WRlV5YzNoV01XUlpZVVprYVdKRmNGWlhWekUwVXpGWmVHSklUbGRpVlZwWlZXMHhORlpzVm5STlZXUlZZWHBHV1ZwRlVsZFpWbHBZWVVaQ1dsWjZSa3hWYWtwUFVqSk9SMk5HWkZkaWEwbDVWbTB4ZDFGdFZrZFRXR3hWWVRGd2FGVnRNVk5YUm5CWVpFWmFhMDFXY0hwV1YzUnJWMGRLVjFkcmFGaGhNbWhRVm1wS1MxTkdWblJQVmxaWFlrWnZlbFpxUm1GWlZrbDRZa1JhVTJKRmNFOVdiR2hEVTFaa1dHUkdUbHBXYkZZMVZXMXdZV0ZXU25SaFJscFhZbFJHZGxWcldsWmxWMVpJVW14b1UxWkZXbHBXUkVaaFdWWlNjMU5yV2xSWFNFSllWbXRXY21WR1pGZFhiSEJzVm1zMWVsbHJaRzlWTWtwWVlVZG9XR0pIVVhkVmJURlhVakpLUlZkc1RtbGlWa3BWVmtaYWIxRXhUa2RpUmxwaFUwVTFXVlZ0ZEhkV01XdDNWMnRrVjAxcmNGWlZiWEJQVm0xR2NsZHJPV0ZXVm5BelZXMTRkMU5IUmtaT1ZUVnBVbGhDYUZacVJtcGxSMVp5VFZaa1lWSlhVbGhaYlhoTFl6RlZkMVpVUmxaU2JIQXdXbFZvYTFkR1duVlJiR1JYWWxoQ1JGWnFRWGhTVmtwellVWndUbEpzY0hsV2JURjZaVWRTVjFac1ZsSmlSMUpQV1ZkMFlWUldXbGhqUlhSVlRWVTFXVlV5ZEc5Vk1rcElWVzVDVm1KWWFIbGFSRVpoWkVVeFdWcEdUazVpUlZrd1ZtdGtNR0l4V2toU1dHeFdZbGRvVjFsc1VrZGtiRnB5VjJ4T1dGSlVSbGhWTW5NeFZUSktTVkZZWkZoV1JVcFlWRlZhVTJNeFRsbGFSMnhUVW10d1dGZFhkR3RpTWxaelYyeFdWR0V6VWxWVmFrSmhVMFphZEdWSVpHaFNWRVphVlZjd05WWXlSbkpUYldoYVpXdHdWRlV3V2xOalZtUnpWRzFzVkZKVmNGcFdNV1F3VmpKUmVGcElUbGhoTW1oelZXMHhVMVpXVWxoa1JtUk9UVlpLV0ZZeU1EVldNa3BXWTBWb1drMUdjSEpXYkZwaFRteGFjMVJ0UmxOU1ZuQTJWbXBDYTFZeFNuUlZhMmhxVWpKNFZGUldWblpOYkZsNFdrUkNXbFl3YkRWVmJYUmhWR3hhZEZWdVFsVldSVFZFVmpCYWMyTnNjRWRVYXpscFUwVktXRlpxU2pCTlIwVjRVMjVLVDFkSGFGaFVWelZ2VlVac1YxZHJjR3hTYXpWNlZWZDRiMVl5Vm5KVFZFSllWak5DUTFwVlpFNWxSbkJKVm14V2FWSnVRblpXUmxadlVUSldjMWRzYUU1VFIyaFhWRlpWTVZOR1dYbGxSemxWVFZad01GWlhlRzlYYlVwSFYyMUdWVll6YUhwWk1uaHJZekZTYzFwR1pHbFNNMk41VmpGYVYxWXdOVWRpUm1SWVltczFjVlZxU205V01XeFlaRWRHYkZadVFsbFVWbFpyVlRKR05tSkdhRmRTTTJoeVZsUkdZV1JXUm5SU2JHUm9ZVEZ3ZVZaR1ZtdFRiVlpIVjJ4c2FGSnNjSEJaV0hCWFYyeGtXRTFVVWxSTlZtdzBXV3RvVTJGdFZuSlhiR3hXWWxSRk1GcFdXbHBsVjFKRlVXMW9UbUV6UWtsV1ZFa3hZekZaZDAxWVJsZGlhM0JZV1ZkMGQxUkdXblJsUjNScVlsVmFTRmxWWkc5VWJHUkdVMnhhVjAxV2NHaFhWbHBPWlVaa1dXRkhSbE5pV0doNFZsY3dlRlV4WkVkV2JrNVlZbTFTV0ZadGVIZE5SbXQzVm0xMFdHSkdjSGxaTUdoelZsWmFjMk5JU2xkTlIxSklWRzE0WVdNeFduTlhiV2hvVFRCSmVWWXhaSGRTTVd4WVZXdGFUbFpzV2xkWmJHaFRWREZXY2xacmNFNVNiSEI0Vlcwd05XRkZNVmhWYTJ4V1RXNVNkbFp0TVV0amJHUnpZVVp3YVZJeWFGVldSbEpIWkRGa1NGWnJiRlJpV0ZKUFZtMDFRMVl4V2xoTlNHaHBUVlpzTlZWc2FIZFZiVVp6WTBac1YyRnJOVVJXVlZwelRteEtjMk5IZUZkaE0wRjRWbFJKZUdNeFZYaFRiRlpYWWtkU1dGbHNVa1pOUm5CRlVtNU9WMDFyTlVoWGExcHZZVlpKZUZOdWFGZFNiSEIyVlZSR1QxWXlTa2RYYkdSWFVsWndWMWRXYUhkU01VbDRZVE5rV0dKck5WaFVWVkpIVjFaYVNHTkdUbGRXYkhCWVdUQlZOVmxXV25OalJsSmFUVzVvTTFWcVJtdGtSMHBIVkdzMWFWWXlZM2RXYlRFMFlXMVdTRlp1U2s1V2JXaFdXVlJLVTJOR1ZYZFdibVJZVW14c00xZHJZelZXVlRGWFUyeG9XR0V4Y0ZCWmExcGhZekpPUlZGc1ZsZGlSbkI1VjFaV1lWTnRVWGhhUmxaVVlrWndjRll3V2t0T2JGbDRWMjFHV2xac2JEUlhhMmhYWVd4S2RGVnVRbGROUmxWM1ZGVmFZV05XUm5Sa1JrNU9WbGhDTmxadE1ERlVNV1JJVW1wYVYySnJTbUZaYTJSVFpHeGFXR1ZIUm1wTlZscDVWMnRhZDFZeVNraGtla1pYWWtkUmQxbHFSbUZYUmtwWllrWmFhV0V4Y0ZoWFZtUXdaR3N4UjFkWVpGaGlSVFZZVm0xek1VMUdVWGhYYXpsWFRXdHdTbFZYY0ZOV01WcEdZVE5vV2xaRldsaFpNbk40VjFaT2NrNVdaRk5oTTBKWlZtdGFhazFXVlhsVWJrNVlZa1phVlZsVVRsTmpWbEpYV2taT1RsWnNXbGxhVldSSFlVWkpkMVpxVGxwTlIwMHhWbXBLUjJOc1pIUmhSbVJvWVROQ1ZWWlVRbUZXTWs1MFUydGtWMkpYYUhOWmJHaHZWbXhaZUZwRVVscFdhekUwVmpGb2IxZEhTa2RYYkZKYVlrWktlbGxxUmxOV01XUnlaRWQ0YVZKc1dURldSM2hoVkRGYWMxTnVUbXBTVjJoWFZGZHdSMU5HV1hsbFIwWlRZa2RTZUZaSGVHdGhSVEZaVVcwNVYxWXphR2hWZWtwT1pWWlNjbUZIZUZOTmJtaFZWbTB3ZDA1Vk5VZFhiazVZWWxoU1VGVnRlSE5PUmxsNFlVZDBWV0pGTlVsV1YzaFhWMjFGZVZWVVFsZE5WbkJvV1RKNFlXUkdTblJoUms1cFYwZG9XRlpzWTNoT1IxRjVVMnRrV0dKcmNIRlZNR1EwVjFac1ZWSnVaRmRTYlhoWVZqSjRkMkpIU2xaWGEyaFdWak5vY2xsV1dtdFNiRTV6VW14b1YwMHdTa1JYYTFKTFZqRkplVlJyV21GU01GcFVWRmN4YjFac1dsaGpSV1JVVFd4S2VsWXlkR3RYUjBwWlZXeGtWVlp0VWxSVk1GcGhZekpHU1ZSdGFHbFNWM2Q2Vm1wS05HSXhaSFJUYTJSWVlXczFXRmxzYUc5aFJuQkdXa1prVTAxWVFraFhhMVV4WVVVd2QxTnJkRmRpV0doeFZGWmFUbVZHWkhOYVJtaG9UVmhDV2xkWE1ERlJNVnB6WWtoT2FGSjZiRlZWYlRWRFUwWlplV1ZGT1doaGVrWllWVEkxYzFaWFNraFZibkJYVmtWYWNsVnRlRTlqYlZaSFdrZHNWMUpXVmpOV01WcFRVVzFXUjFOdVNrOVdiSEJvVlcweGIyTkdiSEpXYm1SWVZtMVNXVlJXYUhkVWJGcDBWV3hvVjAxcVZreFdha3BMVm14a2MySkdXbWxYUjJoTlZtcEdZVlV5VFhoaVJGcFhZbGRvY0Zac2FFTlRWbVJWVVcxR1dsWnNjSHBXTWpWVFlVWk9SMk5HYUZwV00xSklWR3RhY21WWFZraFNiWEJYWWxaS05sZFVRbXRpTVZKeldrVmFWR0ZzV2xoWmJGSkhUVEZXTmxKc2NHeFdiRnA1V1ZWYWEyRkZNWFZoUnpsWFZucENORmxxUm10U01WWnpWbXhTYVZaSGVIZFdSbHBoWXpBMVIxZFliR3hTTUZwd1ZXMTBkMlZXYkhKVmJFNVlZWHBHU0ZZeU5YZFdNa3BJVld0NFYwMUhVa2hWYWtaWFl6RndTR0ZGTldsU1ZsbDZWbXBLTkZZeGJGZGlSbVJoVWxkb1ZsbFVSbmRXVm14ellVYzVWMUpzY0hsV2JYUjNWR3hLYzJOSWFGWk5ia0pFV1ZaVmVGWXhTbkZWYkdST1ZqSm9lVlpxUW10VE1WcFlVMnRrV0dKSFVuQldNR1J1Wld4YVIxcEVVbFpOVjFKSlZtMTBiMVV5U2xsUmF6bGFWa1ZhTTFVeWVHdGpiRnAwVW0xb1RsWnRkekZXVjNodlpERldkRk5yYUdoU2JXaFhXVmR6TVdSc1dYZFhiVVpYVm10d01GcEZXazlVYkZsNFUyMUdXRlpGU25KWmFrWmhVakZPZFZac1NtbFNNMmhhVm0weE5GTXhVa2RYYkZaVFlYcHNWRlJXV21GTlZscFlUVlJTVjFKcmJEUlZNbmhYVmpGS2RGVllaR0ZTUlZwUVZXcEdhMk50UmtaT1ZtUlRZVE5DTWxadE1IaE5SMUYzVFZaa1YySkhhSEZWYlhNeFYwWlNXR1JIUm14V2JHdzFWR3hXYTFkc1duTmpSbXhYVmpOTk1WZFdXbUZXTWs1R1pVZEdVMkpJUWxWWGExWnJVekZLY2s1V1drOVdNbmh3Vm1wS2IxbFdXblJqUldSb1lsWmFSMVJzVm10V1ZtUklZVVpzV2xaRmNGUlpNRnBXWkRGa2NtUkdWazVXYmtJMVZtcEtNRTFHV1hoWGJrNVVZa2RvV0ZSWGNFZFRSbHBJWlVkR2ExSXhTa1pXUjNoclZHMUdjbFpxVGxoV2JGcHlWV3BCTVdNeFRuVlViV3hUVFVad1dWWnRjRXRpYlZaelYyNUdVbUpZVWxSWmJGcGhVMVphU0dSSVRsZFNNSEJLVlZjd05WWldXWHBoUlhoWFVteHdhRnBGVlhoV1ZsWjBZVVUxYUdWclZYaFdiRkpMVFVkRmVWSnVUbFJpYkVwWFdXdGFTMWRHVWxaWGJVWlZVbXhLZWxZeU1VZGhNVWw0VjJ0c1ZtSllhRE5XYWtwTFUxWkdXVnBHWkdsU2JrSXlWMWR3UjFsV1pFZFVibFpWWWtkb2NGVnRkSGRoUm1SWFZXdDBhVTFWY0VoWmEyaEhWVEpLY2s1V2JGZGhhMFY0VlRCYWEyTnNaSFJQVm1ST1lUTkNXVlpVU25kV01WbDVVbTVLYVZKR1NsWldiRnAzWVVacmVXTXphRmROVjFKNVZERmFhMkZXV1hsaFJuQlhZbFJHTTFaRVNrcGxWbHAxVkd4b2FXRXhjRlpYVmxKUFZURmtWMWR1VW10U01GcFBWbTE0WVZkV2NGWmFSRUpvVW14d01GWlhkSE5YUjBaeVRsUk9WMDFIVWt4VmFrcFBVMGRHUjJOR1pGTlhSVXBTVmpGb2QxSXlVWGhVYkdSWFlteEtjbFZ0Y3pGalJsWjBUbFZPVmxac2JEUldNbmhQVmxVeFZsWnFVbGRTTTFKeVYxWmFUMUp0VGtkaFJuQm9UV3hLVlZkVVFtRlZNVmw0V2toS1lWSlViRlJaYTJRelRVWmtWMVp0T1doTmExcElWVEkxUzFReFdsaFZiR1JWVm5wV2RscEhlRnBsVjFaSFkwZDRhVkpzYjNkWFZsWmhaREZaZUZkdVZsSmlSbHBaV1ZSR1lXTnNXbkZTYXpsWFRWWmFNVlpITVVkVk1WcEhWMjVhVjFKc2NIWlZWRVpQVmpGa2RWTnNXbWhOYkVwb1ZtMHdlRTVHWkVkWFdHaG9Vak5TVmxsclduZFhWbHBZVGxWa1YySlZjRlpXYlhSVFZqQXhSMk5JY0ZkaVJuQlFXVEp6TVZkSFZrZFViV3hUWWxoUk1WWnRlR3BrTURGWFZWaG9XRmRIVWs5V2JURTBWVEZzVlZOc1RsaFNiRXBaV1RCV2EySkhTa2RqU0d4WFRXNU5NVlpVU2t0U2F6VlpZMFprVG1KdGFIbFhWbHBoWVRGT1NGSnJhRkJXYldodlZGZHpNRTFHV25OWk0yaFhUVlZzTlZaSGRHRmhWa3B6VTI1Q1ZtRnJXa3hhUjNoclZqRldjbFJ0ZEU1V01VcFpWbXBKTVZVeVJuTlRiR2hXWWtaYVZsWnRlRlpsUmxsM1YyeHdiRll4U2tsVU1WcFhZVlpKZUZOcmFGZFNNMmh4Vkd4YVdtVldUbk5pUmxaWVVqSm9XRlpHV21Ga01rNXpZVE5vV0dKRk5YSlZiRkp6VjBaa2NscEhPV2xTTUZZMFdUQmFkMVl5U2xsUmEzaFZZVEZ3UjFwVldtdGtWbEp6WVVkb1RsZEZTalJXYkdONFRVWk5lRmRZYUdsU2JXaHlWVEJrVTFZeFZuUmxSbVJQVW14c05WcEZaREJoUjBZMlVteGtWV0pIYUROV01HUkdaVlpXVlZGc2NGZGlTRUo1VmxSQ1lXUnRWblJVYTJSaFVqSm9iMVJXYUVOT1ZscHlXa1JDV2xZd01UUldNV2h6VmtkRmVWVnNiRnBYU0VKWVZqQmFZV05XU25Ka1IyeE9WbTVDVjFaV1pEUlpWbEp6VjFoa2FWSkdTbGhaYkZKWFZVWmFkRTFWZEdwaGVsWmFWVzE0YTJGV1pFaGhSemxZWWtaYWFGWnFSbXRTYXpGWFYyMUdVMkpXU2xCV2JUQXhVVEExYzFkc1ZsUldSVnB5VkZaa1UyVnNXWGxsUjNSWFRWWndSMVl5ZUc5V1ZsbzJWbTVhV2xaV2NIcFViWGhQWTIxU1JrOVhiRk5XUmxreVZtcEtNR0V5VFhoWFdHaFVZbXMxY1ZWdE5VTlhSbXhZWkVkR2FGSnRVbGhXTW5NeFlrWktkVkZyWkZoaE1YQnlXVlprUzFJeVRrZGlSbWhYVFRGS2VWZFhjRXRUYlZaSVUydGtWMkpGTlhCWmJGcExWbFphZEUxVVVtdE5SRVpJV1RCYVlWZEhTbFpYYmtKV1lsaFNNMXBXV25Ka01XUjFWR3hrYUdWcldYaFdiR040WWpGa2MxZFljR2hTV0doaFZGYzFUbVZHV25GU2JHUnFUVmhDU1ZscldrOWhWMFYzVjFSR1YyRnJiekJaVkVFeFVqSktSMXBHYUdsU01VcFdWMWN4ZWsxWFJrZFdia1pVWVd4S1ZsUldXbUZsVmxwMFRWVmtWMUpzY0RCV1YzaHZWakZaZWxSVVJscFdNMDQwVm1wS1QxSnRTa2RYYXpWb1lrWndUbFp0TVRCaE1VMTRVMjVLVDFadFVtOVZiVFZEVjBaU1ZWSnJjR3hpUm5Bd1drVmtSMVl3TVVWV2JuQldUV3BXVUZkV1drdGtSbFp6WVVad1YxSldiM3BXUjNoaFlUSk9jMWR1VGxoaGVteFlXV3RrTTAxV1dsVlRhbEpvVFZad1NWVnROVTloYkVwMFpVWm9XbUpIYUhaWlZWcHpWbXhrZEZKc1RsZGhNMEkyVm10amVHUXhVbk5YV0doVVlsVmFXRlJYTlZOV01WSnpWMnh3YkZKck5YcFdNakYzVlRKS1YxTnNjRmRpVkVVd1ZYcEdVMUl4WkhOV2JGSm9aVzE0ZUZaR1dtdFZNV1J6WWtaYVdHSlViRzlWYkZKSFYyeFdXRTVZVGxkTlZYQXdWbGR3WVZaV1duTmpSa0pXWVd0d1RGVXhXazlqTWtaSVlrZHNWMkV6UVhsV2JYaHJaREZGZUZkWVpFOVdiVkp4Vld4YWQxWXhiRmxqU0U1WVVteEtWMVpYZEd0VWJGcHpWMnhzWVZKWFRURldNbmhoWTIxT1JscEdaRTVoYkZwTlZtMXdTMUl5VG5OYVNFWlZZa1p3VDFadE5VTlhWbVJ5Vm0xMFYwMVZiRFJXVnpWTFZERmFWVlpzVWxkTlJscElWRzE0WVdSSFRrWmFSMmhPVWtaYVNsWlVSbTlqTVZWNFdrVm9WbUY2YkZkVVZXUlRaR3hzVmxkc1pHdFNWRVpZVmtkNGIxVXlTbGxoUkZwWVZteGFhRlpFU2tkak1XUjFWR3hTYVZJemFHOVdiWGhoVjIxUmVGZFlaRmhoTTFKeVZXcEdZVk5zYkZaWGJYUldUV3hhZVZWc2FHOVhSbHB6VjJ4a1lWWldjRXhXYWtaUFpGWktjMU50YkZkV2JrSmFWbTB3ZDAxV1JYaFViR1JZWW14S2MxVnFRbUZaVmxweFVtdDBWRlpzV2pCYVJXaFBWMFpKZDJORmFGZE5ibWgyVmpJeFJtVlhSa1pWYkdSWFlraENiMWRyVmxabFJscFhWbTVPV0dGNlZtOWFWM2hhVFd4YWRHVkhjRTVXYkVZMFZtMDFVMVpIUlhsaFJtUmFZbGhTVEZZd1duTlhSMUpKV2tkMGFWSnNhM2xXVnpCNFVqSkdkRk5yYkZKaE1YQllWbTV3UjJSc1draGxSMFpxWWtkU1ZsVnRlR3RXTWxaeVZsaGtXRll6UWtoV2JURlhWakZTZFZOdFJsTk5NRXBWVjFkMFYyUXlSa2RhUm1oclVqQmFWVlJXWkZOVFJtUnlWMjEwV0ZJd2NFZFViRnB6Vm0xR2NsSllhRlpoYTFweVdUSjRhMlJGT1ZkWGF6Vm9UVEJLU1ZZeFVrTlpWMGw0VjFoa1RsZEdXbGRaYkdSdlYwWldjbFp0Um1waVJscDRWVzB4TUdFeFduSk9XR3hWVFZad2NsWlVSbUZrVmtaelkwWmtUbFl4UlhkWFYzQkhWbTFSZDAxVmJHaFNiV2h3VlcxNGQxWnNaRmhrUjNSV1RXczFXRlpYZUd0WlZrcHlUbFU1VjJKVVJYZFVWRVphWlZVeFJWWnNaRTVTUlZwSFZsWmtkMVl4WkhOWGJHaG9VMGhDV0ZsWGRIZFVSbGw0VjJ0a2FtSldXa2hYYTJSdllVVXdkMU5zV2xkaVIxSXpWV3BHVW1WV1ZuTmFSbHBwWWtWd2RsWlhNWHBOVmxGNFlraE9ZVko2YkZkV2JYaDNaVlpaZVUxVlpGaGlSbXcwVlcxd1YxWXhXblJoU0ZwWFRVZFNURmw2Ums5a1ZrcHpWMjFzVTJKR1dUQldha1poV1Zac1dGUllhRmRpYTNCV1dWaHdjMVpHYkhKaFJVNVVWbTFTV0ZadE1UQlViRXAwVlc1d1YwMXFWa3haVmxwTFVtczFWMkZHVmxkbGJGcFFWa1phWVZsWFRsZFVia3BoVWpOQ2NGVnNVbGRPUmxweVdrUlNWMDFXYkRSV01qVlhWVzFLVldKR2FGZGhNVnBNV1RKNFlWSldTbkprUjNCT1ZteHZlRlpzWTNoaU1WVjVVbXBhVjJKdFVsaFdibkJYVFRGc2NWRlVSbGROVjFKYVdWVmtSMVV4U2xaalJtaFhVbXh3V0ZsNlFURlNNV1JaWWtkMFUwMHhTbHBXVjNCRFpERk9SMkV6WkZoaE1EVllWRlZTUjFOR2EzZFZhemxZWWtad1dGa3dXbTlaVmtwWVZXeG9WazFXY0ROVmJYTXhWbXMxVjFwSGJGaFNNVVY1Vm0wd2QyVkZOVWhUV0d4VVYwZG9hRlZzWkZOV1ZsbDNXa2M1V0ZadGVGWlZNbkJUVjJ4YWMxTnNaRmROYm1ob1dXdGFTMlJIVmtkaFJtUk9ZV3RXTTFadGRHRlRNbEpJVld0V1dHSklRbTlVVm1oRFpWWmFjVkZ0UmxWTlZYQjZWa2MxUzJGV1NuUlZiVGxWVm14YU0xVXhXbUZYUlRGSllVWmFhVlpyV1hwV1IzaGhXVmRHVjFOWWJHaFNiRXBXVm01d1IyUnNXbk5YYlVaclVqQTFSMXBGWkhOVWJGcHpZMFpzVjJGcmJ6Qlpha3BIWXpGT2MySkdXbWxTTVVwWFZtMHhORll3TlVkVmJrcFlZbFZhY2xWcVJtRlRSbVJ5VjIxR2FGWnNjRmhXTVZKSFZqSktTRlJZYUZaV1JWcHlXa1ZhUzFkWFNrZFhiR2hUVFZWd1dGWXhaREJaVjFGNFYydGtXR0pyV2xSWmJHaFRZMnhXY1ZKcmRGUlNiSEF3VkZab1QxWnJNVmRpUkZwWVZrVTFjbFpxU2t0U01VNXlaVVpXYUUxc1NsUlhiRlpoWVRKU1YxUnVTazlXYldoVVZtMDFRMWRzV1hoYVJFSm9UV3RzTkZZeGFHOVdiVXBJWVVaQ1YySnVRbnBXYlhoWFpFZFdSbVJGTlZOaWEwcFlWakowVjJFeVJrWk5WbVJxVTBoQ1YxUlhjRmROTVZsNVl6Tm9WRkpzV2pGWk1GcHJWakZLVmxkVVFsZGlWRUkwVmtSR1NtVldVbkphUjBaVFZrWmFkMWRYZUd0aU1EVkhWMWhzYkZKdFVtRldiWE14VFVaYWRHUkhkR2hpUlhCWlZsY3hiMVp0U2xsaFJFNWFUVVp3V0ZreFdsTmtSVGxYWVVaa2FWWnJjR0ZXTW5oWFlUQXhSMVZZYUZSWFIxSlFWbXhrYjFkR1VsaGpSbVJXVW14c00xZHJWakJoYXpGeVRsVndWazF1YUZoV2FrcExVMVpHY1Zkc1pGTk5NbWh2VjJ0U1IxbFhUWGhhU0U1WFlrZFNjRlZ0TlVOa01WcDBaVWM1VWsxWFVraFdNblJ2WWtaS05tSklSbFZXYlZKVVZGVmFWMk15UmtoUFZtaFRUVWhDU1ZaVVNqUmlNVnBYVjJwYVYySkZTbFpaVkVaM1RURldkR1ZIZEdwTldFSkpXVEJrYjJKSFJYaGpSbkJYWWxoQ1RGUnJaRVpsUmxwWllVZEdVMVp1UWxaWFYzUlhaREZrUjFWc1pHRlNWR3hRVlcxNFMyVldXWGxsUlRsb1RWVndlbGt3VWtkV01WbDZZVVpTV2xaV1ZqUldNVnBIWXpGd1IyRkdaRTVOYldkNVZtMTRVMUl5UlhoVFdHeFVZVEo0VjFsc2FGTldSbGwzVjJ0MFdHSkhVbGxhUldSSFlUQXhWazVWYUZkTlYyaDZWa2Q0WVZKc1RuTlhiRlpYWWtad05sWkdVa2RYYlZaV1RsWnNWV0pIVWxoWmEyaENaREZrVjFadFJsWk5WMUl3Vld4b2IyRnNTbGxoUm1SYVZqTlNNMVpWV2xkalZrcDBaRWR3VGxZeFNYZFhWM1JyWXpKR1JrMVZiRkpoTTFKWVdXeFNSazFHV25GU2JrNVlVbXhhV2xsVldsZGhSVEZaVVd4Q1YySlVRalJXVkVaaFl6SktTVk50UmxObGJYaFpWbGN4TkdReVZsZFhXR3hPVmxkU1dGUlZVa2RYUm10M1YyMDVXRkl3VmpSVk1uUlRWMnhhUmxKcVVsZGhhMXB5V2taa1MxSXhXbk5hUm1ST1lsZG5NVlp0TVRCVk1VbDVVbGhvVkZkSGFHaFZNRlV4WVVaV2RHVkhSbGhTYkVwV1ZWZDBNRmRHV25SVmJuQllZVEZLVkZsWE1VdFdNV1J6WWtaa2FWZEdTalpXYWtKclV6RmtWMVp1U2xCV2JrSlpWVEJXUzFkV1dsaGpSV1JhVmpBMVdGWkhlSE5oUmtwVlZteFNXbUV4Y0dGYVYzaGhVakZrYzFwR1pFNVdiWGN4VmxSSk1WVXhXblJUYTJoc1VtMW9ZVmxyWkc5a2JGSlZVbXh3YTAxWFVucFhhMlIzVmpKR05sWnFWbGhoTVZweVdrUkdVMlJHU25GWGJHUm9UVEZLV1ZkV1VrdFZhekZIVjI1R1ZHRXlVbGxWYlhSM1YyeHJkMWRyZEdoV2EzQllXVEJhYzFZeFdqWlNWRUpoVWtWd1VGbDZTa3RUVmtwelZHMW9iR0pZYUZwV2ExcGhXVlpzVmsxV1pGaGhNbWh6VldwQ1lXSXhXbkZSYkhCT1lrWndNRnBWYUd0V01ERnlZMFphVm1KSGFISlhWbHBLWld4U2NWVnNjR3hoTVhCNVYydGFZVll5VG5KT1ZtUm9VbXMxVDFac2FFTmhSbHB4VW0xMFQxSnNiRFZXVm1odlYwZEtjazVXYUZwaVdHaE1Wa1JHWVdSWFRrbFViR2hUWWtoQmQxZHNWbTloTVZKelUyNU9hbEp0ZUdoVmJGcExWa1paZVdWSFJtcGlWVFZJV1ZWYWQxUnNTblZSYkZaWFlXdHdObHBWV2xwbFZsSnlWMjFvVTAxR2NGVldiWEJIVXpGT1YxZHNhR3BTVjFKeVZGWlZNVk5XV25Sa1J6bG9WbXR3TUZsVldsTldWbHB6VjJ4b1ZWWkZXbWhhUlZWNFZsWldjMWRyTlZkV00yTjNWbTF3UjJJeVNYaGFSV2hVWW10d2NWVnNVbk5YUm14elZXdGthMkpHY0hwV01qVlBWakZhY2s1VVFsVk5WbkJ5Vm1wS1MxZFhSa1ZXYkdST1lteEtlRlpIZUdGaE1VbDRWRzVXVm1KWWFGUlZiRlozVmpGa1dHUkhSbHBXYkZwSVdXdGFhMVl4WkVoaFJtaFZWak5TTTFWdGVHRlRSMVpJWkVkb1YyRXlkekZYVmxaVFV6RmtSMWR1VGxSaE0yaFhXbGQwWVZWR1ZuRlNiVVpyVm1zMWVsbFZaSE5WTURGV1kwWmFWMkV4Y0ZSVmFrWktaREF4U1dGSFJsTmlWa3BhVjFkNFYxbFdXbGRWYkdoc1VsaFNXVlZ0ZUdGTlJsSnpWMjEwYUZKcmNIbFpNR2gzVjJzeFIxWlVSbGRoYTNCSVdUSXhUMU5XWkhOWGJXeFRZbXRLZGxadE1UUlpWbEY1Vkd4a1YySnJOVmhaV0hCWFYwWmFjbGR0UmxoaVJuQXdWRlZvYTFSc1duTldhbFpXWWxSV1VGWnJaRXRqTVdSelZHeHdhVmRHU2sxV2FrSmhZekZrU0ZScVdsTmlXRkp3VlcxNGQwNVdXbkZUYWxKclRXdHdTRll4YUd0VU1WcFlWVzFvVm1KR2NETlpWVnBoVTBVeFZtUkdUbWxXVkZaSVYxZDBZV0V4V1hoVGJHaHJVa1pLV0Zsc2FFTlVSbFp4VW14d2JGSnNTakZXUnpGelZUSkZlbEZ1WkZkV2VrVXdXa1JHYTFJeGNFZGhSM2hUWlcxNGQxWkdWbE5TTWxaelYyeG9iRko2YkhCVmJYUjNUVlpXV0U1Vk9WZE5hMXA1VmpJeGIxWnJNVmRqUms1aFZsWndjbGw2UmxOa1IwWkhXa2RvVG1GdFp6Rldha1poWWpKUmVGSllhRmhYUjJoWldXMTRTMVl4V25KV2EzUllVbXh3ZVZadE1VZFhSa3AxVVd0a1YwMXVUVEZaVjNONFYxWkdjbUpHY0U1U2JrSlZWbXhTUjFsWFVsZFNibEpRVm0xU1QxWnFSa2ROTVZsNFYyMTBWbUpXV2xoVk1qVkxXVlpKZWxGc1VsZGlWRlpFVmpKNGExZEhVa2RYYXpWWFlsWktXVlp0TURGU01WWjBVMnRzVW1GNmJHRlpWRVozWVVaU1ZsZHVTbXhpVlRWSFYydGFhMVJzU2taWGEyUlhWbnBGZDFkV1dtRmtSazV5V2taU2FFMXRhRmxYVm1Rd1pERlNSMWR1VGxoaE1sSlpWbXBDWVZOR2EzZGFSRkpvVWxSR1dsVlhlSGRXTWtwSVZHcFNZVlo2UmxoVmFrWnJWMWRLUjFWdGFFNWlWMmd5Vm14amVHVnJNVmRYYTJSWVlteEtVRlpzVlRGWlZscDBaVWhrYkdKSFVubFdWM2hQWVVaS1ZWSnNhRlpOYmtKRVZtcEdZV1JIUmtsWGJHaFhZa2hDVVZaWE1UUmhNazE0Vlc1T2FsSXllRmxWYkZKR1RVWmFkRTFVVWxwV2JYaFpWbGQwYjFaWFJuTmpSbEphVjBoQ1dGWnJXbk5rUjFKR1pFWm9VMkpIZHpGWGExWmhWREZXY2sxV1pHbFNSa3BYVkZkd1YxUkdiRmhsUlRsVVZtdGFNRlZ0ZUhkaFZscEhWMnRXVjFaRlNtaFdNakZTWlVad1NWVnNUbWhsYlhoM1ZsZDRiMUZ0VmtkYVJsWlNZbFZhWVZadGVITk9SbFY1WlVkMGFHSkZjREJaVlZwelYyMUZlR05IYUZwTmJtaG9WV3hhUzJOdFRraGxSbVJvVFRCSk1WWnFTakJaVmxsNVVteGtXRmRJUW05VmJUVkRWMFphY1ZSdE9WaFNia0pHVlZaU1IxWXdNVmhWYWtaWFVqTm9kbGxXV21GVFIxWkpZa1prVTJKSVFtOVhXSEJDVFZaWmVGcElTbWhTTTJoVVZGUkdTMlJzV2xobFJrNVNUVVJXV0Zrd1dtRldNVnBIVjJ4b1ZWWXpVak5XYlhoWFpFZFdSMVJzYUdsV1ZuQTFWbXBLTkdJeFpISk5WbVJxVWxob1lWUlhjRWRXUmxaeFVteGthazFZUWtsWmExcFRWVEZhVjJKRVdsZGlXRUpNVkZWYVdtVldTbGxoUmxKWVVqTm9WVmRXVWt0Vk1XUlhZa2hTYTFOSFVuRlZiWGhoWlZaWmVXUkVRbGhTYTNCNlZUSjRjMVpYU2tkWGJFSlhWa1ZhVEZsNlNrdFNWbEp6WVVkb1RsWnRkM3BXYlRFd1dWWk5lVlJZYUZWaWF6VnhWVzAxUTFkR1duUk9WVTVZVm14d01Ga3dWbXRYYkZsM1RWUldWazF1VWxoV2JHUkxVMFpXYzJGR1ZsZFNWWEJOVm10YVlWbFhUWGhoTTNCb1VtMVNUMVpxUmt0VFZscHlXWHBHVkUxcldraFZNalZMVkRGa1JsTnNaRnBoTVhCTVZqQmFZVlpzWkhSa1JtaFRWa1ZhUzFkV1ZtRlpWMFpJVm01S1dHSkhlRmhaVjNSeVpVWldjVkpzWkd0U2F6VjVXVlZhWVdGV1NuVlJiR1JYWWxSRk1GWnRNVmRTTVZaelYyeG9hVlpXY0ZWV1JtUXdXVlpPVjJORldtRlNlbXhZVkZkMFYwNXNWbGhsU0dSWVVqQndTRll5TldGV2JVWnlWMjFvVjJGclduSlpNVnByWXpGU2RHSkdUbWhOTUVwb1ZtMHdkMlZGTlVoVldHaFlZVEpTV1ZZd1pGTlhSbHB5Vm0xR1dGWnNXbnBXVnpWUFYwWmFkR1ZJYkZkaVJrcElWbXBCZUZKV1JuRldiR1JUVFRCS1dWWnRjRXRUTVdSWFZtNVdWR0pWV2xoVVZFRjRUa1phZEdORlpHaE5hekUwVjJ0b1MxUXhXblJWYmtKWFlXdHdkbFJ0ZUdGak1XdDZXa2Q0VTFaR1drbFdha2t4VkRGa1NGTnVUbFJoZW14WVdXeG9VMDB4V2tWU2JHUnJVakZhU2xkcldtdFViRmw0VTJwV1YySlVRalJVVlZwYVpEQXhXVk50Y0ZOV01VcFhWMWQwWVZNeFNrZFhXR3hxVFRKb1ZGUlhjekZUUmxwWVpVZDBhRkl3VmpaVlYzaHpWMFphUm1KNlFsWmxhM0JRVm1wR1lXUldVblJoUms1cFZtdHdVVlpyV21GV01sRjNUbFprV0dKck5XOVZNR1JUVmtaU1dHUkdaRTlTYkZZMFdWVmpOVmRzV25KT1ZXaFhUVzVvZGxZeU1VdFRSMFpHVld4a2FFMVlRbFZXYWtKV1pVWmtSazlXWkdoU01uaFVXVzEwUzFsV1dYbGxSbVJhVm14R05GWXhhR3RVYkdSR1kwWkNWMkpVUm5aV01GcHpZMnh3U0U5WGRHbFNNVXBaVm1wS2VrNVdWWGxTYWxwWFlrZG9XRlZxVG05WFJscHhVbTFHYW1KVk5VWldNbmhyWVZaa1JsTnJiRmhoTVVwSVYxWmtUbVZHY0VsV2JGWnBVbXh3ZDFaWE1ERlJNbEY0VjI1U2JGSjZiRk5VVm1SVFUwWlplV1JIT1dsU2EzQXdWbGR6TlZadFNsVlNiRkpoVmpOb2Nsa3llR0ZrVmxKelYyMXNWMWRGU2t0V01WcFhZVEZKZUdKR1pGaFhTRUpYV1d4a2IyRkdXbkZVYlRsc1lrWktNRnBWVmpCaE1WcDFVV3RvVjFJelRYaFdNRnBMVm0xT1JtUkdaRTVpYldoWlYxWlNTMVJ0VmtkYVJteG9VbTFvY0ZsclduZFdSbVJZWlVkMGFVMVhVa2haYTJoUFlVWktjazVYT1ZaaVdHZ3pWbTE0VjJSRk5WWlBWbVJPVWtWYVdWWlVTbmRTTVZsNFUxaHdhRkpzU21GV2JURlRWRVpXY1ZOck9WUlNWR3hZVjJ0YWExVXhXbGxSYkhCWFlrZG9NMVZxUm5OWFJsSlpZVVpvYVdKR2NGZFhWM1JyVlRGa1IxWnVUbGhpYlZKWVZtMTRkMWRXVWxaaFJ6bFZUVlZzTkZZeU5YZFhSMFY1WVVWNFYyRnJjRXhXTVZwWFl6SktSMWR0YkZoU2EydzJWbTB3ZUU1R2JGaFZhMmhYWVRKNFZsbHJhRU5YUm14VlZHdE9XRlp0VWxaVlZ6RkhZVlV4V0ZWdWNGZE5hbFpRV1ZkNFNtVlhSa2hTYlVaWFRURkplbFpZY0Vka01XUklWbXRzWVZKck5VOVdNRlpMVTBaYVNHVkhkR3BOYTFwWVZqRm9jMWxXU2tkWGJHaGFZa1pLUjFwRVJtRldWa3B5VGxkNFUySkdjR0ZYVmxaaFZqSkdSazFZVGxSaVIyaFpWbTV3Um1ReFpGZFhiWFJUVFd0d1NsWkhNVWRWTWxaMFpVWnNWMVo2UlRCWFZtUlhZekZrV1dKRk9WZE5NVXAzVmxjeE1HUXlWbk5oTTJSWFlsUnNXVlZxUWxkT1JsVjVaVVpPVjAxRVJqRlpWV1J2VmpKS1IyTkhhRnBsYTNCSVZXcEdkMUl4VW5SaVJtUk9ZbGRSTVZadE1IZGxSVFZJVWxob1ZWZEhlRlpaYlhoTFZteHNWVk5zVGxaTlYzaDVWakl4UjFkR1NuUmxTSEJYVFc1UmQxWkhNVXRTTWs1SFYyeGFhVlpGV2tsV2JURjZaVWRPY2sxV1ZsWmlSMUp3Vm10YVlWZFdXblJsUjNSVVRWVTFTVlZ0ZEd0aFJrcDFVV3hvVm1KSFVqWmFSRVpyWXpGa2RGSnNjRmROVlhCSVZrWmFWMk15UmtkVFdIQldZWHBzV0ZsWGRHRlRNWEJGVW0xR1YxWnJOWGhXVjNoclZHeGFjMkl6WkZkV2VrRjRWa1JHWVZOR1RuTmhSMmhUWWxaS2FGWnRjRTlVYlZaSFkwVm9iRkpyTlZoV2JYUjNaV3haZVUxVVVsWk5hM0JZVlRGb2ExWXhXalpSYWxKVlZsWndZVnBXV2s5amJHUjBZa1UxVG1KRmNGcFdiVEF4WkRGS2NrMVZaR0ZTYlZKb1ZXeG9VMVpXVm5SamVrWnNWbTFTZVZkcmFHdFdhekZXWTBSR1ZsWXphSHBXYWtaTFpFWlNXV0ZHY0doaE1YQjVWbGR3UzFNeFRsZFRiazVWWWxkb1QxWXdWa3RPYkZwMFRVaG9UMUp0ZUZkVVZscHJWMGRLU0dGSVRsWmlWRVpVV1dwR1lXTldSblZhUmxKVFlsaFJlbFpxU1hkT1ZtUkhVMjVPYVdWcmNGZFdiVEZ2Wkd4YWRHVkhSbE5pUjFKNVZERmtSMVl4V25WUmJUbFlZVEZ3YUZaRVNrNWxSbkJKVlcxb1UxWkdXbFZXVnpFMFpHMVdjMWR1UmxOaVdGSlBWVzB4TkZkV1dsZGhSemxYVmpCd1NWWlhlR3RYYlVWNVZXeFNWMDFXY0hwWmVrcEhVakZTZEdKRk5WZGhNMEphVm0wd2QwMVhSWGhWYms1WVltczFXVmxyWkRSaFJscHpXa2M1YW1KR2NIaFZWbWh2VmpKS1ZtSjZTbFpOYm1oeVdWWmFhMUl4VG5OV2JHUm9ZVEk0ZDFZeFdsWk5WMDE0Vkc1V1ZXSlhhRlJVVlZwM1ZsWmtXR1JIT1ZKTlYxSllWMnRvUzFZeVNsbFZiRnBWVm14YWVsUnNXbUZUUjFKSVQxZG9WMkV6UVhkV2JHUjZUbFphVjFkc1pGUmhNbEpvVm1wT2IyRkdhM2hYYXpscVZtdGFNRmxWVlRGVk1VcFhZMFYwVjJKWVVtaFpha3BHWlVaV1dXRkdhR2xpUlhCWVYxZDBZVk14YkZkaVNFNW9VbnBzYjFWdE1UQk9SbGw1WlVkMGFHSkdjSGxVYkdodlZqRlplbUZHYUZkU00yaG9XVEl4VDFJeVNrZGFSMmhvVFc1Uk1GWnFSbUZaVmxWNVZGaG9ZVk5HV2xaWmJHUTBWa1pXZEdSSVpGaFdiSEF3V1RCVk5WWnRTbGRTYWxKWFRXcFdTRlpYZUd0VFIwWkhZVVpXVjJKR1ZqUldSbHBoWTIxUmVGcElWbUZTTW1oVVZtdFdZVmxXV2xkYVNHUmFWbXhzTlZVeWRHOVdWMFp6VTJ4a1lWWXpVak5XYTFwWFkxWktkRkp0ZEZkaVJuQTJWbFprTkdFeVJsZFhia3BxVWtVMVdGUldaRTlPUmxKV1YyczFiRkp1UWtoWGEyUkhWa1pLV1ZGc2NGaFdNMmhZVjFaYWMxWXhaSFZTYkVwWVVqSm9VVlpYTUhoVk1sWlhZa1phVjJGclNtOVZiRkpIVmpGcmQyRklaRmROUkVZeFdWVm9ZVll3TVhWaFIyaFdZbGhvVUZreFdsTmpNWEJHVGxkc2FWWXlhREpXYWtadlpERkplVlJ1VWxkaWJFcFVXVlJLYjJOR1ZuTlZiR1JwVFZaS1dGWXlOVXRoTURGWFkwaHdWMVl6VW5KWlZsVjRZMnhhY1ZWc1pFNVdNbWd5Vm1wQ2ExSnRWa2hVYTJ4VFlrWndjRlpyVmxaa01WcHhVVzFHYWsxck1UUldiVFZMV1ZaSmVsVnVRbFppV0dnelZHeGFZV05XVGxWU2JXaE9WbXhaTUZacVNURlRNVkY0V2tWb2JGSXlhRmRaYTFwM1RURmFjbGR0UmxkV2ExcGFXVlZhVTFZeVJYaGpSRlpZVmtWS2FGbHFSbHBsUms1elYyMXdVMlZ0ZUZwWFZsSkhVekZPUjJKR1ZsTmhNMEp6VlcxNFMwMVdXblJsUms1b1ZtMVNSMVV5ZUZkV01WbDZZVVpTVjJGclduSlpla1pyWkZaV2RHTkdUbGRTTTJoVlZtdGFZVlp0VmtaT1ZXUllZa2RvYzFWcVFtRlpWbHAwWkVoa2JGWnNTbnBaVlZZd1ZqSktWbU5HY0ZkV00wSlFWbXhhWVdNeVRraGhSMFpUVmpGS1dWWlhjRWRrTVU1SVVtdGtZVkpVVmxWVmJGWjNWRlphZEdWSFJtaGhla1paVld4b2IxbFdTbGhWYkd4YVlsaG9URlp0ZUZwa01YQklUMVpvVTJKSVFqVldiVEF4WVRGYWMxTnVUbGhpYldoWFdXeFNWMk5zV2xWUldHaFlWbXRhZVZsclduZFdNVnAxVVd4R1YySllRa2hWTWpGWFpFWktjbFpzVm1sU01VcDNWbGR3UjFKdFVYaFhiazVXWVRKU1dWbHNXbUZYUmxsNVRsVjBXbFpyY0RCWlZXaERWbTFHY2xkcmVHRlNNMmhvVmpCa1YxSXhVblJqUlRWWFRUSm9XbFp0Y0VwTlZsVjRWVzVPV0dKcmNGQldiWGhoVjBac2MxVnNaRk5TYkhCNFZXMHhSMkV4U1hkT1ZXaFhVak5vY2xaSGVHRmtWa1p4VjJ4b1YwMHhTbFZXTVZwaFlUSk5lRnBJVG1GU2JFcHdWV3hXZDFkV1pGZGFSRUpUVFVSV1NGWXlOVWRXUjBZMllrWlNWVlpzV21oVVZWcFhaRWRXUms5WGFGZGlTRUkxVjFSQ1lWTXhXWGxUYTJSVVlURktZVlpyVm1GVE1YQldWMnM1V0ZZd1drbFpNRnBQVmpBeGRHRkVXbGRpUjFJelZYcEJNVkl4Y0VkYVJtUnBZVEZ3VlZkV1VrZGtNazV6Vld4a1dHSnRVazlWYlRWRFZqRlplV042VmxkaGVrWkdWVzAxYzFZeVNsbFJiR2hYWVd0YWFGcEZaRWRUVjA1SFdrZHNWMUpXY0U1V01XaDNVakZSZVZSWWJGTmhNbEp4VldwS05GZFdWblJrU0U1UFlrWnNORmxWYUd0Vk1ERlhZa1JXVjFKdGFIWlhWbHBQVW0xT1NWTnNXbWxXUlZwVlZtcENZV015VFhsU2EyaFFWbFJzY0ZWdE5VTk9iRmw1WkVaT1VrMXJXa2RVVm1oTFYwZEtTRlZzV2xkaVdHZ3pXVEo0YzFkSFZrWlBWbEpUVFVad1NWZFdWbUZaVjBaWVUyNUtWR0V4U2xoVmJYaDNZVVpzTmxKdGRGUlNiRXBhV1RCa2IxVXlTbGRUYmxwWVlrZFJNRmRXV210V01YQkhZVWQwVTAxR2NIbFdSbHBoVXpKV2MxWllhR2hUUlRWdlZXMTBkazFzYkhKWGJrNVhUV3R3V2xsVlpHOVhiRnBYWTBoS1YyRnJXbkphUldSVFVqRndSazVYYUd4aVJuQktWbTB3ZDJWRk5VZGlSbWhUWWtkU1ZWWXdaRzlXVm14MFRWWk9XRkp0ZUhwWlZWcFBZVVpLYzJKRVZsVldiSEJ5V1ZkemVGZEdWbk5qUm5CWFZtNUNNbGRXV21GWlZsbDVWR3RzV0dKSFVsUlphMmhEVjFaa2NsVnJTbXhTYTJ3MFYydG9TMkZHU1hwVmJGSmFZa1p3VEZZeWVHRlhSMDVHVkcxMFRsWlVWa2xXYWtadll6SktSMU51U2s5V2JXaGhXV3RhWVUweFZYZFhiRnBzVmpGYVNWUXhXbXRoVmxwWlVXdHNXRlpGU25aVmVrWmFaREF4Vm1GR1dtbFNWWEJZVjFkNFUxSXhXa2RXYmtaVFlrVTFjVmxZY0ZkWFJtUnlWbFJHVjAxWFVrZFZNbk40VmpKS1ZWRnFVbFZoTVhCNlZqQmFUMWRYU2tkWGJHaFRUVzFvZGxac1pEUmhNa2w0VjJ4a2FWTkZjR2hWYTFwTFYwWlNWMXBFVWxoaVIzUXpXVlZWTlZkSFNrZGpTSEJhVFVaS1NGWXljM2hTTVdSMFlVWndhRTFzU2sxV1YzQkhWREpOZVZKclpHRlNWRlp2V1ZSR1dtVnNXblJOV0dSU1lsWmFTVlpITlU5WlZrNUdZMGhHVm1KWWFETldSRVp6WkVkTmVscEhlRk5pU0VGM1YxUkNWMDFHV2taTldFcFBWMGhDV0ZWdWNGZFRSbGwzV2tWMFZGSXdXa2haVlZwM1lVVXhWMkl6Y0ZkaVJuQm9XVlJHYTFkR1VuSlhiWFJUWVhwV1VGWnRlR3ROTURGSFYyNU9XbVZyV2xWVVZtUTBWMFpWZUdGSVpGWmlWWEJJVlRKNGIxZHNXa1pYYWs1YVZsWndlbFp0ZUd0a1IxSkhZVVpPVGxaWVFrdFdiR040VGtkUmVGZFlaRTVXVjFKeFZXeGtORmRHYkhKYVJrcE9VbTFTV0ZZeU1UQldSa3B5VGxoc1YwMXVUVEZXYWtwTFVtMU9SMkpHYUZkTk1tZ3lWbXRqZUZZeFNYaFdiazVZWWtkb2NGbHNXa3RXVm1SWVpFZEdhMDFXY0hwV2JUVlRZa1pKZWxWc1dscGhNVm96VldwR1dtVlhVa2xVYkdoVFlraENTRlpVU1hoaU1XeFhVMnRhV0dKcmNGZFVWVnAzVlVacmVXVklaRk5OYTFwSldXdGtiMVJyTVVaalJteFhZbFJDTkZSclduTlhSbFpaWVVab2FFMXNTbHBYVnpFMFV6Sk9WMVZzVmxSaVZHeFlWbTE0ZDAxR1VuTldhemxXVFVSR1dGVnRjRk5XTURGeFVsaGtWMkpZVGpSWk1qRlBVbTFPUjFkc1pHeGhNWEJLVm0weGQxTXhUWGhhUm1SVFltdHdWMWxyYUVOWFJsWnpZVVZPV0ZadFVsWlZNalYzWWtaS2MySkVVbHBOUmxwMldWWmFTMk5yTlZsUmJHUm9ZVE5DTWxac1dtRlpWMUpHVFZaV1ZtSlhlRTlXYkZwYVRWWmFjbGR0T1dsTlYxSkpWVEkxUzFReFduUlZiVVpYWVRGYU0xWnJXbHBsUm1SMVZHMXdhVk5GU2tsV2EyTjRUa1paZVZOc1pGUmhiRnBaVm0xNFlWWXhVbk5YYkhCc1VtMVNXbGRyWkhkVk1rcFhVMnhzVjFKdFVqTldha0YzWlVaa2RWSnNTbGhTTW1oNFZtMHhOR1F5VmtkWGEyaHNVak5TVmxsclZuZE5WbFpZVFVSV1YwMVZiekpWYkZKRFZtMUdjbGR1U2xkTlJuQk1XVEo0ZDFOR1NuTlViV3hYWVROQ1YxWnRNWGRSTVZsNFZGaG9ZVk5GTlZsV01HUnZWakZzVlZSclRtcE5WbG93V2xWa1IxUnNTbk5qUkVKVllrWndVRlpxUmtwa01WcHhWV3h3VGxKdVFrbFdiWEJMVXpGYVYxTnVUbFppUjFKVVZXeGFkMVpXV25GUmJGcHNVbTFTUjFReFdtRlVNVnBWVm14b1dtSllVa2hVVkVaaFkyeGtkRkp0YkU1aE1Wa3dWbTE0YjJFeFVuTlhibEpvVTBVMVYxbHNVa2RXUmxwMFpVaE9hbUpJUWtsVU1WcGhWVEpLV1dGR2JGZGhhMjkzVkZWa1JtVkdUblZVYkdob1lUQndWMVpHV21Ga01rWkhZa1prV0dFelVuRlpiRlV4VTBac2NsZHRPVmROVlhCWlZEQm9hMWRHWkVsUmEzaFhVbnBHV0ZWcVJuZFRWbHB6VjIxc1UxWkdXak5XYkdSM1V6SkplRnBHWkdGU2JXaHlWVzB4VTJOc1VsWlZiR1JzWWtac05GbFZhRTloUlRGV1kwaHNWV0pHY0ZCV2JGcGhaRVpXYzFWdFJsZE5NbWhvVjJ4YVZrMVdXWGhWYms1aFVqSjRXRlp0ZUhKbFJsbDVaVVprV2xZd01UUlhhMmhQVjBkRmVHTkdiRnBXUlRWMlZtcEdVMVpzWkhWYVJuQlhZbXRLV1ZZeWRHRmhNVnBIVTI1S2FsTkhlRlpVVm1SVFpXeGFWVk5yZEdwaVJUVldWVEo0YTJGV1NuVlJibXhYVWpOU2FGWXlNVmRXTVU1MVUyeG9hR1ZzV2xsWFYzaGhVekpXUjFkc2FHdFNNRnB5VkZaa1UxZEdXWGxPVlhSWFRXdFdObFpYTlVkWGJVVjRZMFJPVjAxV2NGUldha1pyWkVkU1IyRkdUbWhOTUVreFZtdGtOR0l5VFhoYVNFNVlZa2RvVjFsWGN6RlhSbHB5Vm0xR2FGSnNXbmhWYlRFd1lURmFkRlZ1Y0ZwV1ZuQnlWa2R6ZUdSR2IzcGlSbVJwVjBkb2VWZHNZM2hXTVVsNFZHeHNhRkl3V2xSWmJHaHZaR3hhV0UxVVVtdE5hMncwVmxkNFYxVnRSWHBWYms1YVlURndNMVl4V2xOV01WWnpWR3hhVGxKRldrZFdiVEUwWWpGWmVWTnJhR2hUU0VKaFZtdFdZVlJHVW5STlZYUlRUV3RhU0ZkclpHOWhSVEZKVVc1YVYwMXVhSEpVYTFwclpFWmFjMkZHWkdoTmJFcHZWbGN3ZUZVeFVYaGlSbFpUWWtoQ1QxVnRNVk5XYkZaWVpVVTVWMVpVUmxoWmExSlBWbFphYzJOSVNscFdNMmhNVlcxek1WWXlSa2RqUm1ST1RWVndkbFl4V2xkWlYxRjRVMWhvWVZORk5WWlpiR2hEWWpGd1dHVkhSbGhpUjFKWldrVmtSMVpWTVhKWGJHeFdZa2RvY2xsVlZYZGxWMVpIWVVad1YwMHhTbTlYVmxaaFdWZE9WMU51VWxOaVdFSnZXbGQ0WVZkV1pGZFdiVVpWVFd0YVdGVXhhRzlXUjBwSFkwWm9XbFl6VWt4Wk1uaGhWbFpLYzFwR1RrNVdNVWw0VmxSS05HRXlSbGRYYkdScVVtNUNXRlp1Y0VaTlJtUlhWbGhvVTAxV1ducFhhMXAzWWtkS1IyTklXbGRXZWtWM1drUkJlRkl5VGtkWGJHaHBZWHBXYUZadE1UUmtNV1JIVjFoc2FsSlViRmxaYkZaWFRrWnJkMXBGWkZwV2EzQkhWakkxUzFkck1YRlNiRUpXWVd0d1NGVXdaRWRTYXpWWFlVWk9WMVp0ZERWV2JURjNVakZzVjFkWWFGaGliRXBZV1ZSS1UxWldiSEphUms1WFVtMTRlVmRyVWxOaFZURlhWMnBDVlZac2NGQldha1pMWkVkV1NXSkdaR2xXUmxwNVZtMTRZVmxYVFhsVWEyUllZa1p3VDFacVNtOU5iRnAwWTBWS2JGSXdOWGxVVmxwWFZtMUtTRlZzYUdGV00yaG9WakZhWVdSSFRrWmtSbEpPVmxkM01GWnJZekZWTVZaSFYxaGtXR0pIYUZaV2ExWmhWRVpzY1ZKdFJtcE5WbkF3VlcxNGQxWXdNVlpqUlhCWFlrZFJkMWxxU2tabFJrNXpWbTFzVTJKRmNGZFdiVEUwWkRBd2VGWllhRmhpU0VKelZtcEdTMU5XVm5STlZ6bFZZa1p3TUZwSWNFZFdNVnBHWW5wQ1dtVnJXbGhhUlZwUFkyeGtjMVZ0YkZOTlZYQnZWbTB4ZDFReFZYbFNhMlJZWVRGd1dWbHJhRU5qYkZKWFdrWk9UbFpzY0VsVVZtaHJZVVphY21KRVVsWk5WMmh5Vm1wR1MxSnNaSFJoUm1Sb1lUTkNTVlp0Y0VkVU1rMTRWMjVPWVZJeWFFOVpiVEZ2V1ZaYWRFMVVRbGROVlRFMVZrYzFUMkZXVGtaWGJGSmFZa1phYUZZd1dsTldNWEJIVkcxNFYySkhkekZYYkZacVRsZEdSMWR1VG1sU1JscGhWbXhrVGsxV1duRlNiSEJzWWtaYWVsbFZXbTlXTWtwWFUyeHNXRmRJUWt4VmJURlhaRVpPY21GSGVGTmlSWEJWVmtaYVYyUXhXbk5YYmtwWVlsVmFXRmxZY0VkV01WSlhWbTEwYUdKRmNGaFpNR1J2Vm1zeFIxWllhRmROUm5CVVZtcEdhMlJXY0VkVWF6VlhZbXRKTWxZeFdsZGlNVkY0VjFoa1RsZEZjSEZWYkdSdlZqRlNXRTVXU210TlYxSllWakl4UjFkR1NuTlhibkJYVW5wR1NGWnFSbUZrVmtaellrWm9XRk5GU2tsWFZsSkxWREpPY2s1V1pHRlNNbWhVV1Zod1YxZHNXbGhsUm1SclRWWldORll5TlZOVWJFNUlZVVU1Vm1KWWFIcFViRnBoVmpKR1NFOVhhRmRoTTBGM1ZteGpNVkV4V25KTlZXUllZV3MxWVZac1duZFhSbkJIV2tVNVZGWnNTbnBYYTFwUFlWWktkRTlVVGxkaE1sRXdWbXBHVW1WR1pISmFSbWhwWVhwV1ZsZFhkR3RpTVdSSFlraE9hRkpWTlZSVmJURTBWakZhYzJGSE9WZE5hM0JYVkd4V2QxZHJNVWRqUkU1WFVqTm9URmt5TVU5U2JVcEhXa2RzV0ZKVmNFNVdiR2gzVWpGc1YxZFlhRlZpYXpWd1ZXcENZVlpHYkhOWGEzUnJZa1p3U0ZZeU1EVlZhekZYVTJ4b1YwMXFWbFJaYTFwS1pERmtjMVpzVmxkaVZrcFZWbXBHWVZadFZsaFZhMmhyVWpKb1ZGbFVUa0prTVZweldYcEdWVTFYVW5wV01uUmhWa2RLZEdWSGFGWmhNVnBvV1ZWYWQxSnNXbGxoUm1oWFltdEtTVlpzWkhwTlZsbDVVMnRrYUUweVVsaFphMXBMVTBac2NWTnJOV3hTYlZKNldWVmFUMWRHU1hwaFJtaFlWbnBGZDFWNlJscGxSMHBKVkcxb1UyVnRlSFpXVnpCNFRVVXdlRmRZYkU5V1ZHeFlWRlphZDJWV1dYbGpSV1JZVWpCV05WWldVa05XTVZwR1kwVjRWMkZyV2xCWk1WcHJZekZ3U0dGSGFFNWhiV2Q2Vm0weE1GVXhUWGhUV0d4VlltdHdUMVp0TVRSV2JHeHlWbFJHYVUxWGVIbFdiVFZyWVVaS2RGVnNhRmRXTTFGM1dWWlZlRll5VGtaaFJtUk9ZbXhLTWxkWGRHRlRiVkY0V2toV1UySklRbGxWTUZaTFYxWmFjVk5xVWxkTlYxSkpWbTEwYjFVeVNsaGhSbEpWVmxad1lWUlZXbXRXVmtaMFkwVTVWMkpIZHpCV2FrWnZaREpHUjFOWWJHaFNiV2hZV1ZSR1lVMHhXa1ZTYm1SWFRWZFNlVnBGWkhkaFZrbDRVMWhrVjFaNlJUQldSRVpUWkVaT2MyRkhhRk5TV0VKWlZrWmpNV0l5VG5OVmJGcFlZWHBzY1ZsWWNFZFhSbVJ5VjIwNVdGSnJiRFpaVldoelZqRmFObFpxVGxwbGExcFhXbFZhVjJNeGNFaFNiRTVvWld4YVYxWnNZM2hPUmxsM1RsWmtWbUpyTlZoWlYzUkxWMFphYzFWclpGZE5Wa3A2Vm0wMWExWXlTa2RpZWtwV1lsaFNkbFpxU2tkamJVNUdaVVprYVZKdVFrMVhXSEJIVmpKTmVHTkZaRlZpUjFKd1dWUkNXazFzV25SbFIzQnNVbFJXU1ZWc2FITldWMHB6VTJ4a1dsWkZjSFpaTW5oWFpFVXhWMVJ0Y0ZOaVJtOTNWa1pXVTFZeFVuSk5WbVJxVTBoQ1dWWnJWVEZrYkZwRlVtdHdhMDFyY0VaV1YzaHJZVlpKZVdGRVNsZGhhMHB5VlcweFYxTkdVbkphUjJ4VFltdEtXVlpHVWtKbFJUVkhWMjVHVW1KVlduRlVWbHAzVjBaVmVVNVZkR2hOVlhCNlZqSjRVMWR0UlhoWGFrNVZZa1p3YUZwRlpGZFRSVGxZWWtVMVYySkdiRFpXYTFwaFlqRk5lRlZZYUZoaVIyaFhXV3RrYjFac1duRlVhMDVUVFZaS1YxWXlNVWRXTVZweVkwUkNWbUpVUmpOWlZscGhWbFphY21KR1pHaGhNamgzVjFkd1IxZHRWbGRYYmxaVVlrZFNXVlZxUmt0WFZscHhVVzA1VWsxVk5VaFphMUpoVlRKS1NWRnVUbFppVkZaRVZUQmFjMk5zY0VaYVJscE9ZVE5DV1ZaVVNURlpWbGw0VTI1T1ZHRXlhRmRhVjNSaFYwWldjVkp0ZEdwaVNFSklXVlZrYzFkR1NuSmpSa3BYWWtkT00xcFZXbFpsUmxKeVdrZEdWRkpZUWxwWFZ6RjZUVmRKZUdKSVNsZGliVkpaVm0xNGQxZFdVbFpWYkdSWFRVUkdlVll5TlhOV2F6RjFVV3hDVjJGcmNFaFpNbmhyWXpGV2MyTkZOV2xpVjJoYVZqRlNTMDVIVVhoVFdHaHFVbGRvYjFWcVRtOWlNVkpYWVVWT1dsWnNjREJhVlZwUFZrZEtWMWRyYkZaTlYyaDJWakJrUzJOdFRrWlBWbVJPVW14d2IxWnRkR0ZqTVZwWFZHNU9WV0pYYUZSWmExcDNUbFphZEUxSWFGTk5hMW93VlRKMGIyRXhTa2RYYldoWFlrWndNMVpWV25OWFIwMTZZVVpvVTJKR2IzaFhWRUpoWWpKR1JrMVlUbFJoYkhCWVdXdGFTMVJHVmpaVGF6bHFUVlpLTVZVeU1YZFZNa3BYVTI1YVdGWnNTa2hhUkVGNFl6RndTVk5zV21oTmJFcFdWMWQ0WVZsV1RrZFhhMmhzVTBVMWIxVnRkSGROUm14V1lVVk9XR0pIVWtwVlYzaHZWakpLV1dGSVNsZE5SbFkwVm14YVIyUkhVa1pPVm1ScFlUQndZVlpxUm10TlIwbDRWRmhvYVZKdFVsVlpWM2gzWTBaV2RFMVhPVmRpUm5Bd1dsVm9hMVpXU25OalJFSmhWbFp3YUZscldtRldWa3B5VjJ4a2FWZEhhRzlXYTJRMFdWWmtWMUp1UmxoaVIyaFlWV3hXZDJJeFpGaGpSV1JZWWxaR00xUldXbk5XTWtwWVlVWldWbUpIYUVSV01WcGhaRWRTUjFwR1RrNVNSbHBKVm1wSk1WVXhVbk5YYkZacFVteEtZVmxVU205U1JsVjNWMjFHYTFJd05ESlZiWGhyVkcxRmVGZFVTbGRXYlUxNFYxWmFXbVF3TVZkYVIzQlRZa1Z3V0ZkV1pEQlpWbEY0WTBaYVdHSllVbkpXYlhoaFpXeGFkRTFYT1ZWaVZYQkhXVEJhYjFZd01WaFZXR1JhVmtWYVYxcFdXbE5qYkhCSFdrZHNhVkpZUWxKV2JURTBWbXN4V0ZSclpGWmlSMUpvVlcxek1WZEdiSEpYYlVaWVZteEtXRlp0TVRCV01ERnlWMVJLVm1KWWFISldNbk40VTBkR1JWUnNaR2hoTUZrd1YxUkdZVmxYVFhsU2EyUmhVako0VkZSV1ZuZFViRnB6V1ROa2JGSnNSalJXUjNoclZUSktjazVXYkZwaVIxRXdWbXRhYzJSSFVrWmFSVGxwVW01QmQxZFVRbGRVTVdSelYxaGtWMkZzU2xoVVZtUnZaR3hhY1ZOcmRHcGlWVFZJVlcxNGEyRldaRWhoUnpsWFlURktTRmRXWkZOVFJscHlZa2RHVTFaSGVIZFdWekF4VVRBMVIxZHNWbFJpYlZKWFZGWmtVMlZzV1hsT1ZrNVhZbFZXTlZwVldtdFhiVVY1Vlc1YVdrMXVhR2hWYkZwTFpFWktkR1JHVG1sU2JrRXlWbTF3UzA1SFJYbFNhMXBPVm0xU2NGUlVTalJYVm14eVdrWktUbEpzY0ZaVmJURkhZV3N4V1ZGcmNGZFdNMmhRV1ZaYVNtVlhSa2RXYkdSVFlraENiMWRyVWtkVU1VbDRXa1pzYVZJelVsUlVWVnAzWkd4YVIxcEVRbHBXYlZKSVZteG9jMkpHVGtaT1ZtUmFZa1phYUZwWGVGcGxWMVpKVkd4a1RtRXpRbUZYVmxacllqRlplVkp1U2xoaGF6VllXV3hvYjJOc2JEWlNiWFJyVWpGYVNGWkhNWE5XTWtWNVQwaHNWMkpZUWt4VVZXUkdaVlpXV1dGR1pGaFNNbWhhVjFjeE1HUXlUbGRXYmxKT1ZrWktXVlZ0TVRSbGJGcFlaRWRHVldKRmNERlZWM1JoVm0xS1dXRkVUbHBoTVhCTVdYcEdhMk5XU25OWGF6Vm9ZVEZ3U2xadGVGTlNNV3hYVTFob1lWTkdXbkZWYlRGVFYwWndXR1JHV210TlYxSjVWbGQwTUZZd01YSk5WRkpZWVRGd2VsbFdXa3BsYlVaSFZXeGthRTFzUlhkWGEyUTBXVlprU0ZaclpGVmlSVFZQVm14U1YwNXNXblJOVkZKcFRXdHdTRlV5TlV0VU1WcDBaVVprV2xZelVreFVWRVpXWkRGa2RWTnRkRTVoTVhCS1ZsY3hOR0l5UmxkWGJHUnFVa1phV0ZsWGRIWmtNV3hWVW01T1YwMVhVbnBYYTJSM1ZUQXhkR0ZIYUZoaVIxRjNWMVpWZDJWR1duVlNiRTVwWWxaS1ZsWlhjRU5aVmtsNFZXNU9ZVk5GTlZkVVZtUlRVakZWZVUxVlpGZE5hM0JXVld4U1ExZHNXa1pTV0doV1RVWndVRll4WkV0U01WWnpZVVpPVG1KWGFGaFdiVEYzVVRKRmVWTllhR0ZTVjFKd1ZUQmFTMk14Vm5OaFJrNXFWbTE0ZVZZeU1VZGlSMHBJWlVaa1YwMXVUVEZXYWtGNFVsWktjMkpIUmxkV01tZzJWbTF3UW1WSFRsZFhibFpVWWtkU2IxbFVRbHBOUmxwMFkwVmtWVTFyTVRWVmJYUnJZV3hLZEZWc2FGVldla1oyVkd4YVlXUkZNVmxhUmxKT1ZsUkZNRlpVUm05ak1WcFlVbGhzYkZORldsZFpiRkpIVmtaYVJWSnVUbXRTTVZwSFdrVlZNV0ZXU25WUldHUlhVbXh3VkZaVVJtdFRSazV6V2tab2FHRXdjRmhYVjNodlZUSkdSMkpHV2xoaE0xSnhWRlprVTAxV1ZsaGxSM1JvVWxSR1dGa3dZelZXTWtwWllVZG9XRlpzY0hKVmJYTjRWakZhYzFkdGJGTmlTRUpSVmpGYWIyUXhTbkpOVldSWVltdHdZVnBYZEdGV2JGSlhXa1JTV0ZKc1ZqVlViRnBQVmpKS1ZtTkZiRnBXVm5CeVZqSXhSbVZIVGtoaFIwWlhZa2hCZWxadGNFZGhNbEpIVTI1U2ExSnJOVTlXYlRWRFV6RmFjMWt6Wkd4U01HdzBWbGMxVTFVeVJuTmpSbEpYVFVkb1JGWXdXbGRqVmxKMFQxWm9VMkpZYUZkV1Z6QjRVakZrUjFOdVNrOVdSVnBYVkZjMVRrMVdXbkZUYTNSVFlsVTFTVmxWV205V01rcEdZMFZzV0dFeFNrTmFSRXBYVWpGd1NWWnNVbWxTTW1oM1YxWm9kMVl4WkZkWGJsSk9Wa1pLVlZSWGVHRlhSbGw1WkVjNWFWSnJjREJXVnpBMVZqSktXVlZxVG1GV00yaDVXa1JHVjJSR1NuTmFSVFZvVFRCS1dGWnNXbXRrTVZWNFYyNVNVMkpyY0ZsWmEyUnZXVlpTV0U1Vk9VOVNiSEI0VlcwMWExVXdNWEpYYTJ4YVlURndVRlpITVV0WFIwWklVbXhrYVZkR1NtOVhWbVI2WlVaa1IxUnNiR2xTYXpWdlZGZDRTMlF4V2xoTlNHaHBUV3MxV0ZaWGVGZFdSMHBWWWtac1YySllhR2hhVlZwWFpFVXhWbHBHWkZOaE0wRjNWbXhqTVdNeFdYZE5XRVpUWVRKb1lWWnNXbmRoUm5CR1YyeGthbUpWV2toV01uTXhZVmRHTmxWWVpGZGlWRVl6VlhwR1RtVkdUbGxoUmxacFlUTkNlbFpYTUhoVk1rbDRZa1pXVTJKdFVuTldiWGgzWlVaV1dFMVZaRmRTVkVaNVZHeG9kMWRIUlhsaFJrSlhZV3R3VEZZd1pGZFNNVlp6WTBkc1dGSnJjRTVXYlhCTFRrWmtkRlpyWkdwU1ZscFRXV3RvUTFkR1VsZFdiSEJPVW14d2VWZHJVbE5oUlRGWVZXdHNWazFxVmt4V1JFWmhaRWRHU0ZKc2NGZFNXRUpWVm0xMFlWbFdXbk5hU0U1aFVqTlNWRlJXVm5kVE1WcHlXa2h3VDFac1ZqVlZNblJyVjBaYVJsZHNhRlpoYXpWMlZqQmFVMVpzWkhOalIzaFRZWHBXWVZZeWRHdGtNVlY0VjFob1ZHSlhhRmhWYlhoaFlVWndSVk5zVG1wTlYxSXhWVzE0VTJGRk1IaFRiRlpYVW14d1YxUldaRmRXTWtwSFYyeG9hVkl4U25aV2JUQjRWVEZPVjJKR1dscGxiRnBZVkZkMGQxZHNWbGhrUnpsWVlrWndSMWt3VlRWWlZscFlWV3hDVm1KWWFETlZha1poWkVkR1NHVkhiRk5pYTBwb1ZtMHdkMlF5VVhkTlZtUlRZbXR3VDFZd1ZURlhWbXgwWkVkR1YxWnRlRmxhUlZZd1YyeGFjMk5FUW1GV1ZuQnlWa1JHWVdNeFduRldiVVpUVmpGR00xWnRjRWRUYlZGNVZHdGFhRkp1UWs5VmFrcHZVMVphZEUxSWFGUk5WMUpZVmxkNGMyRkdTblJWYXpsV1lsUldSRlJ0ZUd0V1ZrNXhWVzFvVG1KRmNFbFdWRWt4VlRKR1IxTnVTazlYUlVwWFdXeFNWMUV4VWxobFIwWnJVakExUjFwRlZUVlZNa3BHVjFSQ1YySllhSFpaZWtaaFUwWktXV0pHV21saE1YQllWa1pXYTFWck1VZFhXR2hZWW1zMVdGWnRkSGROVm1SeVYyeGtWazFyY0ZwWlZWcHpWakpHY21JelpGVldWbkJoV2tSQmVGZFdUbkpQVm1SWFRXMW9iMVp0TVRSWlYxRjVWRzVPYVZKc2NGaFdNR1J2VjFaYWRHUkhSbXhpUm5Bd1dsVmpOVll3TVhKalJXUmFUVVphZWxacVNrdFhWa1p5WVVaYWJHRXpRbEZYVkVwNlpVWlplR05GWkdoU01uaFVWRmN4YjAweFduTmFTR1JVVFd0c05WWlhOVTlYUjBWNVZXeG9XbUV4VlhoV01GcFRWakZ3UjFSc1VsTmlWa28xVm1wSmQwNVhSa1pOVmxwcFVrWndXRlp1Y0ZkU1JscHpWMnh3YkdKR1dqQlpWVnBoVkd4S2RWRnRPVmhoTVZwWFZGWmFZV1JHVm5KYVIwWlRWa1phZGxaR1dtOVJhekZ6VjI1T1ZtRXpVbEJWYlhoWFRrWlplV1ZIZEZoU01IQjVWR3hvUjFadFNraGhTRnBhVmxad2FGcEZaRmRUVm5CSFdrVTFXRkpWY0ZwV2Frb3dXVmRGZUZaWWJGUmlSMUpWV1ZSS2IxZFdiRlZTYkZwc1VtMTRWMVpzYUc5WFJrbDRVMnRhVjJKWWFISlpWbHBLWkRBMVJWRnNhR2hOVlhCSlYxaHdSMWR0VmtkalJXUnBVakpvVkZsc1pHOWtNV1JYWVVoa1YwMXNXa2hXTW5odlZHeE9TR0ZJUWxWV2JIQjZWR3RhYzJOc1pIUlBWMmhPVmxkM2VsWnFTalJXTVZwMFUyeFdVMWRJUWxaV2FrNXZWMFp3UmxaWWFGZFdhMW93V1ZWa2MxVXlTbkpUVkVwWFRWWktSRlpVUmtabFIwcEhXa1pvYVZJeFNuaFdWekV3VXpGc1YxZHVVazVXYXpWVVZGWm9RMUpzVlhsamVsWldUVVJHV0Zrd2FIZFhSMFY1Vlc1d1YyRnJXa3hXYWtaaFkxWlNjMXBIYkZkU1ZtdzJWbXhrZDFNeFVuUldhMlJoVW0xNGIxVnRlR0ZqUm14WlkwWmthVTFXY0ZsVVZsSlRZVEF4Y21KRVVsZFdNMmh5V1ZWYVMxWnJOVmRpUm1ScFZrVmFWVlpxUW1GWlZtUklWV3RXVW1KSFVtOWFWM1JoVjFaYWRFMVlaRlpOVjFJd1ZXeG9jMkZHU2xsaFJtaGFWak5TTTFaRldtRmtSMVpJWkVkd1RtRXhjRWxXYlRFMFlUSkdWMWR1U2xkaGF6VllXV3hvUTFSR1VuSmFSVGxyVW14YVdsbFZaSGRWTVZwelkwWlNXRll6YUhKWmFrWmhVakpLU1ZOdGFGTldWRlpSVjFkMGExVXhXbk5XYkdoT1ZsZFNiMVZzVWtkWFZscFlUbGhPVjFac2NIcFdNalZMVmpBeFNGVnJlRlppV0doUVdYcEtSMUl5VGtoaVJrNU9ZbGRrTlZacVJtRldNV3hYVjFoc1ZtRXlhRmhaVkVaM1kyeFdkRTFYT1ZoU2JYZ3dXa1ZXTUZaR1duUlZiRnBXVm5wRmQxWkVSa3BrTVdSeVdrWldWMkpJUWpaV2JHTjRVbTFXYzFKdVRtaFNia0p3VlcxMGQxSldXa2hrUjBaV1RXczFlbGRyYUV0VU1WbDZZVVpvV21FeFdqSmFWVnBoWTJ4d1JWVnNaRTVoTVhCYVZsY3hkMWxXV1hsVGEyaG9VbTE0V0ZsWGN6RmtiSEJJWlVoT2FsWnJjREJhUlZwclZHeGFkVkZZYUZkV2VrVXdWbFJLUjFZeFpISmhSM2hUWWxkb1dWWlhNVFJrTWtaSFkwVldWR0pIVW5GVVZtUlRWMnhzY2xaVVJsZE5WbXcwVlRKNGMxWXhTbk5YYkZKV1lXdGFZVnBWWkV0VFZrNXpWMjFzVTFaR1dscFdNVnB2WkRGSmVWWnJaRmhpYkVweVZXdGFTMWRXYkhOV2JHUlBVbTEwTTFadGNGTldNREZ5VjI1c1drMUdjRVJXYlRGSFkyeGtjMkZHY0d4aE0wSlJWbGR3UjJReFNYaFZiazVoVW0xU2MxbHNhRTlPVmxwMFRVaGtiRkpVVmtoV2JHaHZWa1prU0dGR2FGZE5SMUoyVmpGYWMyTnNjRWRVYkdSWFlsaG5kMWRyVm05aE1rWjBVMnRrV0dGclNtRlVWRTVEVTBaYWNWSnJkR3RTTVZwS1dXdGFhMkZXV2tkWGF6RllWak5TYUZkV1pFNWxWbEp5V2tkc1UySkdjRmxXYlhCTFlqQXhjMWR1U21GU1JrcFZWRmR6ZUU1R1pISmhSV1JXWWxWd1NGa3dWVFZYYlVwWllVVjRXbUZyV21oWk1WcEhaRWRTUjFWck5WZFdSbHBLVm0wd2QwMVdVWGhhUldoVVlUSlNXVmxyWkc5WFJteFlaRWRHVlZKc1NsbGFWV1JIWVdzeFYyTkVRbFppV0dnelZtcEtTMVl4VG5KalJtUm9UVmhDTWxkclVrdFNNVWw0Vkc1V1ZHRjZiRmxWYkZaM1YwWmtWMXBFUWxwV2JFcElWbGMxVDFkSFNsWlhia1phWVRKb1JGVnRlR0ZYUjFaSldrWmtUbUV6UWxsV1ZFb3dZekZaZUZkcldsaGliSEJvVld0V1lXTnNhM2xqTTJoVVZqQndTRll5TVhOVk1ERjBZVVp3VjAxWFVUQldWRVpLWlVaYVdXRkdXbWxTYmtKYVYxZDBhMVV5VGxkWGJsSnJVMGRTVDFWdGVHRk5SbEpYWVVkMFYxWXdjRWhaTUZwaFZqSktTR0ZJV2xkaGExcG9WVzB4UzFKV1ZuTldiV2hPVjBWS1dWWXllRmRaVjBWNVZHNU9ZVk5GTlc5VmFrbzBWa1pzY21GRlRsaGlSbXcwVjJ0U1UyRlZNVmRXYWxKWVlURmFjbGRXV2t0a1JsWnpZa1p3VjFKVVZsVldiWFJoVlRGWmVHTkZaRlZpV0dod1ZXcEdTMDVXV25GVFdHUlBWakJhU0ZZeU5VdGhWa3BIVTJ4a1ZWWjZWblpaTW5oYVpERmtjMk5IZUdsV1ZuQkpWakowYTFJeFdYaFhiazVYWVd4S1dGWnFUa05UUm1SWFdrWk9WMDFXY0RGV1Z6RTBWVEpHTmxac1FsZFdla0Y0VlZSR2ExWXhaSFZUYkdocFYwWktVRlpYTVRSak1EQjRWV3hhYUZKNmJHOVZiRkpEVGxaYVdHVklUbGhpVlhCSVZqSXhiMVl3TVVkalJsSlhZV3RhY2xwR1duZFNNVkp5VGxaa2FFMHdSWGxXYWtaaFZqSkZlRk5ZYUZoWFIxSlBWbTB4VTJOV1ZYZGhSVTVhVm14S1YxWXlOV3RoTWtwSFkwaG9WazF1VW5KWlZ6RkxVMFpXY1ZGc2NGZFdia0Y2Vm10amVGTXlVa2RpTTNCcVVtMVNXRlJVUWt0VFZscHpWV3QwVldKV1draFdiVFZYVmxkS1dHRkdVbHBYU0VKWVZsVmFhMWRIVmtoa1IyeE9WbFJGTUZacVNURlZNVkp6VjJ0a1ZHSlViR0ZaYTFwM1lVWldjVkpzVGxkTlZuQXdXa1ZhYTFZeVNsZFRhM0JZVm14YWFGbHFSbXRrUms1ellrWldXRkl5YUZsV1JscGhaREpXYzJORldtRlNhelZWVm0wMVExTkdiRlpYYXpsb1ZtMVNTVmRyVWs5V01rVjVWVlJDVjJGcldsTmFWVnAzVW14d1IxVnRiR2hsYkZvMFZteFNRMkV3TlVkYVJXUnBVMFUxYjFWdGRIZGpiRkpYVjI1a2JGWnNiRFZhUlZKRFlVZEdObEpzYkZkV2VsWXpWakl4Um1WV1ZuSmhSbVJvWVRGd2IxZFljRXRVTVU1WVUydGtZVkl5YUU5V2JHaERVMnhhZEdORmNHeFNiR3cwVlRGb2IyRnNTbGhsUmxaYVlrWmFhRlpyV25OamJVWkdWR3hhVTJKV1NscFdSbFp2WWpKR1ZrMVdaRlJpUjJoWVZGZHdWMVpHYkZobFJYUllVbXhhTUZWdGVHdGhWbVJJWVVSYVYxSXphR2hYVmxwUFUwWldjbUZHVG1sV00yaFZWMVpTVDFGdFVYaFhiazVoVWtaS1YxUldXbk5PVmxWNVpVaE9hRkpyY0VkVWJGcHZWbFphYzJORVRscFdWbkJZV1RGYVMyUkdTblJrUms1b1RUQkpNbFp0ZEd0bGF6RllVbXRvVjJKcmNGaFdNR1JUVjBac2MyRkdUbXBXYkVwWVZqSjRkMkpHU25SVmJuQmFWbFp3VkZsV1drdGtWa1p6WTBab1YySlhaM3BYV0hCSFdWZE5lRnBJVmxWaVIyaHZWRlJHUzFkc1dsaE5WRkpyVFd4YVdGWXhhSE5VYkZwWVZXMDVWVlpzV25wVWExcGFaVmRTU0U5V2FGTk5SbGt3VjFSQ1UxUXhXWGxTYmtwcVVsZFNhRlpxVG05VFJtdzJVMnQwVTAxcldraFhhMVV4Vkd4YVdFOVVWbGRpV0doMldrUkdTbVZHY0VsVmJHUnBVakZLVmxkWGRHdE9SMDVYVm01U2ExTkhVbkZWYlRFMFZteFdkRTVYZEZkTlJFWllXVEJTUTFaV1duTlRiRkpYVFc1b1lWcEVSbXRqYlVaSFdrVTFhR0pHY0VwV2JYaFRVekZOZUZSclpGZGliRnBWV1d0YWQySXhiRlZTYm1SVlZteHdWbFZYTVVkWGJGcHlUbFZzVjJKWVVuWldWRXBMVWpKT1JrOVdjRmRTVm5Cb1ZrWmtORmxXV1hoalJWWldZbGQ0VDFacVJrdFRWbHB4VW0wNWEwMVdjREJWTWpWUFlXeEplV0ZHWkZwV1JWcG9XVlZhYzFac1pIVlVhemxwVWxoQmQxZHJWbXROUmxsNVUydGFhbEpHY0ZsV2JYaGhZMnhzY1ZKc1RtdFNhelY2V1ZWa2IxVXlTbGxoUm14WVZqTm9WRlZxUVhkbFJtUnlWbXhTYUUwd1NucFdWekUwWkRKV1YxcElTbGhpVkd4dlZtcENWMDVzVmxoTlJGWlhUVlp2TWxWWGNGTldNVnBHVjIxb1ZtRnJjRXhWTVZwUFl6RndSMXBHVGxkaWEwa3lWbXBHYTAxR2JGZFhXR1JQVm0xU2NWVnRlSGRoUmxaeVZtdDBXRkpzU2xkV1YzUnJWMFpLZEdSRVRsZFdNMUp5Vm1wS1MxSXlTa1ZYYkdSWFpXeGFUVlp0Y0V0U01rNTBWR3RhWVZJd1dsaFdiVFZEWlZaa1dXTkZkRk5OVld3MFdUQldiMkZHU1hsaFJUbFhUVVphVEZaSGVHRmpWazV4Vld4a1RsWXphRmxXYTFwdll6RmFkRk5yYUZaaVIxSmhXV3hvVG1WR1duUmxTRTVxVFZoQ1JsWlhlR3RWTWtwWldqTmtXR0V4V2xoVVZWcHJVakZPZFZSdGNGTlNWWEJvVmtaV1lWbFdWa2RYYmtaVVlUSlNVRmxyVm5kbGJHeFdWMjEwYUZacmJEVlpWVkpMVmpKR2NsTnVTbFpsYTNCUVdUSnpNVll4Y0VoaFJrNXBZVEJ3TTFac1kzaE9SMUY1VTFob1dHSnNTbkpWYWtKaFdWWmFjVkpyZEZSV2JIQXdXa1ZrUjJGRk1WWmpSRUphVmxad1ZGWXlNVVpsVjBaR1ZHMUdVMUpXY0hsV2JYaGhWVEpTVjJORlpGVmhlbFp2VkZab1ExTXhXbk5aTTJoclRWZDRXRlpzYUhOV1IwVjVZVVprV21FeVVuWldiWGhoWkZkT1IxcEhkR2xTTTFFeFYyeFdhMUl5UlhoVGJGWlRZa2RTYUZWc1duZGtiRnB4VTJ0MFUwMXJOVVpXYlhodllWWktjMk5IT1ZoV2JFcElWakl4VjFZeFpIVldiRkpwVWpKb2QxWlhjRTlpTVdSWFdrWmtZVkpGU21GV2FrRXhaV3hhZEU1VlpGWk5hMVkyVmxjMVIxWldXbk5qUjJoVlZteHdhRlV3WkZkVFJUbFlZVVprYUUxdVkzZFdiRkpLVFZkRmVGZFlhRmhoYkhCVFZqQmtiMVl4V25KV2JVWllVbTEzTWxWdE1UQmhNVnB6VTJwQ1dsWldjRlJXVkVGNFZtMU9SMVpzWkdoTldFSlpWbXhTUjFkdFZrZFZia3BoVW0xU1dWVnFUbTlWVmxwMFpVWk9hazFYVWtoV2JUVkhWVzFLZEZWdVRsZGlWRVYzVkZSR1dtVlhWa2hrUm1oVFRVaENXRlp0TVhkVk1WbDNUVmhXVW1KRlNsaFpWM1JIVGtaV2NWTnJPVlJTTUZwSVdUQmtOR0ZGTVZsUmJIQlhUVlpLVEZSclpGSmxSazUxVTJ4Q1YySlhhSGRXVnpGNlRWZE9SMkpHVmxKaWJWSmhWbTE0ZDAxR1VsZGhSM1JYVWxSR1JsWnRkSE5XYlVwSVlVaGFWMkZyV25KVk1GcFhZMnM1VjFwSGJGaFNNbVEyVm0xNFYxbFdiRmhWYTFwT1ZtMW9VVlp0TVZOVU1WcHhWRzA1VDJKSFVsaFdiWGhyVmxVeGNsZHJhRlpOYWxaVVdXdGFTMlJIVmtkWGJHUnBWMGRuZWxkVVNqUmpNVnBYVTI1S2ExSXpRazlXYWtaS1pVWmtWVkZ0UmxwV01GcFlWakowWVZkSFJYbGxSbWhhWWtkb1JGWkZXbUZqVms1eVRsZDRVMkpyU2t0V2EyUTBZVEpHVjFOWWFGUmlSM2haVm1wT1UxZEdjRVZTYXpsWFRWZFNNVlpYTVhkVk1WbDRVMnh3V0ZZemFHaFhWbHBQVWpGd1NWTnRhRk5pVmtwWVZrWmtNR1F4U1hoaE0yUm9VbFUxV0Zsc1ZuZFRSbFY1WlVjNVYwMVdjRmhaTUdSdlZqSktSMk5GYUdGU1YxSlVWVEJrUzFKck5WZGFSbVJUWWtoQ2FGWnRNSGhrTVU1eVRWWmtWVmRIYUhCVmJURlRWbFpzVlZKdVpGZFdiWGg1VmpJeFIxWXlTa2RqUkVKaFZsZG9jbGxWV2t0a1ZrWnpZa2RHVjFadVFYcFhWM1JoV1ZaYVYxZHVUbUZTTUZwVVZtMDFRMWRXWkZkWGJVWlVZbFphU0ZaSE5VdGhNVXAwVld4b1dtSkdjRWRhUkVaclZqRldjbHBHYUdsV2JIQlpWbXRqTVZReVJsZFRXR3hvVW14S1ZsWnVjRWRrYkZsM1YyMUdVMDFXY0RCVmJURXdWR3haZUZOcmJGZGhhMXAyV1ZSR2MxWXhUblZWYkZwcFVteHdXRmRXWkRCWlZsSkhWbGhrV0dKWVVuRlphMlJUWlZaUmVGZHNaR2hXYTNBeFZWWm9iMVl4V25SVldHUlZWbFp3WVZwRVFYaFdNWEJJWTBaT2FWWXlhR0ZXYlRCNFRrZFJlRlZZYUdwU2JIQlpXV3hvVTFkV1duRlJiVVpVVW0xNFYxZHJhRTlXYXpGRlVteGtXazFHU2xSV2FrcExVMFpXVlZGc2FGZGlWa3BVVjJ4V1lXUXhTbk5qUldSaFVqSjRiMXBYZUdGWlZsbDRXa1JTVjAxWGVGaFhhMXByVmpKS2MxTnVUbFpoYTBwb1dYcEdWMlJIVmtoU2F6VlRZbXRLU0ZZeWRGTlJNa1pIVTFoa1dGWkZjRmRaYkdodlkyeFplV016YUZSU01GcEdWa2Q0YTJGSFJYZFhWRUpZWVRGd2FGWlVSbXRYUmtweVdrZEdVMDF0YUZCV2FrSlhVekZTYzFkdVVrNVdSa3BoVm0weE5GZFdXa2RoU0U1V1RXdFdOVlpYTVc5V2JVWnlZbnBDVjAxV2NGaFpNVnBQWkVVNVYyRkhiRk5pYTBrd1ZteGpkMlZHU1hoYVNFNVlZbXR3Y1ZWclZrdFhSbXh6WVVaT2FtSkdiRE5YYTFZd1lXc3hXRlZ1Y0ZkTmJtZ3pXVlZWZUZkV1JuUlBWbWhYVFRCS1NWZFljRXRVTWsxNFdraFdWMkpWV2xSWmJGcExWbFprV0dWSFJsUk5WMUo2VjJ0b1MxWXlTbFpYYlRsVlZtMVNWRnBYZUZwbFZUVldUMWRvVjJFelFrbFdWRW8wWWpGa2RGTnJaRlJpUjJoWVdWUkdkMlZzV25OWGEzUnFZWHBzV0ZaWGVFOWhWa3AxVVZSS1YySllRa3hVYTJSR1pWWktjMXBIUmxOV01VcFdWbXBDYjFFeFpFZGlTRTVXWVRGd1QxVnRlSGRsUmxWNVpVVTVWMUpyY0hwV01qVnpWakF4ZFdGRlVsZGhhM0JNVm1wR1QyUldjRWRhUm1Sc1lUQlpNRlpzV2xOUmF6RllWRmhvWVZOR1dsUlphMXBMWWpGc2NsWnVaR3RpUm5CSVZqSXhNRlpyTVVWU2EyaFhUV3BXVkZaRVJtRlhWbFp6WWtaYWFHRXdjRmxXUjNoaFl6RmFjMXBJVWxCV2JXaHdWbXhvUTFOc1pGZFdiVGxhVm14c05GVXllR3RoYkU1SVpVZG9WMkpVUmxSV01GcFhZMVpLZFZwR1VsTk5WWEJKVm10a2VrMVdWWGhUYms1cVVsaFNXRmxzVWtaa01XeFZVVlJHVkZKcmNGcFpWVnB2VjBaSmVXRkdXbGhXTTFKeVZsUktTbVZHVm5OV2JGSm9Za1Z3V2xaWE1IaE9SMVp6WWtaYVdtVnNXbTlWYlhSM1RVWmFXR1ZIT1ZkTlJFWXhXVlZTVDFkdFJYaGpSWGhhVFc1TmVGWnFTazlTTWs1SFdrWmthV0V3Y0ZOV2FrWmhXVmRGZUZOWVpFOVhSVFZaV1cxek1WZFdiSEphUnpsWVVteEtWbFZ0ZERCaFZURlhZa1JTVjAxcVJYZFdiRlY0WTJzeFZWVnNaRTVoYkZwWlZtMTRhMU14U1hsVWEyeFNZa1p3YjFsVVJuZFVWbHB4VVcxR1dsWnJiRFJYYTJoVFZUSktXVlZyT1ZwaE1YQXpWRzE0WVdOV1RsVlNiRnBPVm10d05sWnFTalJpTVZwMFUydG9hRkp0VW1GWlZFWjNWRVpWZDFkc2NHdE5WMUo2VmpJeE5GWXdNVlpqUlhCWVlURmFhRmxVUmxOa1JrcFpZMFpLYVZaV2NGbFhWM1JyVkcxV1IxWnFXbE5pU0VKelZXMHhVMlZHV1hsbFJUbG9VbFJDTlZsVldtOVhSbGw2WVVoYVdtRnJjRkJaZWtwTFVsWmtjMVJ0YkdsV2EzQldWbXRhYTJWck1WZFVhMlJoVTBWd1dWbFljSE5YUmxKWFZtNWtiR0pIZEROV01uTTFWakF4Y21OR1dsWldNMEpVVm14a1JtVkhUa2hoUjBaVFZtNUNiMWRVU2pSa01VbDRWbTVTYVZJeWFITlphMXAzVFd4YWRHVkdUbEpOVm13MVZsWm9iMWRIU25KT1dFSldUVVphTTFZeFduTmtSVEZYVkcxd1YySkdiM2RXUmxwVFZUSktTRk5yYUd4U2JWSlpXVlJLYjJOc2JGWldXR2hUVm10d2VsbFZXbmRVYkVwMVVXcEtWMkZyU25KVmJURlhVakZTZFZSc1dtbFNNVXBaVmxkNFYxZHJNVWRYYmxKcVVsaFNWbFJXVlRGWFZscElaRWQwV0ZJd1dUSldiVEExVjIxRmVHTkVUbGRTTTJob1drVlZlRk5XY0VobFJrNW9UVzVrTmxaclpEUmlNVkY0VjJ0b1ZHSnJjRkJXYlRGVFdWWnNWVk5zVGxkU2JYUXpWako0ZDJFd01WbFJhMnhWWWtkUk1GbFdXa3RrVmtaelkwWm9hRTFXY0hsV1YzQkhZVEpOZUZwSVZsVmlWM2hVVlcxMGQxZHNaRmRWYTNScFRWWmFTRmRyV210WFIwVjZWVzVHVlZadFVsUlVWbHBYVjBkV1NHUkhhRmRoTTBJMVYxUkNWMkl4V1hoVGJrNVlZbGRvV1ZadGVIZGpiRlowWXpOb1YwMVdjSHBXTWpGelZrWktWbU5HY0ZkTlYxRjNWMVphYTJOck1WZGFSbWhwVWpKb2VsWlhOWGRqTWtsNFZXeG9hMUl3V25OWmExcFhUbFpTYzFaVVZsaFNhMnd6V1RCV2MxZHNXbGRqU0ZwWFRXNW9hRlZ0ZUd0ak1YQklVbXhrVjJKclJqWldiRkpEWVRGWmVGUnJaRlJpYXpWV1dWaHdWMWRHVWxkV2JscE9Za1p3ZUZVeWNFTlhiRmwzVm1wU1YxWjZWbEJXTUdSTFl6RmtjMVJzY0ZkTk1taHZWbXBDWVZVeFpFWk9WbVJWWWxkb1ZGbHJhRU5TTVZwWVRWUlNXbFl3Y0VoVk1qVlhWVzFGZVZWdFJsZGlSMUpVV2tkNFlWWldTbk5qUjNoWFRVWndTVmRYZEdGaE1rWlhWMnRrV0ZkSVFsaFdibkJEVGtaYVdFMVdaRk5OVjFJeFZXMTRiMkZXU2xWV2JtUlhWak5DU0ZWNlNsZFNNV1J5V2tab2FWZEdTbGhXUm1RMFdWZFdjMWRZYkU5V2F6VndWVzEwZDFkc1dsaE5SRlpYVFd0YWVWVXljRTlaVmxwelkwWmtZVlp0VWxoVk1WcFRZekZ3Ums1WGFFNU5SWEJaVm0xNGEwNUdWWGhTV0doaFVsZFNXVmx0Y3pGalZsWjBaRVYwVjAxWGVGbGFSV1JIWVVaS2RHUjZTbFpOYmxKeVZtdGFTbVZHWkhKaFJtUlRUVEpvTWxac1VrdFNiVlp6VW01U1UySkhVbkJXTUdSdlpWWmtjbFZyWkZSaVZscEpWVEowYTFsV1NuTlRiR3hXWVd0d2RsWXllR3RYUjFKSVpFZHNUbUY2UlRCV2JUQXhWREpHUjFOdVNrOVdiWGhYV1d4b2IxUkdXWGRYYkhCc1ZsUldXVnBGV205Vk1rVjZVVmhrV0dFeFdsUldSRVphWlZaT2MxWnNUbWhOYldoWlYxWmtNRkl3TlVkWGJsSk9WbFJzVkZSWGRHRlRSbVJ5VmxSR2FGWXdjRmxYYWs1elZqSktWVkZxVG1GV1ZuQkxXbFphVTJSV1VuUlNiRkpUVjBWS01sWnNZM2ROVmtWNVZGaG9hVkpzV2xSWmJURlRWbXhhZEUxV1RsaGlSM1F6Vm0weE1HRkdTbFZTYm14VllrZG9lbFpzWkV0U01rNUpVMnhrYVZaRldrMVdWekY2VFZaWmVWSnJaRmhpVjNoWlZXcEthMDVzV25SalJYUlBVbTE0V1ZaWGRHRlViRnBZWlVjNVZtSkdTbnBXYTFwelkyeHdSVlJyTlZOaVZrcGFWMnRXYTFJeVJrWk5WbVJYWVd4S1dWbFVSbUZrYkd4V1YydDBhMUl3V2tsVmJYaDNZVlpKZVdGR1FsaGlSbHBvVjFaa1UxTkdXbkppUmxacFVqSm9WVlpHV21Ga01VNUhXa2hLVjJKVldtRldiWGhMWld4WmVHRklaR2hTYTNCSVZqSjRiMWR0U2tkVGExSlZZVEZ3V0ZreFdrdGpNazVJWkVVMVUxSldjRnBXYWtvd1dWZEplVkpyYUZOWFIxSnhWVzV3YzFkR1duRlViVGxxWWtkNGVGVXljelZoYXpGWVZXcEdWMUl6YUhaWlZscGhWakpPU1dGR2FGZE5NbWhZVmtaYVlWUXhTWGhqUld4VVlrZG9jRll3V2t0V01XUllaVVprYTAxc1ducFdiR2h6WWtaS1dGVnNhRlZXTTFJelZtMTRWMk14Vm5KVWJHaFRZa2hCZDFac1pIcE9WbXhYVjJ4a2FsSkZOVmRVVmxwM1ZVWnNObEpyWkdwTldFSkpXV3RrYjFSc1RrWlNXR3hYWWxoQ1NGZFdXbFpsUms1WllrWmFXRkl5YUZkWFYzUnJWVEZrVjJKSVVteFNXRkpXVkZaYWQyVldXWGxrUkVKWFRWWndlbFV5ZUhOWGF6QjZVV3RvV21FeVVreFZha3BQVW0xS1IxWnRiRk5pUmxZMFZtMHhkMUl4VG5SVldHeFZZVEpTY1ZWdE5VTlhSbHAwVGxWT1QySkdjREJVVldodlZUQXhjazVVUWxkU00xSjZWakJrUzFJeVRrbFJiRnBwVmtaYVJWZFhjRWRoTVdSWVZHdGFZVkl5YUU5WmExWjNVMVphVlZOVVJsVk5WM2hZVlRKNFYxWXlTa2hoUm1oYVZqTk5lRmt4V25kU1ZrcDBVbTF3VGxac2NEVlhhMVpXVFZaVmVWTnNiR2hTYmtKWVZtdFdkbVF4YkZWU2JVWlVVbXMxZVZsVldtRmhWMFY0WTBab1dGWXphSFpaYWtaVFVqRndSMXBHYUdsV1ZuQjRWMWQwWVdReVZsZGpSVnBYVmtWYVZsbHJXbmROVmxaWVkwWmtWMDFyV25sWmExSlRWbTFHY21ORmFHRlNWbkJRV1RKNGQxTkhUa2RVYkU1WFYwVktXbFpxUm10T1IwbDVVMWhvVjJFeVVsbFpiWFJoVmxac1ZWUnNUbGRTYlhoNVYydGFUMVl5U2tkV2FsWmhWbGROTVZacVFYaFdiVTVIV2tad1RsSnVRbGxXYlhCSFdWZE5lRlJ1U21oU2JXaFlXV3RvUTJWV1dsaGpSV1JXVFd4S1dGWkhOVTloUmtsNVpVWlNWVlo2Um5aVVZFWmhZekZ3U1ZwR1RrNVdWRVV3VmpKMFYyRXhiRmRUYmxKb1UwVTFWMWx0TlVObGJGcHhVbXhPVjJKR1dubFdSM00xVlRKS1NHUjZSbGhoTVZweVZGVmFhMUl4VGxsYVJtUm9Za2hDV1ZadGNFOWlNbEp6VjFoc1RsWldjSE5XYlhoaFpXeGFXRTFWWkZkTmEzQktWVmN3TlZZeFdrWlRia3BYWVd0YVVGVnFSazlrVmxKMFVteE9WMUpzY0RKV2ExcFRVVEZOZUZSdVRsaFhSMmhYV1ZSQk1WWXhVbGRYYms1UFVtMVNlVlp0TVRCWGJGcHlZMFpzWVZaV2NGQldNbmhoVW0xT1NWZHNaRTVTYmtKdlYxUktORmxYVWtkVGJsSm9VbXMxY0ZZd1pFOU9WbHB6V1ROb2JHRjZWbGxWYkdodlYwZEtjbU5HUWxkTlIyaEVWakJhWVdSWFRrWmFSM2hwVW01Q1YxWlhNSGhTTVZWM1RWWm9WbUp1UW1GWlZFWjNZMnhzVmxaWWFGaFdhMXA2Vm0xNGExZEdUa1pUYXpGWFZrVnNORlpxUmtwbFJsWjFWbXhTYVZaV2NGVlhWM2hyWWpKUmVGZHNhR3BTVjFKVlZGWmtVMlZzWkhKWGJUbG9UVlZzTmxaWGVHdFdWbHB6WTBST1lWWXphR2hXTUdSWFUwZFNSMkZHVGs1VFJVcExWbTE0YTJWck5WZFhiR1JZWW14S2IxVnNXa3RYUm14WVpFZEdhRkp1UWtkV2JHaHZWakpLU1ZGcmFGaGhNbEoyV1d0a1JtVkhTalpTYkdScFZrVkpNRmRyVWtkVmJWWkhZMFZzVkdGNlZsaFdha1pMWlVaYVdFMVVRbFJOVjFKSVdXdGFiMkV4VGtoVmJGcFdZbGhvV0ZSVVJscGxWMVpJWkVkb2FWSnVRWGRXYkdNeFpERlplVk5zYkdoVFJYQllWbXRXWVdGR2NFZFhhMlJyVm0xU2VsZHJaSE5XTVVwWFZtcE9WMkZyV21oWFZscFBaRVphYzFwR1dtbGlSbkJYVjFkNGIxRXhXa2RYYmtaVFlUTlNXRmxyWkZOWFZuQldXa1JDVlUxVmNIcFpNRlp2VmpBeGNWWnNVbGRTTTJob1ZXMTRUMk14Um5OWGJXeFlVakpuTWxaclpEUlpWMUY0VjI1T1lWTkdTbkpWYlRGVFZERldjbFp0UmxoU2JIQklWako0VDFack1WZGlSRlpXVFc1b1dGWnFTa3RTYkU1ellVWldWMVl4U2xWV2ExWmhWakpPVjFSdVNsQldhelZQV1ZST1ExTldaRlZSYlVacFRWWndTRlV5ZUdGaGJFcFpVV3hvV21KR1NrUlVhMXBUWTJ4a2MyTkhlRmRpUlhCaFYxWldhMUl4V2tkVGJrNXFVbnBzV0ZadWNFWk5SbkJGVW0xR1UwMXJjRXBWTW5odllWZEtWMU5zY0ZoV00xSnlWbFJLVjJNeFpIVlZiWGhUVFRGS2RsWlhlRk5TTVdSSFlraEtWbUpIVWxoWldIQkhUVlpzVmxwSE9WZE5hMXA1V1RCV2IxZHRWbkpqUmtKV1lXdHdTRlZxUm10a1IwWklZVWQ0YVZKdGR6RldiVEI0VFVaWmVHSkdaR2xTYldoV1dXdGtVMVpXYkhSbFJYUlhVbTE0ZVZkcldrOVdWVEZZWlVad1drMUdjSEpXYTFwTFl6Sk9TV05HYUdoTlZYQlZWMVpXVm1WR1dYbFRhMVpYWWtad1QxbHRNVzlOYkdSWFZtMUdWRTFWYkRWV1IzUnJZVVpLYzJOSE9WcFhTRUpZVm14YWExWXhXblJTYkdST1lYcFdXVlpyWXpGVE1WRjRWMWh3YUZKc1NtRldNR2hEVmpGd1ZsZHRSbXBpU0VKR1ZsY3hjMVJ0UlhoalJteFhWa1Z2TUZacVJscGxWazUxVkcxd1UySlhhRmhYVjNodllqQXdlRmRZWkZoaWJWSlVWbTEwZDJWc1ZYbE5WRkpXVFd0d1dGVXljR0ZYUmxwelYyNUtWV0V4Y0ZkYVZscFBZekZ3UjFWdGJGZE5iV2hhVmpGa05GVXhTblJWV0doWVltdGFVMVpyVm1GV1JsSlhXa1pPVGxac2NGbFVWbEpUVm1zeGNtTkdhRlpOYm1oNlZtcEdXbVZzUm5KVmJVWlRVbFp3YjFkWWNFdFRNVTVYVkc1T2FGSXlhSE5aYkdodlYyeGFkRTFJYUU5U01VWTBWMnRXYTFZeFpFaGxSa0pYWVd0S2FGWXdXbUZqVmtaeldrVTVVMkpZVVhwWFZsWlhUVVprU0ZKcVdsTmhhMXBoVm14a1UyUnNXWGxqTTJocVZtdHdlbFpYZUdGaFIwVjRZMGhzV0dFeFduSlZla1pLWlVaV2RWVnRiRk5OYldoUVZsUkNWMU14YkZkWGJsSk9WMGRTVkZSV1pEUlhSbGw0WVVoT1YxSnRVa2xhVlZwclZqQXhTRlZ1V2xkTlZuQjZXa1ZrVDA1c1NuTmhSbVJwVjBka00xWXhVazlrTVVsNFdrVmtXR0pzU25OVmJYaDNWakZTV0dORlNrNVdiSEI0VlZab2IxWXdNWEpPVlhCYVZsWndjbFpVU2xkamJFcFpZVVprYVZkRlNrbFdXSEJMVkcxV1YxVnVTbWxTTW5oVVdXeGtiMlJzV2tkWGJUbFNUV3hhV0ZZeU5VOVdiVVY2Vld4V1ZWWnNXak5hVmxwVFl6RmtkVlJ0YUdsU1dFSTJWMVJDVms1V1pIUlRiRlpUWW14d2FGWnRlSGRoUm5CR1drVTVVMkpJUWtoWk1GcHJWR3hhV1ZGc2NGZGlSMDR6VkZaYVRtVkhTa2RhUmxKcFlrVndXRmRYZUZOak1WcHpWMjVTYkZOSFVrOVVWbHB6VGtaWmVVMVZaR2hOVld3elZHeFdhMWRIUlhoalJsSmFWbXh3YUZsNlNrOVNiVXBIV2taa1UxWXpVVEJXYlRGM1VqRnNWMXBGWkZWaWEzQlpXVmh3YzFkR2JITmhSemxZVW0xU1dGZHJhSGRVYkZsNFUyNXdXazFHY0haWmExcEtaREZrYzJKR1dtaGhNWEJ2VmxSQ1lWZHRWbGhVYWxwVFlrZFNUMWxVVGtOVFJtUlZVV3hPV2xac2JEVlZNbmhYVld4a1NHRkdhRlpoTVZwb1YxWmFkMVl4WkhKUFYzQk9WakZLTmxkV1ZtdGpNVlY0VjJ0a1dHSkhhRmhaYkZKRFRrWlNjbHBHU214V2EzQjVWMnRhYjFkR1NYaFRiSEJZVmpOb1dGZFdaRTlqTVZwMVZHeGFhRTFzU2xwWFYzUnJWVEpXVjFwSVNscGxiRnB2VlcxMGMwNUdXWGxPV0U1WFRVUkdNVmxWYUdGV01rWnlZMFZvV2sxcVJreFViWGhIWXpKT1IxcEdUbGRpYTBveVZtcEtNRll4YkZkVldHeFZWMGQ0VlZsVVNsTlhWbXh6V2tSU1dGSnNTbGxVVm1NMVYwZEtSMk5FUWxWV2JFcEVWbXBCZUZkSFZrZGhSbVJYVFRGS2VWWnRjRWRoTVU1SVVtdGthVkp1UW05VVZscFhUa1phY1ZGdFJscFdNVXBKVm0xMFlXRXhTWHBoU0VKV1lsUldRMXBFUm1GU01XUnpWR3hhVG1FeGNFbFdWRW8wVmpGVmVWTnJiRkppUjFKWVdWZHpNV1JzV2taWGJVWnFWbXMxZVZwRldrOVViVVkyVm10MFYxWkZiekJXYWtwSFVtc3hWMkpHU21oTk1taGFWMWQwWVZsWFJrZGlSbFpVWWtVMVdGUldXa3ROVmxwSVpVVjBhRlpyYkRSVk1uaHpWakZLYzFOcmVGcGhhMXB5VldwR2ExZFhSa2hTYkU1VFZsaENXbFpyV210T1JrbDNUbFZrWVZORmNGaFpiR2hUVjFaV2NWRnVaR3hXYkVwNlZqSTFUMWRIU2xaalJscFdZbGhvVkZacVNrWmxSMDVIWVVkR1UxWXhTbGxXVkVaaFpERk9TRlpyWkdGU01uaFVWRlJLVDA1R1duRlNiRTVWVFd4R05GWXhhRzlYUjBwSFkwVTVWMkpZYUROWk1WcFdaREpHUmxSc2FGTmlSWEJhVmtkNFlWUXlSWGxUYTJScVVrVktWbFp0ZUZwa01WbDNWMnh3YTAxWFVubFphMXAzVmpGYWRWRnViRmRpV0VKSVZYcEdhMVl4U25WVGJXaFRZbGRvZDFaWE1UUmtNa2w0VjI1S1ZtRXpVbFpVVjNNeFpWWlNjMWR0ZEZwV2EzQXdXVlZvUTFZeVJuSk9XRnBYWWtad2NsWXdaRk5UUlRsWFUyczFhVkpZUVRKV2JYQktUVlpSZUZwRmFGUmhNWEJRVm0xNFMxWnNXblJsU0dSc1lrWktlVll5ZUhkaVJrbDNWMnRzVlUxV2NIWldWRUY0VTFaR2NtTkdhR2xTYkhCNVYxZHdSMWxYVWtkVGJsWlVZWHBzV0ZadGRIZFhWbHBZWkVaa1dsWXdXa2haTUZaaFdWWktjazVXVWxWV00wMTRWVEZhZDFac2NFbFViRnBPWVROQ05WWlVTWGhTTVZsNVVsaG9hbEl5YUZoV2ExWmhVakZ3VmxkdGRHcGlSMUo1Vkd4YWEyRldXbkpqUjBaWFRWWndjbFJWV2s1bFJuQkdXa2RzVkZKVVZuWldWelYzWXpKTmVHSklTbUZTUmtwWVZGWmFjMDVXY0VaVmEwNVlVbXR3ZVZrd2FIZFdNREZ4Vm1wT1YwMUhVa2RhVldSUFUxWk9jMk5HWkdsVFJVbzFWbXhTUTJFeFNYaFVhMXBRVm0xU2FGVnRNVk5XUmxwellVVk9hMkpHY0RCVVZtaHJWa1V4VjFacVVsZFNNMUp5Vm1wS1MyTnRUa2RoUm5Cb1RWaEJlbGRVUW1GV01rMTRWbTVPWVZJelVrOVdiVFZEVjJ4a2MxWnRjRTlXYkZwNVZGWldWMVl5U2toaFJtaFZWbnBXZGxZd1dtRmpiSEJHV2tkd1RsWlVWalpXYlRFMFZqRlplVk5yYkZKaGJIQllWV3BPVTJGR1dYbE5WbVJVVW10d2VWbHJaRWRWTWtwWFUyNWtWMkpZYUdoYVJFRXhZekZ3UjFac1NtbFdWbkIzVmtaYWExVXlWbk5YV0d4clVqQmFXVlZxUW1GbFZsSnpWMjA1VjFac2NGaFpNRkpQVmpBeFIyTkliR0ZXVm5CeVdUSXhVMU5IVGtoaVJsSlRWbGhDVEZacVJsTlJNVnB5VFZaa1dGZEhhRmxaVkVwVFYxWmFjbFp1WkZoU2JYaDZXVlZqTldGc1duVlJiR1JYWWtaS1NGWlVRWGhXTWs1SFkwWndWMVp1UWpKWFZscGhVMjFXZEZKclpGWmlSMmhZVkZSR1MySXhXbGxqUldSb1RWVnNOVlV5ZEhOV1YwcFlZVVpTWVZaNlJUQldNbmhoVjBVeFNXRkdXazVXTVVwSlZtcEdiMk15Um5SV2JrcFlZbXRLVjFsc2FGTk5NWEJZWlVad2JGWlVWbHBXUjNoclZHeEtSbGRZYUZoV2JGcDJWWHBHV21Rd01WWmFSM0JUVjBaS2IxWnRNSGhWTVU1SFZtNUdVMkpIVW5GVVYzUmhVMFprY2xaVVJsVmlSbkJhVlZjeFIxWXlTbGxSYTJoWVZteHdlbFpxUm5kVFZsWnpXa2RvVG1KRmNIWldiRkpEV1Zac1YxZHVUbWxUUlRWb1ZXNXdjMWRHVm5SbFNHUnNWbTFTZVZaWGVFOVhSa3B5WTBSQ1YxWXphSHBYVmxwTFYwWldjbUZHY0ZkU1ZWa3dWbTF3UzFNeFNsZFdiazVoVWxSV1dGUlhNVzVOYkZsNFYyeE9VMDFWTVRSV01uaHZWa2RGZVZWdE9WWmlWRlpFVmpGYVZtUXhXbkprUms1WFlraENTbGRzVm10U01rVjNUVlphVDFadGVGaFZhazVUWVVaYWMxcEZkRlJTYkZwNVZERmFhMkZXV2tkWGExWlhZV3RhYUZsVVJtRldNVXAxVkcxR1UwMXVhRkJXYlRCNFRUQXhWMWRzVmxSaGJFcHhWRmQwWVZOR1ZYbGxTRTVvVW10c00xWXllR0ZXTWtwMVVXeG9ZVkl6YUhsYVZtUlhVMVpPZEdWR1pFNVNSVlY1VmpGYVYxbFhSWGhWYms1WVltdHdjVlZyV25kWFJsSllUbFpPYUZKdGVGWlZNblJyVjBaS2NtTkdjRmhoTWxJelZsUkdXbVZHVG5OaVJtaFhUVEpvVlZaWE1YcGxSa2w0WTBWa1lWSnRhSEJaV0hCWFYxWmFSMWR0ZEZaTlYxSjZXV3RhWVZkSFNsWlhiVGxYWVd0S00xVnFSbkprTVdSMFpFWmtUbUV4Y0RWV1ZFa3hVekZrZEZKdVNsaGlWMmhYV1ZkMGQxUkdWWGhYYXpscVRXdGFTVmxyWkhOV01rVjZVVzFHVjJKWWFIRmFSRXBYVW1zMVZscEdhR2xoZWxaWlYxZDBhMkl4VmtkWGJrWlZZa1UxV1ZWdGVFdFhSbHAwVGxkMGFWSXdjRWxhUlZKUFZqQXhjVkpyYUZkaGEwWTBWbTB4UzA1c1RuTlhiR1JwVWxoQ1NsWnRNWGRTTVdSMFZtNU9WbUpyV2xkWmEyUlRZakZzVlZKdVpHeFdiVkphV1RCV01GVXdNVlppUkZKYVRVWmFkbGxXV2t0a1IwWkhWV3h3VjFKVVZrUldSbHBoV1ZkU1JrMVdWbFppUm5CUFZteGtNMDFHV25KWGJUbHBUVmQ0V0ZVeU5WTmhSa3B6VTIxR1YyRXhXbWhVVkVaelZteGtjMXBIZEZOTlZuQkxWakowYTJReFZYbFRhMmhyVFROQ1dGbFhkSFprTVZKV1YyMUdWMDFYVWpGV1J6RjNWa1pPUmxOc2NGaFdiRXBJVlhwR1lWSXhaRmxpUjNoVFRVWndlRlpHWkhwTlZrNXpZa2hLV0dKSFVsaFVWM1IzVTJ4V1dHTkhSbGhTYkhBd1ZsWlNRMVp0Vm5KalJUbGhWbXh3VkZreWVIZFRSMFpIVkcxc2FFMUlRWGxXYlhSaFdWZEplRkp1VWxkaWF6VlpXV3RhWVZaR2JITldiVVphVm14d01GUldXazlXUmxwelkwWnNZVkpYVFRGWlZWVjRWbTFPU1dKR1ZtbFNiRlY0Vm1wS05HRXhUbGRTYms1b1VteGFjRll3Wkc5aU1XUnlWbXhhYkZKc2NGaFdiVFZUWVd4S1ZWWnNhRnBpV0ZKTVYxWmFZV014Vm5Ka1JUVlRZbGhvV2xaWE1ERlVNVnBJVTI1T1ZHSlViRmRaYkZKSFpHeGtWMWR1VGxkV2EzQXhWMnRWTVZSc1duSmpSbVJYVm5wRk1GbFVTa2RrUms1eVlVWmFhR0V3Y0ZoWFYzaHZZakpPYzFkcmFFNVdWbkJ6VldwQk1WSXhjRVpYYlhSVllsVndlbFV5TlhOV01VbDZWVzVLVm1GcldsQlZha1pyWkZaYWMxWnRiRk5oTTBKaFZteFNRMVl4VFhoYVJtUllZa2RvY2xWdE1WTldWbEpZWlVWMGJHSkhlSGxXTW5oclZtc3hjbU5GYUZwTlIyaFFWbXBLUzFkV1ZuRlViR1JPWW0xb2VWZFVTalJrTVU1WFkwVmtXR0Y2Vm05VVZFSkxVMVpaZUZWclRscFdNREUwVjJ0V2ExZEdaRWxSYkdSYVlrZFNkbGxWV2xkamJGcDBVbXhhVTJKR2NEUldWRXA2VGxaVmQwMVlTbGhoTW5ob1ZteGFkMVZHV2tobFJYUnJWbXRhZWxrd1dtdGhWbHBHVTFSQ1YxSnNXbWhaZWtaclVqRmtkVlJ0UmxOTlJuQldWbGQ0YjFFeFpITmFSbVJXWVhwc1YxUlhkSE5PUmxsNVRsWk9hRTFWTlVsV1Z6VlBWMjFGZVZWVVFsZGlXR2hvVlRCVmVGSldXbk5oUms1b1RXNWtObFl4VWtOV01rbDRWMWhrVGxkR1dtOVZNRnAzVjBac2MxVnJaRmhTYlhRMVdsVmtNR0ZyTVhKWGEyaGFUVWRSTUZsVlZYaFhWa1p4Vm14a1RsWXlaM3BXVjNCTFVtMVdWMVZzYkdsU2F6VnZWRmN4YjJReFdsaE5TR2hXVFZad1NGWlhlRmRXUjBwVllrWnNWMkpZYUROVVZWcDNWbXh3UlZGc1ZrNVdWM2Q2Vm0weGQxVXhXWGxUYTJob1UwWndXRmxYZEhkU01YQlhWMnhrYWsxcldraFpNR1J2VkcxS1JtSXpiRmROVjJnelZXcEdXbVZXVWxsaFIzQlRWakZLVjFkWGRHdGlNVnBIWWtoT2FGSjZiRkJXYlhoM1pVWlZlV05GVGxWaVJYQXdWbGQwYzFack1YVlZia3BhVmpOb1RGWXdaRmRUUjBaSFdrZHNVMkpyU205V01uUlRVakZzV0ZSc1pGTmlSM2h2VlcweFUxUXhiRmxqUm1SVVZtMVNXRlp0TVVkaE1ERlhVMjV3VmsxcVZsQlpWM2hMWXpGa2MyRkdjR2xTTW1oRlZtdFdZVll5VWtaTlZtUmhVbTFvVkZsVVRrTk9WbVJZWkVkMGEwMVdWalZWTW5ScllXeE9SMk5HYUZaaVdHZ3pXa2Q0VjFaV1RuSmpSM2hUWWxaS05sZFdWbXRrTVZWNFYxaG9WR0pHY0ZoVmJURlRUbXh3VmxaVVJsTk5XRUpLVlRJeGIxVXhXa2hsUm14WFlsaENSRnBFUm10V01rcEhWMnhrVjFKc2NGbFdSbFpUVWpGT1IxZFliR3RTUmtwWVZGWmFkMWRHYTNkYVJ6bFlZbFphZVZZeWNFOVdiVXBIWTBab1dtVnJXak5WYlhNeFZqRndSazVWTldsV01taHZWbTB3ZUU1SFJYZE9WV2hVVjBkNFZWWXdaRzlYVmxsM1drUlNWMVp0ZUZaVk1qQTFWakF4V0dWSWJGaGhNazB4VmpCYVMyUkhWa2RYYkZwcFZrWmFlVlp0ZUdGVE1rMTVWR3RrWVZKdFVrOVpiVEZ2VlZaYWRHTkZTbXhTYlZKSVZtMDFWMkZXU1hkWGJGSlhZbFJXUkZwV1dtRmpiSEJGVld4d1YwMUVSVEZXVkVadlpERnNWMU51VW1oU2VteFdWbTE0ZDAweGJIRlNiVVpxWWtaYWVWcEZXazlVYkZwWVpIcENWMkV5VVRCWmVrWnpWakZPZFZWc1dtbFdSM2hvVm1wQ2IxRXhaRWRYYmtaVFlsVmFjbFZzVWtkVGJHeFdXa2hPVldKRmNFZFZNVkpEVmpKR2NtRXphRmRXUlhCTVZXcEdUMWRXY0VkaFIyeG9UVmhDV0ZadE1IZGxSbFY0VjJ0a2FsSnRVbGxaYlhNeFYwWnNjbHBHVGs1U2JGb3dXbFZrTUZaWFNrWmpSV1JXVFZaS1NGWXdXbUZqTVdSMFlVWmthR0V4Y0doWGJGWmhWREZrV0ZScmFHaFNiRXBVVmpCV1MxZHNXWGhYYlhST1VtMTRXRlpHYUc5aGJFcHpZMFpzV21FeFZYaFpNbmhoWkVkV1JtUkhlR2xTYmtKYVZrWmFiMVF4V25KTlZWWlRZa2RTWVZSVlduZE5NVnB4VTJ0MFYxWnJXbmhXUjNoWFZqSktTVkZyYUZoaVJscG9Wa1JHYTFkR1NuSmFSMmhUVFc1b2RsWkdVa05UTVdSelYxaG9ZVkpGU205VVZscFhUa1prY2xadGRGZGlWWEJKVmxkNGIxZHRTbGxVV0doWFZsWndXRnBGWkZkVFJrcHlUbFpPYVZKWVFUSldiVEUwVlRGWmVGZFliRk5oYkhCVVdXMHhORmxXVWxaWGJVWnJZa1pzTlZsNlRtOVZNREZYWTBaYVZtSllhSEpaVmxwclVtczFSVkZzWkZkTk1FcEpWakZhWVdFeFpFZFRia3BoVWpCYVZGWnJXbUZXVm1SWVRWUkNWRTFXY0hwV01qVlRWR3hPU0dGR1FsWmlWRVV3VmpGYVlWZEhVa2hrUm1SVFRVaENOVlpIZUdGV01XUnpXa1ZzVW1KSGFGaFVWVnAzWld4cmVXVkhkR3RXYXpVd1dsVmFhMkZXU1hwWk0yUlhZV3R2ZDFaVVJrWmxSbVIxVTJzMVYySldTbGxYVm1RMFV6RmtSMkpJVGxaaVIxSllWVzE0ZDJWV1pISldiVVpwVW10c00xUnNWbTlYYlVWNFkwUk9XbFpXVmpSWmVrWlBZekZhYzFwSGJGaFNWWEJLVmpGb2QxTXhVblJXYkdSVVltdHdhRlZ0ZUdGalJsWnhVbXQwVjFadFVsbGFSV00xVldzeFdGVnJhRmROYWxaVVdXdGFTMDV0U2tsUmJGWlhZbFpLVlZaVVFtRldiVlpJVW10b1VGWnRhRlJVVlZwYVRWWmFjMXBFVW1sTlZuQXdWVzAxUzFReFpFZGpSMFpYWWtad00xbFZXbkpsUm1SeVpFZHdhVlpyY0VsWFZsWmhZVEpHUmsxV2JGSldSWEJZV1d4b2IyTnNVbkphUlhCc1VtNUNSMWRyV2xkaFJURlpVV3hhV0Zac1NreFVhMXByVWpGa2RWSnNWbWhOUkZaV1ZsY3dlRlV4WkVkYVNFcFhWa1ZhY0ZWdGRIZGxiRlY1WTBWa1YwMXJjRnBaVlZwVFYyeGFjMk5GZUZwTmFrWlFWVEZhZDFJeGNFZGFSM2hvVFZac05sWnFTakJWTVVsNVVsaG9WRmRIYUdoVk1GWjNZVVpXZEdWSVpHbE5Wa3BXVlcxME1HRXdNVmRqUldoWFRXcEdTRlpyVlhoak1XUjFZMFprVGxZeWFEWlhWM1JoVTIxV2MxWnVUbWxTYkhCdldWUkNkbVZzV2xWU2JVWmFWbTFTU1ZadGRHOWhNVXAwVld4b1dtRXlhRU5hUkVaaFl6RndSVlZzV2s1V00yaFpWbXBKTVZReVJuTlRhMXBQVm0xb1lWbHJaRzlrYkd4V1YyNWtVMkpIVW5sYVJXUjNWR3haZUZOcVZsZFNNMmh5V1dwR1UyTXhaSFZWYlhSc1lUTkNXVmRXWkRCWlZscEhWbXhXVTJKck5WaFVWbHBoVjJ4c1ZsZHRPV2hXYTJ3MFZUSjRkMWRHV2paU1ZFSldaV3RhWVZwVlpFdFRWbFowWkVaU1UwMVZjREpXYkdONFRrZFJlVlpyWkZoaE1taFBWV3RhWVZkV1ZuUmtTR1JzWWtkME0xbFZZelZXTWtwV1kwWmFWbUpZVW5aV01uaGhUbXhLY21WR1drNVdia0pKVjFSSmVGSXhTWGhhU0VwUFZqSm9iMVJXWXpSbFZscDBUVlJTVmsxVk1UUlZNalZUVmpKS1NHRkdaRnBXUlZwb1ZtcEdjMk5zY0VkVWJGWk9Wak5uZDFaR1dtcE9WbVJIVjI1T2FsSkZTbUZVVlZwaFkyeGFjMXBGZEZkTlYxSjVXVlZhYTFSdFJuTlhiR3hYWWxob2NsVjZSazlUUmtweVlrWkthVkp1UW5kV2JYUmhXVlpLVjFkdVJsUmhiRXB2VkZaYWMwNUdXblJPVlhSYVZtdHdNVlZYZUc5WGJVVjVZVVZTVldKWWFHaGFSVlY0VWxaS2MxWnJOVmROVlhCTFZteFNTMDVHYkZkYVJXaFVZVEpTV1ZsclpGTlpWbXh5V2tjNWEySkhlRmRXTW5oM1lrWktkRlZxUmxoaE1YQnlXVlphUzJSV1JsbGFSbWhvVFZad2IxZFdVa2RWTWxKSFUyeHNhbEpyY0c5VVZ6VnZWMVphZEdSR1pHdGhla1pJV1RCV1YxVXlTa2xSYms1V1lsaE5lRll5ZUhKa01YQklUMVphVGxZeFNrcFhWbFpoWXpGa1IxZHVVbFpYUjFKWlZtMHhVMU5HVm5GU2JYUnJWbXR3ZWxaWE1XOWlSMHBaWVVaYVYwMVhVWGRaVkVaV1pWWmFkVlJ0YkZOaVNFSnZWbGMxZDJNeFduTmlTRTVYWW0xU1ZGUldXbk5PUm14V1lVZDBWMDFFUm5sWk1GWnZWbXN4ZFZWWVpGaFdiSEJvVm1wS1QxSXhWblJTYkU1WFltdEtkbFl4VWt0T1IxRjRVMWhvVjJKc1NuQlZha3B2WXpGc2NsZHVaR2hTYkhCNFZXMHhNRlJzU25OalNHeFZWbXh3ZGxacldtdFRSMFpIV2tad2FFMXNTbFZXYWtaaFl6SlNSazFXWkZWaVIyaFVXV3RhZG1ReFdrZFhiVVpWVFd0d1NWVXlkR3RoVmtwSFYyeGFWMkpHY0V4V01GcHpWbXhrZEZKc1pGZGhNMEkyVmpKMFlXRXlSbGRhUlZwVVlrWmFXRmxzYUVOVVJsWTJVbTEwV0ZKcmNIbFphMXBUWVZaSmVGTnVXbGhXYkVwUVZWUkdUMUl4Y0VsVWJHaHBWbFp3V1ZaR1pIcGxSVFZIWVROa1YySllVbGxWYWtKM1YxWndWbGRzVGxoaVJuQkhWR3hXVDFsV1duTmpSMmhhVFc1b00xVnNXbGRqTWs1SFdrZHNVMDB5VGpSV2JURTBZVEF4U0ZOWWFGaGliRXBVVmpCa2IyTldWWGRXYm1SWFRWZDRlbGxWWXpWVWF6RllaVWhvVm1KVVZuSldNRnBLWlVaT2NtSkdXbWxYUjJoVlZtMXdTMU14VGxkU2JHeGhVbTFTVkZsclduZFdWbHBZWTBWMFUySldSak5VVmxwcldWWkplbEZzVmxaTlJscE1WakZhWVZJeGNFbGFSbVJPVm14d1NWWnFSbTloTVd4WFUyeGthbE5GTlZoWlYzUkxZVVpWZDFkdGRHcGlSMUl3V2tWa2IxVXdNVWRoTTJ4WFlsUkdNMVY2UmxwbFZrNXpZa1phYVZZeWFGbFdiWFJYWkRGUmVHTkdXbUZTVkd4VVdXdG9RMU5XVm5SbFJUbG9VakZhZWxZeWVFZFdNa3BWVWxSQ1YxWkZXbUZhUkVFeFYxWlNjMkZIYkZOaVNFSlhWakZhYTA1R1RYbFRXR2hXWWtkU1dWbHRjekZWUmxaMFpVaE9UMVpzU25wV01qRXdWakpLVm1OR1pGZGlXRUpZVm1wR1dtVnRSa2xYYkdST1ltMW9iMVpYTVRSaE1sSklVbXRrWVZKVVZsUlpiWFJMWkd4WmVGVnJaRnBXYXpFMVZrYzFVMVpYUlhsaFNFNVdZbGhOZUZscVJsTldWa1p5V2tVNVUySklRWGRYYTFaclRVWlJlRk51VGxOaGJGcFhXV3hvYjJOc1duSmFSWFJxVFZkU2VsWkhlSGRoUlRGelUyeFdWMkZyU21oWmVrWnJVMFpXY2xkdGRGTmlWa3BRVm0weE1HUXhaRmRYYmtaVVlXeEtZVlpxUW5kVFJsVjVUbFpPVjJKVldubFdNbmh2Vm0xR2NrNVlXbHBOYm1oNlZtcEdhMlJHU25OYVJUVm9aV3hhU2xadGVHdE9SMFY0Vmxoc1ZHRXllRk5aYkZKelYwWlNWMWR1WkdoU2JYaFdWVEp6TVdKR1duSk9XR3hhWVRGd1ZGbFdXa3RrVmtaMVdrWmtWMDB5YUZWV2JYQkhZVEZaZUZwSVRtaFNWRlpZVld4V2QyVldXa2RhUkZKYVZtMVNTRll4YUc5aFJrNUdUbGhDVm1KWVVucFViWGhoVjBkV1NFOVdhR2xXV0VKSlZtcEtkMVF4V1hkTldGWm9VakpvV0ZSVlpGTlhSbFp4VW14T2FrMVlRa2RVYkZwclYwWktWbUV6YkZkaGExcFVWVlJHV21Rd05WWmFSbWhZVWpOb1ZsZFhkR3RPUjBsNFZsaGtWMkp0VW1GV2JYaExWMVpTYzFsNlZsZE5WWEF3V2tod1MxWnRTbFZTV0dSYVZqTk9ORll4V2tkamJVcEhZMGRvVGxkRlNsSldNVnBoV1Zac1YxUnJaR3BTUm5CVVdXdGtVMk5HV1hkV2EzUlVWbTFTV1Zrd1ZqQldiVXBYVjJ0b1YxSXphSHBaVlZwTFpFZEdSMkpHV21oaE0wSXlWbXBLTkdFeFpFWk5WbXhxVWxSV1dGbHJhRU5YVm1SWVpFYzVWazFyVmpSV1IzUnZWbTFLU0dGR2FGcGlSa3BIVkZWYWQxWXhaSFJTYlhCT1ZteHdOVll5ZEd0aU1rWklWbTVLV0dKSGVGbFdhazVUVmtaYVJWSnRkRlJTYTNCYVdXdGFWMVl4U2xkalJteFhZbGhTV0ZkV1dsTlNNa3BGVjJ4U2FHVnRlRlZXUm1Rd1dWWk9SMXBJU2xkV1JWcHZWbXBDZDFkV2JGWlZiR1JYVFd0d1dsbFZXbE5XYkZvMlVteG9WbUZyV25KV01XUkhVMFpLYzFWc1RsaFNWWEF5Vm0xNGEyUXhSWGhpUm1SaFVsZFNXVmx0ZUV0ak1WVjNXa1pPYWsxV2NEQmFWV2hyWWtkS1IyTkdiR0ZTVmtwRVZtMXplR050VGtkaFJscHBWMFZLV1ZadGNFZFRiVlp6Vm01V1ZHSkhVbkJWYWtaTFZGWmFWVkZ0UmxkTmJFcFlWVzAxVDFkSFNsaGxSbXhXWVd0d2RsbHFSbUZqYkdSeldrWndWMDFHV1RGV2ExcHZZakpHYzFOc1pGaGlSMUpoV1ZSS1UxWkdXa1ZTYlVaclVsUkdWbFpIY3pGVk1rcEpVV3BTVjFaRldsUlZha1poVW1zeFYyRkhlRk5pVjJoWVZrWmtkMVl4VWtkaVJtaHNVbFJzVkZsclZURmxiR1J5VjI1a2FGSlVSbHBWVjNONFZqSktSMU5yYUdGU1JWcGhXbFZhZDFOV1ZuUmtSazVPVFVWd00xWnNZM2ROVmtaMFZWaG9ZVk5GY0ZoWmJHaFRWREZXZEdWRmRHeGlSbXcxVkd4Vk5XRkhTa1pqUldoYVRVWndkbFl5ZUZwbGJGWnhVMnhXVjFadVFubFdiWEJIWVRKTmVGVnVVbXBTVkZaWVZGWldkazFXV25SalJYQnNVakZHTkZac2FITldSMHBJVld4V1dtRXlVVEJXTVZwaFpFVXhWMU50ZEU1WFJVcEtWa1phWVdFeVJuSk5WbVJZWW01Q1dGUlhOVzlrYkd4WFYydHdiRkpyTlRGWlZWcHZWakF3ZUZOdWJGZGlSa3BNVm1wR1dtVkhUa1ppUmxKcFVqSm9kMVpxUW1GVE1sSnpWMjVTVGxaRlNuSlVWM2hoWld4c1ZWUnRkRmRpVlhCSlZsZDRiMVpXV25OWGFrNWhWak5vZVZwRVJtdGtSMUpIWTBaa2FWTkZTbHBXTVZKRFdWZEZlR0pHWkZoaVIxSnhWVEJXZDFsV2NGaGtSMFpPVFZaV00xZHJWVFZWTURGWFUyNXdXR0V5VW5aV1IzTjRVbTFPU0dGR1pHbFdSVWw2VjJ0U1MxWXhTbkpPVmxwb1VteHdXVlZxVG05WFJtUllUVmh3VGxadFVsaFphMXBYVlRKS1ZsZHNhRlppVkVVd1ZtMTRZVk5IVmtaUFZtUk9WbGhCZDFkc1ZtOWtNVmwzVFZoR1UyRXlhRmhXYTFaSFRrWmFjVk5yZEZOV2JIQXdWVzE0YTFZeVNrZFdhbEpYVFZad1dGZFdXazVsUm1SeldrWlNhV0V6UW5oV1Z6RTBaREZrUjFWc1ZsUmlWR3hZVm0xNGQwMUdhM2RXYlhSWFVsUkdlbFV5ZEc5V01WbzJWbXRvVjJKVVJreFZNVnBIWkVVNVYyTkdaRk5XYlRrMlZtMTBZVmxXYkZoVmEyaFZZVEZ3YUZWdE1WTlVNV3haWTBaa1QySkdiRFZhUldNMVZsVXhXR1ZHYUZaTlYyaDZXVlZhUzFaWFNraFNiSEJYVWxad2IxWkdVa2RaVjAxNFdraE9hbEl6YUZSWmJYUkxVakZhVjFwRVVtaE5Wa3A2VmpGb2QyRkdTblJsUm1oYVZqTlNhRnBIZUhOalZrcDBVbTF3VGxkRlNraFhWbFpoV1ZkR1YxZHJhR3hTYldoWlZtcE9VMkZHVmpaVGJHUnFUVmRTTVZWdGVFOWhWMFkyVm01b1dGWXpVbkpXVkVGNFZqRndTVk5zYUdsWFJrcFhWMWQwWVdRd01VZGpSV3hxVWxkU1dWVnFRbGRPUmxsNVpVZDBWMVl3Y0VoWk1HUkhXVlphYzJOR1FscE5ha1pJVldwR2EyUkhSa1pPVjJ4cFZqSm5lVlp0TVRSVk1VVjVVMWhvVTFkSGFGVlpWRXBUVjFac2RHVkZkR3BOVmxvd1ZHeFdUMkZyTVZobFNIQlhZbFJHU0ZaVVFYaFhSMVpIV2taa1RtRnJWak5YVmxaaFdWZFNSMVp1U21sU2JrSllWbTE0V2sxR1duRlJiVVphVm10d01GVXljR0ZWYlVwSVZXMDVXbFpGTlVSV1ZscHJWbFpPZFdOSGVGTmlSM2N3VjFSQ1YyRXhXWGxUYkdoc1VteEtWbFp0ZUdGTk1WbDVaVVp3YkZKdGREWlpWVlV4VlRKR05sSlVRbGRXUld0NFZrUkdhMU5HVG5WVWJGSnBZWHBXV0ZkV1pEQlRNa1pIVjI1R1UySkZOVmhVVm1SVFpWWmtjbFpVVmxaTmEzQktWVmQwYzFkR1duTlhia1pWWWtad2FGa3ljM2hXTWtaSFYyMW9UbUp0YUZwV2JUQXhaREZaZUZaclpGaGliRXBQVm14b1UxWkdVbGhqZWtaVFlrWndTVnBWWkRCaFJrcFZVbXh3VmxZelFtaFdha3BMVjFkR1NHRkdXbWhoTTBKVlZtMXdTMVF4U25OalJXaFRZa1UxYjFwWGVHRk5NVnB6V1ROa1RsWnJXbmxVVm1oUFYwZEtjMU5yT1ZkaE1YQk1XVEJhVTFkSFVrbFVhemxYWWtaWk1WZHJWbXBPVmxsNFUxaGtWMkZzV2xoV2FrNXZaV3haZVUxVldteFdiRm94VmpKNGExUnNTblZSYWxwWVYwaENURlZxUmtwbFJsWjFWVzF3VTAxdWFGVlhWekV3VXpGc1YxZHVTbGhpVlZwWVZGVlNSMU5HV25OaFIzUlZZa1p3ZWxrd1drTldNa3BaWVVST1YyRnJXbFJXTUdSUFVteHdSMVZzVG1sVFJVcFlWbXhqZUU1SFVYbFRhMlJVWW10d1VGWXdaRzlXTVZKWVRsYzVhbUpIZUZoV01uUjNZa1pLY21OR2NGaGhNWEJ5VmtkNFlXUldSblJQVm1ST1ZtNUNlVlpyVWt0VU1rNXlUbFprWVZJd1dsUlpiR1J2WkRGYWRHVkhSbXROVm5CWVYydGFiMkV4U1hkWGJrcFZWbXh3TTFZd1dscGxWVFZYVkd4V2FWSnVRa2xXVkVreFV6RmFWMWR1VGxkWFIyaFlWRlZhZDFsV2NGZGFSbVJVVWpGS1NGa3dXbXRoUlRCM1UydHdWMkpHU2t4VWExcFdaVVprYzFwR2FHbGhlbFo0VmxkMFZrMVhSa2RYYmxKc1UwZFNWMVJXYUVOV01WbDVUVlZrYUUxV2NIcFZNalYzVjBkRmVHTklTbGRTTTJoUVZXMTRUMk50VGtkYVJUVlhZVE5DUmxacVJtRmhNVTUwVm10a1lWSnRlSEJWYlhoTFlqRlNXR1ZGZEd4U2JIQlpXa1ZhWVZSc1duTmlSRkphWVRGd1dGWlVTa3RrUmxaMFQxWmFhVmRIWjNwWGJGWmhWbTFXV0ZWcmFHdFNiVkpVV1d0b1EwNXNXbFZUVkVacVRWWndWMVJXV210aGJFcHlVMjFHVjJKR2NGaFVhMXBhWlVaa2NscEdaRmRoZWxZMlZqSjBhMk14VlhkTlZWWldWMGRTV0ZsVVNsSmtNV1JYV2tVMWJGSnRVbHBaVlZwdllWWkplbUZJWkZkV2VrWTJWRlphYTFZeFduVlNiRkpwVmtkNFdWZFhkR3RWTVdSSFlrWmFhRkl6VWxoVVZWSkhWMFpzY2xWc1RsaGlWVlkxV1ZWV05GWXdNVWhWYTNoWFlsaG9jbHBGVlRWV01XUjBZa1pvVTAxdGFESldiVEIzWlVVMVIxZFliRlpoTW1oWVdWUktiMk5zVm5STlZrNVZUVlphZVZadE1VZFhSbHAwVld4YVZsWjZRVEZaVjNONFZqSk9SMkpHV2s1aWJFb3lWbTB3ZUZJeVRuSk9WbVJvVW14d2IxbFljRmROYkdSWFZtMUdXR0pXUmpSWk1GWnJWa2RLV1dGSVFsZGlSa3BZVlRGYVdtVlhVa2hTYldoT1lUTkNTbFpYZUc5aU1XUkhXa1ZzVW1KSGFHRlpWRXBUWkd4U1ZWSnNaR3BXYTNCNldUQmtORll5U2tkalJGWlhUVzVTYUZscVNrZFhSa3B4VjJ4a2FXSldTbGxXYlhCUFVURlNSMkpJUmxOaVZWcFVWRlprVTAxV1draGxSMFpvVm10c05GVXllSGRXTVZvMlVsUkNZVkpGUmpSVmFrWlhZekZ3UjFkdGJGTldSbHBoVmpGa01GbFhVWGxXYkdSV1ltczFXRmxzVW5OWFJsSldWV3RrVGxac2NGbFVWbU0xVmpBeGNsZHViRnBOUmxwMlZqSXhWMk5zWkhOUmJIQnNZVEZ3V1ZkWWNFZFpWMDE0WTBWb2FWSnNTbFJXYkZweVpWWmFkR05GZEU5U2JYaFlXV3RhYTFkSFNuTlRiR2hhWVRKU2RsWXdXbk5XVmtwMVdrZHdhVkpzYjNkV1JscGhWREZhVmsxV1pHcFRSMmhYV1d4b1VtUXhXbkpYYTNScVRXczFSMWxyWkVkV01WcDFVV3hHVjJGcmJ6QlhWbVJPWlZaT2NsWnNXbWxTTVVwUVYxWmtORmxXVmxkYVJtUmhVa1pLVlZSWGVFdFRWbFowWkVkMFdsWnJjREZWVjNodlZsWmFSbGRyZUZwaGExcG9WbXhhUjJSR1NuUmpSVFZUVW14dk1sWnNVa3BOVmxGNFlrWmtWRmRJUWxOWmEyUnZXVlpzVlZOdE9WSk5XRUpHVlcweE1HRnJNVmRqUkVKV1lsaG9XRlpITVVabFIwNUdZVVprVTJKR2NESlhWbEpIV1ZaT1IxUnVTbUZTYldod1ZXcEtiMkZHWkZoa1IwWlVUVlZzTkZaWGVHRlhSMHBXVjI1R1YySllVak5VVmxwaFUwZFdTR1JHVm1sU2JrSlhWbTB4ZDFsV1dYZE5XRlpXWWxkb1dWWnRNVk5UUmxaMFl6Tm9WMDFyY0VoVk1qRnpWVEF3ZVdGSFJsZGlWRUkwVkd0YVRtVkdWbkphUm1ocFVteHdWVmRYZEdGa01rMTRWbTVHVW1KdFVsVlphMXBYVGxad1ZscEVRbWhTYkhCNldUQmFiMWRyTVVkalNIQlhZV3RhVEZsNlNrOVRWazV6Vm14a1YySkdXVEJXTVdoM1V6RktkRlp1VG1wU1YyaFVXV3RWTVZaR1duTmhSVTVhVm14d2VsZFVUbTlVYkVsNFVtcFdWMkpVVmxCWlZWVjNaVlpXYzJKR2NHbFNNbWhWVm1wQ1lWVXhXbk5XYmtwaFVsUldXRmxyYUVOWGJHUnpWbTF3VDFac2JETlVWbFpYVlRKS2RHRkdaRnBpUjJoVFZGVmFZV05XUmxsaFJtUk9ZWHBXU1ZkV1ZtRmtNVkowVTI1S1RsTkhhRmhaYkdoRFZFWmFSVkpyT1ZSU2JIQjVXVlZrYjFVeFdrZFhiSEJYVmpOb1dGcEVSbE5TTVdSMVZXczFWRkl4U25sV1JtUTBXVlpKZUZWdVRsZGlXRkpZVm0weFUxTldjRlpYYlVaWVlsVndXbFpHYUc5V01rcFpZVWh3WVZKWFVsQlViWGhMWXpGd1JrNVdaRTVOYldONFZtMHhkMU5yTVZoU1dHaFlZa1p3VDFadE1WTldWbXh5V2tSU1YySkdjREJVVmxVeFZHeGFjMk5JY0ZkaVIyaDJWbXBCZUdOck5WWmpSbkJPVW01Q2VWWnJZM2hTTWs1eldraEthVkp0VW5CV01GWkxVa1prYzFadFJsaGlWbHBJVjJ0b1YxVXlTa2RqU0VKV1lXdGFURnBFUm1GalZrWjBaRWRzVG1FeWR6QldNblJoWWpKRmVGTllaRmhpUmxwV1ZtMTRkMlZzVW5OWGJVWlVVakZLU1ZwRldtdGhWbHBaVVd0MFYxWnRVVEJaYWtaaFpFWk9jbHBHYUdoaE0wSnZWbTF3VDJJeVJrZGlSRnBUWWtkU2NWbHJhRU5UUm14V1draE9WMDFyVmpSWlZFNXJWakF4VjFOclVsZGhhM0JIV2xWYWEyTXlSa2RWYldoT1YwVktVbFp0TUhkbFIwbDRZa1prYVZKc1dsUlpiRlpoVkRGU1YxZHNaRTVOVm13MVZGWldhMkZGTVZaalJscFdZbGhvYUZadGVHRk9iRXAxVjJ4a1UwMHlhRzlYV0hCTFUyMVdjMk5GWkdGU2JWSlVWbTV3Y21Wc1duRlNiVVphVm0xU01GWnRlR3RXUjBwelYyeGFXbUV5VW5aWk1GcGhZekZrZFZwR2FGZGlWa3BhVjJ0V2ExSXlSWGROV0VwWVlUSm9XRlJYY0ZkVVJsbDNXa1YwVjJKSFVucFdWM2hYVmpKS1YxTnNWbGhpUm5Cb1drUkdTMk14Y0VsVmJYUlRUVzFvV1ZkV1VrdE5NREZIVjJ4V1ZHSnRVbGhVVmxwelRsWldjMkZJVGxkaVJuQkhWVEo0YzFZeVNsbGhSRTVZVm14d00xWnFSbXRqYXpsWVkwZHNWRkpWY0VwV2Frb3dXVmRKZUZaWVpFNVdiSEJ4VldwQ1lWZEdiSE5oUlU1VFVtMTRlRlZ0ZEdGaVJrcHpVMjVzV0dFeGNISlpWbVJHWlVkT1IxWnNhRmROTW1oWlZqRmFhMVF4V1hoV2JrNWhVbTFTV0ZWc1duZFZSbHAwVFZSU1YwMUVWbGhaTUZwaFYwZEdObUpIT1ZaaVdHZ3pXbFphY21ReFpIVmFSbVJwVW0wNGVWWnRNWGRVTVZsNVVtNUthbEpYYUdGVVZ6VnZWVVp3UjFkck9XcE5helZKV1ZWa2IxUnNaRVpUYXpsWFlsaG9jbHBFUmtwbFZrcFpZa1pXV0ZJeWFIaFdWM2hyVlRKSmVGWnVSbFJoYkVwWVZXMTRTMWRHV25ST1YzUlhUV3R3U0Zrd2FITldNREZ4VW10b1YyRnJSalJaZWtaTFkxWldjMWRyTlZkTmJXZDVWakZhYTA1R1RYbFVXR3hWWVRKU2IxVnROVU5qUmxaMFpVaGthVTFXY0RCWk1GWnJWbXN4V0ZWcmJGZFdNMUp5VjFaYVMxWldXbkpQVm1Sb1lYcFdWRmRzWkRSWlYwNVhWRzVXYWxKVWJGaFpiRnBMVG14YWNWTlVSbFZOYTFwWVZUSjBhMkZzU25SaFJtaGFZbFJXUkZVd1duZFRSMVpJVW0xMFUxWkZXbGhXYWtsNFRrWlZkMDFWVmxkaE1uaFlXV3RrVWsxR1pGZGFSV1JYVFZoQ1IxbFZaRzlWTWxaMFpVWndWMkpZVWxoYVIzTjRVakpPUmxac1RtaE5NRXA2VmxjeE5GTXdNVmRYYkdoT1YwVTFWMVJYZEZwTmJGcDBaVWhPV0ZKc2J6SlZiR2hyVm0xV2NsZHVTbHBsYTFweVdrWmFWMlJIVGtkVWJHUk9WbGhDV2xadGRHRlpWbXhYVTFoa1QxWlhVbGxaYTJSVFlqRldkV05JVGxoU2JFcFpXa1ZvYTJKR1duTlRibkJYVFdwV1VGWXdaRXRXYkZweFZXeHdUbEpyY0ZGV2JYQkNaVVpaZVZScmJHcFNiVkp3VlcwMVExVldaRmxqUldSV1RXc3hORmt3Vm1GVU1WcDBWV3M1VlZaNlJuWldNVnBoWkVkV1NGSnNjRmRpUmxrd1ZsZDRiMkl4V25SVGJrcFBWbXhhWVZsc2FFNWxSbGw0VjI1T2FtSklRa1pXVnpGdlZUSktTVkZxV2xkaGEydzBWV3BLUjJSR1RuSmFSM0JVVWpKb1dGWkdZekZWYlZGNFYyNUdWR0V6VWxWVmJYaGhUVlpzY2xkdE9XaFNWRVphVlZjMWMxWXlSWGxVYWxKV1pXdHdVRmt5Y3pGV2JGcHpVMjFzVTAxVmNETldiR040VFVkUmVGUnNaRmhYUjJoWldXeFdZVmRXYkhOWGJVWllVbXh3V1ZSc1ZqQlhSa2wzWTBWb1drMUhhRVJXYlRGSFkyeGtjbVZHWkU1V2JrSjVWbXBDYTFVeFRrWlBWbVJVWVhwV1dGUldWbmRUYkZwMFkwVjBUbEl3YkRWVmJHaHZWa2RLY2s1WVJsWmlSa3A2Vm1wR2MxZEhVa2hTYkZKVFlrVndWMVpYTVRSVE1rcEhVMjVTVm1KdVFsbFpWRVozWkd4YVZWRllhRlJXYTFvd1ZXMTRhMkZXU1hoU1dHUlhZa1pLU0ZsVVNsTlNNVTV6WWtkb1UySlhhSFpYVm1oM1ZqRmtWMXBHWkZaaE1sSnlWRmQwWVZOR2EzZFdiVVphVm10d01GWlhlRk5XVmxwelkwVjRZVll6YUdGYVZsVjRWMFU1V0dKR1RrNVNiR3QzVmpGU1ExWXlVWGhYV0d4VVlrWmFVMWxYZUV0V2JHeFZVMnhPVkUxWVFsaFdNblF3WVdzeFdWRnJhRmRXZWtaMlZrY3hTMUp0VGtkYVJtUk9WakZHTTFadE1YcGxSbGw1VTJ0a1lWSXllRlJaYTFwM1ZsWmtXR1ZHWkZwV01HdzBWbTAxVTJKR1RrWk9WVGxWVm14d2VsUnNXbE5XTVZwMFpFWmtUbFpZUWpWWFZFSmhXVlphZEZOc2JGWmlWMmhZV1ZkMGQxUkdXWGhhUldSVVVqQmFTRmt3V210aFZrNUdVMjVhVjAxWGFETlZla1pTWlVaU2NscEdVbWxoZWxaMlZsY3dlRlV5VGtkV2JsSlBWbFUxV1ZsclduZE5SbkJHVjJzNVZrMUVSbGxhVlZwelZqRktkR0ZJV2xoV2JIQlFWV3BHYTJNeFpITmpSMmhPWWtWdmVWWXhaSGRTTVZWNFdrVmFUbFp0YUZGV2JURnZWMFpzY21GRlNtdE5WMUo2Vm0weE1GVXdNVmhWYTJ4V1lsaENhRlpVU2tabFYwWkhZVVp3YVZKcmNGbFdiWFJoWXpKT2MxcElTbXRTYldoWVdXdGFkbVZHV2xoTlZGSnJUV3RhUjFSV1dtdFdNa1p6VTJ4c1dtRXlVbE5VVlZwaFpFVXhWMXBHYUZOaVNFSTFWMVpXYTAxR1ZYbFRiR1JVWWtWS1dGbHNVa0psUmxaVlVtczVVMDFYVWpGVmJYaFBZVlpLVlZac1dsZFNiSEJvV1hwQk1WWXhXbGxpUjNSVFRURktkbGRYZEZkak1EVlhZa1phV0dKVWJGbFphMXB6VG14YVdFMVhPVmRpVmxwNVZqSndUMVl5U2xsaFNFcGFUVzVOTVZZd1pFOVRSMHBIV2taa2FXRXdjRXhXYlRCNFRVZEdkRlpyYUZWWFIzaFVXVlJHZDFReFZYZGFSazVYVm0xNGVWZHJXazlYUmtwMFpVaHdXbFpXV2xCV1ZFWkxZekpPUlZGc2NHeGhlbFl5Vm0xd1FtVkdXWGxVYTJScVVtNUNXRlp0TlVOTmJHUlhWMjEwVTAxRVZucFdNalZQWVZaS2RHRkdhRlZXUlhCMlZqRmFXbVZHWkhSU2JHUnBWbXh3U1ZadE1ERlVNV3hYVTI1U2FGTkZTbGhaYTFwM1RURlplV1ZIZEZoU01VcEpXa1ZWTlZVd01WZGpSbXhYWVd0dk1GbHFTa3RTTVU1elZtMXNVMkpYYUdoWFYzUmhXVlV3ZUZkdVJsTmlhM0J5VkZaYWQwMUdjRVpYYlhSVllrVndSMVl4YUc5WFJscHpWMjVhVm1WcldtRmFWbHBMWkZaT2RHTkdUbGhTTW1oYVZtdGFZVmxYVVhoYVJXUnBVa1p3VlZsVVNsTldSbEpYWVVWT1ZGSnNjRWxVVm1oUFZqRktjbU5HWkZwTlJsVXhWbXBLUzFaV1JuRlViVVpYVm14V05GWlVRbUZUTVdSWVUydGtWMkpYZUc5YVYzaGhWMVpaZUZremFHeGhla1pZVjJ0YWEyRldUa1pqUjJoV1lsaE5lRmt4V2xka1IxWklVbTE0YVZJemFGaFdiVEV3VFVkR1YxTnVUbXBUU0VKaFZGVmtiMDB4V1hkYVJWcHNVbXMxZWxaWGVHdGhSMFYzVjFSQ1YxWXphR2hYVm1SUFpFWktjbHBHYUdobGJGcDJWMWQwWVdReFZuTlhibEpPVmtWS2IxUldWWGhPVmxwSVRsWk9WMVl3VmpWV1YzaHZWMjFGZVdGRlVscGhhMXBVVm1wR2EyUldaSFJsUjJ4VFRWVndhRll4VWtOV01rVjVVbTVLVGxkRmNFOVdhMXBoVmpGc2MyRkdUbXRpUm5CWFZqSXhSMkZ0UmpaV2JHUlZUVlp3Y2xsV1dtRlNNV1J5Vm14a1YxSlZjRzlXTVZwclZURktjazFXWkZkaVJuQndWbXBLYjFWR1duUk5WRkpZWWxaYWVsWXlkR3RYUjBwV1YyMUdWMkpVUmxSVk1WcFdaVlUxVjFwR1dtbFdXRUpLVm14amVGSXhaSFJTV0d4V1lteHdhRlZxVG05WlZuQkZVbTEwYWsxck5VbGFSVlV4VjBaS1ZtTkZiRmRpV0VKTFdsVlZlRkl4Vm5WVWJGSm9UV3hLV2xkWGRHdGlNV1JIVm01R1ZXSlViRzlWYlRGVFYwWmtjbFp0ZEZkTlJFWlhWR3hTUjFZeFNqWlNhazVYVmtWd1dGcEZaRmRTTWtwSFdrZHNWMUpXVmpOV2JHaDNVakZSZUZOWWFHRlRSbHBVV1d0Vk1XTkdXWGRYYTNSWVlrWndXVlJXVWxOV1JURnpWMnhvV21FeGNHaFhWbHBMVW14T2MxcEdWbGROTVVwWlZrY3hORll4WkVoV2ExcFZZa2RTVDFadE5VTlRSbHBWVTFSR1ZFMVhVakJWYlRWTFYwZEtSbE5zWkZwV00xSm9XVEo0YzA1c1RuSmFSazVvWld4YVdWWXlkR0ZVTVZsNFdrVmFWR0pIYUZoWmJHaFRZVVprVjFkdVRsZE5hM0JJV1ZWYWEyRlhSalpXYkhCWFlXdEtjbFJyWkU5ak1WcDFVbXhLYVZaV2NIZFdSbHByVGtkV1YxZHVVazlXTTFKWlZXMTBkMlZzV25SalJtUmFWbXh3V1ZaWGRHOVdNa1p5WTBWNFYySlVSbEJWYlRGSFVqSk9SazVXVGs1V1Z6azFWbTB3ZDJWSFZuUldhMlJVVjBkNFZsbFVTbE5pTVZaMFRWWk9WVTFXV25oVmJYUXdWMFphYzJOR2JGVldiRXBVV1ZSQmVGWnRUa2xpUmxaT1ZtNUNNbGRXV21GVE1rNXlUbFpvVUZac1dsaFZiRlozVTBaa2MxWnRSbHBXTVVwSFZGWmFWMVZ0U2xoaFJUbGFZVEZ3TWxwRVJtRmtSVEZWVVcxb1RsWnRkekJXTW5SWFlqSkdSMU51VW14U01GcGhWbXRXZDFaR1duSlhia3BzVW0xU2VsZHJaSGRVYkZsNFUycFdXR0V4V21oWmFrWldaVlpPY21KR1NsaFNNVXBhVjFkMFlWbFhVbk5pUmxaVFlraENjMVZ0Y3pGTlZscFlaVWRHYUZacmJEVlpWVnB6VmpGS2RGUllhRmRXZWtaVFdsVmFhMk14V25OVmJXaE9UVlZ3V2xacldtRmhNVlY1Vm14a1lWTkZjRmxaYkdoVFZteHNjMVp1WkU1U2JYaFhWakowYTFkR1NuTmpTSEJYVFc1b2NsZFdXbUZXTWs1SFVXeGthR0V4Y0UxWGExcGhWVEpOZUZwSVVtbFNhelZQV1d4a2JtVnNXblJsUjNSclRWVmFlVlJXVm1GVWJGcFlWV3hzV21KWVRYaFdha1p6VmxaT2MxUnNaRmRpUlhCWlZtcEpNVlF4VVhoVGJrNXFVa1ZLVmxscldscGtNVmwzVjJ0d2EwMXJOVWRaYTFwclZqSldjbEpZYUZkaVdHaG9Wakl4VjJSR1NuSlhiWGhUWWxaS2RsWkdXbTlSTWxaWFYyNUdVbUpZVWxkVVZsWnpUa1pyZDFadGRHaGlSWEF3VmxjMVExWnJNVWRYYTNSVlZqTm9hRnBGWkU5U2JIQklZa1UxYUdWclZYaFdiR1EwWWpKSmVGZHJhRlJoTWxKWldXMTBTMVl4YkhOaFJ6bE9UVlpzTTFZeU5VOWhhekZ5VjJ0b1YxSXpUWGhXUjNoaFpGWkdjVlZzWkZkbGExVjNWMnRTUzFNeFNYaGFSbXhvVW14S2IxUlhlRXRXTVZwSFYyMUdhMDFyTlhwWmExcHJWMGRGZWxGdVRsWmlXRTE0V2xaYWQxSnNaSFJrUm1ST1lUTkNXRlpHV2xOVk1WbDRXa1ZzVW1FeWFGbFdiVEZUVkRGd1ZsZHVaRlJXYXpWNldWVmtjMVV5UlhwUmJIQlhZa2RSTUZacVNsSmxSbkJHV2tkR1UySlhhSHBXVnpWM1l6Sk9SMVZzWkZoaE0xSlZWVzB4TkZac1draE9WVGxvVm10d2VWa3dXbUZYYlVWNVlVVm9WMkpHY0doWmVrWmhWMWRHU0ZKc1pFNU5iV2cxVmpGU1MwNUhVWGhVYTFwUVZtMVNXRmxzWkRSV1JteDBaRVZrVGsxV2NIbFdWM1JQWVZVeGNrMVVVbGROVjJoNlZtdGtTMU5IVmtoUFZscG9ZVE5DTWxacVJtRlpWMUpJVm10c1lWSnVRbGhaYlhSTFYwWmFjVk51Y0U5V2JWSklWakZvYTFkSFJYbGhSbWhYWW01Q1NGcEhlR0ZUUlRGV1pFWk9hVlpVVmtsWFZFSmhZVEZTYzFkWVpFOVNSVXBZVlcxNFlXRkdXa2hOVm1SWFRWWmFlbGxyWkc5Vk1rcFhVMjVrV0ZadGFETldha1pyVmpGd1IyRkZOVlJTTW1oWVZrWmFZV013TlVkWGJHaHNVak5TV1ZWcVFuZE5SbHBZVGxVNVdHSlZWalJaTUZKUFZsWmFWMk5HVWxkaGExcG9Xa1ZrVTFOSFJrZGFSMmhPVFVWcmVWWnFSbE5STWtsNVZWaG9XRmRIVWs5V01GcGhZakZWZDJGRlRsaFNiRXBaV1RCV2ExVXdNVmxSYkdSWFRXNU5NVmxYYzNoV01XUjFZMFpvYUUxWVFubFhWM1JyVW0xV1NGUnJXazlXYlZKd1ZXcEJNRTFHV2toa1IzUlRZbFphV0ZaWGVITmhSa2w2VVd4U1YyRnJXa3haYWtaaFYwVXhXV05GTlZkTlJFVXdWMWQwYjFNeFpFaFRibEpXWWtkU1lWbFVSbmROTVZKV1YyNWtWMkpJUWtwWGEyUnpWVEpGZWxGcVZsaFdNMUpVVmxSR2ExTkdTbGxoUjNCVVVtNUNXVlp0ZEZka01VbDRZMFphWVZKVWJGUlVWbVJUWld4cmQxcEhPVlZpUjFKSFZXMXdZVll5U2xsUmExSllWbTFTVDFwV1dsTmtWbEowVW14U1UySklRblpXYkdONFRrWk5lRnBGWkdsVFJYQnZWV3hWTVZWR1ZuUmxTR1JYWWtaV05WUnNaREJXYlVZMlVteG9WbUpZUWxSV2JYTjRZMVphY21WR2NGZE5NbWhSVmxSR1lWSXlUWGhqUldSWFlrZFNUMVJWVm5kWGJGcDBaRVprV2xadGVGbFdSelZQWVd4S1YyTklTbFppV0UxNFdUQmFZV014Vm5OYVJsSlRZa2hDUjFaWE1IaFNNa1pHVFZoS1dHSkhlRmRVVjNCWFZFWmFjbHBGWkdwTmF6VklXVlZhWVdGWFNuSlRhMmhYVW14YWFGbFVSbHBsUm5CSlZHMXdVMDB5YUZWWFZ6RXdVekZOZUZkdVNscE5NbWhVVkZaYVYwNVdWblJqUjBaWFRXdHdSMVV5ZUc5WGJVcElZVWhhV2xaV2NETlZiRnBIVmxaS2RHTkZOVmROVld3MFZteFNTbVZHU1hoV1dHaFVZbXR3Y1ZWdE1XOVhSbFowVFZaS2EwMVlRa1pWYlhNMVZUQXhWMk5HY0ZwaE1sRXdWbFJCZUZJeVRrbFhiR2hYVFRGS1dWZHJVa3RXTVZsNFZtNVdWV0pIYUhCV2EyUTBWMnhrV0dWR1pHdE5WbkI2VmpJMVUyRXhTbkpPVm1oVlZsWktTRlV3V25Ka01XUjBUMVpvYUdWcldYaFhWbFp2VXpGa2RGWnVTbGhoYXpWWFZGVmtVMVpHVm5GU2JFNXFZWHBXV0ZaSGVFOWhWazVHVTJzNVYySlVSak5WYWtaV1pVWktXV0ZHYUdsaE0wSlJWbTB3ZUZVeFdYaGlTRkpxWld0YVdGWnRNVFJXYkZWNVRVUldhR0pHY0hwVk1uaGhWbXN4ZFZGc1VsZE5SbkJvV1hwS1QxTlhTa2RhUjJ4VFlUTkNTbFp0ZEd0bGJWWkhXa1ZvVjJFeVVsbFphMXAzWTBaWmQxcEhPV3hXYkhBd1drVmtSMVpGTVhKTlZGWlhVak5TV0ZaVVNrdFRSbFoxVVd4a1RsSXhTakpXYWtaaFdWZFNTRlJyV21GU2JFcFBWbTAxUTFkV1duRlRWRVpWVFZkNFdGVXlOVk5XYlVwSFUyMUdXbFpGV21oVVZFWmhWakZrZEZKc1pFNVdiSEExVmxSS2VrMVdXWGROVlZaVFZrVktXRmxzVWtKbFJscHhVbXhhYkZack5YbFdNakYzVlRKS1dHRkdhRmhXTTJoMldXcEJkMlZHWkhOYVJtaHBWMFpLV2xaWGNFZFpWazVYVm01U2JGSnJOVlpaYTFwM1YxWndTV05GVGxkTmEzQmFXVlZvWVZkdFZuSmpSWGhXWVd0YVVGbDZTa3RTTVdSMFlrWk9UazF0YUZwV2FrWnJUa2RKZUZaWVpFNVRSMmhaVmpCa1UxZFdiSFJrU0dScVlrWktXRll5Tld0aVIwcElWVzVzVjAxcVJYZFdiR1JMVWpKT1JWRnNWazVTTW1nMlZtMXdSMWxWTlhOU2JHeG9VakJhVkZWc1duZGlNVnB4VVcxR1ZFMVhVbGxWYlhSdllXeEtjazVWT1ZwaVIxSjJWakZhV21WR1pIUmtSVFZUWWxob1dWWnNaREJoTWtaWFUydGthbEpzU21GWmEyUnZWa1pyZUZkc1RsZE5WMUo1V2tWVk1WVXlTbGxoUkZaWFlXdHdObFJzWkVkU01VNXpWbXhLYUdGNlZsaFdSbU14WWpGT1IxZHVSbFJoTTFKWlZtcENZVk5zVlhsbFJtUm9VbFJHV2xWWE1XOVhSMHBIVjI1S1ZtVnJXa3RhVldSUFVteHdSMVp0YkZOTmJXaFdWbXRhYW1WSFNYaGFTRTVZVjBkb2FGVnJWa3RpTVZKWFYyeGtUMUp0VW5sV01qRXdZVVphY2s1VlpGVmlSMDB4Vm0weFMxSXhXbGxoUm5CT1ZtNUNiMWRyVm10V01VcDBWV3RrYUZKck5YQldiWFIyVFZaYWRHTkZkR3hoZWxaWVZqRm9hMVJzV2xkWGJGSmFZVEpTZGxZd1dsTlhSVFZXVkd4T1UySldTbGxXYWtvd1RVWlpkMDFXYUZaaVNFSlpXVlJHZDJOc2JGZFhiVVpUWWtkU2VWUldXbXRoVm1SR1UydHNXRlpzU2t4V1J6RlhWakZXZFZOdFJsTk5NRXBWVjFkNFlWTXhaRmRhUm1oclVucHNVMVJXV21GbGJGbDVUbFpPVldKRk5VbFpWVnBEVm0xS1ZWSlVRbGROVm5Cb1ZXcEtSMU5GT1ZkalJtUm9aV3hhU1ZZeFVrTmhhelZYVjI1U1ZHSkhlRzlWYTFVeFYwWldjbFp0Um14aVNFSkhWMnRWTVdKSFNrbFJhMnhoVWxaVmVGWnFRWGhXYlVvMlVteGthVmRIYUhsV1JsWmhWRzFXVjFSdVNtRlNiRXB3V1Zod1YyVkdXbFZSYlRsU1RWZFNTRlp0TlZkaGJFcDBWV3hrVm1KWWFETmFWbHByWTJ4YWRHUkdWazVoTTBKSlYxUkNVMUV4V2xaTlZtUnFVa1UxWVZac1dsZE9SbGw0VjJ0a1dGWXdOVWhYYTFwcllrZEZlRlpxVGxkaGExcG9XVlJHVW1WV1VsbGhSMFpVVW14d1YxZFhlRmRaVmxwSFlraE9XR0V6VWxkVmJYaDNUVVp3VmxwRVFsVmhla1pHVlcxMGIxWXdNWFZoU0ZwWFVqTm9URlZ0ZUd0ak1XUnpWbXhrYVZORlNscFdhMlEwV1ZaYWRGWnNhRlpoTW1oeVZXcEtiMk5HVm5OaFJVNVhUVmRTV1ZwRlpFZGhSVEZYWTBab1YwMXVhSEpaVjNoTFpFWldkR0ZHWkdsU2JrRjZWMVJLTkZsWFRsZFRibEpyVWpOQ1QxWnRkSGRPYkZsNVpFZDBhazFXVmpWVk1qVkxWVEpHY2s1V2FGcGhNbEpRVkd0YVUyTnNaSEpPVjNoVFlrWnZlRlpyWkRSaU1rWllVMnRrYWxKc1NsbFdhazVUWTJ4U2NsZHRkRk5OYTNCSVZtMTRVMkZXU2xWV2JFSlhVbXh3YUZwRVJtRmpNVnAxVlcxNFUwMHhTblpXUmxwWFpESldWMVZ1VG1oVFJUVllWRlZTUjAxV2JGWmhSMFpZWWtad2Vsa3dWakJaVmxwWFkwWkNXbVZyY0VoVmFrcEhVakZ3Ums1Vk5XbFdNbEV4Vm0wd2VFMUhSblJXYTJSWVYwZG9WVll3Wkc5aFJsVjNWbTVrYUZKc1dqQlVWbU0xWVZVeFYxTnNXbFppV0ZGM1ZqQmFZV015VGtWUmJIQk9VbXh3VVZkV1VrSmxSbHAwVTJ0V1ZtSkhVazlaYlhoTFRXeGtXR1JIUmxSaVZrWTBWMnRvVDJGR1NuTlhiR2hWVmtWYVMxcFhlR0ZXVmtaMFVtMXdhVlpyV1RCV01uUnZVekZhV0ZOcmFHaFNiRXBoV1d0YWQxUkdWalpTYlVaWFRWaENSbFZYTVhOVWJGcDFVVmhrVjFaNlFYaFZla1pyVTBaT2MyRkhhRk5OUm5CdlZtMXdUMVV5UmtkWGJGcFlZbTFTVkZSV1pGTmxWbEY0V2toa1ZXSkdjSHBaYWs1clYwWlplbFZ0YUZkU1JYQklWbXBHVTJOc1pITlZiV3hVVWxWd1dsWXhaRFJpTVZWNVVtdGtXR0pHV2xSWldIQlhZekZhZEdONlJsaGlSM2hYVmpJeE1HRkdXWGRYVkVwWFlsaG9NMVl3V2xwbGJGWjFVMnhrVjFKV2NIbFdiWEJMVXpGT1YxUnVVbE5pUlRWdldsZDRZVmRzV25OWk0yaFBVbXN4TkZkclZtdFhSMHB6VTJ4Q1YyRnJOVlJXYWtaVFZteFdjbHBHYUdsU2JIQmFWMnhXYTAxR1dYZE5XRXBxVW14d1YxbHNhRk5rYkZweFUydDBXRlpzU25oV1YzaDNWRzFLZEdGSE9WaFdSVnBvVmxSS1RtVldVbkpYYXpsWFlYcFdkMWRXVWtOa01WVjRWMjVTVGxOSGFISlVWbFY0VGtaYVIyRkhPVmhTTUhCSlZsZDRWMWR0U2xsVVdHaFhWa1ZhZWxsNlJtRmtSa3B6WVVaT2FWSllRbGhXYkZKS1pEQTFXRkpyWkZSaWJFcFhXVzAxUTFkR2JITlZhMlJVVW14c05WcFZXbmRoTURGRlZteHdXazFHY0ROV1IzaExZekpPU1dKR1pHbFhSa3A1Vmxod1IyRXhUa2RYYmtwaFVteHdjRlZxUmt0a01WcDBaRVprVjAxRVFqUldNblJ2WVRGSmQxZHNiRnBpUm5Cb1ZqRmFZV1JIVWtoa1JuQlhZVE5CZDFac1pIcE9WbGw1VTJ0a1ZHRXlVbFpXYkZwM1lVWndSbFpZYUZOV2EzQjZWbTF6TVZZd01WWmpSWFJYWWtaS1RGUlZaRVpsVmtwMVZHeFNhV0pGY0hwV1YzQkRXVlprUjJKR1ZsTmlSbkJ6VlcxNGQyVldXWGxOVldSb1RWVnNORll5ZEc5WFIwVjVWV3BPVjFJemFHRmFWVnBQVjFad1IxcEdaR3hoTVZZelZtMTRVMUl4V25SV2JHUlZZbXR3YUZWcVRrTldSbXgwWkVWMFdHSkhVbGxhUldSSFYyeGFkRlZyYUZwaE1YQllWbFJLUzFOV1JuVlViR1JwVjBVeE5GZHNXbUZoTWs1eldraE9WV0pYYUZoWldIQlhVMFphVlZOcVVtcE5WbXcwVmpGb2QxVnRTa1pUYlVaYVZqTlNhRlpyV2xkalZrcDBaRWQwVjJFelFqWldhMk40WXpGWmVGZHVWbEppU0VKWVdWUkdkMk5zY0Zoak0yaFhUVlUxV2xsVldtOWhWa2w1WVVod1YxWXpRbEJXVkVaclVqRldjMkZIZEZSU01VcGFWbTB3ZUU1R1dYaFhiR2hPVmxkU1dGUlZVa2RXTVd4eVZXMUdWMDFXYnpKVmJUVmhWakpHY21ORmFGcE5ibWh5V1RJeFUxTkdTbk5hUm1ScFlUQndVMVpxU2pCWlZteFhWbGhzVlZkSGVGUlpWRXB2WTBaV2RHTjZSbGhTYkZvd1dsVm9ZV0pHV25OalJFSmhVbGRTU0ZZeWVHRmpNa3BGVm14a1YySlhhREpXYlRFMFlURk9TRkpyWkdsU2JrSnZWRmQ0UzAxc1pGbGpSV1JYVFd4S1IxUldXbXRXVjBwSlVXeG9XbUV5YUVOYVJFWnJZMnhhZEZKdGFFNVdhMWt3VmxSSk1WUXlSbk5UYTFwVVlsZG9XRmxyWkZOVk1YQkZVbTFHYWxacldscFpWV1IzWVZaYVZWWnJiRmhXUlVwb1YxWmFXbVZXV25WVWJHaG9UVzVvV1ZkWGVHOWlNa1pIV2taa1lWSnJOVlJVVmxwM1pXeHNjbHBGWkZaTmEzQklXVEJhYzFZeFdYcGhSMmhoVWtWYWNsWnFSbmRUVms1eldrZHNXRkpyY0ZsV2ExcGhWakpSZDAxVlpGaGlSMmh5VldwT1UxbFdXblJrU0dSWFlrWndNRlJzVms5V01rcFdZMFphVjJKWVVsUldNbmhoVmpKT1NGSnRSbGRXYmtKNVYxaHdSMlF4U1hoalJWcFBWbTFTYjFSV1pEQk5NVnAwVFZoa1ZHRjZSbGhXVm1odldWWktXR0ZHVmxwaVdGSXpWbFZhWVdSRk1WVlZiSEJYWWtoQ05WWnRNREZoTWtWNVUydGthbE5IYUZkWmJHaHZWVVpaZDFkcmRGZFdiSEI2VjJ0YVYyRldTbk5XYWxKWFlrWktURlY2U2s5ak1WSjFWRzFvVTJKV1NuWlhWbEpLVGxVd2VGZHJaRmRpV0ZKVVZGZDRTMU5HV2toT1ZYUllVakJaTWxsclduTldhekZIVjJ0NFYwMUdjR2hWYWtaM1UxWndSMVJ0YUd4aE1YQktWbTF3U2sxV1NYaFdXR3hUVjBoQ1UxbHRjekZaVm14eVYyMUdhRkpzV25oVmJUVlBWakpLU0ZWcVFtRlNWMUoyVmxSR1lWSnNaSE5pUm1oWFVsVndiMWRZY0VkWGJWWlhWRzVPYVZKcmNHOVVWekZ2VjBaYVIxcElaRk5OVjFKSVZtMDFSMVV5UmpaaVNFcFhZbGhvTTFwWGVHRmtSVEZaVkd4YVRsWnVRa2xXYWtwM1ZERlplVk5yYUZWaGF6VldWbTE0ZDFJeGNGWlhiVVpxWWtoQ1NGbFZaSE5WTWtwSlVXeFdWMDFYVVhkWFZtUlNaVVpXV1dGR2FHbGlSWEI2VmxSQ1ZrMVdWa2RXYmxKc1UwZFNXVlp0TlVOV01XUnlWbTEwVjAxRVJrWlZiVFZ6VjJzeFIyTklTbGRoYTBZMFdrWmtSMUl4Um5OYVIyeFRZbXRLZGxZeGFIZFRNVkY0Vkd0b1UyRXlVbGhaYTJSVFkwWlZkMVpyY0U1aVJtdzBWbGQwTUZReFNuTmlSRlpYVW0xb2RsWnRNVXRqYXpWWFlrWndhVkl4UlhkV2FrSmhWMjFSZUZkdVNtdFNiRXBZV1d0b1FtUXhaRlZSYkdST1VteEdORlV4YUd0V01rWnpVMnhvVlZZelFsaFdhMXBoWTJ4d1JtUkdVbE5OVm5CSlZqSjBZV1F4V1hkTlNHUk9Wa1pLV0ZsWGRFdGhSbHB4VTJ4T1ZGSnNjSGxaYTJSSFZUSktSMk5HVmxoV00xSnlWRlJCZUZJeFpIVlNiRkpvWWtWd2RsWkdaREJaVlRGSFZsaHNhMUl6VWxoVmFrSjNUVlpXV0dWSE9WZFdiRzh5Vm0wMVlWZHJNWFZoU0hCWFlXdGFjbGt5TVZOVFIxSkhXa2RvVGxkRlJYbFdiWGhxWlVVMVNGSllhRlppYXpWWlZqQmtOR0ZHVWxWVWEwNVlVbXh3ZUZaSGRFOVdSa3B6Vm1wV1ZWWnNjSEpXVkVGNFYxWkdjbU5HWkdsWFIyaFpWMVphWVZNeVRuUlVhMnhoVW0xb1dGbHJWbmRWVmxwWFZXdGtXbFl3TVRSWk1GWnJZVVpKZWxWc1VsVldWbkF6V1ZWYVlXUkZNVlZWYlhCT1VrWmFTVlpxU2pSaU1rcEhVMjVTVm1KSGFGZFpWM1JMVFRGYWRHVklUbXBpUjFKNlZrZDRhMkZXV2xsUmJVWllWbXhhVkZaRVJscGtNREZXV2tkd1UwMUdjRzlXYlRCNFZURmtSMVpZWkdGU2F6VlVWRlprVTJWV1VuTlhhemxXVFZad01WVlhlSGRXTWtaeVYyeFNWbFpGV21GYVZscExWMWRHU0dKR1RtbFdhM0JoVmpGa01HRXhWWGhhUm1ScFUwVTFhRlZ1Y0hOWFZsWjBaVWhrYkZac2NEQlViR1F3Vm1zeFJWSnNjRlpXTTFKb1ZtMXplR1JXVWxWU2JHUlhVbFZaTUZadGNFZFVNbEpZVkd0a1lWSXllRmxWYWtwdlRsWmFkR1ZHVGxOTlYzaFlWVEZvYjFsV1RrWmpSbXhhWVRKU1ZGa3dXbGRqVmtweVdrVTFUbFp0ZHpCV2FrbDRVakZaZVZOc1pGTmhhelZXV1d0YWQyVnNXbk5hUlhSVFRWVTFNVlZYZUhkaFJURlhZak53V0dKR2NHaFhWbHByVW1zeFYxWnNTbWxYUmtwUVYxWm9kMVl4VGxkWGJsSk9Va1ZhVmxSWGRHRlRSbFY1WlVkR1ZVMVdjSGxWTWpGSFYyeGFSbGRxVG1GV00yaFVXVEo0YTJSR1NuTmhSazVPVWtaR05WWnRNSGhPUjBWNFYxaG9XR0V4Y0ZsWmEyUTBWMFpzV0dSSVNteFNia0pHVlcxNGQyRXdNVVZTYkhCWFlsUkdkbFpVUVhoa1IwWkhZa1prVTJKR2NIbFdiRkpIVTIxV1NGUnJXbGRpUlhCWVZXeGFkMWRXV2tkWGJUbFNUVlUxU0ZZeU5WTmlSa2w2VlcwNVYySllVak5hVjNoYVpVZEdTVnBHWkU1aE1Wa3dWMVJDWVdJeFpFZFhiazVxVWpCYWFGWnNXbmROTVZaMFRWVmtVMDFZUWtsWlZWVXhWMFpLVm1ORVNsZGlXR2h4V2tSS1YxSXhXbGxpUmxab1RXeEtXVmRYTVhwTlYwbDRWbTVPVjJKdFVuRlVWbHBoVFVaU1YxZHJPVmROYTNCSVZqSjRjMVpXV25OWGJrcFhZV3RhVEZac1drdGtWMHBIWTBVMVUySklRWGxXYlhCRFlURktkRlpyWkdGVFJscFpXV3RvUTFkR1duUk9WVTVWVm14d01Ga3dWbXRXVlRGeVRWUldWbUpZVW5KWFZscEtaVmRXUjJKR1dtaGhNMEo1VmtjeE5GbFhVa2hVYTFwVllraENXRmxyWkROTlZscHlXa1JTYUUxV2NGbFZNalZMWVd4T1JtTkdaRnBXTTAxNFZXdGFZVkpXU25SU2JYQk9ZVEZ3U0ZaVVNYaE9SbFY1VTJ0c1VtSkhlRmhVVmxwTFZVWnNjVkpzU214U2F6VXhWa2Q0YTJGSFNrWmpSbXhYVW0xTmVGbHFTbGRqTVdSellVVTFWMWRHU2xWV1JscFdUVmRXYzJKR1dsaGliVkp2Vm0xMGMwNVdiRlpWYTNSWVVteHdlbFl5TVc5WFJscDBWV3hTVmsxR2NGUldNV1JQVTBkR1IxUnRiRmRoTTBKU1ZtMHdkMlF3TVZkU2JsSlhZVEpTV1ZscldtRldWbXhZWlVWMFdGSnNTbGxhUldSSFZrWmFjMVpxVm1GU1YxSklXVlZrUzFKdFRrbGpSbHBPWW0xb05sWnRjRXRTTWs1eVRsWmtWbUpIVWs5VmJUVkRaVlphZEdORlpHaE5hekUxVmtkMGIySkdTbkpPV0VKV1RVWmFTRlJyV21Ga1IxWklZMGQ0VTAxVldURldWRW93WWpGVmVGcEZhR2hUUlZwWFdXeFNSMVpHV1hkWGJrNXFUVlphZVZZeU1UQlViR1JHVTJ0a1YxWjZSVEJhUkVwTFVqRk9kVlZzV21sVFJVcG9WMVpTUzFWdFVYaFhiRlpUWWxWYVZWVnFSbUZUUm14eVYyMDVWMDFFUWpSVk1qQTFWMGRGZUZOcmVGZGhhM0JQV2xWYWQxSXlTa2hpUms1T1RVVndObFl4WkRCWlYxRjRXa2hPWVZKdGFITlZha0poV1ZaYWNWSnRSbGhTYkd3MFdWVm9UMkZGTVZaaWVrcGFZVEZ3ZGxac1dscGxiRlp4Vkd4a1RtSnRhRFpXYlRFMFdWZE9WMVp1VG1oU01taHpXVlJHYzA1R1dYaFhiR1JhVmpCc05GbHJXbXRXUjBwSVZXNUdWbUpIYUhaWlZWcFhZekZ3UjFSc1VsTmlSbkEwVmxSS01HRXhWWGROVm1SVVltMTRWbGxyWkZObGJGcHhVVmhvYTFJd1drZFphMXByWVZaYVJsTlljRmhpUmxwWFZGWmFTbVZXVG5KYVIwWlRUVzVvVlZkWGVHRlRNV1J6VjI1R1VtSllVbkJVVmxwM1YwWlplR0ZIZEZwV2EyOHlXV3RhYjFZeVNsVlNWRUpYWWxob1dGcEZWVEZYUjFKSVlVZG9iR0V4Y0ZwV2JYQktUVmRSZUZkWVpFNVhSVnBZV1cxMGQxZEdiRmhrUjBaVlVtNUNSMWRyV210Vk1ERllWVzV3VjAxdWFISlphMlJMVWpKT1JWWnNaR2xXUlZsNlZsZHdSMVJ0VmxkV2JrcG9VbTFTYjFSWGVFdFhiR1JZWkVkR2EwMVhVa2hXVjNoWFZrZEtWV0pJUWxWV2JIQXpXbFphYTJOdFJrbGFSMnhUWVROQ05sZFhkRk5WTVdSSVVsaG9hbEp0YUZoWlZFcFRWRVpXY1ZOck9WTk5hMXBJVm0xNGExVXhXblZSYXpWWFRXNW9hRmRXV25OWFJsSlpZVVprYVdFelFubFdWekUwVXpGUmVGZHVUbWhTVlRWUVdXdGFjMDVXY0VaYVJXUlhUVVJHV0ZadGNGZFdhekYxWVVkb1YwMUhVa3hWTUdSSFVqSkdSMk5IYkZOTmJXZDVWbXRhVTFJeGJGZFRXR2hoVTBaS1ZGbHNhRU5VTVZsM1ZtdDBVMDFXY0hwWGExSlRZVEF4VjJKRVZsWk5ibEo2VmxjeFIyTXlUa2RoUmxaWFpXeGFWVmRyWkRSV01EVnpVMjVPWVZKck5VOVdha1pLWlVaYWNscEVVbWxOYTFwWVZUSTFTMkZzU25SbFJteFhZbFJHVTFwRVJtdFdNV1J6Vkd4T1RsWnNiM2hXYkdONFRrWlZkMDFWWkdwU2JYaFlWVzE0ZDJGR1pGZGFSbVJYVFZoQ1NsVXllRzloUjFaMFpVWmtXRll6VW1oYVJFRjRWakZhYzJGSGNGTk5SbkJaVmtaYVlXUXhTWGhpUmxaVllsUnNXRlJXVm5kU01XdDNWbTA1VjJKVldubFdNbmhEVjIxV2NsZHRhRnBsYTFwVVdrVmtTMUl4VW5SaFJUVk9VbGhDYjFadE1YZFNNa1YzVFZWa2FWSnRhRmRXTUdSVFZERlZkMXBIT1ZoU2JYZ3dXa1ZvYTFkR1duUmxTSEJYWWxSR1NGWXdXa3RqTVU1ellVWm9hRTFZUWxGWFYzUnJVekZPUjFadVZtbFNiVkpQV1cweGIyVldaRmRXYlVaYVZqQXhOVlpIZEd0WFIwcEhZMGhDVm1KWVVqTlZiRnBoWkVkT1JscEdjRmRoTTBJMlZqSjBiMVl4WkVoVGEyeFNZa2RvVjFsclduZE5NVmwzVjIxMGFrMVhVakJWYlhoVFZHeFplRk5zYkZoV1JVcFlXV3BLUjJNeFRuVlRhemxZVWxWd1dGZFhkR3RpTVVwSFYxaHNiRkl3V25KVmJGSkhWbXhXV0dWSGRHaFNNVnA1VmpKNGQxWXlTa2hVV0doWFVrVmFZVnBXV2s5amJIQkhZVWRzVTJFelFtOVdNVnBUVXpGVmVGZHJaRmhYUjFKWldXdFZNVmRHVWxkYVJrNU9WbTFTZVZkclVsTldNREZ5WTBab1ZrMXVRbGhXYWtwSFkyMU9SVmRzVm1sU2JrSnZWMVJLZW1WR1dYaGpSV2hxVW1zMVdGUlVTbTlaVmxsNFdUTmtUbFpyVmpSVk1uUnJWMGRLY2xkc1RsZE5SMUoyV1RKNFlXUkhWa2hTYlhocFVqTm9XRlpxU1hoU01rWlhVMWhrVjJGc1NtRlVWVnAzWld4WmQxZHRSbE5pVlRWR1ZqSXhSMVl4V25WUmJteFhZbGhDU0ZacVNsTldNVnAxVlcxc1UyRjZWbmRXVjNodlVURlplRmR1VG1GU1JrcFlWRmQ0UjA1R1pISlhiWFJZVWpCd2VsVXljelZXYXpGSVZXNWFWMVpXY0ZoYVJWVjRWbFpXYzJGR1RtbFRSVXBMVmpKMFYyRXdNVWRYV0dST1YwVndjVlZzWkRSWlZscHpXa2M1VmxKc2NEQlVWbFl3VmtaS2MxZHVjRmRXTTJoeVZtcEdZV1JXUm5SUFZtaFhVbFp3YjFaWWNFdFZNVWw0Vkc1V1ZXSkdXbTlhVjNoaFYxWmtXR1ZIT1doaVZscElWakZvYzJKR1NuUlZiR2hWVmxaS1NGVXdXbHBsUjBaSVpFWldhVkp1UVhkV2JHTXhVakZhZEZOc1ZsTmliSEJaVm0xNGQxWkdXblJsUjNSclVtdHdNRmxWV2s5aFZrNUdVMVJDVjJKSFRqUlVWVlY0VWpGa1dWcEZOVmRpVjJoWVYxY3dNVkV4YkZkWGJrNVlZbTFTYjFWdE1UUldNV1J5Vm0xR2FWSnJiRE5VYkZaclYyMUZlR05JV2xkTlJuQlFWVzE0VDJOdFNrZGFSbWhVVWxWd1RsWnRkR3BsUmxsNFUxaHNWV0V4Y0hCVmJYaExZakZ3V0UxVVVsaFdiVkpaV2tWYWEyRXdNVmRqUm1oWFRXcFdWRmxVUmtwa01XUjBVbXhrYVZaRldsVldWRUpoVjIxV1ZrNVdXbXRTYldoVVZGVm9RMU5zV25OYVJGSnBUVlp3V0ZZeU5WTldiRnBHVTJ4b1ZWWldjRE5XYWtaM1ZqRmFWVkpzWkdobGJYaFpWMVpXWVZReFVuTlVhMXBVWVROQ1dGUldXa3RTUm1SWFYyNU9WMDFZUWtwV1IzaHZWMFpPUmxOdVdsZFdNMmgyV1dwR2ExSXhaSFZUYkdScFZsWndlbGRYZEd0TlJUVlhZMFphWVZKWFVtOVVWbFozWlZacmQyRklaRmhTTUZZMFZteG9iMVl5Um5KalJYaFdUVVpWTVZac1dsTmpNWEJJWVVVMVdGSlZjR0ZXYlRFMFZURkplRlJ1VWxkaE1sSm9WVEJhWVZZeGJISlhhM1JxVW14YU1GUnNWazlYUjBwSVZXeHNZVkpYVFRGV1YzTjRWMGRXUjJGR1pFNWhiRnBSVm1wQ2ExTXhXbk5hU0U1aFVteHdjRll3Wkc1bGJGcEhWbTFHYTAxV2NIcFpNRlpoV1ZaSmVXRkhPV0ZXTTFKb1ZqSjRZV014YkRaU2JYUk9WbTVDTmxacVJtOWtNa1pIVkd0YWFsSnRhR0ZXYWs1VFlVWmFSbGR0Um10U1ZFWlhWakl4TkdGV1RrWlRhMnhYVFc1U2FGbFVTa3RUUmtwWllVWmthR0Y2VmxsWFYzUnJZakF3ZUZacVdsTmlSWEJ6Vm0xNFMxZHNiRlpYYlVab1ZqQndTRmt3V210WFJsbDZWVzFvVm1WcmNGQlZha1poWkZaS2MxUnRhRTVOVlhCaFZtMHdlRTVIVVhkTlZXUnFVbFp3V1Zsc2FGTlhWbFp4VVd4d1RtSkdXakJVYkdoclZqQXhSVkp1YUZkaVdHaEVWbXBCZUZOR1ZuSmxSbVJwVjBkb2VWZFljRXRTTVVsNFYyNU9ZVkl5ZUZSWmJYUkdaVlphZEdSSGRFNVNiWGhZVmpGb2MxWnRSWGhqUmtKWFlsaG9NMVpXV21Ga1IxWkpXa1pXVGxZemFGZFdWekF4WVRGUmVWTnJaR3BUUjJoWFZGWmFTMU5HV25OV1dHaFhUV3MxUmxWWGVHRlViVXB6VTI1c1YyRnJTbkpWYWtwUFkyczFWMXBIYUZOaVZrcDJWa1phWVdReVNYaGFSbVJYWWxWYWNWUlZVbGRsYkZWNVRsWk9WazFyY0ZwV1YzaFRWMnhhUms1VlVsVmlXR2hvV1RKNGQxSldWblJoUlRWb1RWaENXbFpzVWt0T1IwMTRWbTVTVTFkSGVITlZiVEZ2V1Zac2NsZHJkRk5TYkVwNVZqSjRUMVl5U2tsUmEyUlhUV3BGTUZaVVNrdFRWa1paWVVaa2FWSXhSWGRXYkZKTFVqRktjazFXWkdsU2EzQndWV3BPYjFkc1duUk5TR2hXWVhwR1NGa3dWbGRWTWtwWlZXeFNWVlpzY0doYVYzaHpWbXhhVlZac1pFNWhNV3Q1Vm0weE5HSXhXWGhYYWxwVFZrVkthRlZyVm1GVlJsWnhVbTEwV0ZZd2NFbGFSVnBQVlRGYVdWRnNjRmRoTVhCeVZGVmtVbVZHVW5OYVJtaHBVakpvVVZacVFsWk5WbVJIVld4a1YySnJOVkJaYTJRMFZqRmtjbGw2VmxkTlJFWjVWakkxYzFkck1VZFhWRUpYWWxSR1NGa3lNVTlTTVVaelYyczFWMDFWY0VwV2JHUjNVekZKZUZOWWJGTmhNbEpYV1d0Vk1WZEdXWGRXYTNSVlVteHdNRlJXVWxOaFJURnpVbXBTVmsxWGFIWlpWbHBMWkVkR1IxZHNaRTVTTVVveVZtMHhOR015VWtoV2EyaFRZa2RTV0Zsc2FHOU9WbGw1WkVkR1ZVMXJXbnBWTWpWUFYwZEtkVkZ0UmxkaVJuQm9WbFZhYzJOc2NFWmtSbEpUWWtad05sZFhkR0ZXTVZsNVUydGFhbEpzV2xoWmJHaFRWakZ3Vmxkc2NHeFNiRW94Vm0weGQxVXlTbGRUYkVKWVZucENORmxxU2xkV01XUjFVbXhLYVZkR1NsWldSbHBXVFZaT1IxZHVVazlXVkd4WlZXcENkMU5HV1hsbFJ6bFlZbFZXTkZrd1VrdFpWbGw2WVVkb1YwMUhVbEJWYlhoM1UwZFNSazVXWkdsaE1HdDVWbTB4ZDFOck1WZFdXR2hYVjBkNFZWbFVTbE5qVmxaelZXNU9XbFpzY0hsV2JURkhWMnhhZFZGc2JHRldWMUYzVm1wR1lXTnNaSEZSYkZwcFYwZG9XVlpyWkRSWlYxSklWV3BhVTJKSFVsaFZiR00xVFRGa1YxVnJkRk5OYXpFMFZrYzFWMVp0U2xoaFJsSlZWbnBHZGxZeFdtdFdNWEJKWTBVMVYwMVZjRFpXYWtadllURmtTRk5zV2xoaWExcFlXV3hvVTAweFVsWlhiR1JyVWxSR1dsZHJaRzlXTWtZMlZtdG9WMVpGYjNkWmVrWmFaVVprY2xkdGJGTlNhM0JvVjJ4a01GbFdXWGhqUmxwWVlsaFNjbFp0ZUdGTlJuQkdWMnM1VmsxclZqWlZWM2gzVmpKRmVHTklSbFZXYlZKTFdsVmFkMUpzY0VkaFIyeG9UVmhDVjFZeFpEQldNbEY1VkZob1YySnNTbk5WTUdSVFZERmFkR1ZJWkZSV2JrSlhWMWh3VjJGR1NuTmpTR3hhVFVaS1NGWnRlRnBsYlVaRlZHeGtUbEp1UW05WFdIQkhWREpPZEZKclpHaFNiVkp3VlRCV1MyUnNXWGhoU0dSVFRWZDRXVlpYZUd0V2JVcHlUbGM1Vm1GcmJ6QldNRnBoWkVVMVZsUnNaRTVXYmtJMlZqRlNUMkl4VVhoVGJsSnNVbTFvV1ZsVVJuZGpiR3hZWlVWMGFrMXJOVWhaVlZwM1lWWkplV0ZHVmxkaGEwcG9WbFJHYTFOR1ZuSmFSM0JUVmtaYWQxWlhNVFJrYlZGNFdraEtWMkpVYkc5VVZscHpUVEZTVjFkdFJtaFdhM0JJV1RCa1IxWXlTa2RqUkU1aFVqTm9hRmt4V2t0amJVNUlaVWRzVjFadVFrbFdNbmhYV1ZkRmVWSnJhRk5YU0VKVFdXdFdZVmRHV25WalJWcE9VbXh3ZUZVeWN6RmlSa2wzVGxWa1dHRXlVa2hXVkVGNFpGZEdSMkpHWkZOaVZUUXdWMVpqZUZZeFdYaGFTRlpXWWxoU1ZGUlVSa3RWUmxwWVRVaG9UMUp0VWtoV2JHaHZZVVpPUms1V2FGZGlWRVpVVlRGYWMxWnNaSE5hUm1ocFZsaENZVlpyV205aU1WbDNUVlprYWxOSVFtRlVWelZ2WVVaYWMxZHJkR3RTTURWSVZrY3hjMVV5U2toa2VrcFhZbFJDTTFwVlZYaFNhekZXV2tab2FWSnVRbEJXYlRCNFZUSk9WMVp1VWs1V1JrcGhWbTE0UzFZeFdYbE5WV1JYVm10d2Vsa3dWbk5aVmxwWVZXdG9XbFo2Umt4VmFrcFBVMWRHUjFwR1pFNU5iV2cxVmpGYVlWbFhSWGhVYTJoVFlUSjRjRlZ0TVZOalJsbDNWbXQwVlZac2NGcFpNRlpyVmtkS1YxZHNhRmRXZWxaTVdWWmFTMk5yTlZsUmJGcHBWMGRuZWxacVJtRmhNV1JJVld0b1UySllVazlaVkVvelRVWmFjVk5VUmxaTmExcDZWVEo0YjFadFNraGhSbHBYWVdzMWRsWkZXbFpsUm1SMFVteG9VMDFWY0VwV1Z6QjRZakZTYzFkc2JGSmhiSEJaVm10V1MxWXhVbk5YYkhCc1ZtczFlbGxyWkc5Vk1ERkhZMFprVjJKWVFsQlpha3BQWXpGa2RWSnNUbWxXVm5CNFZrWmFiMUV4VGtkWGJsSnFaV3RhV0ZSWGRIZGxWbFY0Vld0MFYwMXJjRnBWVjNRd1ZsWmFjMk5HVG1GV1ZuQXpWVzB4UjFJeFVuTmhSazVPVFcxbmVWWnRlR3BrTWxaSFZsaG9hVkp0VWxsWmJYUjNWMFpzYzFadFJscFdiSEF3V2xWV01GWXdNVmRpUkZaaFZsZFJkMWxWVlhoV2JVcEZWV3hrVG1Kc1NubFdNVnBoVXpGa1IxWnVSbFZpU0VKWVdXdG9RMVJXV25SbFIwWmFWakExV0ZkcmFFOVpWa3AwVld4U1YySnVRblpVVkVaYVpVWmtjMVJzVGs1V01VbDNWbTB4TUdFeGJGZFVhMXBxVW0xNFlWbFVTbE5rYkZsM1YyeGthazFyV2tkV1IzaHZWakpLVjFOc2NGaGhNVnB5VldwS1JtUXdNVmxUYkdob1RXMW9XVlpHWkhkV01VNUhWMnhXVkdFeGNITlphMVpoVFZaYVNHVkhSbWhXYlZKSFZGWlNVMVl4U25OalIyaFlWbXh3Y2xVd1dtRmpiSEJIVm0xc1YwMXRhRlpXYlRFd1ZqRnNWMkpHWkZoaVIxSm9WV3RhUzJJeFVsZFhiazVQVm14YU1GUnNWakJXTVVsM1kwVnNWMVl6YUdoV2FrcExWMWRHUlZSc1pHaGhNVzk2Vm0weE5HRXlVa2hWYTJoclVtMVNjRlZzYUVKTmJGcHhVMnBDYUUxck1UUldNV2h2VjBkS2MxZHNUbHBoTVhCb1ZqQmFjMVpXU25WYVIyaFRZbFpLV1ZacVNURlVNV1JIVTI1T2FsSkZXbGhWYWs1dlpHeHNWMWRyY0d4V01GcElWVzE0YTJGSFJYZGpTR3hYWWtaS1NGZFdaRTVsUmxwMVZHeG9hVkp1UW5aV1JtUTBVekZrYzFkc2FFNVdSa3BZVkZWU1YxZEdhM2RYYlVaYVZtdHdSMVV5ZUc5V1ZsbDZWV3BPVjJGcldubGFSRVpyWkZad1IxcEZOVmRpV0dONVZtMTRZVlV4UlhoWFdHeFRZbXR3Y1ZWc1pGTmhSbHB6V2taT1ZsSnNXbmhWYlRWclZrWktjbU5JY0ZoaE1sRXdXVlZWZUZkV1JuSmtSbVJwVjBkb2VGZHNWbFpOVmtsNFYyeHNhVkpzV2xsVmFrcHZZakZhVlZGc1drNVdNRnBJVm0wMVIxWkhSbk5UYkdoV1lsUkZNRlJWV25kU2JGcHhVV3hrVTFaRldsbFhWRUpUVVRGYVYxZHVUbFJpUmtwWVdWZDBSMDVHV25GVGEzUlRWbXhLZWxadE1YTlZNa3BKVVdwV1YySlVSWGRYVm1SR1pVWlNjbUZHVG1oTmJFcDNWbGN3TVZFeVRrZFhXR1JZWVROQ2MxbHJXbmROUm5CV1drVmthR0Y2Um5sVWJHaDNWakF4Y1Zac2FGaFdiSEJNV2tWa1IxSXhWbk5qUjJoT1lsZG9SbFpyWkRCWlZteFhWMWhvWVZORk5WWlphMVV4VkRGYWRHUkdjRTVXYkhCV1ZUSndRMkZGTVhKWGJuQldUV3BXVkZsVldrdGtSMFpIVjJ4a2FXSnJTbGxYYTJRMFkyMVdXRlpyYUZOaVIxSllXVlJHZDFsV1pGZFdiVVpvVFd0YVdGVXhhRzlXUm1SSVlVWnNWMkV4V2t4WlZWcHpWbFpLYzJOSGRFNVNSVnBMVjFkMGEySXhWWGxUYTJScVVtNUNXRmxzYUVOVlJscFZVMnRrVTAxV2NIaFdNbmhUWVVkV2RHVklhRmRTYkhCb1ZYcEJlRll4WkhKaFIzaFRZbFpLZGxadE1UQmpNRFZIVmxoc1QxWXpVbGhVVmxwMlRXeFdjMVZyVGxwV2EzQkhXVEJXTUZsV1dsZGpTRXBhWld0d1NGVXdaRmRTTVZKeVRsWk9hV0V3Y0dGV2JURXdXVlpzVjFkWWJGWlhSM2hZV1cxek1WZFdXWGRhUkZKV1VteHdlbGxWV2s5WGJGcHpZMFJDWVZKWGFISlphMXBoWkVkU1JWUnNjRmRXYkhCUlZtMXdTMU14V25SVWExcG9VbTVDVDFWdGRIZFZWbHAwWTBWS2JGSnJiRFZXUjNSdllVWktjMk5IT1ZwV1JWb3pXV3BHYTJOc1duTlhhemxYWWtkM01GWnFTVEZUTVZGNFYyNVNWbUpyU21GV2ExWkxUVEZaZVdWSFJtdFNNVXBKVlcxNGQxWXlTa2hrZWtKWVZqTlNhRmxVUm5OV01VNXpZVWRvVTJKRmNGbFdSbFpyVlRGYVIxZHNXbGhpVlZweVZXeFNSMWRHV2tobFJ6bFdUV3R3UjFrd1dtOVdNREYxVlcxb1ZtVnJjRXhWTUZwUFkyeHdSMVZ0YkZOTlZYQmFWbXRhYWsxWFNYbFViazVZVjBkU1dWbFVUa05qTVZaMFRWWk9iRlp0VW5sV01qQTFZVVpLVlZKc2NGWldlbFo2VmpCYVlXTXlUa2hoUmxwc1lURndlVlp0Y0VkVE1rMTVVMnRvVTJKRk5YQldha3B2VjJ4WmVGcEVRbHBXTVVZMFYydFdhMWxXVGtaT1ZtaGFZa1phYUZZd1duTmpNV1J5V2tVMVRsWnJjRmxXYWtsNFRVWmtjMWR1U21sU1JuQlhWbXBPYjFaR1duRlRhM1JZVm14YWVGWkhlR3RVYkZwMVVXMDVXR0V4V2xkYVZWcGhWakZhZFZWdGRGTldSbHBaVmtaYVYyUXhUbk5YYmxKcVVsaENUMVp0ZUZkT1JscFlUbFU1V0ZJd2NFaFdNbmh2VjIxS1dWUllhRmRoYTFwNldYcEtSMUl4VW5KT1ZUVllVbFZ3WVZZeWVGZFpWMUY1VTJ0a1dGZEhhRmxaVkVwVFZteFNWMXBHVG10aVJuQldWVzB4UjFVeVNraFZibXhoVWxad2NsWnFTa3RXTVVwWldrWmthVmRGU2tsV2FrbDRWakZaZUZWdVZsUmlWVnBVV1d0V2QyUXhXbGhsUm1SclRXdGFTRmRyV210WlZrcEdVMjFHVjJKWVVucFVhMXB5WkRGa2RGSnNhRk5OU0VKWVZtcEpNVkl4V2xkWGJsSm9VbFpLVjFSVlduZGpiR3Q1WlVoa1ZGSlViRmhXYlRGelZqRmtSbE5yYkZkTlZrcEVWMVphYzFZeFpGbGlSbEpvVFcxb1dGWnRkRmRUTVd4WFlrWm9hMU5IVWxWVVZtaERWakZaZVdONlZsaFNiR3d6VmpKMGIxZEhSWGxWYm5CYVZteHdURll4V2tkalZscHpXa2RzVTAxVlZqTldNV1IzVWpGYWRGWnJaR0ZTYlhodlZXcEtORlpXVm5OaFJVNVlZa2RTV1ZSVmFHOVdhekZZVld0b1YxWXphSEpXTUdSR1pXeFdjMkpHV21sV1JWVjNWbTF3UjJNeFduTmpSVlpTWWtkU1QxVnJWbUZPVm1SVlVXeGthVTFYVW5sVVZsWnZZVVpLUms1V2FGcFdNMUpJVkd0YWQxSXhaSE5hUjNSWFlsWktObFl5ZEd0ak1WbDRVMnhrYWxKVVZsaFpiR2hEVTBaa1YxZHNjR3hTYmtKSVdWVmFWMkZGTVhSaFJsWllWak5TVjFSV1dtRlNNV1IxVldzNVYxWlVWbGxYVjNSaFpEQXhSMVZzWkZaaVJUVlpXV3RhYzA1R1ZuUmpSazVYWVhwR1dWbFZhR0ZXTVZwR1kwVjRXazFxUmxCVmFrWkhZekZ3U0dKR2FGTldSVlYzVm0wd2VFMUdiRmRpUm1oV1lURndVRlp0ZUhkV2JHeHlWbFJHYWxKc1dqQlViRlpMWVRBeFdGVnVjRmRpVkVWM1ZsUkJlRmRHVm5WalJtUk9ZV3hhVVZkV1dtRlRNVWw0V2toT2FGSnNjSEJaYlhSTFYxWmFkR1JIUmxwV01ERTBWMnRvVTJFeFNuTlRiRkpWVmxad00xVXhXbUZqTVhCRlZXMTBUbUV4Y0VoV1JscGhZekZXYzFwRmJGSmlSMmhoV1d0a2IxWkdiRlpYYms1UFlrVndNRlZ0ZUd0VWJGcFpVVmhvVjJKVVFqUlZha1pXWlZaT2MxcEdVbWxpVmtwWlZtMTBWMU14WkVkV2FscFRZbGhTV0ZSV2FFTlRSbVJ5VjIxMGFGWnRVa2RWTW5oSFZqSktWVkpVUW1GU1JYQllWbXBHVjJNeGNFZGhSMnhZVW10d1lWWnNaSGRSTWxGNFZHeGthVkpzY0ZsWmJGSnpWMVpzYzFadVpGUldiWGhYVmpKNFQxZEhSalpTYWtaYVZsZFNkbFpxU2t0U01rNUdaVVp3VG1GcldsVldWM0JMVWpGSmVHTkZXazlXYXpWd1dWUkNkMU14V25STldHUlVUVVJHU0ZscldtdGhWa3AwWVVaU1dtRXlVbFJaVlZwWFl6RndSMVJzWkZkaVdHaGhWMVJDVjJFeFpFZFRibEpzVTBkNFdWbFVSbmRVUmxwSVpVVjBhMUpzV25wWlZWcHJWRzFHY2xkcmJGZGlXRUpEV2xWYVlXUkdVbkpXYkU1cFVqRktkMVp0ZEZkWGJWWnpWMjVPVm1FelVsVlVWbHB6VGtaYVNFNVdaRmhTTUhCSldWVmFiMWR0UlhoWGFrNVdZa1p3Y2xreWVGZGpiSEJIVm1zMVYySllZM2RXYWtvd1lqRlJlR0pHWkZSWFIxSlpXV3RhUzFZeGJITmhSazVPVFZad2VGVnRNVWRWTURGWFkwaHdWMUl6YUhKV1IzaGFaVVpPYzJKR1pHaGhNblEwVm14U1MxSnRWa2RVYkd4aFVtMW9jRlZxU205WFJtUlhXa1JDVkUxRVFqUldiVFZIVlRKS2NtTklTbFZXYlZKVVZGVmFVbVZHWkhSa1JsWnBWbFpaTWxaV1pEQmpNV1JIVjJ0YVZHSkdTbGhWYTFaaFlVWndSbGRyT1dwTmEzQkpXVlZhVDFSdFNsaGhSbXhYVFZkUk1GbHFTa3BsVmtweVdrZHNVMUp1UWxWWFZ6QjRWVEZhVjFadVJsSmlWVnBVVkZaYVMyVnNXWGxOVkVKWFRVUkdlVmt3YUhOV2JVcElZVWh3VjJGcmNFeFdNV1JIVTFaS2RGSnNaRmRpUmxrd1ZteGtkMU14VFhoVFdHaHFVbGRTYjFWdE1XOVdSbEpZVFZjNWEySkdjSHBYYTFKVFYyeFplRkpxVWxkaVdGSnlWakJrUzJNeFRuVlNiVVpYVFRGS2IxWnFSbUZXTWxKR1RWWldWbUpZYUZoWmEyUXpUVlphUjFkc1pHaE5hMXBJVlRJMVMyRnNUa2xSYkdoVlZqTkNXRlJVUm1GalZrWlpZVWR3VjJKSVFYaFdWRW8wWVRKR1NGSlljRkpoZWtaWVZtcE9RMVJHV2tWU2F6bFlVbXMxZVZkclpIZFZNVnBIVjJ4V1dGWXpVbWhXYWtFeFVqRmtkVlZ0ZEZOTk1VcFJWbGN3ZUU1R1pGZFhiR2hyVW5wc1dGbHJaRk5UYkZaWVRsVmtWMkpWY0ZaVmJYaFRWakF4UjJORVRsZE5SMUpVVldwR2QxSnJOVlpPVm1ScFlUQndiMVpxUmxOUk1WbDVVbGhvWVZORk5WbFpiWGhMVmpGc1ZWTnRPVmhTYkVwWldUQmFhMVpzU25SbFJtaFhUVzVTTTFscldscGtNV1J5WVVaa1YwMHlhSGxYVmxwaFV6Sk9kRlJyWkdsU2JWSnZXVlJDZDJJeFdYaFhiWFJXVFZWd2VWUldXbXRXTWtwSFkwaENWazFHV2t4V01WcHJWakpHU1ZwR1pFNVdWRlpaVmpKMFlXSXlSWGhUYWxwcFVtMVNWbFpxVGxOTk1WVjNWMnhhYkZZeFdrbFVNVnByWVZaYVdWRnFWbGRoYTI4d1dWUkdhMk14WkZsalJscHBWakpvYUZadGVHRmtNV1JIWVROb1dHRXpVbkZVVm1SVFRVWndWbGR0ZEZWaVJuQXhWVmQwYzFZd01YVlZiR2hZVm0xU1IxcFZXbGRrVmxKellVZHNhVkp1UWxWV01XUXdZVEExUjFwR1pGaGlhM0JZV1ZST1UxZFdWblJOVms1WVVteHNOVnBWYUd0aFZrcHlZMGhzVldKSGFETldNR1JHWlVkT1NWZHNjRmRpU0VKTVYyeGFhMUl4U1hsU2EyUm9VbTFTY0ZadGRGcGxiRnB4VW0xR1dsWnNSalJWTVdoelZrZEZlRmRzYkZwaE1WVjRXV3BHVTFaV1NuSmtSM2hUWWtoQmQxWkdWbTlpTVZweVRWaE9XR0p1UWxsWlZFcHZWRVprVjFkcmRFOWlWWEJJVmpKNGQyRkZNVmRpTTNCWFZrVkthRll5TVZkWFJscHlWMnhXYVZJeFNsQlhWbEpQVVRGT2MxZHVUbGhpUlRWVFZGWmFjMDVXVm5ST1ZYUllVakJ3TVZWWGVHOVhiRmw2Vlcxb1YxSldjR0ZhVlZwM1VteHdSMVJyTlZoU1ZYQkxWakZrTUZsV1VYaFZiazVZWWtkNFUxbHNWbUZYUm14WVpFZEdhbUpHU25sWGExWjNZa1pLY21OR2NGcGhNWEJZV1ZaYVNtVkdUbk5oUm1oWFRURktlVlpzVWtkaE1VbDVVMnRzVldKSFVuQldiRnAzVjJ4YVdFMVVVbFJOVjFKSVZqRm9jMVJzV2xoVmJGcGFZVEZhTTFSV1dsZFhSMUpJWkVab1UwMUdXVEJXYWtreFV6RlplVkp1U21wU1YyaFdXV3hvYjFSR2JEWlNibVJUVFdzMVIxUnNXazloVmtvMllYcEtWMkpVUWpSYVJFWktaVVpTV1dKR1ZsaFNNbWhYVjFjeGVrMVdWWGhpU0VwaFVtczFjVlZ0ZUdGbFJsWjBaRVJDV0ZKc2NEQldWM2hoVm1zeGRWRnNVbHBXVmxZMFdUSnplRlpXVm5OWGJXeFhVbXh3VWxadGNFTmhNVTE0Vkd0a1YySnJjRkZXYlhoaFYwWndXR1JIUms1aVJuQldWVEp3VTFkc1dYaFRhMlJWVm14YWVsbFZXa3BsYlVaSVQxZEdWMDB5YUc5V2FrWmhXVmRPYzJORlZsWmlWMmhQVm0wMVFtUXhXbFZUVkVaVVRWWkdORll5TlU5WFIwcFdWMjFHVjJFeFdqTldhMXBoWTJ4a2MyTkhkRTVXTVVsM1ZsY3dlRTFHVlhoWGEyUllZa2RvV0ZsVVNsSk5SbHBGVW14d2JGWnJOWGxaYTFwTFYwWkplRk5zY0ZoV2JFcElWMVprVDFZeFZuVlViVVpUVmpGS2VGZFdhSGRTTVZsNFYyNVNiRkl6VW05VmJGSkhUVVpzVmxkdVRsaFNiR3cyV1ZWYVUxWXlSbkpYYkdoV1lXdGFjbGw2Um1Gak1WWjBZVVUxVGxaWVFsZFdiWFJoWVRKV2NrMVdaRlZoTWxKWldXdGtiMk14VlhkYVJrNVlVbXhLV0ZadE5XdFhSa3AwWkVST1YySkhhSFpXYWtGNFkyeGFjVlpzWkZkaVJYQkZWbTF3UzFJeVRuUlVhMXBRVmpCYVdGWnROVU5sVm1SeVYyMUdWMDFyTVRSV1Z6VlRZVlpLY2s1V2JGWmlSbG96VmxkNFlXUkZNVWxhUjNoVFZrWmFTbFpzV205aU1XeFhVMjVTVm1KSGVHRlpiR2h2VkVaYVJWSnNXbXROV0VKSlZERmtkMkZXU25KalJuQllZVEZhY2xWcVNrdFNNV1IxVkd4U2FWSXlhRmxXUm1SM1VXc3hWMkpHV2xkWFIyaFlXV3hWTVZJeFpISlhiR1JvVm10d01WVlhOWE5XTWtaeVlrUlNWbVZyV2xCVk1GcExZMnh3UjFkdGJGTk5WWEJXVm0wd2QwMVdSWGxUV0doaFVteGFWRmxzVm1GV2JGSllZek5vVDFKdGRETldiVEV3WVVaS2NtTkVRbGRXTTAweFZtMHhTMVpXV25KVmJGcE9WbTVDYjFkclZtdFZNVTVJVld0YVVGWnJOWEJXTUdSdlYyeGFkR05GWkdsTmF6RTBWakowYjFVeFpFaGxSbVJhWWxoU2FGWnFSbk5qYkhCSFUyczFVMkpIZDNwV2Fra3hWREpHZEZOcmFGWmhhMHBYV1d4b2IyUnNXbFZUYTNSVFlsVTFSbFp0ZUd0aFIwVjVUMVJPV0dFeFNreFZla1pLWlVaU2RWWnNWbWxTTW1oMlYxWlNSMlF4WkVkWGEyUmFaV3RhY0ZSV1duZFRSbXh5VjIxMFdGSXdWalpXVjNoelZqSktXVlZ0YUdGV00yaDZXVEo0YTJSSFVraGhSbVJwVTBWS1NWWnRNVFJpTWtWNFYxaGtUbFp0VW5GVmJURlRWbXhhZEUxV1RsVk5XRUpYVmpJMWExWkdXbk5UYWtKV1lsaG9VRmxXV2xwbFYwWkZWR3hrYVZJeFNYcFdWM0JIVkcxV1IxcElUbUZTYldodlZGZDRTMWRzWkZoa1IzUldUV3MxZWxaWGVHdFdNVnBHVjJ4c1ZtSllhSHBVYkZwM1VteHNObFp0YUZOV1JWcFlWMWQwVTFReFdYZE5XRlpvVTBad1dGbFhkSGRVUmxsNFdrVmtVMVpzU25wV01uTXhWakpLY2xOdVdsZGlXRUpFV1ZSR1dtVkdVbkpYYkVKWFlsWktiMVpYTUhoVk1rNUhWbGhrVjJFelVsbFphMXAzVFVacmQxWnVaR2xTYTJ3eldXdFNVMVl3TVhGV2JFSlhUVWRTUjFwVlpFOVNNa3BIWTBkc1UwMVZiM2xXYlRGM1VqRlZlRmRZYUdwU1YxSldXV3RhWVZaR2JISlhibVJQWWtad2VGVXljRk5oUlRGeVYyNXNWVlpzY0doV1JFWmhVbXhPZEZKc2NGZFNWbTk2Vm14V1lWbFhUbGRVYmtwclVqTkNjRlZzVWxkT2JHUlZVVzFHYUUxcldsaFhhMVp2WVVaT1NHRkdiRnBoTVhCb1ZtcEdVMVl4WkhKalIzaFRZWHBXTmxkWGRHdGlNVlY1VTJ0c1VtSnRVbGhXYWs1RFUwWldObEp0Um1wTldFSklXVlZWTVZZeFNsWmpTR3hYVW14d2NsWlVSbXRTTWtwSlUyeG9hVkl4U2xoWFYzUmhaREZKZUZkWWJHeFNlbXhZVm0xNGQyVnNhM2RWYXpsWFZteHdXRmt3VWs5V01rcFpZVVJPVm1KWWFETlZha1ozVWpGd1IxcEdUbGRpYTBwdlZtMXdTMDFIU1hsVldHaFZWMGRvV1ZsdGVFdFdWbXh5V2tSU1YwMVhlREJhUldoclYwWktkR1ZHYkdGU1YyaHlWbXhhUzJNeFpIRlJiRlpYWWtaVmVGWnRkR0ZYYlZGNVZHdGFhRkp0VWs5WmJYTjRUa1prVjFkdGRGUk5WMUpKVlcxMGExZEhTa2hWYmtKWFlURmFTMVJWV210ak1XdDZZVVphYVZac2NGbFdha2t4VkRKR1IxTnVTazlXZW14V1ZtcE9iMVJHV25SbFIzUllVakZLU1ZwRldtRlViRmw0VTJ0c1dGWXpVblpWZWtwSFVqRk9jMWRyT1ZkaVdHaFpWMWQ0YjJJd01IaFhXR2hZWW10d2NsUldXbmROUm5CR1YyMTBWMDFXY0VkV01uaHZWMFphUmxOc1VsWldSVnBoV2xaYVQyTXlTa2RYYld4WFRXMW9XbFpyV2xkaE1WVjRWV3RrVjJKc1NuRmFWM1JoVjFaV2MxVnVUbGhTYkhBd1dsVmtNRll3TVVWU2FrSmFWbFphYUZacVNrdFdWa3BaV2tab1YySklRalpXYWtKaFZqSk9kRkpyWkdGU01taFBXV3hrYjA1V1duTmFSRkpXVFZac05GWXlkR3RXYlVwSVZXeHNXbUpVUmxSV1ZWcHpZMnhrZFZwSGVGTmlSbGt4VjFSQ1YxUXhXWGROVlZaVFlrZG9XRlJYTlVOU1JscDBUVlYwVkZJd1drcFpNRnByWVZaYVJsZHJNVmRXZWtZMlZGWmFhMUl4VG5WVWJYQlRZbFpLVlZadE1ERlJNbEp6VjI1S1dHSllVbEJWYlhoWFRrWlplR0ZIT1ZwV2F6VklWakl4YjFadFNsVlNiRkphVFVad1dGcEZWVEZXYkZKeVQxWmthVlpyYnpGV2JUQjNaVVpKZUZwSVRsaFhSMUpaV1d0a2IxWXhVbGhqUm1SWVVteHdXVlJXVmpCV1JrbDNWMnRvV2xaV2NETldha0YzWlVaT1dXSkdaRk5pUm5CdlZtMXdTMVF4V1hoVWJsWldZa1UxY0ZWcVJrdFZSbHAwWlVaT1YwMUVWbnBXTVdoellURkplbFZ1U2xWV2JIQllWR3RhV21WSFJrbFViV2hUWVROQmQxZFdWbUZpTVdSMFUydG9hRkpXU2xoV2JGcDNaV3hyZUZkcmRHcGhlbXhZVmtkek1WWXdNVlppUkZKWFlsaG9jVnBWVlRGU01WcFpZa1pPYUdKSVFsbFhWM1J2VVRGa1IySklUbFpoTVhCUFZXMTRXazFzVlhsbFIzUm9ZWHBHV0Zrd1duZFhiVVY1VlZSQ1YxWkZSak5hVlZwUFl6SktSMXBHVG1sVFJVcDJWakowVTFGdFZrZFhXR2hZWW1zMWIxVnFUbE5XUm14elYydDBXRlpzY0VoWGExSkRZVEF4Vms1VmFGZGlSMmg2V1d0YVMxWnJOVmRpUm5CcFVtNUNiMWRzV21GV01rMTVVbXRvVUZadFVuQldiRnAzVGxaYWNWTllhR2xOVjNoWVZUSTFUMkZzU25OVGJVWmhWak5TYUZaclduZFNiSEJHWkVaT1RsWnJjRFZXUjNocll6RlpkMDFZVW1oVFJuQllXV3hTUjAweFZuRlRhMlJyVW14d2VWWXljelZXTVZsNFUyNWtWMVo2UWpSV1ZFWnJVakZrV1ZwSFJsTmxiWGg0VmxjeE5GbFZNVWRWYkdSWVlYcHNiMVpzVWtkWFJsbDVZMFZrV0dGNlJrbFpWVnBEVmpKS1dWUnFVbGRoYTFwUVdYcEtSMUl4Y0VaT1YyaG9UVmhDUzFadE1YZFJNV3hYVkZoc1ZtRXlVbGhaYlhoaFkwWldkRTFXVG1wU2JGb3dXa1ZvYTFkR1duTmpSRUphVFVaYWNsWXllR0ZqTWs1SFlVWmFUbUZzV2sxWFZtUTBVekpTVjFKdVRtaFNiVkp3VmpCa2JtVnNaSE5YYlVaYVZqRktSMVJXVm5OaFJrcHpVMnM1VjJGcldreFdNVnBoWkVVeFJWSnNVazVoTTBKSlZsUkpNVlV4V25SVGEyaG9VakpvV0ZsWGN6RldSbXhXVjJ4d2JGSnRVakJhUlZwdlZqQXhSVlpyYUZkTmJsSm9WbXBHVTJSR1NuRlhiR1JvWWtoQ1dWZFhlRk5SYlZaSFYydFdVMkpJUW5OV2JYTXhaVlpaZVdONlZsZE5hM0JaV1ZWa2IxZEdXbk5UYTNoYVlXdGFURlZxUm1GWFYwcElaVVpPVGxKdVFqUldhMXBoWVRGVmQwMVZaR3BTVm5CWVZtdGFZVll4VWxoa1JtUlBWbTVDU2xrd1ZrOVdNREZ5VjI1c1dsWkZOWFpXYWtaaFVteGtjMXBIUmxkV2JrRjZWbGN3ZUZNeFNYaFVibEpwVW1zMWNGbFVRbmRrYkZweFVtMUdWazFWYkRSWmExcGhWR3hPU0dGR2JGZE5SMUpVVmpGYWMyTXhXblJTYlhCWFlrVndXVll5ZEdGVU1WSnpWMjVTVm1KdGVGaFVWelZPVFZaYWRHTXphR3BpVlRWSFdUQmFZVll3TUhsaFJGcFhZV3RLYUZkV1pFNWxSbkJKVm14b2FWSXhTbFZXVjNoaFpERmFSMXBJVGxkaVZWcFdWRmQ0UzFkR1draE9WVGxvVW10c05WcFZhRU5YYkZwR1UycE9WMDFXY0dGYVZWcDNVbFpXZEdKRk5XaE5ibU40Vm14amVFMUhSWGhhUldoVVltdHdVRlpxU205V01XeHlXa2M1VjFKdGREUldNbmhQVmpBeFdWRnJhRmRTZWtVd1dWWmFTMlJXUm5OalJtaHBVbXh3ZVZaWGNFZFhiVkYzVFZaa1dHSllRbFJaYTJoRFYxWmtXR1ZIT1ZKTlZrcElWakkxUjFVeVNsWlhia1pWVm14VmVGcFdXbk5XYkdSMFpFZG9VMDFHV1RCWFZFSnJZakZrU0ZOclpGaGlWMmhoVm10V2QxWkdXbkZTYkU1clZteGFlbFpITVhOVk1WcEhWMnBLVjAxdWFISlVhMXB6VmpGa2RWUnNhR2xpUlhCNFZsZDRWazFYU1hoVmJHaHJVMFUxVUZWdGVIZFRWbkJHV2tSQ1dGSnJiRE5aTUZaelYyeGFWMVpVUmxkaGEzQkhXbFZhYTJOdFZrZGFSMnhUWW10S1ZsWnRNWGRTTWtWNVZXdGtWR0pzU25OVmFrbzBWa1pzYzJGSGNHeFNiR3cxV2xWYWEyRkZNVlppUkZKWFRXNW9kbFpyWkVabFYwWkhXa1p3VjFKVVZrVldiWEJIV1ZkT1YxVnVVbEJXTTBKd1ZXMDFRMDVHV2xWVGFrSk9VbTFTU0ZZeGFHdFhSMFY1WlVkR1YySkdjRE5aVlZwaFUwZFdSbVJIZEZkaE1YQTJWMWQwWVdJeFdYaFRiR2hRVTBkU1dWWnRlRXRVUmxwSVRWWmtVMDFXY0RGV2JYaFhZVlpLYzJOSVpGZFdNMmhVVm1wR1YxSXhaSFZWYXpWVFVsWndWRlpHV2xaTlZtUkhWMWhzVDFaVWJGaFpiRlpYVG14YVdHVkZUbGRpVlhCYVZrZHdVMVpYUlhoalIwWmhWbGRTU0ZVd1ZUVldNa1pIVkdzMVZGSlZjRXhXYlRFMFlXc3hWMU5ZYUZoaWJFcFZXVlJLVTJOV1ZuSldWRVpZVW14S1YxWXlOV3RYUmtwMFpIcEtWbUpVUlhkWlZFWkxZMjFPU1dOR2NGZFdia0pSVjFaYVlWTXlVbGRTYkZaU1lrZFNjRlZxUVRCTlJscEhWbTEwVTJKV1dsaFZNbmh6WVVaS2MxTnVRbHBXUlRWRVdsVmFZVlpXUm5Sa1JUbFRZbFpLU1Zac1pEUmlNVkY0VjJwYWFWSnRhRmRaYkZKR1RVWmFjVkp0Um1wTmExcEpWREZhYTFSdFJYcFJiR2hYVWpOb1dGbHFSbUZqYXpGWlZtMW9WRkp1UW1oV2JURTBaREZOZUdORlZsSlhSMmhZVm0xNFlXVnNaSEphUnpsVllsVndSMWxVVG5OV01ERjFWV3hTVm1WcldtRmFWVnBQVjFkR1IyRkhiR2xTYmtKV1ZqRmtNR0V5U1hsVWEyUlhZbXMxYjFWc1ZURmpiR3h5VjI1a1ZGSnRVbmxXVjNoUFZqRktWVkpzYUZwTlJscDJWakJrUm1WSFRrbFhiSEJvVFZoQ1RWZHJWbUZXTWsxNVVtdGtWMkpIVWxoWlZFNURVbXhhY2xwRVFscFdiWGhaVmtab2MxVXlSWGxsUmxwYVlrZFNkbFpFUm1Gak1YQkZWR3MxYVZKdVFqWldNblJUVlRGa2MxZHVUbWxTUmxwWFZGYzFiMlZzV25STlZXUnFZWHBXV1ZsVldtdGhWbVJJV2pOd1YySllVbWhaZWtFeFl6Rk9kVlZzVG1sWFJVcDJWMnhqZUU1R1pGZFhXR3hyVWpOU2NWUldXbGRPVmxWNVRsVjBWMUpzY0VkWk1GcHZWbFphYzJORmVGWmhNWEJvV2tWa1QwNXNTbk5hUlRWWVVsVndURlp0ZUd0T1IwVjVVbXhvVTFkSVFsTlphMmhEVjFaYWRHVkZkRlZTYlhoNFZXMHhNRlV3TVhKalJYQlhVbnBHZGxaVVNsZGtSMVpIV2taa1YyVnJTVEJXUmxaV1RWWlplVlJyWkZoaVIxSllWVzE0ZDJSc1pGZGhTR1JUVFZkU1NGbFVUbXRXYlVWM1RsZEdWMkpZYUROV01GcHlaREpHU0ZKc1pFNVdia0pJVmxjeGQxVXhiRmRUYkdoV1lUSm9WMWxYZEdGamJHdzJVbTVrVkZJd2NFaFpWVnBQVkcxS1dGb3piRmRpVkVZelZXcEdjMVl5U2tkYVIwWlVVbXR3V1ZkV1VrdFZNVnB6WWtoS1lWSkdTbkJVVmxwaFRVWndWbFpxUW1oV1ZFWllWVEo0YjFkc1dsZFhiRUphWVRKU1RGVnFTazlTTWtwSVVteGtWMDFWY0VwV01WcFRVVzFXUjFkWWJGVmhNWEJ2VlcwMVEySXhVbGRoUlU1WVZteHdlbGRVVG05V1JURnpVMnRvVjJKVVZsQlhWbHBMWXpGa2MyRkdjR2hOYldoRVYyeGtOR0V5VFhoalJWWldZbGhDVDFadE5VTk9iRnB4VTJwU1YwMVdiRFZWTW5odllrWktjMU5zV2xkaVIxSjJWV3RhVm1WR1pIUmtSbVJYWVRGd05sWXlkR0ZrTVZsNVUydHNVbUZzY0ZoWlYzUmhaR3h3UlZKdFJtdFNhelV4VlRJeGQxVXlTbGhoUm14WVZucEJlRlZVUms5U01XUnlWMnhvYVZJeFNubFdWM2hUVWpGWmVGVllhRmhoZW14V1dXdGFkMDFXVmxkaFIzUlhUVlp2TWxWc1VrTlhiRnBHVjIxR1lWWnNjRkJaTWpGTFVqRk9kR0ZIZUdsU2JrSmhWbXBHYTA1SFNYbFRXR3hWWW1zMVYxbHRkSGRYVm14MFkzcEdXRkpzU2xoWGExcFBWR3hhYzFacVZscE5NMEpZVm1wQmVGWXlUa2xqUm5CT1VtNUNWVlpxUW1GWGJWWnpWbTVTYUZJd1dsUlZiRnAzWlZaYVdHTkZaRmROYXpFMVZXMTBZVlZHV25SVmF6bFZWbFphTTFSc1dtRmpiR1IwVW14d1YwMVZXVEJXTW5SWFlURnNWMVJyV21wU2JWSmhXVlJHVm1WR1duRlNiRTVYWWtaYWVWZHJXbTlWTWtwWlZWaHdXRlpzV25aWlZFWmFaVlpLY1Zkc1RtbGlWMmhaVjFkNGIxVnJNVWRYYmtaU1YwZG9WVlZ0ZUdGbFZuQldWMjFHYUZadFVrbFpWVnBIVjBaYVJtTkVXbFZpUm5CaFdsVmFkMU5XVm5SaFJrNVhVbXh3V2xZeFkzaE5SazEzVFZoT1dHSnNTbk5WYWs1VFZERldkRTFVVWxoU2JYaDVWakl4TUZkR1NuUlZhMnhhVmxkU2RsWnRjM2hTTVZwWllVWndWMVp1UWxsWFZFWmhWVEpPYzFWdVVtcFNhelZ3VlRCV1NrMXNXblJsUjNST1VtMTRXRlpYTlU5V1IwcHlUbGhHVm1KVVJUQldiWGhoWkVkV1JtUkdaRk5pUjNjeFYyeFdhMUl5Um5KTlZtUnFVMGRvV0Zsc2FHOWhSbXhYVjJ0d2JGWXdXa3BaYTFwdlZqSktWMUpZWkZkWFNFSk1Wa2N4VjFJeVRrWmlSbFpwVmpKb1ZWZFhlR0ZUTWxKelYydGtXR0pWV2xoVVZWSlhVMFprY21GRmRGcFdhM0JJVlRJeFIxWXlTbGxoU0hCVllURndjbGt5TVVkU2F6bFhZMFprYUUwd1JqTldiWGhyWldzMVYxZFliRlJpUmxwWVdWUkdTMVpzYkhKWGJtUmFWbTVDV0ZkcldrOVdSa3B5WTBod1YwMXVUWGhXYWtwTFVqSkZlbHBHWkdoaE1qa3pWbTF3UzFOdFZsZFRia3BoVW14S2NGVnFTbTlrYkZwWVRVaG9hVTFYVWtoWmEyaFRWREZhVms1V1VsVldiV2hFVlcxNFYyUkhWa2hrUmxaT1lUTkNTRmRVUW05a01XUklVbGhzVm1Gck5WaFZhazV2V1Zad1ZsZHJPV3BXYlZKNldWVmFhMVJyTVZaalNGcFhZbFJHTTFWNlJrcGxSbkJHV2taV2FXSkdjRlpYVjNSaFV6Sk9SMVp1UmxWaVZHeFpWbTE0ZDAxR1VuTmhSM1JXVFd0Wk1sVnRkRzlYUjBWNFkwaEtWMDFIVWtoVWJURkxVakZXYzFac1pHbFRSVVkyVmpKNGEwNUhUWGhYYms1cVVsWmFWMWxyV25kVU1WcDBUVlJPVGxKc2NGWlZNbkJUVlRBeFYySkVWbFpOYm1oNlZsY3hSbVZYUmtkaVJtUnBWMGRuZWxaWWNFZGtNVnB6V2toU1UySkhhRmhVVldoRFUyeGtjMVp0UmxWTlYxSklWVEkxUzJGc1NuVlJiR2hhVmtWYU0xbFZXbXRXTVhCSFUyMTRVMkpyU2toV01uUnJZakZTY2sxWVRsUmlSM2haVm0weFVrMUdWalpTYlhSVFRWWmFlbGRyV210aFYwcFhVMnh3VjFaNlJUQlpla0V4VmpKT1IxZHNjR3hpUm5CWlZrWmtNR1F4V1hoWFdHeFBWMFUxV0ZSVlVrZE5WbHBZVGxkR1YwMUVSbmhWYlhodlYyc3hkV0ZJU2xwTmFrWllWV3BLVDFOSFZraGhSVFZZVWxWcmVGWnRjRWRpTWxGNFUxaG9hVkp0YUZaV01HUTBWa1pzVlZOc1RsZGlSM2g1VjJ0YVQxWXhTblJsU0d4YVZsWmFVRlpxUVhoV01rNUZVV3hXVjFZeWFIbFhWM1JoVXpGYVYxZHVTbWhTYlZKUFZtcEtiMDFzWkZkWGJVWlVUV3hLU0ZadE5VOVdNa3BJVldzNVZtRnJXa3hVVjNoclZsWktkRkpzWkU1aGVrVXdWakowYjFZeGJGZFRibEpvVW14S1lWbHJaRzlrYkZweFVtMUdhbUpJUWtaVlYzaFhWR3hhZFZGcVdsZFdSV3Q0VmtSR1lWTkdUbkpoUmxwcFVqSm9XVmRYTURGUk1VVjRWV3hrV0dKVldsUldiWFIzWlZad1JscElaRlZpVlZreVZtMTBiMWRHV1hwVmJrcFdZV3RhVjFwVldtdGtWbEowWWtaT1UxWkdXbHBXTVdRMFZURkZkMDVWWkZkaGJIQlVXVlJPUTJNeFduUmxSWFJzVm0xU2VWWXlNRFZoUmxweVRsVmtWazF1YUhwV2FrcExWMVpHY21WR2NHbFdSVnBaVjFod1IyRXlVbGRXYmtwUFZtMVNWRmxVVGtOaU1WcDBUVmhrVW1KV1drZFViRlpyV1ZaT1JtTkhPVlppUjJoVVdXcEdWMlJIVWtsYVIzaHBVak5SZWxacVNYZE9WbGw0VjI1T2FsSlhVbUZVVldSdllVWmFjVkp0Um1wTmF6VkpXVlZhWVZSc1NYaFRiR3hYVmtWS2NsWlVSa3BsUjA1R1YyczVWMkpXU2xwV1YzaFhZMjFXUjFkdVVtdFNNMUpRVlcweE5GZFdWbk5oUnpsWVVqQldOVmxWV2xkWGJGcEdZMGhhVjJGclducFpNbmgzVTBVNVYyRkdUbWxYUjJjeVZtMTRhMDVIUlhoV1dHaFVZbXMxV1ZsdE1XOVdNV3h6Vld0a1ZGSnRlRmxVVmxZd1ZUQXhjazVWY0ZwTlJuQjJXVlZWZUZkV1JuVmlSbVJvVFd4RmQxWXhXbUZoTVU1SFZtNUdXR0pGY0hCVmFrWkxWMVprYzFwRVFsTk5SRlpJVmpJMVMxWnRSWGxWYkdoYVlrWndhRll3V21GVFJUVldaRWRvVTJFeWR6RlhWbFpoVlRGa2RGSllhRmhoYXpWWVZGWmFkMkZHVm5GU2JVWnJVbXR3ZWxkclpITldNa3BKVVd0d1YyRnJiM2RYVm1SR1pVWndSbUZHVW1oTldFSlJWbTB3ZUdJeGJGZGlSbFpUWW0xU1QxUldXa3RXTVZsNVpVZDBhRTFWYkRSV01uUnJXVlpLVjJOR2FGcFdiSEJNV2taYVIyTldaSE5oUm1SVFZsaENOVlpzWkhkU01rVjRVMWhvWVZKdGVIRlZiWGgzWTBaV2RHUklaRmhXYkhBd1drVmFhMWRzV25SVmEyaGFUVVphYUZZd1pFZE9iVXBKVW14d2FFMXNTbFZYYkdRMFl6RmFjMk5GYkZWaVJuQlBWV3RXWVZkR1pGVlJiVVpxVFZac00xUldXbTlXYkZwR1UyMUdXbFl6VW1oV01GcHlaVmROZW1GR1pHbFRSVXBKVjFaV2EySXhVblJUYTFwcVVqQmFXRlJXV25kV1JscEZVbXhhYkZKdVFrZFhhMXB2WVZkRmVHTkdVbGhXZWtJMFZsUkdZVkl4Vm5OYVJtaHBZbFpLVmxadE1ERlJNVmw0V2toS1YySllVbGhVVlZKSFVteFdkRTVZVGxoaGVrWklWakkxWVZZd01YVlVhbEpXWVd0d1VGVXhXbXRqTVhCR1RsWk9hV0V3YnpGV2JYaFRVakZzVjFOWWJGVmliRXBVV1ZSS1UxZFdiSE5oUnpscFRWWktXRmxWVms5aE1rcEhZa1JTV2xaWGFISldWRUY0VmpGS2NWWnNaRmROTW1oNVZtMTRhMU15VG5KT1ZtUmhVbTVDY0ZWcVJrWmtNVnAwWkVkR1dsWXdOWHBYYTJoVFZUSktTR0ZHYUZwaE1taEVWR3hhWVdOV1RuRlZiRlpPVm01Q1NGWkdXbTlUTWtaWFUydGtWR0pIVWxaV2JuQlhWa1pyZVdWR2NHdE5XRUpIV2tWYVUxVXlTa2RqUkZwWVZqTlNhRnBFU2tkU2F6RlpWR3hTYVZKc2NGbFhWM2h2VlRKR1IxZHNWbE5pU0VKelZXMDFRMU5zV25STlZXUldUV3RaTWxadGVFTldNa1p5VTJ4b1ZtVnJXbkpWYWtaclpGWldjazVXVWxOTmJXaFJWbXhqZDJWR1ZYbFdiazVZVjBkNFVGWnNhRk5pTVd4eVZtNWtUbEpzY0ZsVVZsWnJWakZhYzJOR2FGcE5Sa3BRVm1wR1lWWXlUa2hoUm5CT1ZtNUNVVmRVU1hoVk1VbDRWVzVLVDFZeWFITlphMXAzVXpGYWNWSnRSbGROYTFZMFZURm9iMWRHWkVoVmF6bFdUVWRSTUZscVJsZGtSVEZWVld4b1UySllhRFpYVmxaWFZERmFSMU51VWxaaVIyaFpXVlJHVmsxV2JGaGpNMmhxWVhwV1YxZHJXbTloUlRGWlVXeFdXRlpzY0doV01qRlhaRVpLY2xwR1pHbFNNbWhaVmtaU1IxTXlWbGRYYTJSWFlrWndUMVp0ZEhOT1JtUnlWMjVPYUZacmJEWlpWVnBUVjIxS1IyTkZlRmROVm5Cb1ZXcEdhMk14WkhSbFJrNVhVbXh3U2xadGNFcE5WbFY0VlZob1dHSkdXbkJWYlRFMFZqRnNXR1JGZEU1TlZsWXpWakkxUzJFd01WaFZha1pYVWpOb2RsbFdXa3RrVmtaeVlVWm9WMUpWY0c5V2JGSkhWMjFXVjFSdVRtbFNNbWhVV1d4a2IyRkdaSE5hUkVKYVZsUkNORlp0TlVkVk1rcEdUbGhHVlZac2NHaGFWM2hoVTBVeFdWUnNXazVoTTBJMVZsUkplR0l4V1hsU2JrcHBaV3RLV0ZsWGRHRlpWbkJYVjJ0MFdGWXdXa2haVlZwdlZUQXdlV0ZHWkZkTlZuQlVWWHBHVm1WV1VuTmFSbVJwWWtWd1VWWnRlRlpOVm1SWFZtNVNiRkl3V25OVmJYaDNVMVpTVmxWc1pGZE5WbkI1V1RCb2QxZHJNVWhoU0ZwWFlsUkdURlpzV2t0amJVWkhXa2RvYUUxR2EzZFdNVkpMWldzeFYxZHVUbXBTVjFKb1ZXMHhVMVF4VWxoTlZ6bFBWbXhzTkZZeU1VZFhiRnAwWlVab1ZrMVhhSFpYVmxwUFVteGtjMkpHY0doTmJFcFZWbTEwWVZVeFdsZFRia3ByVWpOb1dGbHJhRU5YYkdSVlVXeGthRTFXY0VsVk1uaHJWMGRGZVdGR2FGWmlia0pZVmpCYVlXTXhjRVprUmxKVFRVWndTMVpXWkRSWlYwWlhVMjVLYWxKdGVGbFpWRXBTVFVaa1YxZHJjR3hTYmtKS1ZsZDRRMVl5UlhwUmJFSlhZbFJGZDFZeWMzaFNNV1IxVW14U2FHSkZjSGRXUm1Rd1pERk9SMVpZYkU5V2F6VllXV3hXZDFZeFdYbGxSemxZWWxWd1NWbFZXbE5XTURGSFkwWlNXazF1YUhKYVJWcExaRWRTUjFSck5WZGlhMHBNVm1wS01GWXhiRmhUV0doWFYwZFNUMVpzWkRSVk1XeHpWbTFHV0ZKc2NEQlVWbFV4WWtaS2MxZHVhRlppVkVaSVZtcEJlRmRHVm5GU2JHUlhUVEpvYjFkV1dtRlRNazUwVkd0a2FWSnRhRmhaYkZwSFRURlplRmR0Um1oTlZXdzFWa2QwWVZkSFNsWlhiRkphVjBoQ1dGWnNXbXRYUjFaSVVteFNUbFpVVmtsV2FrWnZZekZTYzFwRldrOVdiV2hXVm1wT1UwMHhWWGxsUm1SWVVsUkdXVlF4V210VWJFcEdWMnhzV0ZaRlNtaFpha1phWlZaS2RWTnNhR2xTVkZadlZtMTRZV1F5VG5OalJXUllZa1UxY1ZSWGRHRlRWbXh5V2tjNWFWSXdjRWhaTUdSdlZqSkdjbGR0YUZkV1JWcFBXbFphVDFkWFJrZGhSbWhUVFcxb1dWWXhaREJoTWtsNFZtdGtXR0pzU25KVk1HUlRWbXhTVjFkdFJrNVNia0pYVjJ0V2ExWlhTa1pqUkVaV1ZqTm9jbFpxU2t0WFZrWnlWV3h3VjFZeFNrMVdiVEI0VkRGS2MyTkZaRmRpVjNoVVZGY3hhMDVzV25STlNHaHNZbFphU1ZaWGVHOVZNa1Y1WlVaV1dtRXlVbFJaYWtaelZsWktkVnBIYkU1V2JrSmFWa1phVTFVeVJrWk5WbVJxVW0xb1dGVnVjRmRWUm1SWFYydHdiRll4V2toV1YzaDNZVlprUjFOck1WaGhNbEV3VjFaa1UxSnJNVmRpUjBaVFlYcFdVRlp0ZUZOV2JWRjRWMjVTVGxaRlNtOVVWbHAzVTFaVmVVNVZPVmhTTUhCSVdUQmtSMWRzV2taWGJHUmhWbFp3ZWxreFdrdGtWbEowWTBkc1UwMVZiRFJXYWtvd1lUQTFTRkpzWkZSaWJGcFRXV3RvUTFkV2JISlhiVVpvVW0xNFZsVXlkR0ZoTURGRlVteG9XR0V4Y0hKWlZXUkxVbTFPUjJKR1pGTmlWa2w2Vm0xd1IxWXhTWGhhU0ZaVFlrWktiMVJVUmt0WFZtUllaRWQwVmsxc1ducFdNbmh2WWtaSmVsVnRPVmRpVkVaVVZURmFjMVpzV2xsaFJtUk9WbTEzTWxaV1pEQmlNV1JIVjI1U1ZtSkdTbGRVVlZwM1YwWnJlVTFWWkZSU01VcElWa2N4YzFaR1NsWmlNM0JYWWxSQ05GUnJaRXBsUmtwWllVWldhRTFzU2xwWFZ6RXdXVlphUjJKSVNsZFdSVnBZVm0xNFMxZEdaSEpYYXpsVllrVndlbFl5TlhkWGJGcFlWRlJHVjAxR2NFdGFSRXBQVTFkS1IyTkZOVk5pYTBsNVZtMHdkMlZHVFhoYVJtaFRZVEZhVmxsclpGTldSbHAwVGxWT2FVMVhVbmxXYlRFd1ZqQXhWazVWYkZkV00xSjJXVmQ0U21WWFZrZFZiSEJYVWxSV1JGWkdaRFJaVjFKSVZHdGFhMUpVYkZSVVZWcGFUVlphV0UxVVVtaE5WbkJKVlRJMVQxZEhTa1pPVjBaYVZrVmFhRmxWV2xwa01XUjFWR3hrVjJGNlZqWldhMlI2VFZaU2MxZHVUbXBTYmtKWlZtdFZNVTB4Vm5GU2JIQnNWbXR3ZUZZeWVHdGhWazVHVTJ4c1YySllRbEJaYWtwSFVqSktSMWRzWkZoU01taGFWbTB4TUZsWFZuTlhXR3hzVW5wc1dGUlZVa05PUmxWNVpVaE9XRkl3VmpSVk1uUnZWMnhhUmxkcmRHRldWbkF6VlRGYVlXTXhaSFJpUm1oVFRXMW9XRlp0ZUd0a01VbDRWRmhvV0dKSFVsbFpWRXBUVjFac2MxWnRSbXBpUmtwWVZtMDFUMVF4U25OaVJGWlZZa1p3VUZsV1drdGpiVXBGVjJ4a1YwMHlhSGxXYlhoaFdWWlplRlJ1U21oU2JWSnZXVlJHZDJGR1pITlhiRnBPVm0xU1dGa3dWbXRaVmtsNVpVWm9WMDFHV2t4WlZWcGFaVVprYzFwSGFFNWhNbmN3Vm1wR2IySXhXa2RhUld4U1lsUnNWMWxzYUZOVVJscHhVbTVPYWsxcldrZFViR1EwVlRKS1NWRnFVbGRXZWtJMFZGVmtSMk5yTVZkYVIzQlVVMFZLV2xkV1VrZGtNazV6WWtaa1dHRjZiRlJaYTFVeFpVWlZlV1ZIZEdoV2JWSkpXVlZqTlZZeVNrZFRhMmhXVFdwR1dGVnFSbmRTTWtwSVlVWk9UbEp1UWxaV01XUTBZVEpKZUZkdVRtRlNiVkpYV1ZSS1UxbFdXblJsU0U1UFVtMTRlVmxWVmpCV01ERnlZMFJDVjFaNlZraFdiVEZMVjFkR1NHRkhSbGROTW1ob1YyeGFWazFXWkVoVmEyUm9VbXMxYjFSVVFrcE5iRmw0Vld0T1dsWXdNVFJXTW5oclYwZEtjazVXVmxwaE1YQk1WakJhWVdOV1VuSlBWVGxUWWtoQ05GWlhNWHBPVjBaeVRWaEtXR0V5YUZoVVZ6Vk9aVVpzVmxwRmRGTk5helZJVlRKNGEyRldaRVpUYTFaWVZteEtTRlY2U2xOU01WcHpZa2RHVTFaSGVGbFhWM2hoVXpKSmVGZHNhRTVUUjJoWFZGZHpNVk5HV1hoaFIzUmFWbXR2TWxscmFFTldWbHAwVld4U1YySllhRmhhUlZWNFZteHdTR0ZIYUd4aE1YQklWbTB3ZDAxWFVYaFhia3BPVjBWYVdGbFVUbTlYVmxwMFpVaGtWVkp1UWtkV01uaHJZVEZhY2xkdWNGZE5ha1o2VmxSQmVHUkhSa1pYYkdSb1RXeEZkMVl4V21Gak1WbDRXa2hPWVZKc1duQlpWRVozVjBaa1dHUkhkRlpOVmtZMFdXdGFWMVpYUlhkT1ZsWlhZbGhvZWxSc1duZFNiR1IwWkVkb1YxWkZXalZXYWtvd1lqRmFjazFZVm1oVFJYQllXVlJLVTFSR1ZYZGFSV1JUVFd0YVNGa3daSE5WTURGMFdqTnNWMkV4Y0ZSVmFrWnJaRVpXV1dGSFJsUlNWRlp2Vmxkd1QxRXhaRWRpUmxaVllUQTFVRlp0TVZObFZscDBUVlZrVjFaVVJubFdNbmh2VmpBeGNWWnNRbHBXTTJoTVZqQmtSMUl5UmtkalJtUk9UVlZzTlZacldsZFpWbXhYVTJ4a1ZXSnJjR2hWYlhNeFlqRndXR1JIUmxoU2JWSlpXa1ZrUjFaRk1YSlhiR2hXVFdwV1RGbFhlRXRrUjFaSFlVWmthV0pyU2toV1JsWmhWakExYzFOdVRtRlNhelZQVm0wMVEwNXNXblJOVkZKVlRXdGFSMVJWYUc5V1IwcEhWMnhvVm1KWWFETlpWVnBYVG14T2MxcEhjRTVoTTBKSlZtcEplRkl4V2tkVGJGWlhZa2RvV0ZWdGVIZFhSbkJGVW0xR2FrMVhVakZXVjNNMVZqQXhSMk5HYkZkU2JWRjNXa1JHYTJNeFduTmhSM1JUVmtkNGFGWnRNVFJrTVdSSFYyNU9hRko2YkZoVVYzUmhaVlpaZVdWSE9WZE5SRVpaVmxkMGIxWnRSbkpYYmtwaFVsZFNTRlZ0Y3pGWFIwcEhWR3hvVTFaV2EzaFdiVEI0WkRGSmVWSllaRTlXVjFKWlZqQmtORll4V1hkYVJ6bFlWbXhzTTFkcll6VldNREZZWlVSQ1drMHpRa2haVmxWNFZqRmtkV05HWkZkbGJGcFJWbXBDWVZsWFVraFdhMnhxVW0xU1QxbFhkR0ZUVm1SWVpFZEdXbFl3TVRSV01qVkhWakpLVmxkc2FGZGlXR2d6VmxaYVlXTldUbkZWYkhCWFRVUlZkMVpVU25kWlZscElVMnRrYWxORlNsaFVWVnAzVWpGd1JWSnNjR3hTYlZJd1ZXMTRVMVJ0UmpaU1ZFWlhZVEpSZDFsVVNrZFNNVTVaV2tab2FWSnJjRmxYVm1Rd1dWWlNSMWRZYUZoaVZWcFlWbTEwWVUxR2NFWlhiRTVWWWtad1ZsWnRkSGRXTVZwR1lqTmtXbUZyY0VoV2FrWlBaRlpPY2s5V1pHbFdNbWh2VmpGa05HSXhWWGhVYTJSV1lteEtjMVZxUW1GamJGWnpWV3RrVjJKR1dsbGFWV1JIVmxkS1IyTkdXbFppUjJnelZtcEdTbVZ0UmtkaFJuQm9ZVEZ3YUZkc1dtRlVNbEpYVlc1T1ZtSlhlRlJaVkU1RFlqRlplRmRzVGxSTlZsWTBWakowYTJGV1RrWlhiRkphWVRKU1ZGa3hXbE5XTVhCSFZHMTRWMkpyU2toV2FrbDRUVVpaZDAxWVNtcFNia0poVm14YWQwMHhXWGRhUlZwc1VtMVNNVlV5ZUdGaFIwVjZVV3RzV0ZkSVFraFpWRXBUVmpGV2RWUnNXbWxXTTJoVlZrWlNTMkl5VW5OWGJsSk9Wa1pLWVZacVJrZE9WbHBJVGxVNWFGWnJjREJXVnpGdlZtMUtTR0ZHVWxkaVJuQllXVEZhUzJOdFRrWk9WMnhUWWtacmVGWXllRmRoTURGSFYyNUtUbFpXV2xOWlYzaGhXVlphYzFkdVpGUlNiR3d6VmpKNGQySkhTa2RYYWtKYVZsWndjbFpITVVkamJHUnpWV3hvYVZKc2NHOVhhMUpIVkRGWmVGWnVWbFppVjNoVVdWaHdWMlF4V25STlZFSnJUVlp3ZWxZeU5VdFhSMHBHVGxaT1ZWWnNWalJVYTFwV1pWZFdTR1JHYUZOTlNFSTFWbXBLTkZVeFpIUlRhMlJZWWxkb1dGbFVSbmRsYkd3MlVtMTBhbUpJUWtkVU1WcHJZVlpLZEU5VVRsZE5Wa3BFV1ZSR1NtVkdaRmxoUm1oWVVqRktlRlpYZUd0T1JteFhWMjVPV0dKdFVsaFZiWGgzWlVaVmVXUkhkR2hpVlhCSFdUQm9iMVl4V1hwaFJtaGFWbFpXTkZZeFdrZGtSMFpIWVVkc1UySklRblpXYlRGM1V6RlJlVlZyWkZkaWEzQm9WVzE0ZDJJeGNGaGxSMFpyVFZad1dWcFZZelZWYXpGWVZXNXdWMDFxVmtoV2EyUkhZMnhPZFZGc1ZsZGlTRUpaVmtkNFlWWXlVa2hWYTJoclVtMVNWRmxzV2t0VE1WcFhXa1JTVlUxWFVqQlZNblJyVmtkS2RWRnNhRlZXVm5BeldsZDRjbVZYVmtoa1IzUlRZVE5DTlZaSGVGWk5WbGw1VTI1S1ZGWkZjRmhaYkdoRFZFWlNjbHBHU214V2F6VjVWMnRhYjFkR1NYbGhSbkJZVm14S1RGUnJaRWRTTVZwMVZHeG9hV0pXU2xoV1Z6RTBaREZPVjFWc1pGZGlWVnB3VlcxMGMwMHhiSEpWYlVaWVVqQldORmt3YUV0WGJGcHpZMFYwWVZaV2NFeFpNVnBUWXpGd1NHSkdUbWhOTUVwTFZtMHdlR1F4VFhoVmJsSlhZVEpTY1ZWc1pEUldWbXh6V2tjNVYxSnNTbFpWTWpBMVZqRmFjMk5JYUZaV2VrWklWbXRWZUZkR1ZuSmhSbVJPWW14S2VWWnRjRXRUTVZweldraFNVMkpIVW5CVmJYUjNVbFphU0dSSFJtcE5helY2Vm0wMVUxVXlTa2RqUlRsYVZrVTFSRlJzV210V1ZrWjBUMVpXVGxadVFYZFdWekF4VXpGYVNGTnNhR2hTYlZKV1ZteGFkMDB4YTNsbFNFcHNWakZhU2xkcldsTldNa3B5VTJ0c1YyRnJjRFpVVmxwV1pVWk9jMXBIY0ZOV01taFpWMWQ0VTFKck1VZGlTRVpVWVRGd2MxVnRNVk5YYkd4eVYyeE9hRlpyYkRaWlZXaGhWakZhUmxOc2FGaFdiSEJvV1hwS1MxTldUbk5oUjJ4cFZtdHdXRlpyV21GaU1VVjRVMjVPVjJKSFVtOVZibkJ6VjBaV2RHVklaRTVXYkZwWldrVm9UMWRIUmpaU2EyaGFUVVp3VkZacVJtRlNiR1IwWVVaYWFHRXhjSGxYYTFaaFV6Sk5lR05GYUdsU2JWSlVWbXhrTTAxc1duRlRhbEpYVFZkNFdGWXlOVk5XTWtWNVZXeHNXbUpZVWpOWlZWcFhaRWRXU1ZwSGNGTmlSbTkzVmtkNFYxUXhaRWRYYmxKV1lrZDRWbFpzWkc5a2JGcDBZek5vVjAxWFVubFpWVnByVkcxR2MxZHJiRmRpUjA0MFZYcEdUMVl4U25WVGJFSlhZbXRLZGxaR1pEUlRNVnBYV2toT1dHSlZXbGxaYkZwaFZqRlNjMWR0UmxaU2JIQXdWbGN3TlZsV1dYcFZiV2hWWWxob2FGa3hXazlXVmtwMFpFVTFWMkpZWTNoV2JGSkxUa2ROZUZadVVsUmhNbWh2VlcweGIxbFdXbkZVYkU1VVVteEtlVll5TVVkaGJGcHlUbGhzVlUxV2NGUldha3BMVmpGT2NWZHNaR2hoTTBFeVZrWmFhMUl4WkVkVWJrNW9VakJhVkZWdGVIZFhWbHBIV1hwR2FVMVhVa2haYTFwWFZUSkZlbFZ1U2xaaVdHZ3pWRlphWVZkSFZrZFViV2hUVmtWWmQxZFdWbTlrTVZsNFYycGFVMkZzY0ZaV2JYaDNWVEZ3VmxwRmRGUldiRW93VlcxNFQySkhTbGxoUmtwWFlrZE9ORlJyWkZKbFZscHpXa1pvV0ZJemFIcFdWM2hUWXpGWmVHSklUbGRpU0VKUFdXdGFZVTFHY0ZaWmVsWlhUVVJHZVZrd1duZFdNVm8yVm10NFYwMUdjR2haZWtwUFVtMVdTRkpzVGxkaWEwcGFWakowVjFsV1RYbFVXR2hZWW1zMWFGVnRjekZYVmxaelZtNU9UMVpzY0hoVmJYaFBWV3N4V0dWR2FGZE5WMmg2Vm14a1MxTkdWbk5WYkhCb1RWaENiMVpzVWtkak1XUllWR3RrWVZKdGFGUlpiR2h2VGxaYWNWTlVSbWhOVjFKSVZqSTFUMkZzVGtsUmJHeFhUVWRvUkZVd1dtRmpNVnBaWVVaa1RtRjZWa2hYVjNSaFdWWlNkRk51VGxSaVZHeFlXVlJHUzFOR1pGZFhiWFJUVFZad01WWlhlRTloVmtwelkwWnNWMkpZUWtoVmVrRjRZekZrZFZSc1pHbFdWbkJhVjFkNFlWbFdaRmRYYTJSb1UwZFNiMVZ0ZEhkTlJteFdWMnhPVjFac2NGaFpNRkpQVm1zeFYyTklTbGRoYTFwb1drVmFTMlJIVWtaT1ZtUm9UVEJGZVZadGVGTlNNa2w1VTFob1dHRXlhRlZaVkVaM1YxWnNjbHBFVWxwV2JIQjVWbTB4UjJGR1NuUmxSbVJYVFdwRmQxWnFRWGhYUmxaeFVXMUdVMVp1UWxGWFZsWnJWakpTU0ZaclpHbFNiVkp2V1ZSS00wMUdXa2RXYlVaWFlsWmFTRmRyYUV0WlZrcDBZVWhDV21FeWFFUldNbmhyVjBkU1NHUkdXbWhsYTFwSlZtcEdiMk15Um5KTlNHeG9VMFZhVmxadE1WTldSbEpYVjJ4a2ExSXhXa2RVTVdSdlZqSktTVkZzYkZoV1JVcDJXVlJHV21WR1RuVlViWEJUVFcxb1dGZFdaREJTYlZaSFYyNUdVMkpZVW5KV2JYaGhaVlpSZUZkdGRHaFNNVnA2VmpKNGQxWXlTa2hWYWs1V1ZrVndVMXBXV21Ga1ZsSnpXa1pvVTAweWFEWldiR040WldzeFYxcEdaR2xUUlRWWVdXMHhVMWRXYkhKYVJGSlhUVlp3TUZrd1drOVhSa2wzWTBWb1drMUdjSFpXTW5ONFUwWldjbUZHYUZkaVNFSk5WbGN4TkdFeVVraFNhMlJoVWxSV1dGUldWbmRUYkZwelZXdE9hRTFXVmpSVk1XaHZZV3hLV0dGSE9WWmhhelYyV1dwR1UxWXhaSE5qUjNocFVtNUJkMVpHVm05aU1WRjRVMWhrVjJGc1dsaFdiVEZ2Wkd4YVZWSnRkRlJTTUZwSldWVmFZVlJzU25OaU0zQlhZVEZLU0ZZeU1WSmxSbVIxVm0xR1UwMHdTbGxYVjNSaFYyMVdjMXBHWkZkaVIxSldWRmQwWVZOR1ZYbE9WVGxvWWtVMVNsVlhlSE5YYkZwR1kwVTVWVlpzY0dGYVJFWnJZMjFTU0dSR1RtbFNia0V5VmpGYVYxbFhTWGxTYTFwT1ZtMVNjRlZyVlRGWFZscDBUVlpPVDJKSVFsZFdNakV3VlRBeFYyTkVSbGRpVkVaMlZsUktTMU5XUm5WYVJtUm9ZVEJ3ZVZkWGNFSmxSMDE0V2toV1ZtSllRbFJXYWtaTFZteGFSMWR0Um10TlYxSklWakZvYzFReFdsVmlSbWhWVmpOU00xVXhXbk5XYkdSMFQxWmthVlpZUWtsV2FrcDNWREZzVjFkdVRtcFNNbWhZV1d0YWQxVkdXWGhhUldSVFRWaENSMVJzV210aFYwVjNZVE5vVjJKWVVuSlVhMXB6VmpKS1IyRkdUbWhOYkVwV1ZtcENhMVV4WkZkaVNFcFlZVE5TV0ZsclduZE5WbXQzVm0xMGFFMXJjRWhaYTFKWFdWWmFXRlZyYUZkTlJuQkxXbFZhYTJOdFJrZGFSazVPVFcxb05WWnRkR3RPUm14WVZGaHNWV0V5VW5CVmJURlRWREZzZEdWRmRHbE5WMUpaV1RCV01GVXdNWEpOVkZKWFVucFdVRlpxU2t0WFIxWkhWV3h3YVZKdVFrMVdiWEJIV1ZkU1JrMVZiR2hTYkhCUFZtMDFRMU5XV25SbFJ6bHBUVmRTU1ZVeWRHOVdiVXB5WTBaa1dsWXpVbWhaVlZwV1pVWmtjMU50ZUZOaVZrbzJWakowWVZZeVJsZFRibEpyWld0S1dGWnJWblprTVd3MlVteHdiRlpyY0RGVk1qRnpWVEZLY21OSGFGaFdiVkYzVjFaYWMxWXlUa1pXYkVwWVVqSm9XVmRYZEc5Uk1VNUhZa1phWVZORk5XOVdha0pYVFRGcmQyRkhSbGROYTNCSlZsZHdUMVl4U2taalJYUmhVa1ZHTkZVeFpFZFNNWEJJWWtkb1RsZEZTbGhXYWtaaFZURk5lRlpZYUZoaE1sSndWVzB4TkdOV1ZYZFdWRVpZVm14d01GUldVbE5pUmxwellrUldXazB6UWxoV2FrWmFaREpPUmxwR2NFNVNiSEF5Vm0xd1FtVkdaRWhTYTFaVllrZFNiMWxVUWxwTlJscDBZMFYwVlUxVmJEUldiVFZQVjBkS1dXRkhPVlZXUlVwTVZURmFXbVZYVmtoU2JIQlhZa1ZaTVZacll6RlVNV3hYVkd0YWFsSnJTbGhaYkZKSFZrWnJkMWRzY0d0TldFSkpWREZWTVdGV1NuVlJhbHBYVFc1U1ZGVlVSbHBrTURGWFlVZDRVMkpYYUZsV1JtTXhZakpPYzFkWVpHRlNXRkp4V1Zod1YxZEdiRlpYYlhSb1VsUkdXRmt3WXpWV01rcFpWVzFvVjJGcmNGUlZiWE14VmpGa2MxWnRiRk5OYldoV1ZqRmtNR0V3TUhkTlZtUllZVEpvYzFWcVRsTlVNVlowVFZaT1ZGSnNWalZVYkZVMVlVZEtSazVWY0ZaV00yaDJWbXhhV21Wc1JuTmhSMFpUVFRKb2IxZHJWbFpsUmxwMFZXdGtZVkp0VW05VVZFSktUVVphZEdSSGRFOVNNVVkwVmpGb2MxWkhSWGxsUms1YVlrWktlbFl3V21GalZsSnlWR3hTVTJKSVFrZFdWRW8wVkRGWmQwMVdhRlpoYTFwWVZXNXdSMU5HV2xWU2JVWlRUVmRTTVZZeWVHOVdNa3BHWTBWV1YyRnJjRFphVlZwS1pVWndTVlpzV21obGJGcGFWbGR3UjFNeFduTlhhMlJZWWxWYVdGUlZVbGRUUmxsNFlVYzVhRkpyTlVkVWJGcHJWbFphZEZWc1VsWk5ibWhZVmpCVk1WWnNjRWRhUjJ4WFYwVkthRll4V2xkVk1WRjRXa2hLVGxaWFVuRlZNR2hEVjBac2NsZHVaRlJTYmtKSVZqSTFhMVpHU1hoVGEyUlZZa1p3Y2xsV1pFWmtNazVHWkVaa2FWZEZTazFXUmxaclUyMVdWMU5zYkdoU2JXaHdXVlJPUTFWR1duRlJiR1JyVFdzMVdGWnNhR3RoUmtwV1RsWnNWbUpZYUdoVVZWcFRWakZzTmxadGFHbFdXRUpLVm14a05HSXhXWGROV0ZaV1YwZFNZVlpyVm1GVVJtdzJVbTEwYTFZd2NFaFdiWE14VmpKS2NsSnFXbGROVm5CWVZtMHhWMU5HVm5KaFJrNW9UVmhDV1ZkWGRHdFZNa2w0WWtaV1UySnRVbkJVVmxwM1pXeGFXR1JFUWxkV01IQllWakowYjFZd01YRldiR2hYWVRKU1RGVnFSbXRrVmtaelYyMXNXRkl5WkRaV2JURTBXVmRGZUZwRmFGWmhNbWhVV1d0a2IyTkdXblJsU0dSUFlrWndlRlV5Y0ZOV01ERlhWbXBXVmsxdVVtaFdSRVpoWXpKT1IxZHNaR2xXUlZwVlZtMTBZVlp0VVhoYVNFNVlZbGhvV0ZSV1duZFRiRnBGVW0xR2FFMVdiRFZWTW5oclZrZEZlbEZzYUZwaE1sSlRWRlZhYzA1c1NuUmtSM0JPVmpGS1lWZFVRbUZaVjBaR1RVaHNhRko2YkZoWmJHaERWVVpzY1ZKdGRGTk5hMVkyV1d0a05GVXdNSGhUYm1oWVZqTlNkbFZVUms5U01rcEhWMnhvYUdWdGVIWldiWEJEVmpBd2VHRXpaRmRoYTBwWVZGVlNSMWRHVlhsa1JrNVlZa1p3UjFrd1ZUVlpWbHBYWTBoS1YwMVhVa3hWYWtaWFpFZEdSazVYYkZkTmJXTjRWbTB4TUZsV1ZYaFZXR2hUVjBkb2FGVnNaRk5XTVd4eVdrYzVWbEpzY0RCWk0zQkhZVlV4VjFkcVFsVldiRXBVV1d0YVMyTXhaSEZSYkhCT1RUQktTVmRXV21GVE1rMTVWR3RzYWxKdFVrOVpWM2hhWld4YWRHTkZTbXhTTURWWVZUSTFWMkZzU25SVmJHaFdZa1p3TTFscVJtdFdWazVaWVVaV1RsWlhkekJXYWtreFZESkdSMU51VWxaaGVteFdWbTV3UjJSV2NGZFhiSEJzVW01Q1NsZHJXbE5VYkZweVYxUkdWMkV4Y0haWmVrWmhVMFpLV1dKSGVGTmlTRUpvVjFaU1MxVXlVbk5oTTJSWVlsVmFjVlJXWkZOTlZtUnlWMjFHVmsxcmNFcFZWbWhyVmpGS2MxZHNVbFpoYTFwWVdUSnplRll4WkhSaVJrNVRZVE5DV2xacldtcE5WbFY1Vkc1T1dHSnNTazlXYkZwM1l6RmFkR1ZIUm14aVJtdzFXbFZvYTFkR1NuSk9WV1JXVFc1U2VsWXdaRXRTTWs1SVlVWmtUbUZyV2xsV2FrSmhXVmRPZEZOclpGZGlWM2hVVkZaV2QxZHNXbkpYYkdScFRWVldORlpITlU5WlZrcDBWV3hvV21KR1dtaFpNRnBUVmpGd1IxUnNVbE5pUjNjeFZrZDRWazVYUmtoVGExcFBWbGRTWVZSVlduZGpiRmw1VFZWMFUwMVZOWGxaVlZwclZURmFkVkZzYkZoWFNFSklXVlJLVDJSR1ZuSmhSM0JUVmtaYWRsZHNaRFJaVms1elYyNUdWR0ZyU205VVYzTjRUa1paZUdGSE9WaFNNRlkwV1RCYWIxWXdNVWhWYkZKWFRVWndlbFl3WkZOVFJrcDBZVVpPYVZkSGFHRldhMXBoV1ZkRmVGWllaRTVXYlZKVldXdG9RMWxXV25OWGJtUllVbTE0V0ZZeWRIZGlSa3B5VGxod1drMUdjSFpXYWtwWFkyeGFXVnBHWkZoVFJVcE5WbXRTUzFSdFZrZGFTRlpYWWtVMWNGVnNhRU5rTVZwMFpVZEdhMDFYVW5wV01qVlRWR3hhUjFOdFJsZGhhMXBvV2xkNFdtVlhWa2hQVjJoT1ZsZDNNbFpzWkRSWlZtUjBVMnRrV0dGck5WZFVWbHAzWVVaWmQxWlVSbGhXYkVwNlYydFZNVlV4U2xkaWVrSlhZa1p3YUZaVVJrcGxSbVJaWWtaU2FFMXNTbGxYVm1RMFV6RnNWMVZzYUdwU1YxSlhWVzE0WVUxR1VsZFdha0pXVFVSR1dsVlhkRzlXTVVvMlVsUkNXbFpzY0V4YVJscEhZMnh3UjFwSGJGZFNWbGw2Vm0xNFUxSXhUblJXYkdSVVlrZDRiMVZ0ZUV0WFZsWnhVMjA1YVUxV2NGWlZWekZIVmtVeFYyTkZhRnBoTW1oTVYxWmFTMk5yTlZsU2JGcHBWa1ZWZDFaR1ZtRmtNVXB6VjI1R1VtSkhVbFJaYTJoQ1pERmFjMXBFVW10TlYxSjVWRlpXYTFkSFNuSmpSbWhhWVRKU1ZGWkZXbUZqVmtwMFpFZHdhVlpXY0VsV01uUnJZekZaZUZOdVRtcFNXRUpZV1d4b2IyTldjRlpYYXpWc1VteEtlbGRyV2s5aFYwVjZVV3hLVjJKVVFYaFZWRVpyVWpGYWRWUnNXbWxTTVVwVlZtMHhOR1F4VGtkWGJHaHJVak5TV1ZsclduZGxiR3h5Vld4T1dGSXdWalZaVlZwVFYyeGFSbGRyZEdGV2JWSklWVzF6TlZZeVRrZGFSazVYVW14d1IxWnRNWGRTTVd4WFlrWm9WV0pIVWxaWmJYUmhWVEZzYzJGRlRsVk5WbkF3Vkd4V1MyRXdNVmRqUmxwV1RXNUNWRmxYYzNoV01XUnhVV3hhVG1KdGFHOVdha0pyVXpGYWMxcElVbE5pU0VKWVZXeGFkbVZzV25KV2JVWmFWakExZWxkcmFFOVdWMHBaVVc1Q1ZtRnJXa3RhUkVaclkyeGFkRkp0YUU1V2JYY3hWbGN4ZDFsV1dYbFNiazVZWWtkNFlWWnJWbUZoUm10NVpVaGtVMVpyY0hwV1J6RXdWVEpHTmxacVZsZE5ibEp5V2tSR1ZtVkdjRVphUmxKcFVqTm9XbFp0Y0U5aU1WcEhWbXhXVWxaRldsUlVWbHAzVFZaV2RHVkdUbWhTVkVaNlZUSjRkMVl4V2paU2FscFZWbTFTV0ZacVJuZFRWazUwVW14U1UxWkdXbGhXTVZwdlpERkpkMDFWWkdsU2JIQlpXVzF6TVZkR1VsZFdibVJzWWtkME0xZHJZelZXTWtwWFYyNXNWMDF1YUhaV2JURkhZMnhrZFZOc2NHeGhNWEJ2VjFod1IxWXlVa2hTYTJoc1VqSjRXVlZxU205WFZscDBUVlJTYUdKV1drbFdiVFZMVkd4YWRGVnRhRlpOUmxWNFdUQmFWbVF4V25WYVJtaFRZa2hDTlZacVNYaFNNVmwzVFZaa1ZHSkhVbGhXYWs1VFkyeHNjbHBGZEZOTlZuQjRWbTE0VjJGV1NYaFNhazVYWVd0S2FGVjZTazVsVms1eVZteG9hVk5GU2xsV2JYQkhVekF4YzFkdVJsSmlWVnBoVm1wQmVFNUdXWGxPVldSWFlsVndTRmt3WXpWWGJGcEdWMnBLWVZZemFHaFdiRnBMWkVaS2MxZHJOV2xTV0VKTFZteGplRTFIUlhoWGJHaFVZVEpvVjFscldrdFdiRnB5Vm01a2ExWnNTbGRXTWpGSFlURkplRmRyYkdGU1YxRjNWa2Q0WVZZeVNYcGFSbVJwVmtWV00xWXhXbUZWTWsxNFZXNUthRkl5YUZSWmJHaHZZVVphZEdSR1pHdE5iRXA2VmpKNFlWZEhTbFpYYmtaWFlsaFNhRlJWV2xka1JURlpWR3hXYVZKdVFqVlhWRUpoWXpGWmVWSnVTbWhOTW1oWlZtMTRkMVpHY0VaWGF6bHFZa2hDU1Zrd1dsTldSa3BXWTBjNVYySlVSVEJaVkVaWFpFWldXV0ZHYUdsaE1YQlZWMVpTVDFVeFpFZFhibEpyVTBkU2MxWnRNVFJsVmxsNVRWUkNWMDFFUmtaVlYzQlhWMnhhVjFkc2FGZGhhMFkwVm1wS1QxTkhSa2RYYlhob1RVWlpNRll4YUhkU01WRjVWV3hrVm1Kck5WbFpiR1EwVmtaU1YxWnVaRlpXYkhCNlYxUk9iMVF4U25OaVJFNVZZa1phY2xZd1pFdGpNVTUxVkd4YWFHRXdjRzlXYlhSaFZURmtTRlpyV210U2JFcFlXV3RvUTFOc1pISldiWEJQVmpCYVdGVXlOVXRoYkVwR1UyMUdWMkpHY0ROV2ExcGhZekZrZEZKdGNFNVdNVW8wVmxSSmVGSXhXWGhYYmxaU1lsUnNXVlpyVm1GaFJscEZVMnM1VjAxVmNERldSekYzVlRKS1YxTnNRbGRXTTBKUVdWY3hVbVZHWkhWVmJYaFRUVVp3ZDFaR1pIcGxSVFZIVjFoc2ExSjZiRmRVVm1SVFUxWndWbGw2VmxkaVZYQmFXVlZTVDFkR1duTmpTSEJhWld0d1NGVnFSbE5qTVZwelZHMXNXRkl5WTNkV2JYaHFaVVUxUjFWWWFHRlNWMUpWV1d0YVlWWkdiSEphUnpsWVVteGFNVmt3Vm10VWF6RlhZMFZzWVZaWFVraFpWekZMVm1zMVZtRkdjR2hOV0VJeVZtMXdTMU14U1hsVWEyeG9VbTFTVkZSVVNtOWlNVnB6Vld0MFZXSldXa2haTUZaelZqSktSMU50T1dGV2VrVXdWakZhYTFkSFZraFNiRkpPVmpGS1dWWnFTalJpTWtaelUyeFdhVkp0VWxaV2JYaDNZVVpWZDFkc2NHeFdNVXBKVkRGYVYyRldTblZSYlVaWFlrZFJNRlpxUm1Ga1JrcDFVMnhvYVZZeWFGaFdSbFpoWkRKV1YyTkZWbE5pV0ZKeVZXMTBkMlZzV25STldFNVdUV3R3V2xkVVRtdFdNa3BIVTJ0MFZWWnRVazlhVlZwclYxWndSazVXWkdsV2EzQTBWbXhTUTFZeVVYaFhXR2hxVW0xb2NsVnFRbUZqVm14eVYyeGtUazFXYkRWVVZsWnJZVWRLVm1ORmFGcE5SMmd6Vm1wR1MwNXNTblZqUm1SWFVsVlpNRmRyVm10U01VcFhWRzVPWVZJeWFFOVdNRlpMVjJ4YWRHVkdUbE5OVjFJd1ZtMTBhMVpYU25KalIyaFdZbFJHZGxscVJsTldNV1IxV2taa1YySldTbHBYYTFaclRVWmFjazFZU2s5V2JXaFlWbXBPYjJOc1duRlRhM1JxWVhwV1YxUXhXbGRXTWtwSlVXdHNWMUl6VW1oWFZtUlRVbXMxVjFkc1FsZGlWa3BRVmxkMFYxbFZOVmRhUmxaU1lsVmFiMVJXV25OTk1WSlhZVVZrVjAxclZqUlZNbmh2VjJ4WmVsVnFUbFpOUm5CNVdsWmtUMDVzU25OaFJtUnBVMFZHTTFac1kzaE9SMFY0VjFoc1ZHSnJjRlZaYkZKelYwWlNXRTVYT1doU2JYaFdWVzE0WVdKR1NuSk9WRVpXVFc1b1JGWnFTa3RYUjBaSldrWmtWMDB5YUZWV2JYQkxVMjFXUjFadVRtRlNia0p6V1d0YWQxVkdXa2RYYlVaclRXeGFlbFl5ZUc5aE1VbDZWVzA1VjJKR1NraGFWM2hYWkVkT1IxUnNaRTVTUlZwYVYxWldiMlF4V1hsU1dHeFdZVE5vWVZSWE5VNWxSbHB4VTJ0MFUwMXJOVWxaYTFwdlZUSkZlV1I2U2xkaVZFSTBXa1JHU21WR1dsbGhSbWhwWVhwV2IxWlVRbFpOVjBaSFZtNU9WbUpyTlZoVmJURTBUVVp3UmxacVFsaFNNSEJKVmxjMWQxWXlTbGxoUjJoWFVrVmFhRmw2U2t0U1ZscHpWMnMxYVdKRmIzbFdiVEIzWlVaSmVWUnVUbUZUUmtwVVdXdGFZVmRHV25GU2EzUlhWbTFTZWxkclVsTmhhekZYWWtSU1dHRXlhRlJXVkVwTFUwZEdSMkZHY0ZkU1ZtOTZWakZhWVZkdFZsaFZhMmhUWWxkb1QxWnRNVE5OVmxwMFRVUkdWRTFXVmpWVmJUVlBWa2RLU0dGSFJscFdSVm96VmtWYVZtUXhaSFZVYXpscFVsaENObGRVUW10T1JsVjVVMnhrVkdGc2NGbFdhazVUWTJ4c05sSnNXbXhXYXpWNVYydGtkMVpHU1hoVGJIQlhZbFJXTTFWdE1WSmxSbHB4VjJ4T2FWWldjSGhXUmxwclZUQXhWMWRzYUU1V1JrcFhWRlZTUTA1R1ZYbE9WM1JYVFZWd2Vsa3dhRXRXTVZwR1YyeENWbUZyY0VkYVYzaDNVakpHU0dKR1pGTk5NbWQ2Vm0xNGFtVkhWbkpOVm1SVllrZFNXVmxyWkc5ak1WVjNWbFJHV0ZKc1NsbGFSV2hyVjBkS1IyTkZhRnBXVjAweFZtcEdZV015VGtkaFJuQk9VakZLTWxadGNFSmxSazVIVm01T1ZtSkdjSEJWYlRWRFYxWmtXV05GWkd0TlZYQjVWR3hhYTFsV1NuUlZiRkphWVRKb1JGWkZXbUZrUlRGVlZXeGFUbFpVVmpWV1JscGhZVEZhUjFwRmFHaFNNbWhYV1d0a1UxWkdXWGhYYms1WVVqRmFTbGRyV210Vk1rcEpVV3BXVjJKVVJYZFVWVnBhWlZaT2NtRkhlRk5pU0VKWVZrWmpNV0l4VmtkWGJrWlRZVE5TY1ZSWGN6RlNiRlpZWlVaa1YwMXJjRWhaYTFKUFZqSktSMU5yZUZabGExcExXbFZhZDFOV1duUmpSazVwVTBWS1VWWXhXbXROUm14V1RsaE9ZVkp0VWxoWmExcDNZekZXZEdONlJsaFNiRm93Vkd4YWExZEdTWGRqUld4WFZqTk5NVlpxU2t0V1ZscHlWV3h3YUdFeGNHOVhhMVpyVkRGS2MyTkZaRlppVjNoWVdXdG9RMWRzV25STlNHUk9WbXhzTkZZeWVHOVdSMHBIWTBac1dtRXhjR2hXYWtaell6SkdSMVJyTlU1V2JrSllWbXBKZUZJeVJuTlhia3BZWW01Q1dGUlhOVTVsUmxweFVWaG9VMVpzY0hoV01uaHJZVWRGZVdSRVVsZGlSa3BJVmxjeFYxSXhjRWxVYkdob1pXMTRXVmRYZEZka01XUlhXa1pvYkZKck5WUlpXSEJIVTBaWmVVNVdUbWxTYTNCNldUQm9UMVl5U2tkVGEyaFhZbGhvV0ZZd1ZYaFhSVGxYV2tVMWFFMVdhM2xXYkZwclRrZEZlRmRZYUZoaGJIQlVWbXRXUzJGR1ZuSldiVVpxWWtkM01sVnRNVEJoYXpGWlVXdG9WMVo2Um5aV1J6RkxWMGRHUjJOR1pFNVdia0pWVmxkd1MxVnRWbGRUYmtwaFVtMW9jRmxyVm5kbFJtUnpXa1JDV2xadFVraFphMmhMVjBkRmVsVnVUbHBoTWxFd1ZtcEdhMk5zYkRaV2JXaFRZVE5DVjFaWE1UQmtNVnB6VjI1T1ZHRXphRmhaVjNSM1ZFWldjVkpyT1dwaVJscDZXVlZhYTJGV1duSmpSV3hYVFc1b2FGZFdXbHBsVmxKWllVZHdVMVl4U2xkWFYzaHJUa2RPUjFadVRtaFNWVFZQVkZaYWQyVnNaSEpoUjNSWFVsUkdSbFp0ZEc5WFIwVjRWMjVLV2xac2NFeFpla1pyWXpGV2MyTkhiRmhTVkVVd1ZtMTRWMWxXV1hsVmEyaFhZVEo0YUZWcVRtOVdSbXh5VjI1YWEwMVhVbnBXYlhoaFZERmFjMkpFVWxaTlYyaHlWakJhWVZKdFRrZGhSbkJwVWpKb01sZFVTalJaVjAxNFdraFNVMkpZUWs5WldIQlhVekZhY1ZOcVVtaE5hMXBIVkZab1QxWkhSalpTYkd4WFRVZG9SRlV3V25OV1ZrNXlUbGQ0VTAxRVZraFdNblJyVWpGVmQwMVlVbWhUUm5CWVZXMTRTMUpHVmpaU2JVWnFUVmRTTVZaWE1UQlZNREZIWTBkb1YySllRa2hWYWtFeFVqRndTVk5zWkdsV1IzaFpWbTF3UTFZd05VZGhNMlJZWWxWYVdWbHNWbmRUVmxwWFZXdE9XR0Y2UmtoWk1GcHZXVlpLV0ZWc1VsWk5WbkF6VldwS1IxSXhjRWhpUmxKVFZsZDBOVlp0TVhkVE1ERklVMWhzVTFkSGFGaFpiWFIzVkRGYWRFMVhPVmROVjNnd1ZGWlNVMVl5U2tkalJFSlZWbTFOTVZac1drdGtSMVpIWWtkR1YxWnNWWGhXYlhSaFV6Sk5lRnBJVm1wU2JXaHZWRlpvUTJWV1pGZFhiVVphVm10d2VsZHJhRTlXTWtwSVlVWm9WbUpIVFRCYVJFWmhaRVV4U1dGR1pFNVdNVXBKVm1wSk1WTXhaRWhUYTJob1UwVktXRlJWV25kVVJscFdWMjFHYTFJeFdraFdSM2hyVkd4S1IxZHJiRmRoYTJ0NFZsUkdVMk14WkhKYVJsSnBZVEJ3VjFadGNFOVZNa1pIVjFoa1dHSkdjSE5WYWtKaFUyeGFTRTFYT1ZaTmExWTJWVmR3WVZZeVJuSmlla0phWVd0YWFGcEZXazlqTWtwSVlVWk9VMVpHV205V2ExcHFUVmRKZVZKclpGZGlhelZaV1Zod2MyTldVbGRYYTNSc1lrWndTVlJXWXpWaFZrbDNZMFZvV2sxR2NIcFdha0Y0VmpKT1IyRkdjRmRTVm5CTVYyeFdZVmxXWkZoVGEyUldZbGQ0YjFSVVFrdFdNVmw0V2tSQ1YwMVZNVFJYYTFwclYwZEtjMU5yT1ZkaVJrcDZWbFZhVjJSSFZrWmtSbVJPVm01Q05sWnNaREJoTVZweVRWVldVMkpJUWxkV2FrNVRaR3haZVdWSFJsZE5WbkJhV1ZWYWExWXhTbGRqUlRGWFlsaENURlpFUmtwbFZrcHlXa2RHVTJGNlZuZFdiVEV3VmpBd2VGZHVSbE5pVlZwdlZGWmFjMDVHV1hoaFJ6bFhUV3R3U1ZwVlpHOVdiVVp5WTBoYVYyRXhjRE5XTUZWNFZsWldkR1JGTlZkaWEwcGhWbXRhWVdJeVVYaFZiazVZWW10d1VGWnNaRzlYUmxKWFdrYzViR0pIZUZaVmJYUXdWVEpLUms1WWNGcFdWbkF6V1ZWVmVGZFdSbGxqUm1SWFRUQktTVlp0TUhoV01XUkhWbTVLVjJKRmNIQlZha1pMVjFaYVIxWnRPVkpOVlRWWVYydGFWMVZ0U2xWaVJsWlZWbXh3TTFSVldsWmxWMVpKVkcxb1UyRjZWa3RXVm1RMFdWWmtkRk5yYUdoVFJuQllWV3hhZDJWc1VuUmxSVGxxWVhwc1dGWkhNVzlpUjBwSFkwZEdWMDFXY0ZoV2JYTjRWakZXZFZSc1VtbFNNbWg1VjJ4a01HUXhaRWRpU0U1V1lURndUMVZ0TVZOWFJsbDVUbFU1V0ZKcmNIbFpNRnAzVjIxRmVHTkdRbGROUm5CTFdsY3hSMUl4V25OaFJtUnNZVEZXTTFac2FIZFNNV3hYVjFoc1ZHRXllRlZaYkZaaFZrWnNXV05HWkZoaVJuQXdWRlpTVTJGck1VVlJhbEpZWVRKb1RGWXdaRWRPYlVwSVQxWmFhVmRHU1hwWGJHUTBWMjFXV0ZScldsVmlSMUpZV1d0b1FtUXhXbkpYYkU1VFRWWnNOVlV5ZEd0aGJFcFpZVWRvVm1KWWFETlZNRnB5WlZVeFZscEdUazVYUlVwS1YxZDBZV0V4VlhsVGEyeFNZa1UxV0Zsc1VrTk9SbEpXVjI1T1YwMVdTbHBaYTFwWFYwWkplV0ZHWkZoV2VrVjNWMVphWVZJeVNrbFRiVVpUWVhwV1YxWkdXbXRPUm1SWFkwVmFXR0pZVWxaWldIQkhWMFpyZDFWclRsaGhla1pJVmpGb2ExWXlSbkpTYWxKYVRXNU9ORlpzV2xkak1YQkdUbGRvYVZKdVFrdFdiVEI0VGtkRmVGUllhRlZoTW1oVVdWUktVMkl4Vm5SbFNHUnFVbXhhTUZwRmFHdFhSbHB6WTBWc1lWWlhVa2hXTW5oaFkyMUtSVlZzYUdoTmJXaFZWMVpTUjFNeVRuSk9WbHBRVm01Q2IxUldXblpsYkZwVlVtMUdXbFl3TlhwWk1GWlhWbTFLV1ZGck9WcFdSVm96VmpGYVlWWldUbkZWYkdST1lURndXVlpVU1RGVk1rWkhVMjVPYWxKdGFHRldhMVpoWVVaYVJsZHRSbE5pUjFJeFZrZDRhMkZXU1hoVFdHUlhWbnBDTkZwRVJscGxWa3BaWVVkc1RrMXNTbGxXYlRWM1Vtc3hSMWRyVmxOaVJUVnlWVzF6TVdWV1dYbE5XR1JXVFZWd01WVlhlSGRXTWtwWlZXeG9WbVZyY0VoVmFrcExVbFprYzFWdGFFNWlSWEJhVm10YVlWWnJNVmhXYms1WVYwZDRjVnBYZUdGWFZsWjBaRWhrV0dKR1dsbGFWV2hQVjBaS2MySkVXbHBXVm5CVVZtMHhTMWRXVW5GVmJGcG9ZVEZ3ZVZacVJtdFNNVWw1VW10b2FWSnJOVmhWYlhoM1dWWmFkR1JIUmxwV01HdzBWV3hvYjFaSFNuSk9WbXhhWVRKU2RsbDZSbGRqVmtaMFVteGtUbFpyY0ZoV2JHUXdZVEZhUjFOdVVtdFNSVFZZVkZkd1FrMVdXbkZSV0doWFRXczFSMWRyV210VWJVWnpWMjA1VjJGcmJEUlZha3BQWXpGd1NWWnNVbWxXVm5CVlZtMHdNVkV5U1hoYVNFcFlZbFZhVmxSWGVFdFRWbHBJWkVkMFYxWXdjRmxhVlZwdlZsWmFObEp1V2xWV00yaG9Xa1ZWZUZOV2NFaGxSazVYVW14d1NsWnFTakJpTVUxNFZXNU9XR0pIYUZkWmEyUnZXVlpzYzJGR1RrNU5WbXcwVmpJMVQxWXhXbkpPV0hCWFVucEdNMWxXV2t0ak1rNUZWV3hrVjJKSVFsVldWM0JIV1ZaSmVGcElWbFppV0doVlZXcE9iMWRXWkZoa1IwWlVUVlUxU0ZZeU5VOVpWa3BaVld4U1ZWWXpUWGhWYlhoWFYwZFdSMXBHVm1sU2JrSTFWMVJDWVZZeFdYbFRiR3hTWVRBMWFGWnNaRk5XUmxweFVtMUdhMVpzU2pCWlZWcFBZVlphY21OR2NGZGlSMUV3V1dwR1JtVkdaSE5hUjBaVFlsaG9lRlpYZUc5Vk1WcFhZa2hPV0dKVlduTlphMlF3VFRGYWRFMVZaRmRXVkVaWVdUQlNRMVl4V2paV2ExSlhZbFJHVEZVd1pFZFNiRlp6V2tkc1UySnJTbTlXTW5oWFdWZEZlVlZyYUZWaE1taHpWVzF6TVZkR1ZuUmxTR1JVWWtad01GcFZaREJVTVVsM1ZtcFNXR0V4V25aV2EyUkxZMjFPU1ZKc1dtbGlhMG8yVm0xd1IyTXlUWGxTYTFwUFZqTm9WRmxzYUc5T1JscFlUVVJHVlUxcldqQlZNblJ6VlcxRmVHTkdhRmRoYXpWUFdsVmFZVlpXVG5Ka1JrNXBWbFJXUjFadE1UUmlNVmw1VTJ0a2FsTkhhRmhWYWs1dllVWnNWVkpyT1ZOTlZUVXhWVzE0YjJGV1NsVldibVJZVmpOb2RsbHFTa2RTTVdSeVdrWmthVmRHU25kV1JsWlRVVEExUjFwSVNsaGlXRkpaVldwQ2QxWXhXWGxsU0U1WFlsVmFlVlV5TVc5V2F6RkhZMGh3VjJKWWFISmFSVlUxVmpGd1JrNVhhRTVOUlhCaFZtMTRVMU15Vm5SV2EyUmhVbGRTYUZWc1pEUlZNV3hWVTIwNVdsWnNjSGxXYlRWclZteEtjMk5JYUZaaVdFMHhXVlJHWVdNeFRuRlJiSEJYVm01Q1VWZFdXbUZaVjA1MFZHdGtXR0pIVW5CV2ExWlhUVEZaZUZkdFJtcE5WbXcwVjJ0b1YxWlhTa2hoUm14V1lXdHdkbFl3V210V01WWnlVMnMxVjAxSGR6QldiR1EwWVRGWmVGZHJXbGhoZW14WFdXeG9iMDB4VWxaWGJtUlhZa2hDUjFkcldtdFdNVnBHVjJ4c1dGWkZTbWhaZWtacll6RmtjMkZHV21saVNFSlpWMWQ0VTFJeFRrZGhNMnhPVmxoU1VGbHJWbUZsYkd0M1ZsUkdWazFyY0hsVk1qVmhWakF4ZFZWc2FGcFdSVnBoV2xWYVUyTXhjRWhTYkZKVFlUTkNOVlpzWkRSVk1WbDRXa1ZrYVZORk5XOVZhazVEWXpGV2RHVklUazlXYmtKWFZqSXhNR0ZHU1hkWFZFcFhZbGhvZGxacVFYaGtWMFpJWVVaa1UwMHlhSGxXVnpCNFZERkplRkp1VG1GU01uaFVWRlpXVjAweFduUmpSVTVhVm14c05WWlhkR0ZVYkZwMFlVWkdWMkZyTlZSWk1GcFhaRVUxVmxSc2FHbFNia0pKVm1wS05HRXhVbk5UV0dSWVlXdEtWMVJYTlZOaFJscEZVbTFHVTJKRk5YcFhhMXAzWVZaSmVXRkVTbGRoYTBwb1YxWmtUMVl4VW5WVWJVWlRUVEJLVUZadGNFZFRNRFZ6VjI1U1RsWkdTbkJVVm1SVFUwWmFTR1JIUmxkU01GWTFXbFZhYzFZeVJYaFhibkJWWVRGd2FGa3hXa3RrUjFKSFZHczFWMkV5T1RSV2JGSktaVWRKZUZaWWJGTlhSMUp4VlcweE5GZEdWblJsUlhSVVVteFpNbFZ0TVRCV01ERlpVV3RvV2xaV1ZYaFdha1pMVm0xT1IxZHNaRk5pU0VKNVZteFNTMVl5VFhoYVJteHBVak5TVkZSVVJrdFhiRnBZWTBWT2EwMVhVbnBXTW5odllrWktWazVXYUZwaVJscG9XbFphVm1WVk1WaFBWbkJYWWtoQ05sZFVRbUZWTVZsNVVtNUthbEpYYUZkWlYzUmhWa1p3UmxwRmRGTk5Wa293V1ZWa05HRldTblZSYXpGWFlsUkNORlJyWkVaa01EVldXa2RzVTJKV1NscFhWekUwVXpGYVYySkdWbFJpUlRWWlZXMTRjMDB4WkhKWmVsWlhUVVJHV1ZwVldtRldiVXBWVm01S1YxSXpUalJXYWtaclpGZEdSMWR0YkZkU1ZsbDZWakZhVTFJeGJGaFZiR1JUWW10d2IxVnROVU5YUmxwMFRsVk9WbFpzY0RCWk1GWnJWa1V4VjJKRVZsZFNNMUoyVmxSS1MxTkdWbkpQVm5CcFZrVmFNbFpxUm1GaE1WbDRWbTVLYTFKc2NIQldiWGgzVTFaYWRFMUVSbGROVm5Bd1ZUSjBhMVpIU25KVGJHUmFWak5OZUZwSGVITmpWa3AwWkVkd1RsZEZTa2RXVm1ONFRVWlNjMWR1VW10bGEwcFpWbXRXUzJGR2JIRlRhMXBzVW1zMVdsZHJXbTloVmtsNFUyeG9XRll6YUhaWmFrcEhVakZrZFZWdGVGTmlWa3BaVmtaYVlWbFhWbGRYYTJoT1YwVTFWMVJYZEZkT1ZuQkZWRzVrVjAxcldubFphazVyVjJ4YVJsZHVTbHBsYTFweVdYcEdkMUl4Y0VkYVJrNVhZbXRLWVZadE1IaE5SbGw0VTFoa1QxWlhVbkJWYTFwM1ZrWnNXV05JVG1wV2JYaDZWakl4UjFaR1NuUlZibXhYVFdwRmQxWnNaRWRPYkVweVdrWndUbEpzVmpSV2JYQkxVbTFXVjFac2JHRlNia0pZVld4YWQxZEdaSE5XYlVaVlRWZFNXVlZ0ZEd0WFIwcFlaVWM1WVZZemFHaFhWbHBhWlVad1JWRnNjRmRpV0doYVZtdGtNR0V4WkVoVGJrcHFVakpvVjFsVVJuZFVSbXcyVW0xR2ExSXhXa3BYYTFVeFZUSktSbU5HYUZkaVIxRjNXVlJHWVdSR1NuRlhiRTVwVWpOb1dWWnRjRTlpTWxKelYyNUdVMkpJUW5OWmJGWmhVMnhWZVdWSE9WZE5hM0JLVlZkemVGWXhXWHBSYTJoWFVrVndWRlZ0Y3pWV01YQklZMFpPYVZZeWFGZFdiR1EwVmpKUmVGUnVUbGhpYTNCWldXdGtVMWxXV25GU2EyUlBVbXhzTlZSc1drOVdhekZ5Vm1wV1dsWlhhRXhXYlRGTFZsWktjMVZzWkU1U2JrSTJWbTE0WVZReFdsZFdibEpzVW0xU2NGVXdWa3RaVmxsNVpVWmtXbFpzUmpSV2JUVkxWR3hhZEdGR1pGcFdNMUpNVm1wR2MyTnNjRWhQVjNocFVtNUJkMVpHV2xkWlYwcElVMnhhV0dFeWVHRldiRnAzWVVac1YxZHJkR3RXYTFwYVdUQmFhMVV5U2taalJXeFhZbGhDVEZaSE1WZFNNazVHWWtaU2FWWldjRlZXUmxKSFV6RmFWMWRyWkZkaVZWcHlWRlpWTVZkR1dYbGxSbVJYVWpCd01WVlhjelZXTWtwWllVWm9WV0V4Y0dGYVZsVXhWbXM1VjFwRk5XaE5XRUV5Vm14U1MwNUhTWGhhU0ZKVVlUSm9iMVV3V25kWFJsSldWMjVrYW1KR2NIaFZiVEV3WVdzeFdWRnJiR0ZTVm5CUVdWWmFTMlJXUm5SaFJtUk9WbTVDV1ZkV1VrdFViVlpIVm01V1ZHRjZWbGxWYkZKWFZteGtXR1JHWkZSTlYxSklXV3RvVDJGR1NqWmlSemxXWWxob1lWUlhlRlpsVjFKSldrZHNVMkV6UWpaV2Fra3haREZrYzFkc1pGZFhSMmhZV1ZkMGQxTkdVblJsUjBaclZqQmFTRmRyV2s5aFZrNUdVMjVhVjJKSGFETlZha3BHWlVaT1dXSkdVbWhOYkVwYVYxZDBiMUV5VFhoaVNFcFlZbTFTV0ZSV1pGTlhWbkJHV2tWa2FFMUVSbnBXTW5odlZqRmFObFpzUWxkTlIxSk1WakZhVjJNeVJrZFdiR1JwVW01Qk1sWnJZM2hPUm14WFdrVm9WbUV4V2xkWmEyUnZWa1pzY21GRlRrOWlSbkF3VkZab2ExWnJNVmRqU0d4VlZteGFkbFp0TVV0VFIwWkhXa1p3YVZKcmNFbFdhMVpoVmpKT1YxTnVVbE5pV0ZKVVZGVm9RMU5XV25KYVNIQk9WbXhzTkZZeU5VOWhWa3BIWTBab1dtSkhhRVJWTUZwclZqRmtkVlJzWkU1aE0wSkpWakowYTFJeFdrZFRia3BxVW0xNFdWWnRlRXRVUmxwVlUydGtVMDFXY0ZwWGExcHJZVlphVjJOR2NGZGlWRUkwVkd0a1YxWXlTa2RYYkdSb1pXMTRXbFpYTVRCa01ERkhZMFphYUZOSFVsaFVWVkpIVFZaYVYyRkhkRmROVlhCSFZqSXhiMWxXU2xkalJtaGhVbTFTVEZWcVJuZFNhelZZWVVkb1RsWnRkekpXYlRCM1pVVTFSMWR1VWxkaE1sSlpXVzEwZDFWR1duUk5WazVwVFZaYU1GUldXazlXVlRGWVpVWnNZVlpYVWtoV01GcGhaRVpXYzJGR2FHaE5WWEJWVm0xMGExTXhXWGhhU0U1cFVteHdjRll3V2t0bFZscDBaVWQwVkUxVmJEUlhhMmhQWVVaSmQxZHNhRlZXUlZwTVdXcEdZVkl4WkhSU2JXaE9ZWHBGTUZacVNURlZNVlY1VTJ0b2FGTkZTbGhaYkdodlRURlplV1ZIUm10U1ZFWldWVmN4YzFSdFJYaGpSRnBYVmtWYWRscEVTa2RTTVU1MVZHeFNhVkp1UWxsWFYzUnJWVEpTYzFadVNsaGlSbkJ6Vm1wR1lWTldWblJOV0dSb1ZtdHNORlV4YUd0V01VcEdWMjVLWVZKRldsUmFSVnBMVjFkR1NHTkdUbWxYUjJoYVZqRmFVMU14Vm5SVldHaHBVa1p3VkZsclpGTmpiRlowWkVoa2JGSnNiRFZhVlZVMVlVWmFjbUpFVmxwV1YxSjJWbXBLUzFkV1ZuTmhSMFpUVWxoQ1ZWZFljRWRoTWxKWFZHNU9hRkl5ZUc5YVYzaGhXVlphYzFwSVpGTk5WM2hZVmtjMVQxZEhSWGxoUlRsWFlURmFURlpxUmxOV2JGWnlXa1pTYVZKc2NGcFhhMVpxVGxaWmQwMVdaR3BTVjFKaFdWUkdTMVpHV25STlZXUnFZa2RTZWxaWE1VZFZNVnAxVVd4R1dGWkZiRFJWZWtaS1pVWlNkVlZ0YkZOaGVsWjNWMVpTUTJReGJGZFhibEpPVTBkU2NsUlhlR0ZUUmxwWFlVZDBWVTFXY0ZsV1YzaHJWMjFLV1ZWcVRscFdWbkJZV1hwR2QxSXhVbk5oUms1cFVsaENXbFp0Y0V0TlJURklVMnRrV0dKck5YQlZhMXBoV1ZaU1ZWUnJUbGhTYkd3elZqSjBNR0Z0U2xaT1ZXaFhUVzVvY2xsV1dtdFRSMFpJVDFaa2FWZEZTazFXV0hCSFlURmtSMU51U21sU2JFcHdWV3BHUzFkV1dsaGxSemxTVFZkU1dGZHJXbk5oYkVwWlZXeFdWVlpzVlhoV01GcGhWMFUxVms5V2NGZGhNbmN4VjJ4V2FrNVdiRmRYV0hCb1VqSm9XRmxzYUc5aFJtdzJVbTVrVkZadVFraFZNbk14VmpBd2VXRkdjRmRpV0ZKeFZGWmFVbVZHY0VaaFJsSnBZWHBXVmxkV2FIZGpNV1JIWWtoS1lWSnJOVmhWYlhoelRURlplV1ZGT1ZoU2EydzBWakowYzFadFNsVlNWRUpYWVd0d1RGVXdaRk5PYkVweldrWk9UazF0WjNsV01WcFRVakpGZUZOWWFGVmliRnBYV1d0YWQySXhVbFZSYTNSWVVteHdNRmt3VlRWV2JVWTJVbXRvVjAxWGFIcFdSM2hoWkVaV2RWSnNjR2xTYkZZMFZsUkNZVll4WkVoV2EyaFRZbGRvVkZSVldscE5SbVJZWTBVNWEwMVdiRFJXTVdoM1lVWkplV0ZIUmxkaE1Wb3pWa1JHZDFac1pITlViWFJYWWtadmQxZFhkR0ZVTWtaWFYyNUthbEpGY0ZoWlZFWjNWa1pXVlZKck5XeFNiSEI2VjJ0YWIyRlhSWGhqUmxaWVZqTm9kbFpVUmxkU01WcDFWVzE0VkZJeFNucFdiVEUwVXpGa1IxZFliRTVXVjFKWVZtcENkMU5XV2xoa1IzUlhWakJ3U1ZsVlZtOVdNa3BWVW10NFZrMUdjRmhaZWtaWFl6SkdSMXBIYkZSU1ZWa3lWbTB4ZDFFeVJYaFdXR2hWWVRKU1ZWbHRjekZYUm14WlkwWmtXRkp0ZUhsWlZWWkxWRzFLUjJOSWFGWk5ia0pFVm0xemVGWXhXbkZWYkdScFVqSm9ObFp0ZEd0U2JWWllWbXRrVldKSVFsaFZiRnAyWld4YWRHTkZaRlpOVjFKSlZrZDBZVmRIU2xsVmF6bFhZV3MxZGxZd1dtRmpWazV4VlcxMFRtRXhXWHBXUmxwdlV6RlJlRmRzYUdoU01GcFlXV3RhZDAweGEzbGxSMFpVVWxSR1YxcEZaSGRoVmtwVlZtcFdWMkpVUlRCWlZFcEhVMFpLV1ZwSGNGUlNNMmhaVm1wQ2IxRXhUa2RYYTFaVFlYcHNWRlJXVlRGTlZsVjVUVlZrVmsxclZqWlZWelZyVmpGYVJsTnNhRlpsYTFwWVZXcEdhMk15UmtoalJrNVhUVlZ3VjFacldtRlpWbXhYV2tWa1dGZEhlSEpWYm5CelkwWldkR1JJWkd4aVIzUXpWbXhTVjFZd01YSmpSbHBXWWxob1ZGWnRjM2hXTWs1SVlVWmFUbEl4U2xWV1ZFSldUbFprU0ZKclpHRlNNbWhQVkZWV2QxZFdXblJOU0dSc1VqRmFlVlJzV210WFJtUklaVVpXV21FeGNHaFdWRVpoWTJ4YWRGSnNaR2xTTTJoWFZsY3dNV0V4WkhOWGJsWlNZa2RvV1ZsVVJuZFZSbHBWVVZob1dGWnJXbmxaVlZwcllWWmtSazFVVWxoV2JGcHlWbXBLVG1WR2NFZFdiRkpwVWpGS1VGWnRjRWRUYlZaelYyNUtWbUV6VWxaWmJGcGhVMFprY2xkdVRtaFNhMnd6VmpKNFUxWXlSbkpqU0ZwaFVqTm9hRlpzV2tkak1XUnlUbFprYVZJelkzZFdiWGhyVGtac1YxcEZhRlJpYkVwWFdXeFNjMVl4YkhOaFJ6bGFWbXhLV1ZwVldtdGhNVWw0VjJ0c1lWSldjSEpXUjNoaFpGWkdjVlpzWkdoaE1uUTBWMWh3UjJFeFRrZFRiR3hwVW14d2NGbHRkRXRoUmxwMFRWUlNhMDFXU2toV01qVlBWMGRLVmxkdVJsVldNMUpvVlRCYWEyTnNXbFZTYkdST1VrVlpkMVl5ZEZOWlZsbDVVMnRvVm1Gck5WZGFWM1JoVXpGd1ZsZHRkRmhXTUZwSVZtMHhjMVV3TUhsaFNGcFhZa2RTTTFaRVJrWmxSbVJ5V2tkc1ZGSlVWblpXVnpWM1l6RmtWMWR1VWs1V2F6VlpWbTAxUTFZeFdYbGplbFpYVFVSR1JsVnRkR0ZXYkZsNlVXeFNWMDFxUmtkYVZXUlBVMGRHUjFwRk5WTk5WWEJPVm14U1IxbFdTWGxWYkdSV1ltczFhRlZxU205aU1WSlhZVVZPVldKR2NIcFdWM1JyVjJ4YWMxWnFWbGRTYldoMlYxWmFUMUl4VG5OVmJIQm9UVmhCZWxaclVrZGpNVnBYVTI1V1ZHSllhRmhaYTJoQ1pERmFSMWRzVGxKTlZtd3pWRlphYTJGV1NrWk9WbHBYWWxob00xcEhlR0ZqTVhCR1drZHdUbFpVVmpaV01uUnJVakZaZDAxSWFGUlhTRUpZV1d4b1UyRkdXbkZUYXpsWFRWVTFNVlpYTVRCVk1EQjRVMnhzV0ZZelVuWlZWRUV4WXpGa2RWSnNVbGhTTW1oNFZrWmFZV013TlVkWFdHeFBWbTFTVjFsc1ZuZFdNVmw1WlVjNVdHSlZWalZXVjNoUFZsWmFWMk5IYUZkaVJuQk1XWHBLVDFOSFVrWk9WazVUVm01Q1RWWnFSbUZXTWtWNFUxaG9WMWRIZUZWWmEyUTBZakZWZDFwSE9WaFNiSEI0Vmtjd05XRkdTblZSYTFwV1RXNU5NVmxYYzNoV01XUjFZMFprVG1KdGFHOVhWbHBoVXpGYVYxZHVUbE5pUjFKWVdsZDBTazFHV2toa1IwWllZbFphU0ZkcmFGZFdiVVkyVm14U1ZtSllhRE5XTVZwaFpFZFdSMVJzVGs1V2JYY3dWMWQwYjFNeFduUlRhMmhXWWtkb1ZsWnRlSGRsYkZKMFpVZEdWMDFyV2tsYVJWcHJWRzFGZWxGdFJsZGhNbEl6VmxSR1lXUkdTblZUYkdocFVsVndhRlpHWXpGaU1XUkhZa1JhVkdGNmJGVlZha0ozVTBac1ZsZHJPVlZpVlhCWlYxUk9iMVl5U2xsUmEyaGFZV3R3VTFwVldrOVhWMHBIVjJ4b1UwMXRhRmRXTVdRd1lURlZlRnBGWkdsVFJrcHpWV3hvVTJOV1VsZFhiVVpzVW14V05Wa3dXazlXTURGWFkwaHdWMDFxVmpOV2FrcExWbFphZFZOc1pHaGhNRmt3Vm0xd1MxUXhUbGhVYTJSaFVsUldiMWxVUm5OT2JGcDBaRWQwVDFKdGVGbFdSelZQVjBkS2NsZHNaRnBoTW1oRVdXcEdVMVl5UmtaVWF6VnBVbTVDTmxac1pEQk5SbHBHVFZaYWFWSkdXbGhWYWs1VFkyeGFkRTFWZEZSV2Exb3hWVmQ0YTFSc1NYaFRha1pZWWtkUk1GWXlNVmRTTVhCSlZXeE9hVmRGU2xCWFZtaDNVbXN4UjFkdVVrNVNSVnBWVkZaa05GZEdWWGxPVms1b1VtdHdlbFV5TVVkWGJVcElZVVpTVjFKV2NGZGFSRVpyWkVaS2RHTkdaR2hsYkZwWVZteGpkMlZIU1hoVmJrNVlWMGRvVlZsVVNqUlhSbXhZWkVoS2JGSnNjRVpWYlRGSFZrWktjbU5FUmxaTmJtaDJXVlphU21WR1RuTmlSbWhYWld0R05GWldVa2RVTVVsNVZHdGFhRkl6YUZSVVZWcDNaVVphZEUxWWNFNVdNVnBZV1RCV1lWbFdUa2hWYlRsV1lXdGFhRnBYZUZwbFYxSkZVV3hvVTJKSVFraFdWRWw0WWpGa2MxZHJXbGhpUmtwaFdsZDBZVlZHY0VkWGJVWnFUVlUxTUZscldrOVdNV1JHVTIxR1YySllhSEZhVlZVeFUwWldXV0pHVm1saGVsWlpWMWN4TUZsV1dsZGlTRXBYVmtWYVdGVnRlRXRYUmxsNVpFUkNhVkl3Y0VsYVZXaHpWMGRGZVdGSVNsZGlXRTQwV1RJeFQxSXlSa2RYYXpWb1lrWndOVlp0Y0VOWlZtUjBWbTVPVjJKc1NtOVZha0poVmtaV2MyRkZUbGhXYkhBd1dUQldhMkZGTVhKTlZGSmFUVVphY2xZd1pFdFhSMFpHVDFaYWFFMVlRbTlXYlRFMFYyMVdSMXBJVWxCV00xSlBWbTB4TTAxR1dYbGtSbVJvVFZkU1NWVXlOVTlXUjBweVkwWmtXbFl6VFhoV2ExcGFaREZrZFZSdGNHbFRSVXBKVm10a05GVXhXWGxUYTJ4U1lraENXRlZ0ZUhkalZsSnpWMnh3YkZKdFVqRldSekZ6VlRGS2RWRnNiRmRpV0VKUVZWUkdWMUl4WkhWVWJHaHBWbFp3V1ZaR1pIcE5WazVYWWtaYVlWSlhVbGRVVmxwM1pXeGFkR05HVGxkTmEzQmFWVmQwYjFZeFdrWmpSVGxoVm14d1ZGa3llSGRUUmtwelZHczFhV0pYYUdGV2FrWmhWVEZSZUZKWWFGVmlhelZaV1cxNFMyTnNWbkZVYkU1V1VteGFlRlZYTlU5VU1WcHpWMjV3V2xaWFRURldNbmhoWTJzMVZscEdjRTVTYkZWNFZtMHhlbVZHVGtkV2JGWlNZa2hDVDFadE5VTldWbHAwWlVkR1ZVMXNTa2RVTVZwcllXeEtkRlZ1UWxaTlJscElWR3RhV21WR1ZuSlViR1JPWVRGWk1GWnFTakJaVmxKelYyNVNiRkpyTldGWlZFcFNUVVpzVmxkdFJtcE5XRUpJVmtkNFUxVXlTbGxoUm1SWFZucENORlZxU2tkamF6RlpVMnM1VjFadVFsaFdiVFYzVWpGT1IxZHNWbE5pVlZweVZtMTBZV1ZXVWxkWGJYUm9VbFJHZVZSclVrTldNV1JKVVd0NFYxSjZSbGhWYWtaWFpGWmFjMVJ0YkZOV1Jsb3pWbXhrZDFJeFRYaFdhMlJoVW0xb1QxVXdaRzlqUmxKWFYyNWtXRkpzYkRWYVZXTTFZVWRLUm1OR1pGcE5SbFV4Vm1wS1MxZFdVbGxoUmxwT1VtNUNiMWRyVmxaTlZscHlUMVprYUZKck5VOVZNRlpMV1ZaWmVXVkdaRnBXYkZZMFZqRm9jMVpIU2tobFJtUmFWak5OZUZZd1duTldWa3AxV2tkb1UySnJTa2hXTW5SV1RsWlZlVk5zWkZSaE1taFlWRmMxVG1WR1duRlNiVVpUWWtad1dsZHJXbXRoVmxwR1UxaHdWMUpzY0doV01qRlhWakZPZFZac1ZtbFNhM0IzVjFkMFYyUXhaRWRhUm1oT1ZrVktZVlp0ZUhkbGJGbDVUbFpPVldKR2NIbFpNRlUxVm0xS1ZWWnJVbGROVm5BelZtMTRkMUpXUm5SaFIyeFhWMFZLUzFadGVHdGtNVVY0WWtaa1ZHSkhhRmRaYlRWRFYwWmFjbFpyWkU5U2JGWTBWakowYTJGck1YSlhhMmhZWVRKU2RsbFZWWGhqVjBaRlZHeGtUbFl5WjNwV1YzQkxVbTFXVjFWc2JHaFNNRnBWVld4b1ExZHNaRmRoU0dScVRWZFNTRmxyYUU5WlZrbzJZa2M1Vm1KWWFETlVWVnB5WkRGYVZWWnRhRmRXUlZwWlZtcEtNR0l4V1hsVGJGWlhZVEpvV0ZaclZuZFVSbGw0VjJ4a2ExWnJjSHBYYTJSelZqRktWMk5HV2xkTmJtaHlWR3RrVDJSR1ZsbGhSMFpVVW10d2VWWlhNSGhWTVZGNFYyNVNUMVpWTlZWV2JYaDNaVVpXZEUxRVZtaGhla1pZV1d0U1QxWldXblJoUm1oWFlsUkdURll3WkVkU01rcEhXa2RzVjFKV2NGWldiWGhUVWpKUmVGZHVUbUZUUmxwb1ZXMXpNV05HVm5GU2EzUlBWbXh3U1ZwVlpFZGhSVEZ5VjJ4b1YwMVhhSHBaVlZwTFVqSk9SMkZHY0doTmJFcFZWa1pTUjFsV1NsZFRia3BZWWxob1ZGbHJXbmRaVm1SWFZtMTBhazFXY0VoVk1uaFhWakpLYzJOR2FGZGlia0pZVkZSR1lXTldTbk5UYlhoVFRVaENTMVpVU2pSaU1rWlhWR3RhVkdKRlNsbFdhazVUWVVaa1YxWllhRk5OYXpWSVZqSjRhMVl4U25OalJteFhZbGhDUkZwRVJrcGxSMFY2V2taYWFFMUVWbWhXYlRFd1pERmtSMVpZYkd4U2VteFlWRmQwZDFkc1draGpSazVZWVhwR1dGa3daRzlYYXpGMVlVWm9XbVZyV2pOVmFrWjNVbXMxVms1WGJGZE5iV2Q1Vm0weGQxTXdOVWRpUm1ScFVtMVNXVll3WkRSV01XeHlXa1pPV0ZKdGVEQlpNM0JIWVVaS2MxZHVhRlpOYmtKVVZqQmFTMk14WkhGUmJVWlhWakpvYjFkWGRHRlpWMDE1Vkd0c2FWSnRVazlaVjNSaFUxWmFjVk5xVWxoaVZrWTBWakkxUjFadFNrZGpSVGxhVmpOb2FGWldXbXRXTVdSMFVteFNUbFpYZHpGV2EyUXdZVEZhV0ZOcmJGSmlhMHBYV1d4b2IwMHhiSEZTYlVacVlrWmFlVmRyV210VWJVWTJWbXhzVjJKSFRYaFdWRVpYVWpGa2RWUnNVbWhsYlhoWlYxZDRVMVl4U2tkWGJrWlRZbFZhV0ZadGRIZE5SbEY0V2toT1ZXSkdjSGxXTVZKRFZqRmFSbGR1V2xwV1JWcGhXbFphUzJSV1VuTlZiV3hUVFcxb1dWWXhXbXRsYXpGWFYydGthRTB5ZUhOVmJUVkRZMnhTVjJGRlRsTk5WMUo1VjJ0b2ExWlhTa2RpUkZKV1RWZG9jbFpxUm1GT2JFcFZVVzFHVTFKWVFrbFdiWEJIVkRGa1dGSnJaRlZpUjJoVVZGWldkMWRzV25STldHUlZUVlpXTlZWdGRHdGhiRXBYVjJ4U1dsWkZOVVJaZWtaWFpFVTFWbFJzVW1sU2JrRjNWa1phVjJFeFduSk5XRXBxVW0xNFlWWnNXbmRYUmxweFUydDBXRlpzV25wWlZWcHZWakpLU1ZGdWJGaFhTRUpJV2tSR1QxWXhWblZVYlVaVFRXNW9XbFpYTVRCa01EVlhWMjVLV0dKVldtRldiWE40VFRGU1YxWnRkRmROVjFKSldsVm9UMVpyTVVkV1dHaGFZV3RhV0ZwRlpGTlRWbkJIVkdzMVYyRXpRVEpXYlhCS1pEQTFWMWRZYkZOaGJIQlVXVlJLTkZsV1duTlhiVVpYVW14d01GbDZUbTlWTURGeVRsVm9WMVl6YUROV1J6RkxaRVp2ZW1OR1pGZE5NRXBKVm14U1MxUnRWbGRUYmtwaFVteGFjRlpxVG05WFZtUlhWV3R3VDFJeFdsaFdNalZUWVd4S1dWVnJPVlpoYTBwWVZGUkdVMk14V25Sa1JtaFRUVVpaTVZac1pEUldNV1IwVTJ4c1ZWZEhhR0ZVVmxwM1YwWnJlRmRyWkd0U2EzQjZXVlZhVDJGV1RrWlNhbEpYVFZaS1JGZFdaRVpsUmxaMVUyczFWMkpXU25oV1Z6RTBaREZaZUZkdVVrNVdlbXh5V1d0a05GZFdiRFpVYlRsWFRVUkdXVlpYY0VkWGJVVjRZMFJPV2xaV1ZqUlpla1pQWTFaa2MxcEhiRk5oTTBKS1ZtcEdZVmxXYkZkWFdHaGhVMFphVmxsclpGTmpSbFp4VTIwNVdGWnNjRWhXVjNRd1lWVXhjbUpFVWxkTlYyaDJWakJrUzFac1pITlhiRlpYVFRBME1GWkhkR0ZYYlZaV1RsWmFVRll5YUZSWlZFNURWakZhZEUxVVVtbE5WbkF3VlRKNGMxWnRSbkpPVjJoV1lXczFkbGt5ZUZwa01YQkhXa1pPVGxkRlNrcFhhMVpXVFZaWmQwMVdXbXBTYmtKWVZGWmFTMUpHWkZkWGJrNVhUVmRTTVZaWGVFOVhSa2w0VTJ4R1YySlVRalJVYTFwYVpVZEtSMkZIZEZOWFJrcFFWa1phWVZZd05VZFhXR3hPVmxkU1YxUlZVa2RsVmxsNVpFaE9WMVpVUmxoWk1HaExWakpHY21ORmVGWk5WbkJJV1hwS1MxSXhjRWhoUjJoT1lteEZkMVpxU2pCVk1VbDRZa1pvVldKcmNFOVdiVEZUWVVaV2NWUnJUbGRTYlhoNlYydGpOV0ZWTVZkalJteFZWbXhLVkZsVVFYaGphelZaWTBad1YxSlVWalpXYTJRMFdWWmFXRk5yWkZaaVJscFlXV3RvUTFSV1drZFdiVVpyVFZad2Vsa3dWbTlWUmxwelYyNUNWbUZyV2t4Vk1GcGhWMGRXU0U5WGNFNVdiWGN4VmxSS05HTXhWblJTV0d4b1VtMW9XRmxVUm1GaFJscFdWMjVrVTJKSFVqQlZiVEYzWVZaYVYyTkZiRmRoTWxFd1dXcEdWbVF3TVVsaVIyaFRZbFpLV1ZaR1dtRmtNVnBIVm01R1ZHSkZjSE5XYlhoTFpWWmtjbGR0ZEdoV01Ga3lWbTB3TlZZeFdYcFZiV2hXWld0YWNsVnFSbGRqTVhCSVVteE9VMkV6UWpaV01XUXdXVmRSZUZwR1pGWmlhelZZVm10YVlXSXhWblJrU0dSc1ZtMTBNMWxWYUd0WFIwWTJVbXRvV2sxSFVuWldha3BMVjFkR1NGSnRSbGROTW1oWlZtcEdZV1F4U1hsVWEyUmhVbXMxV0ZsdGRFdFVNVnB4VTJwQ1YwMXJWalJXTVdodlZrWmtTR1ZHVWxwV1JYQlVXVEZhVjJSRk1WZFViR2hUWWxob05WWXlkRk5VTWtwSVUydGthVkpHU2xsWlZFWkxVa1pzVmxaWWFGZGhla1pXVmxkNGExUnNXWGxoUkVwWFlsaG9jbFY2U2s5a1JsSnlXa2RvVTJKclNuWldSbHB2VVcxV2MxZHVSbEppVlZweVZGWmtVMU5XV2xoa1IwWm9Za1Z3VmxadGVGTlhiVXBIWTBWNFYwMVdjR2hhUlZWNFUxZEdSMVJyTlZkTlZYQkxWbXhTUzA1SFJYaGFSV2hVWW14YVUxbHNWbUZaVmxweFZHczFiRkpzU2xaVmJURXdWakF4V0ZWdWJHRlNWMUYzVmxSQmVGSXlUa1prUm1SWFlsWkZkMVl4V210U01VNUhVMnhzYWxKcmNHOVpWRTVEVjFaa1YxVnJaRnBXTUZwSVZqRm9jMVJzV25SVmJHeFdZbGhvVEZwV1dscGxWVEZXV2taYVRsSkZTWHBXVkVvMFVURlplVk5zYkZKaE1taFhXbGQwWVZWR1ZuRlNiWFJxWWxWYVNWcFZXazlVYkVwMVVXcE9WMkV4Y0hKVVZWcGFaREExVmxwR1pGaFNNMmg2VmxSQ1ZrMVdXWGhpU0U1WFltMVNWVlZ0ZUZkT1ZsSlhXWHBXVjAxRVJubFdNalZ6VmxkS1IyTkdVbGROYm1ob1ZtcEtUMUpXVW5OWGF6VlRUVlZ3V2xac1VrTmhNVlY0VTFob2FsSlhVbWhWYWtwdlZERlpkMVpyV214U2JIQXdXa1ZhVDFVd01WaGxSbWhYVW0xb2RsWnRNVXRqTVU1elZteHdWMUpXYjNwWFZFWmhWakpPYzFwSVZtRlNiV2hZV1d0b1EwNVdXblJOVkVKT1VqQldOVlV5ZEd0WFIwcEhZMFprV21KSGFIWlpNbmh6VmxaS2NtUkhjR2hsYkZwaFYxUkNZV0V5UmxkYVJXaG9VbXRhV1ZadGVIZGhSbVJYVjJzNVZGSnNjSGxYYTJSelZUSktXR0ZHYkZoaVIxRjNWV3BCTVZJeFpITmFSbHBvVFd4S2RsWkdXbGRqTURWWFZtNU9hRk5IVW05V2JYUnpUbXhzVmxkc1RsZFdiSEJZV1RCU1QxWXlTbGxoUjJoWFRVZFNXRlZxUmxOak1WSnlUbFprVGxaWVFrdFdiWEJMVFVkSmVGUllhR2xTYlZKVldWUkdkMVpXYkhKYVJrNVhZa1p3ZUZaSGVFOVVhekZaVVd4b1YwMXVhR2haYTFwaFZsWktjMXBHYUdoTldFSjVWbXRqZUZKdFZrZGFSbFpUWWtkU2IxUldhRU5OYkdSWVkwVmtXbFl3TVRSWGEyaExWMGRLV1ZGc1VsZGhhM0IyV1ZWYVlWSXhiRFpTYkZaT1VrWmFTVlpxU1RGU01WcElVbGh3Vm1KR1dsZFpWM1JMWVVaVmQxZHRSbFJTTVZwSFZERmFhMVJ0UlhwUmFsWlhWa1Z2TUZsNlJscGxWazV6WWtkb1UySkZjRmhXYlhSWFpERkplR05HWkZoaVZWcHlWbTF6TVdWV1VuTlhiWFJYVFVSR1Yxa3dhR0ZXTWtwSFUydFNWMkZyV25wV2FrWnJZMnh3U0dKR1VsTmhNMEpSVm0wd2VHVnJNVmhVYkdScFUwVndXVmx0TVZOVU1WWjBUbFZPVjAxWGVGZFhhMUpEVmpGWmQyTkZhRnBOUjJnelZqSnplRkl4VG5KVmJHaFhZa2hDYjFacVFtdFNNVTVYVkc1T1lWSXllRlJVVmxaM1UyeGFjbGt6YUU5U2F6RTFWa1pvYjJGc1NsaFZia1pXWWtaS1dGWnJXbk5XVmxKeVZHeGFhVkp1UVhkWFZFSlhWREZrYzFkdVVsWmhhMHBZV1d4U1YxVkdXbFZUYTNScVlsVTFTbFV5ZUdGaFZtUklZVWM1VjJGclNtaFhWbVJUVW1zMVYxZHNVbWxYUjJoWlYxZDRZVk13TlhOWGJsSk9VMGRvVDFWdGVIZFdNVkpYVjIxR1ZVMVdjREJaVlZwdlYyMUtSMU5zYUZkaE1YQjZWbXBHYTJOdFVraGpSVFZYVmtaWk1sWnRlR3RPUjBWNVVtdGFUbFp0ZUZOWmJGSnpWMFpXY1ZSdE9XaFNiVkpZVjJ0Vk1XSkdTWGRPVldSYVlUSlNTRlpVU2tkT2JGcHpVV3hrYVZkRlNsRlhWM0JIWVRGSmVGcElTbWhTTTJoVVZGVmFkMlJzV2tkWGJYUldUVlUxV0ZadE5VOWhSazVHVGxab1dtSkdXak5XTVZwelZteGtkR1JHYUdsV1Zsa3hWbXhrTkZVeFdYbFNXR2hxVTBkNGFGWnRNVk5YUmxaeFVteE9hazFZUWtsWmExcHJWakpLY2xOcmRGZGlWRVYzV1ZSQk1WSXhXbGxpUms1cFVqRktWbGRYTVRSWlZsVjRWMWhrWVZKck5WbFZiWGhoWlVaYVNFMUVWbWhOYTNCSldsVmFZVlp0U2xWU1dHUmFWak5PTkZZd1dsZGpWa3B6V2taa1RrMXRhSFpXTVZwWFZtMVdTRlJZYUZWaWJFcHZWVzB4YjFkR2JISldibVJWVm0xU1dWa3dWakJXVlRGeVRWUlNXR0V5YUZoV2EyUkxVMGRHU1ZGc1pHbFNia0Y2Vm1wS05GbFdaRVpOVld4aFVsUnNXRlpyV21GT2JGbDVaRWM1VkUxWFVrbFZNbmhYWVZaS2RHRkdXbGRpV0dob1ZGUkdXbVZYVmtkYVJtaFRUVVJGTWxkV1ZtRmlNVlY1VTJ0c1VtRXlhRmhXYTFaMlRVWnNWVkp0UmxoU2F6VjVWMnRrZDFVeVJYZGpSbXhZVm0xUmQxZFdWWGRsUmxwWllVWm9hR1Z0ZUhsV1YzQkNUVlpPUjFkcmFFNVdlbXhXV1Zod1IxSXhhM2RYYTNSWFRXdHdXbGxWYUV0V1YwVjRZMGh3VjAxR2NGaFdNVnAzVW1zMVYxcEhiRmRoTTBKb1ZtMHhkMUV5UlhsVFdHaFlWMGRvY0ZWdGVHRldiR3hWVVZSR2FsWnNTbGhXTWpGSFZHeEtkVkZzWkZwV1ZsVXhWbXhrUjA1c1NuTmhSbHBPWW0xb01sWnRjRXRUTVZwWFVteFdVMkpIVW05WlZFNURWRlphZEUxSWFGVk5WWEF3VlRKMGIxVXlTa2hWYkdoYVlsaFNURll5ZUdGa1IwNUdZMGQ0VTJGNlJUQldNblJoWWpGVmVWSlliR2hTZW14WFdXeG9iMDB4YkRaU2JrNVhWbXR3TVZkcldtOVdNa3BKVVZoa1dHSkdXbkpWYWtaaFZtc3hXVlJzVW1oTmJFcFhWa1phWVdReVVuTmlSbVJZWVROU1dGWnRlSGRsYkd4V1YyeGtWMDFyY0VoWmFrNTNWakpHY2xOdGFGaFdiVkpQV2xWYVlXUldUblJrUms1T1RXMW9NbFl5ZUd0TlJteFhXa2hPV0dKSGFFOVZhMVpoVmxaU1YxZHJkR3hpUm13MVdsVmpOV0ZHU25KT1ZXUlZZa1p3Y2xZeU1VWmxWbFp6Vkd4V1YxWnVRbWhYYTFKSFlUSk5lR05GYUdwU2JWSndWV3hvUWsxV1duUmtSM1JQVW14V05GWnNhSE5XUjBwSVpVYzVWbUpVVmtSV01GcFhaRWRXU1ZwR2FGTmlXR2hYVmxjd2VFMUdWWGROVmxwUFZtNUNZVlpzV25kV1JteFdWbGhvYTFZd1draFhhMXB2VmpBd2VGTnRPVmhoTVVwTVZXcEdTbVZHY0VsVWJHUnBVbXR3ZGxaR1VrZFRNVnBYV2tab2ExSXdXbkpVVjNoaFUwWlplV1JIT1dsU2EydzJWbGQ0WVZkdFNrZFhhazVoVm14d1YxcFdaRTVsYlVaSFdrVTFhRTB3U2xoV2JGcHJaREZWZUZkWWJGTmlhM0JaV1d0V1MxWXhiRmhrUjBacVlraENTRll5Y3pWaE1VbDNZMFZvVjFKNlJucFdha3BHWld4R1dXSkdaR2hoTWpoM1YxWlNRbVZHU1hsVGEyUm9VbTFTY0ZsWWNGZFhiR1JZVFZSU1ZFMXJOWHBXYlRWSFZsZEtSazVZUmxaaVdHaE1WakZhZDFac1duRlJiR2hUWVROQ05sZFVRbTlrTVdSelYyeG9WVlpGV2xoWlYzUkhUa1pyZVdWSGRGZFdhelY2V1RCa2IxUnNaRVpUYkVwWFlsaENTMXBWV2t0a1JscHpXa1phYVZKc2NGVlhWM1JoV1Zaa1IxWnVUbGhpYlZKUVdXdGtVMVpzVlhsalJrNVlZa1pzTkZVeWRHdFdWVEZYWTBoYVdsWldjRXhhUlZwWFpFVTVWMVpzWkU1TlJXOTVWbXRrTkZsV2JGaFVXR2hvVFROQ2IxVnNVbGRXUmxweVZtMUdWRlpzY0hoVk1WSkhWbFV4V0ZWcmJGWmlSMmgyV1ZkNFQxSnNaSE5hUmxaWFZtNUNiMVpHVWtkaE1WbDRXa2hXVldKSGFGUlVWbFozVTJ4YVdFMUlhR3ROYTFwWVZUSTFWMVZ0Um5OalJtaGFWak5TTWxSVldtRlNWazV5V2tkd2FHVnJXbGxYVjNSaFV6SkdSazFZVm1oU2VteFlXV3hvYjJGR2NFVlRhemxxVFZkU1dsZHJXbTloUlRCM1UyNXdWMkpVUVhoVlZFWkxZekZrYzJGSGVGTk5NVXAyVmxkd1ExWXdOVmRWV0doV1lYcHNXVlZ0ZUhOT2JGWllaRWM1VjJKVmNGWlZiWGh2VmpKR2NsZHNRbUZTYkhCVVdrVmtSMUl4VW5SaVJrNVlVbFZzTmxadE1UUmhiVlpHVGxWb1ZsZEhhR2hWYlRGVFlVWldkRTFYT1ZWTlZtd3pXVlZXVDFaVk1WZGpSRUpWVm14S1ZGWXdXa3RqTWs1SFlrZEdWMVl3TUhoV2JYaHJVekZPUjFadVNtcFNiSEJZV2xkNFlWVldXblJOU0doVVRWWndXRlV5ZUhOWlZrcHpWMnhvVm1KR2NETmFWbHByVmxaT2NWVnNjRmROUkZaWlZsY3dNVlV5UmtkVGJGWlhZa2RvV0ZSVldtRlRNVkpZWlVkR2FrMVdXbmxhUldRd1ZHeGFXR1I2UWxkaGExcDJXV3BHWVZOR1NuVlViWEJUWWtWd1dWWkdWbXRWTVZwSFYxaGtXR0pyTlZsVmFrWkxVakZrY2xaVVZsWk5hM0JLVlZab2ExWXhTbk5qUm1SVllrWndhRlZxUm10WFZuQkdUMVprVjAxdGFHOVdiVEUwV1ZkUmVWUnVUbGhpUmxwVVdXeFdZVlpHVWxkYVJrNVhZa1pXTlZwVlpEQldWMHBIWWtSU1ZrMVhhRE5XYWtaaFpFWlNjVlZzWkdoaE1YQk1WMnhXYTFReFNuTmFTRkpUWWtVMWNGVXdWa3ROTVZweldraGtWVTFyYkRWV1ZtaHZWMGRLU0dGRk9WWk5SMUoyVm1wR1UxZEhUalpTYkZKVFlsaG9OVmRXVmxaT1YwWkhVMjVLYVdWcmNHRlpWRVozWVVaYWMxZHRSbXRTYkZwNlZsZDRhMVJzV25WUldIQlhZbFJGTUZsVVNrOWphemxYV2tkR1UxWkdXbFZXVjNoaFpHc3hWMWRZYUdGU1JVcFhWRlphVjA1R1pISmhSazVXVFZkU1NWcFZZelZXYlVwWlZXdDRWMDFXY0doYVJXUlhVMVp3UjFac1RtbFhSMDQxVm14U1MyVnJOVmRYYTJSWVltdHdjVlV3YUVOWFJsSllZMFZrYkdKR2NGWlZWbWh2WVRGSmQxZHJhRmROYm1oeVdWWmFZVkpzV2xsYVJtUk9WbTVDYjFacVNYaFdNVWw1Vkd0YVdHSlhhRlJaYTFwM1pHeGFSMWt6YUdsTmJGcFlWako0YjFSc1RraGhTRUpWVm0xU1ZGVXdXbk5qYkdSeldrWmtVMkpJUWtsV1ZFa3hWREZaZVZOc2JHaFNSVFZvVm1wT2IyTnNhM2xOVldSVVVqRktTRmRyV2s5V01VcFhZMFp3VjAxV1NrUlhWbVJLWlVaa1dXRkdVbGhUUlVwWVYxY3hOR1F4YkZkaVJsWlRZbTFTVmxWdGVIZE5SbXQ2WTBWa1YwMUVSbmxaTUZadlYyc3hSMk5JU2xkU00wNDBWbTB4VDFKck5WZGFSVFZwWWxkb05WWnJaREJaVm1SMFZteGtWbUpzV2xaWmJGWmhWbFpXYzJGRlRtbE5WbkJaVkZWb2IyRlZNVmRqUldoYVlUSm9WRmxVUmt0WFZsWnpWbXhhYVZaRldsVldiVEUwVmpGa1JrMVdXbUZTYlZKVVZtdFdZVmRXV2xWVFZFWnJUVlp3ZVZSV2FGZGhSazVKVVd4b1YySnVRa2hWTUZweVpWVXhWazlXVGs1aE1YQkpWMVJDWVdFeFVuSk5WbHBxVTBad1dGbHNVa1prTVdSWFYyeHdhMDFFVmxwV1IzaFRZVmRHTmxac1pGaFdNMmgyVmxSR1lWSXlTa2xUYkdocFlsWktVVmRYZEd0Vk1XUkhWMjVTVGxaWFVsaFVWVkpIWlZaWmVXUkhkRmRXYkhBd1dWVmFiMWRzV2xkalJYaGhVbGRTV0ZWcVNrdFNNWEJJWWtkc2FFMUlRa1pXYWtvMFZqRnNWMWRZYUZoaVIxSldXVzEwZDJOV1ZuRlViVGxYVW0xNGVWbFZWazlVTWtwSFkwUkNWVlpzU2xSV2JYTjRZMnhrYzJGR1pFNWliRW95VjFkMFlWUXhUa2hTYTJSb1VtNUNjRlZ0ZEhkU1JtUnpWbTFHVjAxV2NGaFZNalZMVlVaYWNrNVZPVnBXUlRWRVZURmFZV05XVG5GVmJXaE9ZVEZ3V2xaVVNqUmhNVnBJVTI1T2FsSnRhRmRaYkdodlRURnNWbGR1VGs5aVJWcFdWVzE0VDFSc1duVlJXR2hYWWtkT05GcEVSbFpsVms1eldrWlNhVk5GU2xwV2JYQlBZakZrUjFkdVJsSldSVnBZVkZkMGQxTkdXWGxsUnpsb1ZteHdTVnBWV25kWFJsbDZWVzFvWVZKRlJqUlZha1pyWXpKR1NHUkdUbE5oTTBKYVZtdGFhMDFHYkZoV2JHUllWMGQ0VUZac2FGTlhWbXhaWTBWa1dGSnRkRE5YYTJNMVYwZEtWMWR1YkZkTmJtaDJWakp6ZUdSV1VsbGhSbVJvWVRGdmVsWlVRbXRUTVVsNFkwVmtWV0Y2Vm5CV2JYUlhUbFphZEUxSVpHeFNNVVkwVmtab2ExUnNXbGhWYmtKV1lsUkdWRll4V2xwa01YQkhWR3hhVTJKSVFqWldha2t4WVRGYWMxTnVUbXBTUlVwb1ZteGtiMk5zV25SbFIwWnFUV3MxU2xrd1dtOWhSVEZ5VFVob1dGWnNXbWhWZWtwT1pVWndTVlp0Y0ZOaWEwcFpWbTB4TkdReFZsZFhibEpPVjBoQ2MxVnRlSE5PUmxwSVRsVTVXbFpyY0RCV1Z6VkRWakpGZUZkdGFGWk5WbkJ5Vm1wR1YyTnNjRWRqUm1ST1VrVlZkMVp0Y0VwTlZrbDRWMjVTVkdFeWFGZFpiWFJMVjBac1ZWSnRSbFJTYkVwNVZqSXhNRmRHU1hoVGEyeFdZbGhvVkZaSE1VdFNiVTVHWTBaa2FWSXhSak5XYlhCSFYyMVdWMVJ1U21GU00wSlVWbXRrTkdGR1duUmpSVGxwVFd0YVNGWnROVTlYUjBwV1YyNUdWVlpzY0ROVVZWcFhaRWRXUjFwR1ZtbFNia0phVjJ0b2QxSXhXWGxTV0d4V1YwZFNXVlp0TVZOU01YQldWMnM1YTFac1NqQlpNRnBQWVZaWmVXRkdiRmROVjFGM1YxWmFjMVpyTVVsaFJtUllVakpvV2xkWGVHOVZNV1JYVm01T1ZtRXlVbGhaYTFwM1YxWndWbGR0ZEZkV01IQklXVEJTUjFac1dYcFJiV2hYWVd0d1RGVXdXbE5YVjBaSFYyMTRhRTFZUW5aV2JYQkRXVlpSZVZSWWJGUmhNbWh2Vlcxek1XTkdXbkZUYlRscFRWWnNORmRyVWxOaFZURlhWbXBTVjFZelVuSlhWbHBMWkVaV2MySkdjR2xTYkhCdlYxUkdZVlV4V1hsU2ExcFZZa1pLY0ZWcVJrdE9WbHB4VTI1d1QxWnNjRmxWTW5oaFZqSkdjMU50UmxwV00wMTRXVEo0WVdOV1NuUlNiRTVwVmxjNGVWWldaRFJoTWtaSVVsaG9hbEo2YkZsWlZFWmhZVVphUlZOck5XeFNiVkl4VmtjeFIxVXdNWFZoUmxaWFVteEtURmxxUm10ak1XUlpZVWRHVTFKcmNGaFdSbHBYWXpBMVIxZFliR3RTTTFKWlZXcENkMU5HYTNkWGJrNVlZbFZ3V2xaR2FHOVdNREZYWTBab1drMVdjRWhXYkZwSFkyczFXR0pHVG1saE1IQm9WbTEwWVZsV1ZYaFdXR2hZWW10d1QxWnNXbUZXUm14eVdrYzVXbFpzU2xkV01uaDNZVEF4VjJOSWFGWk5ibEYzVm1wR1lXTnRUa2xoUm1ST1lXdGFTVlp0Y0VkWGJWWkhWRzVLVGxadFVsaFVWRUpMVTFaa1YxVnJkRlZOYkVwSVZUSTFTMkZHU1hsaFJsSmFZVEZhTTFac1dtdFhSMUpJVDFaS1RsWXhTbGxXYWtreFV6RmtTRk5zV2xoaVZWcFlXV3hTUmsxR1dYZFhiVVpyVWpGS1NWcEZXbXRVYlVWNlVXdHNWMkZyYnpCV1JFWmFaVlpLV1dGSGNGTk5iV2haVmtaV1lXUXlWbk5pUkZwVFlsaFNjbFZ0ZEhkbGJGcElZM3BHVjAxcmNIbFZNakZIVmpBeGRXRkdhRmRoYTBZMFZUQmFTMk5zY0VkaFIyeG9aV3hhTkZac1kzZE5Wa1Y0VjFob1dHSnNXbkZWYkdSVFZsWldkR1ZJWkd4U2JGWTFXa1ZTUTFack1VVlNiR1JWWWtkb2VsZFdXbUZYUmxaeVlVWmthR0V3V1hwWGExSkNUVlpPV0ZSclpHaFNNbmhVV1d0b1EyUnNXWGxrUms1VFRWVXhOVlpHYUc5aGJFcFlaVVphV21KSGFFUldhMXBUVmxaT2RFOVhkR2xTYmtKSlZtMHdkMDVXVm5KTlZWWlhZa2RvV0ZSV1pHOWtiRmwzV2tWMFUyRjZWbGhXTW5oWFZqQXdlRk5ZY0ZoaVJuQm9WbFJHV21WR2NFbFZiWFJUWWxaS1VGZFdVazlSTVU1eldrWmtWMkpVYkZSVVZscDNaVlpTVjFadGRGZE5WMUpKV1ZWYWIxWldXbk5qUkU1YVZsWndNMVZ0ZUhkU01WSnpWV3hrYVZacmJ6RldhMlEwWVRKTmVGWlliRlJpYTNCVVdWZHpNVmRHYkZWU2JtUm9VbTE0ZUZVeWRHRmlSa3AxVVd0a1dsWldjRlJaVmxwTFpGWkdkV0ZHWkZkbGExVjNWMnRTUjFkdFZraFRhMnhWWWtad2IxUlhlRXRsVm1SWVpFZEdhMDFzV25wV01XaHpWR3hhV0ZWdE9WVldiRm96V2xkNFdtVlZOVmxVYkhCWFlraENXbFpzWkRCaU1WbDRWMnRhV0dKWGFHaFZiWGgzVTBac05sSnRSbXBOYTFwSVYydGFUMVl5U25KVGFrcFhZbGhvY2xwRVJrNWxSbHBaWVVaV2FFMXNTbFpYVnpFd1pESkdSMVp1UmxKaVZWcFlWVzE0UzFac1ZYbE5SRlpvVFVSR1dGa3dhRzlXYkZvMlVsaGtWMkpVUmtoVWJYaExZMjFHUjFwRk5XaGlSbkJTVm0wd2QyVkdTblJXYkdSWFltczFiMVZ0ZUdGWFJsSlZVbXQwV0Zac2NFbGFSV1JIWVdzeGNrNVljRmhoTW1oVVZsVmFZV1JHVm5OaFJsWlhWbTVDYUZaR1dtRmhNVmw0VjI1U1UySkhVazlXYWtaS1pERmFWVk5xVW1wTmExcElWVEo0YzJGR1NuUmhSMFpYWVdzMVZGbFZXbmRYUjFaSFkwZDRVMkpyU2toV1JFWmhWVEZaZVZOcldtbE5NbEpaVm0xNFlXRkdXa1ZUYTJSWFRWWktlVll5ZUU5aFIwcEdZMFpzVjFKc2NHaFZla1pMVWpGa2RWSnNVbWhOV0VKNlZtMHhNR1F3TVZkV1dHeHFaV3RhV0ZSWGRIZFhWbXhXWVVoT1dGSXdjRWxXVm1ocldWWktSbGR0Um1GV1ZuQllXWHBLUjFOSFRrZFViV3hYWVROQ1dsWnRlR3BrTWxaR1RsVm9WMkpIVW1oVk1GWjNWMFpzYzFadFJtcFNiRnA0VlZjMWExWkdTbk5pUkZaVllrZG9VRll3WkVkT2JFcHlZVVp3VGxJeWFFMVdha28wV1ZkTmVWUnJhR2hTYkhCdldWUkdkMlZXV25GU2JYUlZUVlZzTkZrd1ZtRlVNVnAwVlc1Q1dsWkZTak5VVjNoaFkxWktkRkpzV2s1V1YzY3dWbXRhYjJNeFduUlNXR3hXWWtad1lWbHNhRk5OTVd0M1YyeGthbFpyV2pCVmJYaHJWVEpLV1dGRVZsZGlWRUY0V1ZSR2ExSXhaSFZVYlhCVFVsVndhRlpHVm1GWGJWRjRZa1phVjFkSGFGUldiWFJoWlVaYVdHVkhkRlZpUm13MVdWVlNTMVl5U2xWUmFsSldZbFJHV0ZsNlJtRmtWbEp6V2tkc1UySklRbHBXYTFwVFVXMVdSazVWWkZoaVJscFRXV3hXWVZkR1VsaGxSWFJVVm14d01GcEZZelZXYkVwelkwUkdWbFl6YUhaV01uaGhVbTFKZW1OR1ZsZE5NbWh2VjFod1IyTXdOWE5UYms1VVlYcFdXRmxzYUdwbFJscHpWV3QwVGxJd1ZqVlZiVFZQVmtkRmVHTklSbFppV0dnelZqQmFjMk15UmtoUFZUVk9WbTVDTkZaWE1ERmhNVmw1VTJ0b1ZtRnJTbGRaYkZKR1pERmFWVkZZYUZkaVZUVkhXV3RhYTJGV1drWlhWRXBYVW14d2NsVnFSbHBsUmxKMVZHMW9VMkV3Y0ZsV1YzaFRWakZrVjFwR2FHeFNlbXh3VkZkek1XVnNXbGhPVlhSYVZtdHdXbFZYTlU5V2JVcFpZVWRvVjAxdWFIcFdiWGhyWkVVNVdHRkdUbGRTVm5Cb1ZteGFhMDVHYkZkYVJXUllZV3h3VkZZd1pGTlhWbHAwVFZaT1ZGSnNXbmhWYlRFd1lURmFjMWRxUW1GV1ZuQlFWa2Q0UzJSV1JuTlhiR1JvVFZoQ2IxWXhXbUZVYlZaWFYyNVdWV0pIYUZsVmFrNXZaVVprYzFwRVVscFdiVkpJVmxkNGIyRXhUa2hWYkdoVlZteHdlbFJzV25kU2JHdzJWbXhvVTJFeWQzcFdiVEYzVmpGWmVGZHVUbFJoTVVwWVZGYzFiMkZHYkRaVGF6bFRUVlZhZWxZeU1YTlhSa2w1WVVaS1YwMXVVbGhYVmxwT1pWWlNXV0ZIY0ZOV01VcHZWbGN4ZWsxV1pFZGlTRkpyVWxkU1VGWnRlSGROUmxKV1lVYzVhRTFFUmxkWmExSlhWakZLZEdGSVdsZE5SbkJ5VlRCa1IxTldTbk5YYld4VFltdEdObFl4V2xkWlZsbDVWR3hrVm1KcmNGWlphMlJUVjBac2NsZHVaRTlpUm5CNlYydFNVMkZGTVhKWGEyaFdUV3BXVkZadE1VdFRSMVpJWVVaa2FWSnVRWHBXYkZaaFdWZE9WMUpzYkdoU2JWSlBXVmh3VjFOR1pGZFdiVVpyVFZaS2VsVXlOVmRWYlVaeVkwWnNWMkpZYUV4Vk1GcFhUbXhLY21OSGVGTmlSVzk0Vm0weE5GVXlSbGRUYmxaU1ltMVNXRmxzYUZOWFJtUlhWMjFHVjAxWFVubFhhMXB2WVZaYVYyTkdiRmRTYkhCeVZsUkdTbVZHVm5OYVJtaHBZWHBXV1ZadGNFTmtNVTVYVjJ4b2JGSnJOVmxaYTFwM1VqRlNjMVpzVGxkV01IQklXVEJvUzFZeVNrZGpSV2hoVWxaVk1WWXdaRk5TYXpWWFdrVTFWMWRGU2t4V2JUQjRaREZOZDAxVlpHbFNiV2hVV1cxek1WWnNiRlZUYWxKV1RWZDRlbFp0TVVkWGJGcHpZMGhvVjFJemFGQldSM040VmpKT1IxcEdaRTVpYldodlYxWlNRbVZHWkVkV2JsWnFVbTFTVkZSVVNtOU5iRnAwWTBWMFZFMXJOWHBXUnpWTFlVWktkRlZzVWxaaVJuQXpXV3BHYTFkSFRrWmFSbVJwVm14d1dWWnJZekZXTVZwSVUydGtWR0pVYkdGWlZFWjNUVEZaZUZkdGRGaFNNVXBKV2tWYVYxUnNTa1pUVkVKWVZrVkthRmRXV210VFJrNXlXa2R3VkZKVVZsbFhWM2h2WWpKR1IxZFliR3hUUlRWWVdXdG9RMU5zV2tobFIzUldUV3RXTmxWWGNGZFhSbHBHVTIxb1ZsWkZXbUZhVlZwclYxZE9SMWR0YkZOTmJXaGhWbTB3ZDJWR1ZYaFdhMlJYWW10YVZGbHNWbUZqYkZwMFpFaGtiR0pHVmpWYVZXUXdWbXN4VjJORVJsWldNMEpZVm1wS1JtVkhUa2hoUm5CWFVsVldORlpYY0VkaE1XUllVbXRrYUZJeWVGUlVWekZ2VGxaYWMxcElaRlZOVmxZMVZURm9iMVl5U25KWGJFNWFZVEpvUkZaRVJuTmpiR1IwVW1zMVUySkZjRFpYVmxaclRVWlpkMDFWVmxOaE1YQlhXV3hvUTFOR1duUmxSbkJzWWxWYVNsWXllR3RoUjBWNlVXdG9XR0pHV21oWFZtUlBWakZhZFZSdFJsTk5ibWhhVmxkNFUxSnJNVWRYYmxKcVVsZFNiMVJXVlhoT1JscElaRWQwVjFJd2NIbFViRnBoVjIxS1NGVlVRbGROUm5CNlZteGFVMk5zVW5OV2F6VlhZbXRHTTFacldtRmlNa1Y0Vm01S1RsWnRhSE5WYlRGdlYwWldkRTFYT1d4aVJuQXdWRlpXTUZaR1NuTlhha1pXWWxob2FGbFdXa3RrVmtaWlkwWm9XRk5GU2tsV2JYQkxWVEZPUjFWdVJsaGlSVFZ3VlcxNGQxVkdXblJOUkVaU1lsWmFTRmRyV2xkVmJVcFZZa1pXVlZac2NFeGFWM2hXWlZVMVZrOVhhRmRoTTBKSlZsUktOR014V1hsU1dHaFhWMGRvWVZSWE5XOWxiR3Q1WlVkMGFtSldTa2xaTUZVeFZqRmtSbE5VUWxkaVdGSnlWR3RhV21WR1pGbGlSbEpvVFd4S2VGWlhkRmRrTVdSSFlraEtXR0V6VWxaVmJYaGFUV3hXZEdONlZsZFNhM0I1V1RCb2MxZEhSWGhqUmtKYVZteHdTMXBWV2s5ak1VWnpXa1prYkdFd1dUQldiRnBUVXpGT2RGWnJaR0ZUUlRWd1ZXcE9RMVpHV25GU2EzUllWbXh3U0ZZeU1VZGhNREZZVld0b1YwMXVVblpXUkVaaFkyczFWMXBHV21sWFIyZzJWa2Q0WVdReFduTmFTRkpRVm0xb2NGWnNhRU5UYkdSWFZtMUdWVTFXY0ZoV01qVlBZV3hKZVdGR1pGcFdNMUpvV1RKNGQxSnNaSEprUjNSVFRVWndTRlpIZUd0aU1WSnpXa1ZhVkdKVldsaFpiRkpIVFRGV05sRlVSbFJTYkVwYVdWVmFiMkZYU2taalJscFlWbXhLVEZaVVJtdFdNa3BKVTIxR1UyRjZWbHBXVnpCNFRrWmtWMkV6Y0dwU1YxSlhWRlpXZDAxR2NFWlZiR1JhVm14d1dGa3dVazlYYlVWNFkwVjRZVkpXY0ZoYVJtUkxVMFpLYzFSc1pHbFNiRmt3Vm1wR1lWbFdiRmRVV0d4VlYwZDRWVll3YUVOaFJsWjBUVlpPVjFKc1NsWlZNakExWVZVeFYyTkljRmRXTTFKeVZqQmtTMVl4WkhKaFJtaG9UVzFvVVZadGNFdFRNVTVIVm01U1VGWnNXbGhaYTFwMlpXeGFjVkp0UmxwV2EydzBXV3RTWVZVeVNrWmpSVGxYWWxoU00xVXhXbUZqVms1eFZXeGtUbFp1UWtwV1ZFb3dXVlpSZUZkdVRsUmlSbkJZV1d4b2IxWXhjRlpYYkU1WFRWZFNNRlZ0TVRCVk1WcEdWMjFHVjJFeVVUQlhWbHBUWXpGa1dXRkdVbWhOYldoWlZtMTBWMlJyTVVkYVJtUllZa2hDYzFWdE1WTlhiR3QzVjJ0MGFGSlVSakJaVlZwdlYwZEtTRlZZWkZaaGEwWXpXbFZrVDFJeFpITmhSMnhwVm10d1ZsWnJXbXROUm14WFUxaG9WbUpyTlZsWmExVXhWakZTVmxWclpGZE5WM1F6VmpKMGExWXdNWEpqUmxwV1lsaENVRlp0ZUdGU2JVNUhWRzFHVjFadVFsVlhXSEJIWkRGSmVWSnJhR2hTVkZad1ZtcEtiMVV4V25STlNHaFBVbXh3ZVZSV1dtdFhSbVJJWVVoQ1ZrMUdXak5XTVZwelpFVXhWMVJzWkZkaVNFRjNWa2Q0VjFReFdYZE5WbVJxVWtWS1lWUlZXbUZWUmxweFVWaG9hbUpWTlVoWGExcDNWR3hLZFZGWWNGZGlWRVV3VjFaVk1XTXhaSFZTYkZacFVqRktkMVpYY0VkVE1WSlhWMnhvYWxKWVVsWlVWbFV4VjBaYVNFNVZPV2hpUld3MldWVmpOVlpXV25SVVZFWlZZbGhvYUZsNlJuZFRWbkJIVldzMVYyRXhhM2RXYlhSclRVZEplRmR1VWxOWFIzaFhXV3hrYjFZeGJISlhhM1JZVW14c00xWXlNVWRoTVVwVlVteGFWbFl6VFRGV1ZFcExVMVpHY1ZWc1pGZGxhMGt3VmtaV1lWVXlUWGhVYkd4aFVqSjRWRlZ0ZEhkWFZscEhWMjEwYVUxc1ducFdNbmhYVmtkRmVsVnNWbFpoYTBwb1ZUQmFZV1JIVmtsYVIyaFRWa1ZhTmxaVVNqUldNVmw1VW01S1dHSlhhR0ZhVjNSaFkyeFZkMWR0Um1waVZWcElWa2N4YzFVd01WWmpSRTVYWWtaS1JGWnFSazVsUm5CSlZHMUdWRkpZUWxsWFYzaFhXVmRPYzFWc1pGaGhNMUp6V1d0YVYwNVdVbk5YYlhSWFlsVndWMVp0Y0ZkWGJGcFhZMGhhVjAxcVJreFZha1pQWXpKR1IxcEdaRmRpYTBwMlZtMHhORmxXVFhsVWJsSldZVEpvY1ZWcVNqUldSbEpYVm01YVRtSkdiRFJYYTFKRFYyeFpkMkpFVmxaaVdGSm9Wa2Q0WVdSR1ZuVlJiRlpYVWxSV1JWWnFRbUZqTWsxNVVtdGtWV0pYYUZSWmExcHlaVlphV0UxSWFFNVNiR3d6VkZaYVlXRnNTa1pYYkdoYVlrWktTRlJVUm1GV1ZrNXlaRVpvVTAxR2NFdFdha28wWVRGVmVWTnJiRkppVkd4WldWUkdTMUV4Y0ZaYVJUVnNVbTVDU2xadGVHRmhWbVJHVTJ4V1YyRnJTbWhWZWtaclZqRmtjbHBHYUdsWFJrcFlWa1phVmsxV1RrZFhXR3hyVW5wc1ZsUldXbmROUmxwWVpVZDBXR0pWY0VoV01uQlBWbTFHY2xkdWJHRlNSVnA2VkcxNFlXTXlSa2hpUms1T1ZsaENUVlp0ZUdGaE1EVklVMWhvYVZKdFVsVldNR2hEWWpGV2NWTnRPV2hTYkZwNlZqSjRZV0pHU25OaVJGSlhUV3BXY2xaVVFYaFhWa1p5V2taV2FWSnVRbEZXYkZKSFdWZFNWMUp1VWxOaVIxSndWakJXUzFSV1drZFdiWFJVWWxaYVNGWnRlSE5oVmtweVRsYzVWVll6YUV4V2JYaHJWMGRTU0dSRk9WTmlSbGt3VjFkMGIxTXhXWGxTV0hCV1lrZG9ZVmxVUm5kTk1WSldWMnhPVjAxWFVubFVNV1J2VkcxRmVsRnJiRmRpVkVZelZsUkdXbVF3TVZsV2JXaFRZVEJ3YUZadE5YZFNNVkpIVmxob1dHRXlVbkZaYkZaM1UxWldkR1ZGT1ZkTmEzQjVWVEo0WVZZd01WZGpSMmhZVm14d1QxcFZXbXRqTVhCSFlVZHNhRTB3U25aV2JHTjNaVVpWZUZwRlpHbFRSVFZZVmpCa2IxVkdWblJOVms1WVVteHdXVnBGWkRCWFIwcEhZMGh3V21FeFNsUldha1pMVG14YWNtRkdaRTVTTVVwTlZsUkNZVll5VWtaUFZtUlhZa2RTVkZZd1ZrcGxWbGw0VjJ4a1dsWXdWalJXTVdodlZqSktjbU5IYUZaaGF6VlVWa1JHVjJOc1duSmpSVFZUWWtoQmQxZHNWbXBPVjBaV1RWWm9WbUV5ZUZkVVZ6VnZZVVpaZDFwRmRHcGlWVFZJVjJ0YWQxWXdNSGhUYTJoWVlrWmFhRlp0TVZkU01YQkpWRzFHVTAweFNsVldSbHBoWkRGT2MxZHNhRTVXUmtwWVZGZDBZVmRHV1hsbFNFNVdZbFZ3U2xWWGVHOVdWbG8yVm10U1YxWldjSHBXYkZwTFl6Sk9TR1JGTlZOU1ZuQm9WbTB3ZUU1R2JGaFNiR1JZVjBkNGIxVnFTbTlYUm14ellVVk9WbEpzY0VaVlZsSkhWVEF4V0ZWc2NGaGhNWEIyV1ZWVmQyVkdUblZpUm1ScFZrVlZkMVl4V210V01rMTRXa1pzYVZKVVZsaGFWekUwVmpGa1dHVkdaR3ROVjFKWVdXdGFZVlp0UmpaaVJtaFZWak5TTTFVd1dsWmxWMUpIVkd4b1UySklRWGRXYkdRMFZERnNWMWR1VG1wU2JFcGhWRmMxYjAweFZYZGFSWFJUVFZaS01GbHJXbXRoUlRCM1UyMW9WMkpZUWtoWFZscFdaVVpTV1dGR1pGaFNNMmhYVjFjeGVrMVhUa2RXV0dSWFltMVNiMVZ0ZUdGTlJtdDZZMFZrV0ZKc2NIcFdNbkJEV1ZaYVdHRklTbGRoTVhCb1drVmtVMUpXVW5OYVIyeFRZVE5DV2xadGNFTmhNVTE0VTFoc1ZXRXlVbGxaYTFwM1kwWlpkMXBIT1U5aVJtdzBWakl4UjFkc1duUlZhMnhXWWxoU2VsWnJaRXRUUmxaeVQxWndhVlpGV2pKWFYzQkhXVlprUmsxVmJHaFNiRnBQVm14U1YxZFdXbkpaZWtaVlRXdGFlbFV4YUhOaFJrcFZZa1pvV21KSGFIWmFWbHAzVWxaS2RGSnRkRk5OUkZaSVZqSjBhMkl4VW5OWGJHaHJaV3RLV0ZaclZuWk5SbXhWVW0xR1ZGSnJOVEZWTW5NMVZqSktWMU50YUZoV2JFcE1WbFJHWVZJeFpGbGFSbWhwVmxad2VGZFhkR3RWTURGSFZtNVNiRkpVYkZoVVYzUjNVMnhXV0dOR1RsZE5WbkJIV1ZST2IxZHNXa1pYYkdoYVRXNU9ORll4V2s5amF6VlhXa1pPYUUwd1NtRldiWGhyWkRGUmVWTlliRlZpYXpWWldXMXpNV0ZHVm5OaFJrNXFWbXhLV0Zac1VrZFViRnB6WTBWc1lWWlhVa2haVlZwS1pERmtWVk5zWkdsWFIyaFpWbTF3UzFNeFpGaFNhMmhvVW0xU2IxbFVUa05XVmxwVlVXMUdXbFl3TlRCVk1uUnJZVVpKZVdGSVRscGhNWEF6VmpKNFdtVkdjRVZWYkhCWFlYcEZNRll5ZEc5VU1XUklVbGhzVm1KSGVHRlphMXBMWld4YWRHVkdUbGROVjFJd1ZXMHhORll5U2taalJteFlWbXhhV0ZSVldtdFNNVTVaV2taa2FHSkdjRmxXYlRWM1VqSlNjMWR1UmxSaE0xSlZWVzE0WVUxV1dYbGxSM1JvVWxSR1dsVlhNRFZYUm1SSlVXdG9ZVkpGV2t4YVJWcFhZMjFHU0dOR1RsZFNiSEF5VmpKNGEwNUdiRmRWYTJSWVltczFXVmxzYUZOVlJsWnhVbXRrVDFac1dqQmFWV1F3VmpGSmQyTkliRlZpUm5CMlZqSjRXbVZ0UmtabFJtUk9WbTVDYjFkVVJtRlZNazV6Vlc1T1ZtSkZOWEJaVkVKM1UwWmFjMWt6YUU1U1ZFWkpWVzAxUzFSc1duUlZiR3hhVmpOU2FGWXdXbUZqVmxKMFQxWk9VMkpJUWpSV1ZscHZZakpGZUZOWVpGaGhNbWhoV1ZSR2QyTnNiRlphUlZwclRXczFTVlF4V210WFJrNUdVMnRzVjJGcmJEUldha1pLWlZaU2NsZHRiRk5pUlhCM1ZsZHdSMU15VVhoWGJrWlNZbFZhVlZSV1duTk9SbGw1WkVkMFdsWnJjRWRWTWpGSFZqSktWVkpzVWxkTlJuQm9Xa1ZWTVZZeFVuUmlSazVvVFc1a05sWnRjRXRPUjBWNFYyeGtXRmRJUWxkWlYzTXhWMFpzYzJGSE9XaFNia0pIVm14b2IxZEdTbFZpUm1oYVZsZFNlbFpxUm1Gak1rVjZXa1prYVZaRlZYZFhWM0JMVW0xV1NGTnJaR0ZTYldoWlZUQldTMlJzV2xWUmJHUnJUVmQ0V0ZaWGVHdFhSMHAwVld4YVZtSlVWa1JWYWtaclkyeGFWVlpzWkZOaE1uY3dWbXBLTUdJeFdYaFRXSEJvVTBWd1dGWnJWbUZoUm5CSFYydGthbUY2UmxoWGEyUnpWMFpKZVdGSVdsZE5WbkJVVlhwR1dtVldWbkphUm1ocFlUTkNkbFpYTVhwTlYwNUhWbTVHVkdKVWJGaFdiWGgzWlVaV1dFMUVWbFpoZWtaWVZtMXdVMWR0UlhsaFJsSlhVa1ZhYUZadGN6RldNa3BIVjIxc1dGSXlhRTVXYlhCSFdWWlZlVlJZYUdGVFJYQlJWbXBLYjFReGJGVlVhMDVVVm0xU1ZsVlhNRFZoVlRGWFkwaHNWVlp0YUZoV2JURkxZMjFPU0ZKc1pHaGhlbFpSVmtkMFlXTnRWbGhVYWxwVFlrZFNjRlpzV25kVFZsbDVaRWRHYUUxcmNFbFZiR2h2WVZVd2VXVkdhRnBpUmtwSFdrUkdhMVl4WkhKT1YzaFhZa1Z3WVZkWGRHRldNa1pHVFZoU2FGSnJjRmhaYkZKRFRrWmFWVk5yT1ZOTlYxSXhWVEo0YjJGV1RrWlRibkJZVmpOU2FGcEVSbXRXTWtWNldrWmthR0V3Y0ZsV2JYQkRaREZrUjFkWWJHdFRSVFZZV1Zod1IwMVdXbGhsUnpsWFRVUkdTVlpYZERSV2JVWnlWMnhDWVZKc2NFaFpla3BQVWpKR1IxVnNUbGRYUlVwb1ZtMXdTMDVIUlhkT1ZXaFRWMGRvYUZWc1pHOVdNV3hWVTJ4T2FGSnNXakJVVmxwUFZsVXhWMWR1YkZkTmFrWklWakJhWVdNeVRrbGpSbVJPWVd0RmVGZFdXbFpsUmxsNVZHdFdVbUpHY0hCVmFrcHZUbXhhZEUxSWFGUk5WbkJaVlRKMGEyRkdTblZSYkdoVlZrVmFURlpHV21GU01WWnlXa2QwVGxZeFNrcFdiVEV3WVRGc1YxTlljRlppUmtwWVdWUkdkMkZHWkZkWGJIQnNWakZLU1ZWdE1XOVViRnB6VjFSR1YxWkZiM2RaZWtaWFpFWk9jbUZIZUZOaVdHaFpWMVprZWsxV1NrZFhiRnBZWW1zMVdGWnRkSGROUm5CR1YyeE9WazFyVmpaVlZ6RkhWMFphYzFkdGFGcGhhMXB5VldwR1QxZFhSa2RWYld4VFRUSm9ZVlp0TVhkVU1WVjVWRzVPV0dKR1dsUlpiRlpoVmtaU1YxZHVaRmhpUjFKNVZqSXdOV0ZHV25KalJscFhZbFJXZWxacVJscGxiRVp5VlcxR1UxSldjRkZXYlhCTFV6Rk9WMVJ1VG1oU01uaFVWbXRhWVZkV1duSlhiR1JXVFZWc00xUldWbXRYUjBwSVZXeGtXbFpGUlhoV01GcFRWMGRTU1ZwR1VsTmlSbGt4VjJ0V2FrNVdXWGROV0VwWVltMTRXRlJYTlc5VlJtUlhWMjFHVjAxck5VZGFWVnByVkd4YWRWRlljRmRXZWtZMlZGWmFXbVZXU25KYVJsWnBVakZLVlZkWGRHcE9WVFZ6VjI1U1RsWkdTbTlaYkZwSFRsWmFkR1JIUmxWTlZuQlpWbGQ0YzFkdFJYbFZiRkpYVFZad2VscEZaRk5UUmtweldrWmthVmRIWnpGV2JURTBWVEZKZVZKdVRsaGlhelZaV1ZkMFMxWnNXblJsUlhSWFVtMTRlVmRyVmpCVk1ERnlZMFZhVjJKWWFGaFdha3BMVWpKT1NXSkdaR2xYUjJoNVZsaHdSMU15VWtkVmJrcFhZa1Z3Y0ZWcVJrdFhWbVJ6V2tSU1dHSldXbnBXTWpWSFZrZEdjMU50UmxkaVdHaDZWR3RhV21WWFZrZGFSbHBPWVROQ1MxWldaRFJpTVZwWFYydGFhbE5HY0ZoVmJGcDNZMnhyZVdWR1pHcGlTRUpKV1ZWVk1XRkhWbkpXV0dSWFlsaENTMVJXV2xKbFJuQkdZVVpTYUUxdGFGaFhWekV3VXpGWmVHSklTbUZTZW14VFZGWmFTMWRXY0ZaYVJXUm9ZWHBHV0ZZeU5YTlpWa3BYVmxSR1YxWkZjRWhVYlhoaFYxWndSMXBIYkZOaWEwbDVWakZhVTFJeFZuUldhMlJoVTBaYVZsbHJaRzlqUmxaMFpVaGthRkp0VWxsYVJXUkhWMnhaZDFkcmFGZE5hbFpNVmpCa1MyTnJOVmxTYkZaWFlraEJlbFpxU2pSak1WcHpWMnhXVjJKR2NFOVpWRTVEVXpGYVYxcEVRbXBOVm13MVZUSjRWMVZ0Um5OVGJGcFhZa1p3TTFsVldtRmtSMDE2WVVaa2FWSnVRalpXTW5Scll6RlZkMDFXV21wU2JXaFlWRlprVW1ReFpGZGFSa3BzVm14d01WWkhNWE5WTWtwWFUyeHdXRlpzU2xCVlZFcFBZekZXYzFwSFJsTmhlbFo2VjFkMGEwNUdXWGhYV0d4c1VqTlNXRlJWVWtkbFZtdDNWbTA1V0dGNlJraFZNakZ2VmpKR2NsZHJkR0ZXTTJoWVdrVmtSMUl4Y0VaT1YyaG9UVmhDWVZadGVHdGtNVWw0WWtab1ZtSkhVbFpaYlhoTFkyeFdkR042Um1wU2JIQXdXa1ZvYTFSck1WZGpSRUpWVm14S1ZGbFZWWGhTVmtaeFZHeFdWMkpJUW5sV2FrSnJVekZKZUZwSVRsZGlSMUp2VkZaYWQySXhXblJqUldSV1RWWnNORmRyYUZkV1YwWTJZa1pvV21FeGNHRlVWbHBoVTBkV1IxZHJPVmRpUjNjd1ZsUkdiMkV5Um5OVGJsSnNVakJhV0ZsclduZE5NWEJJWlVkR2FrMVhVakJWYlhoclZHMUdObFpyYkZkTmJsSnlWV3BHV21WR1pIVldiRXBZVTBWS1dWWnRjRTlpTWtaSFZtcGFWR0pGTlZoVVZscGhUVlpWZVdWRlRsZE5SRVl4V1ZWYVYxWXlSbkpUYkdoV1RXNU9ORlpxUm10a1ZsWjBaRVpPVGsxRmNEWldiR1IzVWpGSmQwNVZaRmhpYXpWdlZUQlZNVmRHVm5GUmJtUlVWbTVDVjFZeU1UQldNREZ5Vm1wU1YwMXFSblpXYWtGNFZqSk9TV05HWkdsU2JrSk5WMnRXWVZNeVVraFVhMmhwVW1zMWIxUlVRa1psUmxwMFkwVjBUbEpzYkRWVmJHaHpWVEZrU0dGR1ZscGlXRkl6V1RGYVZtUXlSa1pVYkhCWFlsaG9WMVpVU2pSVU1WcEhVMjVPYWxKc2NGZFVWelZ2WTJ4c1dHTXphRmhTYkZveFdUQmFkMkZGTVZsUmFrcFlWbXh3YUZVeU1WZFNNVTUxVW14V2FWSXhTbmRXYWtKWFV6RktSMXBJU2xaaE0xSllWRlpWTVZOR1ZYbGxTRTVvWWtWc00xWXllRk5YYlVwSFkwVjRWMDFXY0doV01GVjRWbFpHZEdSRk5XbFNia0V5Vm0xd1MwNUhTWGxTYms1VVlrZG9WMWxzVm1GWFJteHpZVVUxYkZKdVFsbGFWVnAzWWtaYVZWWnNhRmRTZWtaNlZsUktSMDVzV25KaFJtUlRUVEpvYjFkV1VrZFpWbGw0V2tac2FsSXlhRlJVVnpGdllqRmFkR05GT1dsTlZtdzBXVEJhYTFZeFdrWlhiR2hWVm0xb1JGVXdXbXRqYkhCSVQxZHNVMDFHV1RCWFZFSmhaREZaZVZOc2JGSmhNMUpXVm0xNGQxUXhjRlpYYm1SVVZteGFlbGRyWkhOaFJUQjNVMnBTVjJKSFVUQlpha3BLWlVad1JscEhiRlJTVkZaWVYxWlNTMVV4V25OV2JsSnNVakJhVDFWdE5VTldNVmw1VFZSQ2FGSlVSbGRaYTFKUFZqQXhkVlZ1V2xkaGExcGhXbGN4UjFJeFJuTmpSbVJwVTBWS1VsWnNZM2hPUmxGNVZHeGtWV0pyTldoVmFrbzBWMFpXYzFadVRrOWlSbkI1VmpJeFIyRkZNVmRYYWtKWFlsaFNjbFpzWkV0VFIxWkpVV3hhYVZkSGFHOVdha1poVmpKT1YxUnVVbEJXTTFKUFZtMDFRMWRzWkhKV2JYUlRUV3RXTTFSV1dtdGhiRXAwWVVkR1dsWkZjSFpXYTFwelYwVXhWMXBIY0dsU01VbDRWbGN4TkdFeVJsZGFSV2hvVW5wc1dWbHJaRkpOUm13MlVtMUdhazFyY0VaV01uaHJZVlpLYzJOSVpGZFdNMmgyVlZjeFYxSXhaSE5hUjBaVFVtdHdkbFpHV210Vk1VNVhWbTVPYUZKNmJGaFZha0ozVTBaVmVVMVZaRmROYTNCSVdUQlNUMWRHV25OalJFNVdZa1p3VUZreWN6VldNVkp5VGxkb1RrMUZjRXRXYlhCTFRVWnNXRkpZYkZOaVIxSlpWakJrTkdJeFZuSlhiVVpZVW0xNGVsbFZWazlXVmtwelUyNXNWMDFxVmxCV2FrRjRWMFpXY1ZKc1drNWlhekI0Vm0xd1MxTXhUbGRTYms1aFVtMW9XRlJVUmt0aU1WbDRWMjFHVm1KV1draFhhMmhYVm0xR05tSkdhRmRpUmtwWVZteGFZV1JGTVZWVmJYUk9Va1ZhU1ZkVVFtRlpWbVJJVTJ4YVdHSnJTbGRaYkdoVFRURndWMWRzVG1wTlZuQXdWREZhYjJGSFZuSlhhMnhYWVd0c05GbHFSbHBsUms1eVYyeG9hVll5YUdoV1JtUjNVakZXUjFadVVtcGxiRnBZVkZkek1WTldiSEpYYlRsV1RVUkdNRmxWVlRWV01rcFpWVzFvV0Zac2NIcFdha1ozVTFaV2MxcEhiRk5OYldoYVZqRmFVMU14VlhoWGJrNXBVMFZ3V0ZaclZtRldiRkpYVjIxR2JGWnNiRFZVVmxaclZqRkpkMk5GYUZwTlIyZ3pWakJrUm1WR1RuTlZiR1JPWW0xb2FGZHJVa2RoTWsxNVVtdGtXR0Y2Vm5CWmJHUnZUbFphZEUxVVFtaE5WVEUwVlRJMVMxUXhXblJWYlRsV1lsUldSRll3V2xOV1ZrcHlZMGQ0YVZKdVFYZFhhMVpyVWpGWmQwMVZWbGRpYmtKWFZGZHdWMVZHV1hkYVJYUllWbXhhZVZReFdtdGhWbHBIVjJ0U1dHSkdXbWhXTWpGWFYwWldjbUZIZEZOTk1VcFFWbTB4TUdRd05YTlhXR3hyVW0xU1lWWnRlSGRUVmxaellVaE9hRkpyY0RCYVZWcHZWMjFLU0dGSVdscFdWbkI2Vm0xNGEyUldVbk5hUm1Sb1pXeFpNVll5ZEZkWlZsRjRWVzVPV0ZkSGFGVlpiRlpoVjBaU1dFNVdUbXBpU0VKR1ZXMHhSMVV3TVZaT1ZuQmFWbFp3VkZsV1drcGxWMFpIWWtab1YwMHlhRlZXYlhCQ1pESldSMWR1VmxOaVJUVndWV3BHUzFaV1drZFhiVVpyVFZkU2VsbHJhRXRXTVZwR1YyeG9WVlp0VWxSVk1GcFdaVmRXU0ZKc1pFNVdiVGg1VmxkNFUxRXhaRWRYYmxKV1lrZG9WMWxYZEdGaFJsbDRXa1YwVkZJeFdraFdWM2hQVkd4YVdWRlliRmRpVkVJeldsVlZNVk5HVWxsYVJUbFlVbFJXZDFaWE1UUmtNV1JIWWtoS1lWSnJOVmxXYlhoaFRVWndWbUZGT1ZWTmEzQklXVEJhYzFaWFNrZFhXR1JYWVd0R05GWnFTazlTYkhCSFkwVTFVMkpyU2xaV2JUQjNaVVpKZVZSdVRtRlRSbHBWV1d4V1lWWkdiSEpoUlU1cFRWZFNlVlp0TVRCV1JURldZa1JTVjFaNlZreFdSRVpoVmxaYWRWRnNaR2hoTTBJeVYxZHdSMWxYVWtaTlZsWldZbGRvY0ZadGVIZFRSbHBIVjJ4a2FVMVdjSHBYYTFadlZtMUdObUpHYUZWV1ZuQlhXbFZhYzFac1pITmFSM1JUVmtWYVdWWnJaRFJpTVZsNVUyeHNhRkpHY0ZsV2JYaGhWMFphUlZKdFJsZGhla1pZVjJ0a2QxWkdTWGxoUm1oWFlsUldNMVpxU2s5ak1rcEpVMjFHVTFkR1NsWldWM0JIV1ZaT1IxcElTbGhpV0ZKdlZtMHhVMU5XYkZaWGEyUlhUV3R3V2xWWGRHOVdiVlp5WTBVNVlWWnNjRlJaTW5oclpFZEtSMVJ0YkZkaE0wSmhWbTEwWVZVeFRYbFRibEpYWW1zMVdWbHRlRXRVTVZWM1drYzVWMVpzU2xsYVZWWXdWMFpLYzFkcVFsVmlSbFV4Vm1wS1MxWnRUa1pqUmxwWFpXeGFSVlp0Y0VKbFJrNUhWbTVXV0dKSFVsaFphMmhEWWpGa2NsWnNXbXhTYkhCWVZtMDFVMkV4U1hsbFJtaGFZVEpOTVZSVVJtRmpNV3Q2WVVVMVUwMUdXVEZXVnpBeFZERmFTRk5yWkZoaVIyaGhXV3RhUzJWc1duUmxSMFpxWWtad2VWcEZXbE5VYkZweVkwWndXR0pHV21oYVJFcExVakZrV1dGR2FHaE5iV2hhVjFaU1MxVXlWbk5YYTJoc1VqQmFjbFZxUmtwTmJGWllaVWQwYUZKVVJubFVWbEpUVmpKRmVGTnJhRmRpVkVaWVZXcEtUMUpzWkhSaFJrNXBVMFZLTTFac1kzaE9SMUY1VW10a1dHSnNTbkZWYkZKelkwWlNXR1JIUmxSU2JHdzBXVlZqTlZkR1NYZGpTR3hWWWtkb1NGWXlNVVpsVjBaR1ZXeGFUbFp1UWxSWGJGWmhZVEpTU0ZWclpGaGhlbFp2VkZSQ1MxTldXWGhWYTA1YVZqQXhORll4YUd0VWJHUkhWMnhrV21FeVVsUldiWGh6WTJ4d1IxUnNUazVYUlVwWVZtcEtlazVYUm5KTlZtUnFVMGhDV1ZsVVNsTmtiRnBJVFZWMGExSXdXa2xWYlhoclZHeGFkVkZzVmxkWFNFSklWbTB4VjFZeFpIVldiRlpwVmpOb1ZWZFhlR0ZUTVdSeldrWm9iRkp0VW1GV2FrRXhWMFphV0dWSE9XaE5WVFZIVkd4YVExZHRSWGxWYkZKaFZteHdZVnBXVlhoV1ZrWnpXa1prVGxORlNsbFdNVkpEVlRGRmVGcElUbGhpUjFKVldWUk9iMWRHYkZoa1NHUlRUVmhDVjFZeWN6VmhiVXBYVjJ0b1dHRXhjRkJXVkVaaFpGWkdjMU5zWkdsU01VbDZWbGR3UjFWdFZsZFdiazVoVW14d2NGbFljRmRYYkdSWVpVZDBhVTFyTVRSWmEyaFBZVVpLTm1KSFJsZGlXR2d6V2xkNGExWldVblJQVmxacFVsZDNNRlpYTVhkV01WcDBVMnhzVm1KcmNGaFVWV1JUVkVacmVXVkhkR3BOVmtwNldUQmtiMVJ0U2taalJscFhZbFJGZDFkV1dsWmxSbkJHWVVaa2FFMVlRbmxXVjNCUFlqSk9SMVp1UmxOaE0xSlFWbTB4VTFkR1duUk5WV1JYVmxSR1dGa3dXbXRXVmxwelkwaEtXbFl6YUV4VmJYaFBZekpHUjFwSGJHbGhNSEJhVm0xMFYxbFdiRmhVYkdSVlltdHdjbFZ0TVZOWFJteFZWR3RPV2xac2JEVmFSV1JIVmpBeGNsZHNhRmhoTVZwMldWVmFTMDV0U2tkaFJuQlhUVEZLVFZadGNFZFZNVmw0V2toU1UySllRazlXYlhoMlpVWmFjMWt6YUdsTlZsWTFWVEo0YTFaSFNraGxSbWhYWVdzMWRsbFZXbmRUUjAxNllVWk9UbFl4U1hoV2JHTjRUa1pWZDAxSVpGUmliWGhZVlcxNFlWWkdWbkZTYlhSVFRWZFNXbGxyWkRCVk1ERkhZMFprV0ZZelVtaGFSRVpyVmpKS1IxZHNhR2xXVm5CWlZrWldVMUl4VGxkWGJHaFBWakJhV1ZWdGVIZGxiR3QzWVVoa1YwMXJjRWhaTUZwRFYyMVdjbGRzVWxwbGExcG9XWHBHVTJSSFNrZFVhelZPWWtWV05WWnRNSGRsUjFGNFZHNVNWMkV5VWxWV01HUTBWa1paZDFwSE9WaFdiR3d6VjJ0YVQxWnNTbk5qU0hCWVlURktWRll5ZUdGak1rNUpZMFprVG1Gc1dubFhWbEpMVXpGSmVWUnJaRmhpUm5Cd1ZtdFdZVk5XV25OVmEzUlVUVlUxU0ZadE5VOWhiRXAxVVdzNVZtSlVWa1JhVmxwaFpFZE9SbHBHVWs1V2JYY3hWbXRrTUdFeVJsZFRibEpvVW0xb1ZsWnJWa3RVUmxaeVYyMTBhazFXY0RCVmJYaFRZVlphYzJOR2JGZFdSVzh3V1hwS1IyTXhUbGxpUjNoVFlrVndhRmRXVWtkWlZUQjRZMFZXVTJKWVVsaFVWbHBoWlZaYVNFMVVRbFZpUm5BeFZWZDBjMVl5Um5KaE0yaFhWa1Z3U0ZsNlJrOWpNa3BIVjIxc1UwMVZjRmhXYlRCNFRrWlpkMDVWWkZaaWEzQlpXV3hXWVdOc1ZuRlNiVVpVVW0xU2VWWXlNVWRoUmxwelkwWm9WMDFXU2t4V2FrcExVMFpXVlZGc1dsZFNWbkJvVjJ4YVlWUXlUWGhYYms1VllsZDRWRmxVVGtOa2JGcDBUVmhrVlUxcmJEVldiVFZQVjBkS2MxTnVUbFpoYXpWVVdURmFjMWRYVGtsVWJHaFRZa2hCZDFaR1dtOVVNVnB5VFZoS2FsSnVRbGxaVkVaTFlVWmFjVk5yV214V2JGcFdWVmQ0YTFZeFNsZGpSV2hZWWtaYWFGbFVTazVsVmtweVdrWldhVkl5YUZWV1JsSkxZakZrVjFkWWFGcE5NbWhQVldwR1IwNUdiSEpYYlhSWVVqQndlbFV5Y3pWV01rcFpWRmhvVjJKWWFGaGFSV1JYVTFad1NHVkdUbWxTYlRrelZtdGFZVlV4UlhsU2EyaFVZVEpTY1ZVd1pEUlhSbEpZWTBaa1RrMVdiRFZhVldSSFYwWktjMWRxUmxwTlJuQnlWbXBHUzFac1pGVlJiR2hvVFZad2VWWlhjRWRUYlZaSFZXNVdWV0pWV2xSV2ExcGhWMVprVjFWck9WSk5WWEI2VmpGb2IxZEhTa1pPVmxKVlZteHdhRlJWV21GV01rWklaRVpXVGxadVFYZFdiR1EwWXpGa2MxcEZiRkppYmtKWVZGVmFkMlZzYkRaVGEyUlVVbFJzV0ZsVldtdGhWbHB5WTBkR1YwMXVVbGhaVjNNeFZqRmFkVk5yTlZkaVYyaFlWMVpTUzJJeGJGZFZiRnBZWW0xU2NsbHJaRFJXYkZaMFpFaGthRTFFUmxsV1YzQkhWakZKZW1GRVRscFdWbFkwVmpGYVIyTXlTa2RhUms1T1RWVndkbFpxUm1GaE1WVjRWR3RrVm1KcldsbFphMlJUWTBaYWNWUnRPVmRXYkhCSVZtMHdOVlZyTVZaT1dIQlhUVzVTV0ZaVVNrdFNhelZYVjJ4V1YySldTbFZYYkZwaFZURlplRmR1VW10U2JWSlVWRlZvUTFOc1pGZFdiVVpwVFZac05WVnROVXRVTVdSSFkwZEdWMkpHY0ROV2ExcDNVbXhhV1dGR1pHbFdhM0JKVm10amVHTXhXWGxUYTJ4U1lUTlNXRmxyWkU5T1JsSnlXa1ZhYkZacmNIcFhhMXBUWVZkS1IyTkdVbGhXYkVwUVZWUkdhMUl4Vm5OaFJUbFhaVzE0ZGxaWE1IaFZNV1JIVjFoc2JGSllVbkJWYlhSM1RVWmFXR05GWkZkTlZXOHlWVzAxZDFZeFdrWlhhM2hoVW14d1NGbDZSbUZqTWtaSFdrVTFUbUpYWnpGV2JYUnJUVVpzVjJKR1pGUlhSMmhZV1cxek1WZFdiSE5hUnpsWFVteHdlbFpYZUd0WFIwcElWV3hzWVZKWFVraFpWRUY0VWxaS2NtRkdaRmROTW1odlZtMHdlRkp0VmxkV2JsSlFWbXhhV0ZadGRIZFRWbVJ6VjIxR1dHSldXbGxXVjNSdlZVWmFkR0ZHVWxWV1ZuQmhWRlZhWVdOV1RsbGhSMnhPVm0xM01GWlVSbTlrTWtaSFUxaHNhRkp0VW1GWmEyUnZaR3hyZVdWSVRrOWlSVFY1V2tWYVQxUnNaRVpUYTNCWVZteGFWMVJXV2xwbFZrNTFVMnhPV0ZJeWFGbFhWM2h2VlRKR1IxcEdaRmhpYXpWWVZGWmFkMWRzYkZaWGJUbFlVbXRzTlZsVmFHOVdNVmw2WVVkb1lWSkZjRkJaZWtaaFpGWktjMVp0YkZOV1JscGhWbXhqZDJWRk5VaFdiR1JZVjBkNFVGWnFUbE5YVmxaeFVXNWtWRkp0ZUhsV1YzaHJWMnhhY21OR2FGcE5SMmhNVm1wR1MxSnNaSEprUjBaVFVsaENVVlpYTUhoU01VbDRZMFZhVDFZeWVIQldha3B2VFd4YWRFMVlaRkpOYTFZMFZURm9jMVpYU25KT1YyaFdUVVpWZUZsVldsZGpWa1owVW14b1UySkZjRmRXVnpFd1RVZEdWazFXWkdwVFNFSllXV3hTUjFOR1duRlJXR2hZVW14YWVWZHJXbGRXTWtwSlVXMDVXRlpzU2toVk1qRlhZekZLZFZWc1FsZE5SbkJaVjJ4a01GWnRVWGhYYkd4cVVsZFNiMVJXV25OT1JsbDVUbFpPYUUxVmNGWlphMXBUVjIxRmVXRkZVbFpOVm5Cb1ZteGFUMVpXU25OV2F6Vm9UVmhCTWxac1VrdE9SMDE1VW10a1ZHSnNTbTlWYlRGdldWWnNjbHBIT1d0aVJuQkhWako0YTJGdFNraFZibkJYVFdwRk1GWnFRWGhTVmxaWllrWmtWMlZyVlhkWFZsSkhWVEpOZUZwSVZsUmlXRUpVVkZWYWQxZHNXblJOVkZKYVZqQmFTRmRyV210WlZrcFlWV3hXVm1KWVVqTldNbmhyWTJ4d1NWcEdXazVTUlZsM1YxWldZV014V1hoWGFscFNZV3hLV0ZadWNFZFZNWEJXV2tVNVUySkdjSHBWTW5odlZUQXhkR0ZHY0ZkaE1YQm9WMVphYzFkR1duVlViVVpVVWxoQ2IxWlhlR3RWTVZsNFZXeGtXR0p0VWxWV2JUVkRWakZzVmxwRlpGZE5SRVo1V1RCYWQxWnNXWHBWYkZKWVZteHdURlZ0ZUd0ak1VWnpZMGQ0YUUwd1NrNVdiR1IzVWpKRmVWUllhR0ZUUmtwdlZXeFNWMk5HVm5OaFJVNW9VbXh3TUZwVlpEQmhNREZXVm1wV1YxWnRhSFpXTUdSTFkyczFWMkpHY0dsWFIyaE5WMWh3UjFZeVVsaFVhMnhWWWtoQ1dGbHJhRUprTVdSeVZtMDVhRTFyY0VsVk1uUnZZVEZLUms1WFJsZGlSMUoyVmxWYVdtVlhWa2hTYlhCT1lUTkNSMVpxU2pSa01WbDRWMjVXVW1GcmNGaFVWbHAzWVVaV05sTnJOV3hXYkVwNVZqSXhiMVV3TVVkalJsWlhZbGhDU0ZWNlJsTldNV1J6WVVVMVdGTkZTbEJXYlRCNFZURk9WMVp1VW10U2VteHZWbTEwZDJWV1VuTlhiazVYWWxWd1NGWXlNVWRXVmxwWFkwZG9ZVkpXVmpSVk1WcDNVMGRXUjFSc1pGTldia0pNVm0xNGFtUXdNVmRXV0doWVYwZDRWRll3WkRSV01XeHlXa1JTV0ZKc1NsZFhhMXBMVkd4S2MyTklhRlppVkZaUVZtcEdZV05yTlZsalJtUlRaV3RaZWxadGNFdFRNVWw1VTFod1lWSnRVbFJaYTJoRFZsWmFjMVZyWkZoaVZscFlWa2MxUzJGR1NYcGhSbEpXWWtaYU0xbHFSbUZYUjFaSVVteG9hVlpyV1RCWFYzUmhZakpLUjFOWVpGaGlhM0JZV1d4b1UyRkdjRmhsU0U1WFlrZFNNRlF4Wkc5Vk1WcEdWMnBXVjFKc1duWlpha1pyVWpGa2RWUnRjRk5OYldoYVZtMHdlRlV4V2tkV1dHUllZa2RTY1ZsclduZGxiR1J5V2toT1ZrMXJjRXBWVjNoM1ZqQXhXRlZZWkZwaGExcEhXbFphWVdNeGNFaFNiRTVwVm10d1lWWXhaRFJXTVd4WFlrWmtXR0pzU25OVk1HUlRWMVpXZEdWR1pFOVdiRXA2VmpJeE1GZEhTa2RqU0d4YVRVWktTRlp0ZUZwbGJVWkpWMnhrYVZaRldrMVdWRUpyVWpGS2MxWnVVbE5pUjFKd1ZUQldTMDVXV25SalJVNW9UVlpXTkZVeGFHOVpWazVIVTI1T1ZtSllUWGhaTUZwaFpFZFNTVnBHY0ZkaVNFSTJWakZTVDJJeFVuTlRiazVwVWtaS1dGbHJaRzlsYkZweVdrVmFiRlpzV25wV2JYaDNZVVV4YzFOcVNsZGhhMHBvV1hwS1QyTXhjRWxUYlhSVFlsZG9WVmRYZEdGa01EVnpWMjVHVkZkSGFGUlVWbHBYVFRGU1YxZHVUbFppVlZZMFdUQmFiMVl5U25WUmEyaFZWa1ZhYUZVd1pGZFNNazVJWlVaT2FHVnNXVEpXTVdRd1dWZEZlVkpyV2s1WFJUVlVWakJrVTFkV1duRlVhMDVVVW0xM01sVnRlSGRpUmtwelUyNXdXbUV5VWpOV1ZFcExVMVpHZFZwR1pGZE5NRXBSVjFkd1IyRXhTWGhqUldSb1VqTlNWRlJWV25kV2JGcEhWMjEwVmsxVk5VaFpWRTVyVjBkS1ZXSklRbFppV0ZKNlZHMTRZVmRIVmtoUFZtUk9ZVE5DWVZacldtOWlNVnBYVjI1T2FsSXlhRmRVVldSVFYwWldkRTFXVGxSU01GcElWa2R6TVZZeVNsVmhNM0JYWVd0dk1GWnFSbk5YUms1WllVZEdVMVl4U2xwV2FrSnZVVEZaZUdKSVNtRlNlbXhoVm0xNGQyVldXblJOVldSWVVtdHdlbFl5Tlc5V2JVcFZWbTVLVjFaRmNFeFdiWGhyWTIxS1NGSnNaRmRpYTBwU1ZtMTBhbVZHVFhoYVJXaFRZVEpTY1ZWdE1WTlVNVnAwVGxWT2JGWnNjRWhXYlRGSFlXc3hXRlZyYUZkTmFsWllWbXhrUzFJeVRrbFJiSEJZVTBWS1dWWnFTalJoTVdSSVZXdGtXR0Y2VmxoWmEyaERWMVphZEUxRVJsVk5WbkF3VlRKMGIxWnRTa2hsUm1SYVlrWktTRlpyV25kV01XUjBaRWR3YVZKc2NEWldhMk40WWpGVmVWTnJiRkpoYkZwWVZXcE9iMWRHYkZWU2JVWnFZWHBHV2xWdGVFOWhSVEYwWVVac1dGWnRVWGRYVm1SSFVqRmFkVlZ0ZUZOTk1VcDRWa1phWVZsWFZuTmhNMlJZWWxoU1YxUldXbmROVmxaWVkwWmtWMDFyY0ZaVmJYQlBWbTFHY2xkc1RtRldiSEJVV1hwR2QxTkdTbk5WYkU1WFVteHdNbFp0ZUd0a01VMTNUbFZrWVZKdFVsaFpiWE14VjBac2RFMVdUbXBTYkVwWVZqSTFUMVF4U25SVmJteFhWak5vVUZsVldrdFdWa3B5VjJ4a2FWZEdTakpXYlRCNFV6Rk9TRkpyYkZoaVIyaFlXV3RvUTFWV1dsaE5WRkpvVFdzeE5GWXlOVTloYkVwMFlVWldWbUpHV2pKVVYzaGFaVVpXY21SRk9WTmlSM2N4Vm14a01HSXhXWGxTV0d4c1VqSm9WMWxYY3pGa2JGcHlWMjVPYW1KSFVqRlhhMXB2WVZaS2RWRnJiRmRoYTI4d1ZrUkdWMk5yTVZkaFJscG9UVzFvV0ZaR1pIZFdNVkpIWWtab2JGSllVbkpXYlhSaFpXeGtjbGR0ZEdoV2JIQkhWakp3UzFkSFJYbFZWRUpZVm0xU1ZGVXdXbE5YVjA1SVlVWk9hVlpyY0ZGV2JURjNVakZPZEZWWWFHRlNiVkpZV1d4V1lWbFdXbkZSYm1SVVZteGFlbGxWYUd0V2JVcFdWMVJLVm1KWWFIWldha3BIWTJzMVZsVnNaRk5XYmtKWlZrY3hORk15VG5SVWEyaHNVbTFTYjFSVVFrcE5WbHB4VTJwQ1dsWXdWalZWYlhoclYwWmtTR1ZIT1ZaTlJuQXpWakJhVjJSSFZraFNiWFJwVW14d1YxWlhNVFJoTVZWM1RWWm9WbUpJUW1GV2JHUlRVMFphVlZKcmRHcGlWVFZJV1d0YWIxWXlTbGhhTTNCWFZqTkNTRll5TVZkU01WcDFWbXhXYVZJeWFIZFdha0poVXpKR1IxZHVVazVYU0VKUFZtMTBjMDVHV2xoT1ZUbGFWbXR2TWxscldtOVhiVXBIVjJwT1ZrMVdjR2hXTUdSWFVqRlNjMXBGTlZkWFJVcEpWbTF3UzA1SFNYaGlSbVJVWWtkU1dGWXdaRzlYUm14ellVYzVWMUp0ZHpKVmJUVnJWVEpHTmxac2FGaGhNbEo2V1ZWVmVGSXlTa1ZYYkdScFZrVldNMWRXVWtKTlZrbDRXa2hXVkdGNmJGaFpiRnBMWWpGYVZWRnNXazVXYlZKWVdXdG9VMkZ0Vm5KWGJrWldZbFJXUkZZeFduZFNiVVpJWkVaa1RsSkZXbHBYYkZadlpERlplRmRZY0doVFJYQllXV3hvYjFSR2JEWlRhM1JUVm14d2VsWnRlR3RoVmtwMFpETndWMkpVUmpOVmFrWnpWMFpTV1dKR1ZtaE5ibWg0Vmxjd2VGVXhXa2RWYkZaVVlsUldjMWxyWkZOWFJscDBUVlJDVmsxcmNGaFdNblJ6VmpGSmVsVnNhRmRoTWxKTVZUQmFWMk15UmtkV2JHUlRWbTVDVGxZeFpIZFNNV3hZVkc1T1YySnJjSEpWYlhoM1ZERmFjMVZzWkZSV2JIQXdWRlZTUjFaRk1YSlhhMmhXVFZkb2VsbFZXa3RqTVU1MFVteHdhRTFzU2xWWGEyUTBXVmROZUZwSVVtdFNiV2hVVm10V1lWWXhXbGRhUkZKV1RWWktNRlV5ZEd0aGJFcFlaVVpvV2xZelVqSlVWVnBoWTFaS2MxZHRlRmRoZWxZMlYxZDBZVmxYUmxoU1dHaHFVbTFTV0Zsc2FHOWhSbFkyVW10MFUwMVdXakZWTW5odllWZEdObFp1YUZkaVZFVXdWWHBCZUZZeFpISmhSM2hUVFRGS1YxZFhlRmRXTURWSFlUTmtWbUpWV2xoVVYzUmhaVlpzZFdORlRsZE5WWEJIVmpJMVMxbFdTbGRqUmtKYVRXcEdTRlV3WkVkU01WSnpXa2RvVGsxRmNESldiVEV3V1ZaWmVHSkdhRlpYUjJob1ZXeGtVMkl4VWxWVGJUbFlWbTE0VmxVeWVFOWhiVXBIVjJwQ1lWSlhhSEpaYTFwaFl6RktjVlZzYUdoTmJXaFJWbTB4ZW1WR1NsZFNia1pYWWtkU1ZGUlVRa3RYVmxwMFkwVjBWRTFWYkRWV1IzUnZZVVpLZEZWc2FGWmlSbkF6VmtWYWEyTXhaSFJTYkZKT1lYcFdObGRVUWxkaE1WcDBVMnRvYUZKc1NsWldiWGhoVFRGU2NsZHRSbXBOVjNRMlYydGtORlV4V2tkWGEyeFhUVzVTV0ZsVVNrZFdNVkp5VjIxd1UySllhR2hXYlhSV1RWWmFSMkpJUmxOaVIxSnlWV3BHWVZOR1pISldWRlpYVFd0d2VWVXllRzlXTWtwVlVtcE9WbFpGY0VoVmJYTjRWakZ3U0dOR1RsTldia0paVm0weGQxUXhWWGROU0doWVlteEtjMVZ0TlVOak1XeHpWbTFHVTJKR2NFbGFWV2hyVmpBeGNtTkZjRlpXZWtFeFZtcEdZVTVzU2xWUmJIQlhVbGhDVUZkc1dtRlVNazV6WTBWb2FGSnJOVTlaYkdSdlZWWmFkRTFJWkU1V2ExWTFWbGMxVDFkR1pFaGxTRXBXWWxoTmVGWnJXbE5YUjFKSFdrVTVVMkpIZHpCWFZsWnFUbFpaZDAxWVNtcFRTRUpZVkZjMWIyUnNXWGxOVlZwc1VtMVNlRlpIZUhkVWJFcDFVVzFvV0dFeFNraFhWbVJQWkVaV2NscEdhR2xTVkZaM1ZsUkNWMU5yTVVkWGJrNVlZbGhDYzFWc1VrZFRSbGw1VGxWMFZXSkhVa2RVYkZwVFYyeFplbUZGZUZkTlJuQjZXVEo0ZDFORk9WaGtSMnhUWW10Sk1GWnNVa3ROUlRGSFYxaG9XR0pyTlhGVmExWmhWakZTV0U1WE9WaFNiSEI0VlZab2EyRXdNVVZXYTFwV1ZqTm9jbFpVU2t0U2JVNUdZa1pvV0ZORlNrMVdhMUpMVkcxV1IyTkZiRmRpUm5Cd1ZqQmFTMVpXV2tkWk0yaHBUVlphU0ZZeWVHOWhNVXAwVld4c1dtSkdjRWhVYTFwclkyMUdSazlXWkU1aE0wSllWbXBKZUZJeFdYbFRiRlpUWWtaS1ZsWnNXbmRXTVhCWFdrWk9WRkl4U2tsWlZXUnpWVEZaZWxremFGZE5WbkJZVjFaYWMxWXhaRmxpUmxKb1RXeEtlRlpYZEZaTlZteFhWV3hvVDFaNmJITlphMXBMVFVad1ZsWlVWbWhpVlhCS1ZWZDBiMVl4U2paU2JscGFZVEpTVEZZeFpFZFRSa3B6V2tVMVYyRXpRa1pXYWtaaFdWWldkRlpyWkZkaWJGcFdXV3RhUzJJeFVsaGxSWFJYVm0xU1dGZHJVbE5YYkZwMFZXdG9WMVl6YUhKWFZscExZMnMxVms5V1ZsZGlTRUpvVmtaa05GWnRWbGhWYTJoVFlsZDRWRmxVVGtKbFJscFhXa1JDYVUxWFVrbFZiR2h2WVd4S2NsTnNhRlZXVm5BelZYcEdkMVpzWkhKUFYzUlhZbXRLU1ZZeWRHRmhNVlY0VjJ4c1VsZEhlRmhaYTFwM1ZrWldjVkp1VGxkTlYxSmFXVlZrUjFaR1NuTmpSbVJZVmpOb1dGZFdXbUZTTWtwSFlrZHdVMkpXU25sWFYzUmhaREZrVjFWc1dtaFNlbXhXV1d0V2QxWnNWbGhqUms1WVVqQldOVmxWVmpSV01rWnlZMFZvV2sxdWFGQmFSVlUxVmpGYWMxcEhiRk5pVkdzeVZtcEtOR0V3TlVkYVNGSlhZa1p3VUZadE1UUldiR3h5V2taT1dGSnNjSGxXYlRGSFYwZEtSMk5JY0ZoaE1VcEVXVlpWZUZZeVNrVldiRnBwVmtaYVRWZFdaRFJUTWxKSVVtdG9VMkpHV2xoYVYzaGhUV3hrVlZOcVVtdE5WV3cwV1RCV1lWVkdXbkpPVlRsYVZrVmFNMVV4V210V01WcDBVbXhhVGxac1dUQldha28wWXpGV2RGSnFXbWxTYldoaFZtcE9VMkZHY0VobFNHUlRWbXR3ZVZSc1pEUlZNa3BYVTIxR1dGWXpVbWhXYWtwSFYwWk9jbGR0Y0ZOaVYyaGFWbTB4TkZNeFRrZGpSVlpVWVhwc1ZGUldXbmROVmxwWVkzcEdWMDFyV1RKV2JUVnZWakZhTmxGcVVsVmhNVlkwVldwS1QxSnNaSE5hUjJob1RVaENNbFp0TVRSVk1VbDRXa1ZrYUUweVVtOVZibkJ6VjBac2NsZHVUazlpUjNoWFdWVldNRmRIU2tkaVJGcFhVak5DVkZZeU1WZGpiR1J5WlVad1RsWnVRbGxYV0hCSFpERkplRlZ1VW1sU2JWSlBXV3hrVWsxV1duUk5TR1JyVFd4R05WWnRkR3RXUm1SSVpVWmFXbUpZVFhoV2JYaHpaRWRXUm1SR1pGTmlXR2cxVm1wSmVGSXhaRWRUYms1VVlrWndWMWxzYUZOTk1XeHlXa1YwVTAxck5VZFpWVnByVkcxR2NsZHJiRmRpVkVZMldsVmFXbVZXVG5KV2JGcHBVMFZLVUZaWE1UUmtNa2w0VjI1T1YySlZXbGxaYkZwaFYxWldkR1JIZEdoU2EzQjZWako0YjFZeVJuSmpTRnBXWWtad2FGWXhaRTlTYkhCSVlVVTFWMkpZWTNkV2JYQktUVlpSZUZkc2FGUmhNWEJRVm14U2MxZEdiRmhrUjBaVVRWaENSbFZ0TVVkV01WcHlUbGhvVmxaNlJucFdSM2hoWkZaR2MySkdaR2hoTWprelZqRmFZV0V4VGtkVWJrNVlZa2RvY0ZWcVNtOWhSbHAwWkVaa1dsWXdXa2hXVjNoWFZUSktWbGR1UmxwaE1sSlVXbGQ0Y21ReGNFVlJiRlpwVWpGS1NGWlVTakJqTVZsM1RWaFdWbUpYYUZoV2ExWmhWakZ3UlZGWWFGZE5XRUpKV1RCYVQxWXdNWFJoUm5CWFlrZE9ORlJyWkZKbFZsSjFWRzFzVTFKdVFsVlhWM1J2VVRKTmVGZHVVbXBsYTFwelZtMHhORll4WkhKVmEwNVhZWHBHVjFrd1dtRldNa3BaWVVod1YyRnJXa3haZWtwUFUwZEdSMWR0ZUdoTldFSk9WbXhrZDFNeFRYaFRXR3hUWVRKb2NWVnFUbTlpTVZKWFlVVk9XbFpzY0hwWFZFNXZWREZKZUZKcVZsZGlWRlpRV1ZaYVMyTXlUa2RpUm5CcFVteHdiMWRYY0VkV01rMTRWbTVLWVZKVVZsaFpiR2h2VjBaYWNWTllhRTVTYkd3elZGWm9TMkZzU25WUmJHUlhZV3MxVTFSVldtRmpWa3AwVW14T2FWSXhTalpYVmxaaFpESktTRkpZYUdwVFIzaFpWakJvUTFOR1pGZGFSVFZzVW14S01WWlhNVzlWTVZwSFYyeENWMkpZYUhaVlZFWnJZekZrZFZWdGVGTk5NRXA1Vmtaa05GbFdUa2RYYms1b1UwVTFXRlJYZEhkbFZsSnpXa2M1VjJKVmNGcFpWV1J2VmpKS1dXRkljRnBsYTFwWVdrWmFVMlJIU2taT1ZtUnBZVEJaZWxacVNqQldNa2w0VlZob1ZtSnJjRTlXYlRGVFZsWnNjbHBIT1ZoU2JIQjRWa2N3TldGdFNrZGlSRTVZWVRGWmQxWnFTa3RTTWs1SllVWmthVmRIWjNwV2JYQkhXVmRPZEZSclpGTmlSMUp3VmpCV1MxTldXWGhYYlVaWVlsWmFTRmRyYUZkVk1rcEhZMGhDVm1GcldreFdWVnBoWkVkT1JscEdVazVXVkZaWlZtcEtOR0l5U2tkVFdHUllZa1phVmxacVRrOU9SbEp5VjJ4d2JGWlVWbGRVTVZwcllWWmFXVkZyYUZkU00yaFhWR3hhWVZZeFpITmFSbEpvVFd4S2IxWnRjRTlpTWtaSFlUTm9XR0V6VW5KVmJYUjNUVVpzVmxaVVJsWk5WWEJZV1RCV01GWXlTbGxWYldoYVlXdHdTMXBWV210ak1rWkhWVzFvVG1KWGFGbFdNV1F3WVRGVmVHSkdaR2xUUlRWdlZXNXdjMkl4Vm5SbFNFNVBVbXhzTlZSc1ZUVmhSMFkyVW01c1YwMXVVblpXYWtaS1pXMUdTVmRzWkdoaE0wSk5WbGR3UzFReFNsZGFTRTVvVW0xU2NGVnROVU5YYkZwMFpFWk9WRTFWTVRSVk1XaHZWbGRLYzFkc1dscGlSMUV3Vm10YVYyUkhWa2xhUjJ4T1ZtNUJkMWRzVm10U01rVjNUVmhLV0dFeWFHRlpWRXB2VkVaWmQxcEZXbXhpUlZveFZUSjRWMVl5U2xkVGJGWllZa1p3YUZsNlNrOWpNWEJKVlcxMFUySklRbEJXVjNSWFUyc3hSMWRzVmxSaWJWSmhWbTE0YzA1V1ZYbGtSemxYVmpCYWVsVXllR3RaVmxsNlZXcE9WMVpXY0hwVWJYaExZekZTZEdSR1pHbFRSVWt5Vm14U1NtVkhUWGhYYTJSVVlrWndjVlZyVlRGWFJteHlXa1pPVGsxV1duaFZiWE14WWtaS2RGVnVjRmhoTVhCMldWWmtTMUp0VGtsaFJtUlhUVEpvZVZac1VrZGpNVmw0V2toV1ZtRjZWbGhaV0hCWFZteGFkRTFVVW10TlYxSllXVEJXWVZkSFNsbFZiR2hWVm14d2VsUlVSbkprTVZwMFpFWmthR1ZyV1hoWFZsWnZXVlpaZDAxWVJsTmhNMmhZVkZaYWQxZEdhM2xOVm1SVFRWZFNlVlJzWkhOaFZsbDVZVVJLVjJKVVJqTlZWRVpoWkVaYWNscEhSbE5pVmtwNFZsZDRhMVV4V2xkaVJteHFVbTFTV1ZWdGVFdFhSbHAwVGxkR1ZXSlZjRWhaTUZKRFYyc3hSMWRZWkZkU00yaExXa1JCZUZaV1ZuTmFSMnhYVW14d1ZsWnRNVEJoTVUxNFUxaG9ZVk5HV2xOWmExcDNZakZzVlZGdVpHbE5WbkF3VkZaU1UxZHNXWGROVkZKYVRVWmFjbFpzWkV0WFZsWjFVV3hhYVZkSFozcFdSM2hoV1ZkT1YxUnNWbE5pUmxwUFZtMTBXazFXV2xWVGFrSmFWbXhHTkZkclZtOWlSa3AwWlVkR1YyRXhXbWhVVkVaM1UwZFdTRkpzWkZkaGVsWTFWMnRXWVZReVJsZFhiR2hyWld0d1dGUlhOVk5oUm14eFVteHdiRlpyTlhsWGEyUjNWa1pKZW1GR2JGZFdla1V3VjFaa1IxSXhaSFZWYXpWWFlUTkNlVlpHVmxOU01XUkhZa2hLV0dKWVVtOVdiWGgzVjBacmQxZHJUbGROVlhBd1ZrWm9iMWR0Um5KWGJrcGFaV3RhY2xwR1dsZGphemxYWVVaT1RsWllRbGRXYlhSaFlUQTFSMkpHWkdGU1YxSlpXV3RrYjFWR1duTlZiazVhVm14d01GcEZhR3RXTWtwSVpVaHNWMDFxVmxCV2FrcExWbTFPUjJOR2NGZFdiR3QzVm0xd1FtVkhVbGhTYTJ4cVVtNUNUMWx0TVc5bFZtUlZVMnBTVmsxck1UVlZiWFJyVmxkS1dHRkZPVlZXVmxwNVdsWmFZV05XU25OVWJFcE9Wak5vV1ZacldtOWlNV1JIV2tWb2FGSnNXbUZaYkdodlZFWmFjVkpzY0d0TldFSklWa2N4YjFVeVNrZGpSRlpYWWxSQmVGbFVSbUZTYXpGWFlrWkthVkl4U2xwWFZsSkhWMjFSZUZkc1ZsTmlWVnB5VlcxNFlVMVdhM2RYYlhSWFRXeGFlVll5Y0dGV01rcEhVMnQ0Vm1WcmNGQlpla1pUWkZaU2MxUnRiRk5OVlhCUlZtMHdkMDFXUlhkTldFNWhVMFZ3VjFsVVNsTlhWbXh6VjIxR1ZGSnNjRWxVYkZVMVYyeGFjbUpFV2xaV00yaFVWakl4Um1WWFJrWlZiSEJvWVRGd2IxWnFRbXRWTVU1SFUyNU9WbUY2Vm05YVYzaGhVMnhhZEUxSVpFNVdiRlkxVlRKMGExWlhSWGxoUm1SYVlUSlJNRll3V25Oak1rWklUMVpTVTJKRmNEVldha2w0VWpGa1IxTllhRmhoTW5ob1ZXeGFkMk5zV2tobFJYUlRZa2RTZVZkcldtdFdNbFp5VjFod1YxWXpRa2haVkVwT1pVWndTVlJ0YUZOTmJXaFZWa1pqZUdJeFpGZGFSbWhzVW1zMVZGUldaRk5UUm14VlZHNU9WV0pHY0ZaWmExcFRWbFpaZWxWdGFGWk5WbkJZV2tWa1YxSnJPVmRhUlRWb1RUQkpNVlpzVWt0bGF6RlhWMWhrVGxadGFHOVZhMVV4VmpGd1dHUkhSbFJOV0VKWFZqSnpOVmRHV1hkWGEyaFhVbnBHZWxsVlpGZGpNV1J4VTJ4a2FWSXdOREJYYkdSNlpVWmtSMVZ1U21GU2JWSlpWV3BHUzFkV1pGZFZhemxXVFZad2VsbHJhRXRYUjBwMFZXNU9WbUpZYUdoVVZWcFRWakZhZEdSSGFGTmhNbmQ2VjFSQ1lXSXhXblJUYkd4U1lrVktXRmxyWkZOVVJsWnhVMnM1VkZJd1draFhhMXBQVlRGYWRWRnFWbGRpUjA0MFdsZHplRll4WkZsaFIzQlRWakZLZUZaWE1IaFZNVnBIVjI1U1RsSkdXbEJaYTFwM1RVWlNWbUZIT1ZWTlZXd3pWRlpTVTFZd01YVmhTRXBYWWxSR1RGa3ljekZXTVdSelkwZHNVMDF0YUVaV2JURXdXVmROZVZSdVVsTmhNWEJXV1Zod2MxWkdiSEpoUlU1WVZteHNORlpYY3pWaFZURlhWbXBPVlZac2NIWldiVEZHWlZkR1IyRkdWbGROTUVwWlZtcENZVmxXWkVaTlZscHJVbXhLVkZsclduZE9iR1JZWkVkR2EwMVdiRFJWTW5ocllXeEtWVkpzYUZwaVIyaFVXVlZhYTFZeGNFWlBWM0JPWVhwV1NGWnFTWGhOUmxWNVUyeGtWR0p0VWxoV2FrNURVMFpXTmxGVVJsTk5WMUo2VjJ0a1IxVXhTbkpqUm14WFVteHdhRlY2U2xkak1XUlpZVWRvVkZKVVZuWldWekV3WkRGa1IxZFliR3hTZW14WldXeFdkMU5XYkZaaFIwWllZa1p3V0Zrd1dtOVdWMHBaWVVWNFdrMXFSbFJWTUdSUFVtczFWMkZHVGxkWFJVcE9WbTB3ZUUxSFJuUldhMmhVVjBkb1dGWXdaRk5VTVZweldrWk9hbFpzV2pCVVZsSlRWMFpLYzFkcVFtRldWbGwzVm14YVMyUkhWa1ZSYkZaWFlraENlVmRXWkhwbFJtUkhWbTVHVTJKR2NIQldNR1J2VlZaa1YxZHRSbHBXYkd3MVZrZDBhMWxXU25SVmJGSmFZa1p3UjFwRVJtRlhWMDVHV2tkb1RsWnRkekJXTW5SdlV6SkdSMU5ZY0ZaaVJrcFdWbXhhZDAweFduRlNiWFJZVWpGS1NWVnRNVEJVYkZwMVVXcGFWMkZyYTNoV1ZFcEhaRVphZFZSc2FHbFNNbWhvVjFkMFlWbFZNSGhXV0doWVltczFXRmxyV25kbFZsRjRWMjVrVjAxcmNFcFZWM0JoVjBaYVJsTnVTbFpoYTFwNlZtcEdhMk14Y0VoalJsSlRWMFZLZGxac1pEUlpWMUY0Vld0a2FsSldjR2hWYkdSVFZrWnNXV05HWkZoU2JIQkpXbFZWTlZZd01WZGlSRnBYVm14S1JGWnFTa3RXVmtaeFZXeFdhRTFzU2tsWFZFcDZaVVpaZUdORlpHRlNiV2hVVkZjeGIxbFdXWGhaTTJoc1lYcEdXVlZ0ZEd0V01rcHlUbGRvVm1KdVFucFpNVnBUVmpGa2RGSnJOVk5pYTBwSVZqSjBWMkV4WkVkVGJrcHFVMGhDVjFSWE5XOWpiRmwzV2tWYWJGSXdOVWRhVlZwclZUQXdlV0ZGTVZoaE1WcHlWbXBHVDFkR1NuSmFSbWhwVmpOb1dWWlhNVFJrTURWWFYyNVNUbGRIVWxOWmJGcGhVMFpaZUdGSE9WcFdhelZIVmpKNFUxZHRSWGxWYkZKWFlURndNMVl3WkZOVFJrcHlUMWRzVTJKclJqTldNVkpEVmpBeFIxZHJXazVXYlZKd1ZXdGFTMWRHVm5WalJtUldVbTFTV0ZZeWREQmhNVXB6VjI1d1dsWldjR2haVmxwS1pVWktjVmRzYUdsU01VVjNWakZhWVZReFRrZFhia3BvVWpOU1ZGbFljRmRrTVZwMFRWUlNhMDFYVWxoV01uaFhWa2RHYzFOdVJsVldNMUpvV2xkNFZtVkhSa2xVYldoVFlUTkNObFpVU2pSaE1XUjBVbGhvYWxJeWFGWldhMVpoV1Zad1JWSnRkR3RTTVVwSVdWVmFUMVJzV25WUmEzQlhZbGhTY2xSclpFWmxSbFoxVkd4b2FXSkdjRlJYVmxKTFRrWmtSMkpHYUd0VFJuQnlWRlprTkZac1ZuUmxTR1JwVW10d01WVlhkR3RYYkZwWVZXNWFWMkV4Y0V4V01WcEhZekpHUjJGR1pFNU5iV2Q1VmpGa2QxTXhTWGhUV0doaFVtMTRjRlZxVG05V1ZsWnpWV3hrV0ZadFVsbGFSV1F3Vm1zeFJWSnNhRmhoTW1oTVZqQmtTMWRXVm5OWGJIQnBVbXh3V1ZaSE1UUldNV1JJVm10c1ZXSkhVazlXYlRFelRXeGtWMVp0T1ZwV2JWSjZWakowWVZkSFNuSmpSbVJhVmpOU2FGa3llSGRTTVdSelZHMXdUbFpzYjNkWFZsWldUVlpaZUZwRldsUmlSM2hZV1d4U1EwNUdVbFpYYkhCc1ZteGFXbGxWWkVkVk1WbDRVMjVrVjFZelVtaGFSRVpoVWpKS1NWTnRSbE5oZWxaNFYxZDBZV1F3TVVkalJscG9Vak5TVmxsclZuZE5SbkJXWVVoT1YwMUVSakZXUmxKSFYyeGFWMk5IUm1GU1JWcG9XVEZhVTJNeVRrWk9WazVvVFRCS01sWnRNSGhrTVUxNFZGaG9XR0pIVWxWWmEyUTBZVVpXZEU1VlRsaFNiRnA2Vm0xNGExUXhTbk5qUmxwV1ZucEdTRll5ZUZwa01EVlpZMFp3VGxKc2NESldiRkpMVXpGS2NrNVdiRkppUjFKdldWUk9RMDFzV2toa1IwWmFWakF4TkZrd1ZsZFdiVXBZWlVVNVYySkdjR0ZVVmxwaFkyeGtkRTlYYkU1V2JYY3hWbFJKTVZNeFpFaFRhMlJVWWxWYVdGbFVSbUZOTVZweVYyMUdWMkpIVWpCVmJURXdWVEF4VjJORmJGZE5ibEpYVkd4YVZtVldUbk5pUjJoVFlsZG9XbFp0TVRSWlZsbDRWVzVPV0dKSVFuTlZiVEZUWld4YWRHVkZPV2hXYTJ3MVdWVmtiMWRHV25OVGEyaFdaV3R3U0ZWcVJtdFhWMHBJWlVaT1RsSnVRbUZXYkdSM1VURnNWMU5ZYUZoaVIyaHpWV3BPVTFac2JITldiVVpzVm14c05WbDZUbTlXTURGeVYyNXNWMDFxVmt4V2JURkhZMnhrY21WSFJsTldia0p2VjFSS05HUXhTWGhqUldocFVtMVNUMVJYTVc5aFJscDBaVWQwYTAxVk1UVlZNV2h2VjBkS2NrNVdiRnBpV0UxNFdWVmFWMk5zWkhKa1JuQlhZa2hCZDFkc1ZsZGhNVkY0VTI1T2FWSkdXbWhXYkdSU1pERmFjVkpyY0d0TmF6VktXVEJhWVZSdFJuTlhhMVpYWWxSQ05GVjZSbXRXTVZaellrZG9VMkpXU2xWV1YzaGhaREZrUjFwSVNsWmhNbEpoVm1wQk1VMUdXbGhrUjNSb1lrVndNRlpYTlVOV2F6RkhWMnRvVlZaRldtaFpNbmhyWXpGd1NHSkZOV2hOVm10M1ZtMTRhazFXVVhoYVJXUmhVbGRvYjFWdGVFdFpWbHB4VkcwNWFGSnNjSGhWYlRWUFlXc3hjbGRyYUZkU2VrWXpXVlphU21WR1RuTmlSbVJvWVRJNU0xWkdWbUZYYlZGM1RWWnNWR0Y2YkZoV2FrWkxWakZhUjFkdFJtdE5helY2V1d0YVlWWXhaRWhoUm1oVlZqTlNlbFJ0ZUhKa01XUjBaRVpXYVZKdVFYaFdWbU4zVGxaWmQwMVdaR3BUUlhCWVZtdFdZVlJHYTNsak0yaFhUVmhDU0ZsVlpHOWlSMHBaWVVad1YyRXhjRlJWZWtwS1pVWmtjMXBIUmxOaVYyaDZWbGMxZDJNeVRrZFZiR1JZWW1zMVVGVnRlSE5PVm5CV1dYcFdWMVl3Y0VkWk1GWnJWakF4Y1ZGVVJsZGlSbkJvV2tWYVYyTXhWbk5YYXpWVFltdEtiMVl5ZUdGV2F6RlhWMWhvVm1Kck5WbFphMVV4WTBaVmQxWnJkRlJpUm13MFZsZDBUMWRzV1hkaVJGSllZVEpvVkZaclpFWmxWbFp6Vm14d1YxSllRakpYVmxaaFZqSk9WMVZ1VWxCV00yaHdWVzAxUTA1R1dsaE5SRVpvVFZaV05WVXlkSE5WYlVWNVZXeGFWVlp0VWxSYVYzaGhWbFpPY21SR1VsZGhNVzkzVjFaV1lXRXlSa2hTV0d4UVZrVTFXRlJXV25kaFJtdzJVbXh3YkZKc2NERldiWGhYWVZaSmVXRkdjRmRXTTBKTVdXcEdZV014Y0VkYVIwWlRVbXR3ZVZaR1dtdFZNVTVIVjI1U1QxWnJOWEJWYlhSM1YyeGFXR1ZIUmxkaVZYQmFXVlZrYjFsV1dsZGpSbWhoVWxaV05GWnNXa2RqTVdSeVRsWk9VMVp1UW1GV2JURjNVMnN4V0ZWWWFHRlRSa3BVVmpCa05GWXhiSFJPVlU1WVVteHdlVlp0Tld0Vk1ERlpVV3RhVmsxdVRURldWRUY0WTIxT1JtRkdhR2hOV0VKNVZtdGtlbVZIVWtoU2EyeFlZa2RTVDFsdGVFdFdWbHBaWTBWa1dHSldXa2hXUjNoellVWkplbEZzVWxkaGExcE1Xa2Q0WVZkSFRrWlBWMnhPVm01Q1NWZFhkRzlUTWtaSFUyeGFUMVp0VWxkWmJHaHZUVEZTVmxkdVNtdE5WbkI1V2tWa2MxVXlSWHBSYkdSWFlsUkZkMWxxUm10a1JrcFpZVWR3VTJKWGFGbFhWM1JyVlRGU1IyTkZXbGhpUjFKeVZXeFNjMWRHWkhKYVNFNVlVbXR3ZVZsclVtRldNa3BaVVd0NFZXRXhjR0ZhVlZwM1VtMUdSMXBIYUU1WFJVcFlWakZrTUdFeVNYbFVhMlJZWW1zMVdWbHJhRU5VTVZwMFpVaGtiR0pIVW5sV1YzaFBWakZhVlZKc2FGcE5SbkIyVm1wQmVHTldXbk5SYkhCWFRUSm9UVmRyVm1GV01sSklVbXRrWVZJeWVGUlVWbFozVm14YWMxVnJUbHBXYkhBd1ZsWm9iMWxXVGtaalNFcFdZV3MxUkZaRVJscGtNVnB5WkVaU1UySklRa3BYYkZaclVqSkdSazFXWkZSaWJrSllWRmMxYjJWc1dsaE5WVnBzWWtWYWVsbFZXbmRoVmtsNVlVWldXRlpGYnpCV1ZFcFBZekpPUmxkdGNGTk5NbWhWVjFkMFlXUXhiRmRhUm1SWFlsaFNWRlJXV25kVFJsVjVaVWhPVm1KVmNFZFZNbmh2VjJ4WmVsVnJlRmROUm5CeVZtcEdhMlJIVWtkVWF6Vm9UVEJLU2xZeFpEQmhNbEY0VjJ0a1ZHSkdXbGhaYlhoM1YwWmFkV05GV2s1U2JWSllWbXhvYjFZd01YSldhbHBZWVRGd2NsbFdXbXRTTVU1ellrWm9WMDB4U2xsWGExSkxWakpOZUZwSVZsWmlXRUpVVm10a05GZHNXbGhqUlU1WFRVUldTRll4YUhOVU1WcFpWV3hvVlZZelVsaFVhMXB5WkRGd1NFOVdhR2hsYTFsNFYxWldiMU14WkhKTlZtUnFVbGRvWVZwWGRIZFZSbFYzV2tWa1UyRjZWbGhaVlZwUFZqRmtSbE5zUmxkaVZFWXpWV3BLUm1Rd01WWmhSazVZVWpKb1YxWnFRbXRpTWtaSFZtNVNUbFpyTlZsVmJURTBaVlpaZVUxVlpGZE5WbkF3V2xWb2MxZEhSWGhqUmtKWFlrWldORlpxU2s5VFYwWkhWMjFzV0ZKcmJEWldNV1F3WVRGTmVGTlliRlZoTW5od1ZXMHhVMWRHVWxWU2EzUnNWbXh3TUZwVlpEQldSVEZYWWtSU1dHRXlhRkJaVlZwTFpFWldjMkZIUmxkTk1taHZWbXBHWVZsWFVraFZhMmhyVW14S1QxWnFSa3RYVmxwMFRVUkdWRTFXV2toV01qVlBWMGRLU0dGSGFGZGhhelZVV1ZWYVUxZEhWa2hTYlhCT1YwVktSMVpzWkRSa01WbDNUVlphYWxKWVFsaFpWRXBTWkRGa1YxZHNaRk5OVjFJeFZUSXhkMVV4V2tobFIyaFhZbGhTV0ZwSE1WZGpNVlp6VjJ4b2FWWldjSGxXVjNoVFVqRktjMVp1VW14U00xSldXV3hXVjA1R2EzZFZiVVpYVFZad1Ixa3dVazlYUmxwMFZXdG9WMkZyV2xCWmVrWmhaRWRLUjFSdGJGZE5iV2gyVm1wR2EwMUdiRmRVV0doVllUSlNXVmx0ZEhkWFZteHlZVVZPYW1KR1NsaFhhMXBQVkd4S2RWRnJaRmROYWtWM1ZtcEJlR050VGtaYVJuQm9ZWHBXZVZacVFtdFNiVlpIV2toV1ZHSklRbTlaVkVaM1ZsWmtjbFp0UmxSTlYxSlpWa2QwYTFaSFNsaGhSVGxWVmxaYU0xWXllR0ZqTVhCRlVXeGtUbFl6YUZsV2Frb3dZVEZzVjFOdVVsWmlSM2hoV1ZSS2IxSkdiRFpTYlVaclVqQTBNbFZ0TVRSaFZrcDFVVmhrV0dKR1duSlVWV1JIVWpGT2MxWnNUbWxTTVVwb1ZrWldhMVV5VW5OWGJrWlVZVE5TV0ZadGRIZFdiRlpZVFZWa1ZrMVZjRmhaTUZwRFYwZEtSMWR1U2xkU1JWcExXbFZhZDFOV1VuUmhSazVPWWxkb1VWWnJXbUZXTWxGM1RsVmtXR0pzU2s5Vk1HUnZZekZzV1dORlpGaFdiSEF3Vkd4Vk5XRkdTbFZSYWxaWFZucEdkbFp0TVVabFIwNUdaVVp3YUdFeGNGbFhWRVpoVXpKU1IxTnVVbXhTTW5oVVdXeG9hbVZHV1hoVmF6bHJUVlZzTkZZeGFHdFViRnBYVjJ4U1dtRXlVblpYVmxwVFZteHdTRTlXVmxOaVNFSTJWbXBKZUZJeFdYZE5WbVJxVTBkb1dGVnVjRWRUUmxweFUydDBWRlpyV2pCVU1WcHZWMFpPUmxOcmJGaGhNVXBJVlRJeFYxSXlUa1ppUmxwcFZqTm9WVlpHWXpGaU1WcFhXa1pvVGxaRlNsVlVWM1JoVTBaWmVVNVZaRlpOYTNCYVZsZDRRMVp0Um5KVGJHaFZWa1ZhVkZsNlJtRmtSMUpIWTBaa2FFMHdSak5XYlhoclRrZEplRnBJVWxSaVIzaFdWakJrYjFkR1VsWlhibVJzWWtoQ1IxZHJXbXRXUmxwMVVXdHNXazFHVlhoV2FrcExZMnhLY1ZSc1pHaE5XRUp2VmpGYVlWVnRWa2RqUlZwaFVtMW9jRmxZY0ZkV2JHUllaRWQwVmsxWGVGaFdNalZQV1ZaS1ZWWnJPVmRpV0dneldsVmFWMVl5UmtoUFZscE9WbTVDTlZkVVFsTlNNV1J5VFZWa2FsSXlhRmhWYm5CSFZFWndSbHBGWkZOV2JWSjZWMnRrYzFkR1NsWmpSWEJYWWxoQ1MxcFZXbHBsVmxKWllVWm9hV0pHY0ZsWFYzaHZVVEZhUjJKSVRsaGhNMUp5VkZaYWQxZFdVbFpWYTJSV1lYcEdlbFl5ZUc5V01ERjFZVWhhV2xZemFFeFdNVnBYWXpGa2MxWnNaR2xTYkZrd1ZtMXdRMWxXV1hsVmExcFBWbXh3VVZacVNtOWpSbFp6V2tST1RsWnRVbnBXYlRGSFZtc3hXRlZxUWxaTmJtaDZWbTB4Um1WdFJraGhSbHBvWVhwV01sZFdWbUZqYlZaWVZtdG9hMUl6UWs5V01GWkxVMVprVlZGdFJtaE5Wa3A2VlRJMVQyRkZNSGxoUm1oYVlrZG9WRmxWV25OalZrNXlUbGQ0VTJKSVFtRlhWM1JoVkRGa1IxTlliR2hUUjJoWVZtNXdSbVF4WkZkWGJYUlRUV3R3U0ZsVlpIZGlSMFY0WTBaV1YxWjZSVEJhUkVwWFZqRmtXV0pIZUZOV1IzaFpWa1prTUdReFRrZFhXR3hQVjBkU1dGbFljRWRsUmxaelZXdE9WMDFXY0VkWk1GWTBWbXN4VjJORmFGcE5ibWd6VldwR2QxSXhjRWhsUjJoT1VqTmplVlp0TVRCaE1EVkhZa1prV0ZkSGVGWlpiWFIzVkRGYWRFMVVVbGRXYlhoNVYydGpOV0ZzU25OWGJtaFhVbnBCTVZZd1drdGpNazVHWVVab1dGTkZTa2xYVmxwV1pVZE9jazVXYkdwU2JWSlBXVmQ0WVZSV1dYaFhiVVpVVFZkU1dGWnROVmRWTWtwSlVXeHNWazFHV2t4V01WcGhZMVpLZEZKdGNFNVdia0kyVmpKMGIxVXlSWGhUV0d4b1VtMW9ZVlpyVlRGU1JsSjBaVWRHYWxacmNEQlVNV1F3Vkd4WmVGTnJjRmRXUlc5M1dWUkdhMU5HVG5OaFIyaFRUVVp3VjFadGNFOVJNVTVIVjFoa1dHSkhVbkZXYlhNeFpWWlJlRmRyT1doV2EydzBWVEp3VjFZeFNrWlhiV2hhVmtWYVZGa3ljM2hYVmxaMFlVWk9VMVpHV2xwV01XUXdZVEZTZEZaclpHcFNWbHBWV1Zod2MyTldiRmxqUldSWVVtMVNlVmRyVm10V2F6RnlZMFpzV2xaWGFIcFdha1phWld4R2NsVnNhRmRpVmtwUlZtMXdSMVl5VFhoalJXUm9Vako0Y0ZadGRIZE9iRnAwVFVob1QxSnJNVFJXTVdodllWWktjMk5IT1ZaaVJrcDZWakJhVTFkSFVrbGFSbVJPVmpOUmVsWnNaREJVTVZsM1RWWmthVkpHY0dGV2JHUnZUVEZhY1ZOclpHcGlWVFZIV2xWa1IxVXlTa2xSYTJ4WVZrVnZNRlpxU2s1bFJtUjFWVzFvVTFaR1dscFdWM2hYWkRGc1YxZHVSbE5pUlRWVVZGWmtORmRHV2xkaFNFNVhWbTFTU1ZsVldtdFhiVXBaVkZob1YySllhSHBXTVdSUFVqRndTR0pGTlZoU1ZYQmhWako0VjJFeFNYaFhhMmhVWVRKU2NGVnJXa3RYVm14VlVtdDBVMUpzYkRWYVZXUkhZV3N4Y21ORldsZFdNMmh5VmtkNFdtVlhSa2xpUm1Sb1RXeEZkMWRXVWtkVGJWWkhZMFZzVm1KRlNsaFphMmhEWkRGYWNWRnRSbFJpVmxwNlZqSTFSMVV5U2xaWGJVWlhZV3RGZUZZd1dtRlhSVFZXVDFaa1YwMUlRbUZXYkdNeFVURmFkRk5zVmxkaE1VcFlXVmQwWVdGR1duTlhhemxxVm10YWVsa3dXbXRVYkU1R1UydHdWMkpHU2t0VVZscFNaVVp3Um1GR1VtbGlSWEI2Vmxjd2VHSXhXbk5YYmxacVVtMVNjbGxyV25OTk1WbDVUbFU1VjAxcmNFaFpNRnAzVjBkRmVWVlVRbGRXUlhCSVZHMTRZVmRYUmtkaFJtUk9UVlZ3ZGxZeFdsTlNNV1IwVm14a1dHSnNXbFZaYTFwTFYwWldjMVp1WkZoV2JIQlpXVEJWTlZack1YSlhhMmhhWVRGd1dGWnJaRWRPYkZwMVZHeGFhVlpGV2xWV1JscGhXVlpPUmsxV2FGQldiSEJQVm0wMVExTnNaSE5XYlVacVRWWnNORlV5TlU5V1IwVjVZVVprWVZZelVqTldhMXB6VG14S2RHUkhjRTVoTVhCSVZrZDRZV0V4VlhsU1dIQlNZV3hhV0ZSV1duZGtiSEJGVW10d2JGWnNjREZXUjNodlYwWkplbUZHUmxkaVZFWTJWRlphWVdNeFZuTmFSbWhwWWxaS1VGWlhNVFJrTVdSWFkwWmFhRkpVYkZsVmFrSjNVMVphV0dSSVpGZGlSbXcyVmxkNFUxWXlTa2hWYTNoV1lXdHdVRlZzV2xOak1YQklZa1pvVTAxdGFESldha1pUVWpGc1YxTlliRlZYUjJoeFZXeGtVMkZHVm5OVmJHUlhWbXhhZWxadE5XdGhWVEZYWTBSQ1ZWWnNTbFJaVldSSFRteEtjMkpHWkZkaVYyZ3lWakZhWVZReFNuUlVhMXBRVm0xU1QxVnROVU5pTVdSWVkwVmtWMDFyTVRWVmJYUnZWVVphZFZGc2FGcGhNVm96VmpKNFlWTkhWa2hqUlRsWFlraENObFpVU1RGVk1rVjVWbTVLYWxKdFVtRlphMlJ2VkRGU1YxZHVUbGhTTURFMldWVmFiMVl5UlhoalJGWllWbXhhYUZscVNrZFNhekZYWWtaS2FXSllhRnBXYlRFMFpESkdSMVpxV2xKV1JWcHlWVzEwZDJWV1duUmxSM1JvVm10c05GVXlOV3RXTWtwWlZXeG9WMkpVUmxOYVZWcHJWMWRHUjJGSGJGZFdia0kwVm10YVlWbFhUWGRPVldSaFUwVndXVmx0Y3pGaU1WWjBaRWhrYkdKR1ZqVmFWV2hQVmpKS1ZsZHViRnBOUjJob1ZtcEtTMUl5VGtsVGJHUk9VbXhaTUZacVJtdFVNVXB5VGxaa1lWSlVWbFJaYlhSTFV6RmFkRTFJWkd0TlJFWllWbXhvYzFaSFJYbFZiRlphWVRKUk1GWnFSbk5rUjFKSVVteGthVkp1UVhkWGJGWnZZVEpHUjFOdVZsSmlSM2hvVm14a1UxTkdiRlZTYTNSWFZteHdlbGxyWkVkVk1WcDFVVzVzV0Zac1duSldha3BQWXpGd1NWUnRiRk5pVjJoWlZsZDRWMlF3TVhOYVNFcFdZVEpTV1Zsc1dtRlhSbHBJVGxVNVYwMXJjRWRVYkdNMVZsWmFObEp1V2xkTlZuQm9Xa1ZrVTFJeGNFZGpSbVJPVW01Q1NsWXhaREJWTVd4WFZsaHNVMWRJUWxkWmJYUmhWMFpzYzFWclpGZFNia0paV2xWb1MyRXdNVmRqUmxwV1lsaG9hRlpITVVabFJtUlZVMnhrVjJKV1JqTldNVnBoVjIxV1YxUnVUbWxTTW1oVlZXeGFkMkl4V25SbFIwWnJUVlpHTkZrd1dtRlhSMFkyWWtoS1YySllhRXhVVlZwWFpFZFdSMVJzV2s1V2JrSkpWbXBKTVZsV1dYbFRhMmhWWVdzMWFGWnNXbmRXTVhCWFYyeE9hbUpJUWtoWlZXUnpZVVV3ZDFOc2NGZE5WMUV3Vm1wR2MxWXhXbkphUjJ4VVVsaENXbGRYTUhoVk1rMTRWMjVTYkZORk5WQldiWGhMVjBaYWRFMVVRbGROUkVaWFdUQmFZVlp0U2xsaFNIQlhZV3RhWVZwWGVGZGtWMDVIV2tkb2FFMHdTazVXYlhCSFdWWlplVlZyYUZOaE1sSm9WV3BLTkZaR1VsZFdibVJWWWtad2VsZHJhR3RXUlRGWFVtcFNWazFYYUhwV1ZFcEdaVlpXZFZKc1dtaGhNMEl5Vm10U1IxZHRVWGhYYmtwaFVsUnNjRlZ0TlVOT1ZsbDVaRVpPVmsxWFVucFdNV2hyVmpKR2MxTnNiRnBXUlZveldrZDRZV014Y0VaWGJYaFRUVVJXU2xkV1ZtRlpWMFpYV2tWYVRsWkdTbGhaVkVaTFUwWmtWMXBHVGxOaGVsWllWako0VjJGSFZuUmxTR1JYVm5wQmVGVlVSbHBsUm1SelZteE9hVkpVVmxWV1JscGhaREZKZUZWc1pGaGlXRkp2V1d0V2QxZFdjRlpYYlhSWFZteHZNbFp0ZUZOWGF6RjFZVWRvV2sxdWFETlZiVEZUVTBkT1NHRkhlR2xTYmtKaFZtcEdZVll4YkZkWFdHaFlWMGRvV1ZZd1pHOVdWbXh5VjIxR1dGWnRlRlpWTW5oTFZHeEtkRlZzYUZoaE1WVXhXVmR6ZUZkV1JuSmpSbVJYVFRKb1VWZFdXbUZUYlZaSFZHNU9VbUpIVW5CV01GWkxVMVphV1dORlNrNVdNREUwVjJ0YWMyRldTWHBWYkZKVlZsWndNMVpxUm1GU01XUjBVbXhTVG1KR2NEWldha1p2WXpKS1IxTnVVbFppUjJoV1ZtcE9VMWRHVW5OWGJrNVhZa2RTTVZaSGVHOWhWbHBYVjFSQ1dGWkZTbkpaYWtaYVpEQXhWbHBIY0ZSU1dFSlpWMVprTUZsWFRuTmlSRnBUWWxoU2NsVnFSbUZUUm1SeVdrYzVWV0Y2UmtkWk1HTTFWakpLV1ZGcmVGVldWMUpIV2xaYVYxZFhSa2RhUm1oVFRUSm9WbFl4V210T1IxRjRXa1ZrYVZORmNHaFZhMXBMVjFaYWRHVklaR3hTYkhCSldsVlZOV0ZHU25KalNIQlhUVlpLVEZadGMzaGtWMFpIVVd4d1YwMHdOREJYVkVwNlRWWmFkRkpyWkdwU2JWSllWRlpXVjAweFduUmxSazVTWWxaYVNGVXhhSE5XVjBWNVZXNUNWbUpVUmxSV2ExcHpZMjFHUmxSdGJFNVdNVW8xVm14a01FMUdXWGROVm1ScFVrWktZVlJWV21GbGJGcHlXa1YwVkZJd1drbFVNVnBYVmpGS1YyTkZNVmhoTWxFd1YxWmtVMUpyTVZkV2JFcHBWMFpLVUZadGNFZFRNVTVYV2tab2ExSXdXbGhVVmxwM1YxWlZlV1ZHWkdoV2EzQXdXbFZhYTFkc1dYcFZhM2hWVmtWYVYxcEVSbXRqTWs1SVpVWmtUbFp1UWt0V2ExSkhXVmRGZVZKc1pGaGlhelZ4Vld0YVlWZEdiRmhrU0ZwT1VtMTRlRlZ0TVRCaE1VcHpZMFJHVmsxdWFIWlpWbVJHWld4R2RHRkdhR2xTTVVZelZqRmFhMVF5VFhsVGExWllZa1pLYjFSWGVFdFdiRnBZWTBWT2EwMVZOVWhXTW5SdllrWkplbFZ0T1ZkaGEwcFlWRlJHY21ReFpIVmFSbVJPWVROQ1YxWlhlRk5STVdSelYydGFVMWRIYUZkWlYzUjNWRVpXY1ZKdVpGUlNNSEJJVmtjeGMxWXlSWHBSYkd4WFlXdGFhRlpVUms1bFJscFpZVWRHVTFZeFNuZFdWRUpYWkRKR1IxWnVWbXBUUlRWeFZtMTRTMWRHV1hsTlZXUnBVakJ3U1ZaWE5YTldNREYxVkZSR1YwMUdjRXhaTWpGUFVsWkdkRkpzWkZkTmJXY3lWbTB4ZDFGdFZraFZiR1JYWWtkNGFGVnRNVk5VTVZaeFVtdDBWVlpzY0ZsWk1GWXdWbFV4Vm1ORVFsWk5ibEoyVmxSS1MxTkdWbk5oUm5Cb1RXeEdObGRzWkRSWlYxSkdUVlpzWVZKcmNIQldiWGgzVTFaYWNWSnRPV3BOVm5CWlZXeG9jMVp0U2xWaVJtUmFZa1pLV0ZWcldtRlNWa3B6V2tkMFUwMVdjRXRXTW5SaFlURlplVk5yYkZKWFIxSlpWbXRXUzFkR2JGVlNiWFJxVFZkU1dsbFZXbE5oUlRGMVlVWm9XRll6YUhaV1ZFWnJVakZrZFZSdFJsTlhSa3BWVmtaYWExVXlWbk5pUmxwWVlsaFNiMVp0ZUhkVFJsbDVaRVprVjAxV2NFZFdNakZ2VjJ4YVJsZHVTbGROUm5CVVdUSjRhMlJHU25OVWJXeFRWMFZLVWxacVJtRmlNbEY0VTI1S1RsWlhVbGxXTUdRMFkyeFdkV05JVGxkaVJrcFlWakkxVDFReFduTldhbFpoVWxkTk1WWnFTa3RXYlU1R1lVWmFUbUp0YURKV2FrbzBXVlpLYzFwSVJsVmlTRUpZVm0wMVEySXhaRmxqUldSb1RXc3hOVlpIZEc5aVJrcHlUbGhDVjJKWVVucFVWRVpoWXpGcmVscEhlRk5OUkVVd1ZteGpNVlV4VlhoYVJXaHNVMFZ3YUZacVRsTlVSbGwzVjI1T1YxWnJjREZYYTJRd1lWWkplbUZFVWxkV2VrVXdXa1JLUzFJeFpIVlRhemxZVWpOb2FGWnRlR0ZrTWtaSFlrWmtXR0V6UW5OV2FrSmhVMVpzVmxkdGRHaFdiVkpJVlRKNGMxZEhSWGhUYTJoWVZteHdTMXBWV25kVFZscHpWbTFzVTAxdGFETldNVnB2WkRGWmVGcEdaRmhpYkVwUFZtdGFTMVpXVWxaVmEyUlVVbXh3V0ZsVll6VlhSa2wzVjFSS1dtRXhjR2hXTWpGR1pVZE9SVlJ0UmxkTk1tZzJWMVJHWVZVeVVraFZhMlJvVW1zMVQxVnRlSEprTVZwMFkwVjBUMUl3YkRSV01uaHJWMGRLU0ZWdVJsWmhhM0IyV1ZWYVYyTXhaSFZhUmxwVFlsaFJNVmRzVm05aE1WcEhVMWhrVDFaWGFGaFdhazV2VmtaYVZWSnRSbGhXYTFvd1ZXMTRhMkZIUlhoalNHeFhVak5TYUZadE1WZFNNWEJIWWtkR1UxWkdXbFpXVjNCTFlqRmtjMWR1UmxKaVdGSlhWRlprVTFkR2JISmhSVGxYVFd0d1YxWXlOVWRXTWtwWllVVjRWMDFHY0hKWk1uaHJZMnM1V0dKR1RtbFRSVVl6VmpKNFYxbFhSWGhYV0dST1YwVmFWRmxVU205WFJteFlaRVZrVDFKc1ducFdNblJyWVd4YWMyTkljRnBOUm5CeVZtcEtTMUl5UlhwYVJtUnBWa1ZaZWxaWGNFZFVNbEpIVjI1V1ZtSkZOVzlVVnpWdlZteGtXR1JIZEZaTmEydzBXV3RhVjFVeVNuUlZiRnBYWWxSR1ZGWXllSEprTVZwMFpFWmthR1ZyV2paV1ZFbzBZakZaZUZkcVdsZGlSVXBZV1d4U1IxUkdXWGRhUm1SVFRWWmFlbFp0ZUd0aFZrcDBUMVJhVjJKWVFreFVhMXB6VjBaV2NsZHJOVmRXTTJodlZsZDRVMVl4WkVkaVJsWlRZa2hDVDFWdGVIZE5SbkJXV1hwV2FGWlVSbGxXVjNSelZtc3hjVlpyZUZwV00yaE1Xa1ZrUjFOR1NuTmpSbVJUVjBWS1ZsWnRNVEJaVjBWNFYxaG9ZVk5HU2xSWmJHaFRWa1pTVjFadVpGUk5WbkI1VjJ0b2QxUXhXbk5XYWxaV1RXNVNjbGxXVlhkbFZsWnpZVVphYUdGNlZqSldiWEJIVlRKTmVGcElVbE5pV0VKdldsZDBZVmxXV2xWVFdHaHJUVlpXTkZZeGFITmhSa2w1WVVab1ZtSllhR2haVlZwM1VsWk9jbHBHVGs1V01VbDRWbGN4TkZNeFpFZFRXR3hvVW14YVdGVnRlSGRoUm5CRlVtMTBhazFyY0VoV01uaHZZVlprUjFOc2JGZFNiSEJZV2tSR2ExSXlSWHBhUm5Cc1lrWndXbFpYTUhoVk1VNXpWbXhvYTFKNmJGbFZiWGgzVFVaYVdHVkdUbGRpVlZwNVZqSjRRMWxXU25OalJsSmFaV3RhV0ZwRlpFZFRSMVpJWWtaT2FXRXdjRzlXYlRGM1VqSkZkMDVWYUZSWFIzaFVXVzE0UzFZeFdYZGFSemxZVm0xNE1GcFZWakJoYlVwSFYyNW9WMUl6YUZCWlZ6RkxVakZPYzJGR1pFNWliV2g1Vm10U1IxTXlUWGxVYTFaU1lrWmFjRlZ0TlVOVlZscDBZMFZrVkdKV1JqUldNalZIVm0xS1NWRnJPVlppVkZaRVZHMTRZV05XVGxsaFJrNXBWbXh3V1ZadE1ERlVNVnAwVTJ0b1ZtSlViR0ZXYTFaaFRURlNkR1ZIZEZoV01EVkhXa1ZhVDFSc1dsaGtla0pYWWtkTmVGWkVSbk5XTVU1MVUyczVXRkpWY0ZoV1JsWmhXVlpTUjFaWWJHeFNNRnB5VldwQk1WSXhjRVpXVkVaV1RWWndSMVl5ZEhOV01rWnlWMjVhV21WcldtaFZNRnBMVjFkS1NHRkdUbWxXYTNCdlZqRmtORlV4U25KTlZXUllWMGRTV1ZsclpGTmpWbHAwWlVWMFRsSnNSalJYYTJNMVZtc3hjbU5GY0ZaV00wSlVWbXBHWVZKdFNYcGFSbFpYVm01Q1dGZHJVa0psUm1SWFZHNUtVRlp0VWxoVVZ6RnZWMVphZEUxWVpGVk5hMncxVmtjMVQxZEhTa2RYYkU1WFRVZFNWRmt5ZUZOV01WcFZVbTE0VjJKSVFscFhiRlpyVFVaYWNrMVZWbEpoYkVwWFZGZHdWMlZzV25GVGEzUlVVbXhLZUZaWGVHdGhSMFY0WTBWNFdHSkdXbWhXYWtwVFZqRmtkVlJ0UmxOTmJtaFZWMVpTVDFFd01IaFhiazVhVFRKb1QxVnFSa2RPVmxwWFlVYzVXRkl3Y0VsWlZXaFBWbTFLV1ZSWWFGZE5SbkJVVm1wR2QxSXhVblJsUjJ4VFlsaGplRll5ZUZkaGF6VlhWMnhvVkdFeGNIRlZiR1JUVjBaU1dFNVhPVlpTYkhCNlZqSXhSMkZyTVZoVmJtaFhVbnBHU0ZacVFYZGxWMFpJWVVab2FWSnVRbmxXYkZKSFZERkplRlJ1VmxWaVZWcFVWbXRhWVdSc1drZFZhMDVVVFZkU1dGWXlOVk5oYkVwWlZXeENWbUpVUlRCV01GcGFaVmRXU0dSR2FGTk5TRUkxVmtkNFlXTXhaSFJUYTJoV1lteHdZVlpzV25kaFJtdDRWMnhPYTFKVWJGaFpWVnBQWVZkRmQyTkZiRmRoYTI5M1YxWmtSbVZHWkhKYVJsSllVakpvVmxkV1VrdGlNV1JYWWtaV1UySnRVbkZaYTJRMFYwWlplVTFWWkdoaVZYQlhWR3hXYTFkdFJYaGpTRXBhVmxaV05GbDZSa3RYVm5CSFdrVTFWMkpyU25aV2JYaHFaVVpaZUZOWWFHcFNWMUp3VldwS05GWkdiSEpXYm1ScllrWndTRmRyVWxOV1JURllWVzV3V0dFeGNIWlphMXBLWld4V2RWRnNWbGRpU0VJMlZrZDBZVmR0VmxaT1ZscHJVbTFTVDFsVVRrTlhSbHB4VTFoa1QxWnNjREJWTW5oWFZqSkZlRk5zWkZWV1ZuQXpXVEo0Y21WWFZraFNiWEJYWVRGd05sWnFTbnBOVmxsNVUyNUtWRlpGY0ZoWmJHaERVekZTVjFwR1NteFNia0pLVmtkNGIyRldTWGxoUm1oWVZucEJlRlZVUm10U01XUjFVMnhrYVZaV2NIWldWekF4VVRGT1IxZFliR3RTTTFKdldWaHdSMlZXYTNkV2JUbFlVakJXTlZaWE5YZFdNVnBHVW1wU1ZtSkdjRmhXTVZwM1VqRndTR0ZGTlZoU1ZYQmhWbTF3UjFsV2JGZGlSbWhXWVRKU1dWbHRkSGRoUmxaMFRWWk9hbEp0ZUZwWk1GcHJZVlV4VjJOR2JGVldiRXBVVm10VmVHTnJOVlpoUm1ScFZrWmFWVlpyVWtkWlZscHlUbFprYVZKdVFtOVVWM2hMVmxaYWNWRnRSbHBXYlZKSlZsZDBZV0V4U25OWGJrSldZbFJXUkZSdGVHdFhSMUpIVkd4YVRsWnRkM3BXUmxwdlVqRlplVk5yWkZSaVZWcGhWbXRXWVUweFZqWlNibVJUVm10d01GcEZaREJXTWtwR1kwUmFWMDF1VW5KWmVrWnJVakZPV1dKSGFGTldSbHBaVmtaak1XSXhaRWRhUm1SWVlsVmFjbFZ0ZUhkbGJHeFdWMjFHYUZKVVJsaFpNRnBUVjBaWmVsVnVTbGRXUlZwVFdsVmtTMUl4V25OV2JXaE9Va1phVjFac1kzaE9SMUY0Vkd4a2FsSnNjR0ZhVjNoaFlqRnNXV05GWkZoU2JYUXpXVlZvVDFZeFduTmpSRUphVmxad2RsWXllR0ZXTWs1R1pVWmtUbFl4U2tsV1YzQkxVakZKZUZwSVVtaFNNbWh6V1d0YWMwNVdXblJOVkVKWFRWZDRXRll4YUhOV1YwcElWV3hXV21KWVVqTldWbHBoWTFaU2NsUnNhRk5pV0dnMlZtcEtNRTFHVVhsVGEyUnBVa1phYUZWc1pGTlRSbXhXVmxob2FtSkhVbnBaVlZwclZUQXdlRk50T1ZkaVdGSnlWWHBHVDFZeFNuVlViV2hUWW10S2RsWkdaRFJUTVZwWFYydGtWbUV5VWxoVVYzTXhWMFpWZVU1VmRHaGlSV3cyV1ZWYWIxZHRSWGhYYWs1WVZteHdjbFpxUm1Ga1JrcHpZMFprVGxKdVFtRldiR1EwWWpKSmVWSnVUbFJpYkVwelZXMHhORmRHYkZoamVrWnJZa2hDU1ZwVmFFOWhiRnB5WTBSQ1ZtSllhRkJXUnpGR1pXeEdjbUpHWkdsV1JWVjNWbGh3UzFJeFpFZFViazVoVW14S2NGVnFUbTlYVmxwMFRsaGtVMkY2UmtoWk1GWlhWV3hrU0dGR1VsVldNMDE0VlRCYVdtVlhWa2hQVjJoWFlsWktTVlpVU2pSa01XUkhWMWh3Vm1KWGFHaFZhMVozVjBaYWNWTnJkRlJXYXpWNlZqSXhjMVV4V2tkWGJIQlhZVEZ3YUZkV1pFNWtNRFZaVkd4b2FWSXlhRkJXYlRWM1l6RmtSMVZzYUd0U01GcHpWbTB4TUUweFduUk5WRUpZWWtad2Vsa3dhSGRYYXpGSFkwaGFWMDFxUmxoWk1uaHJZekZXYzJOSGVHaE5NRXBTVm14U1EyRXhTWGhUYmtwUFZtMVNhRlZxU2pSaU1WSldZVVZPYVUxV2NEQlVWV2h2Vkd4SmQxZHFRbGRpV0ZKb1ZrUkdZVmRHVm5WUmJGcHBWa1ZhVlZkV1ZtRldNazE0WTBWb1VGWnRVazlXYWs1dlZqRmFXRTFFUm1oTlZuQjZWakkxVDJGc1NrWlRiV2hYWWtkU2Rsa3llR0ZqVmtweVpFZHdUbUY2Vmt0WFYzUmhZVEpHVjFkcldsaGhNbmhZV1ZkMFMyTnNWalpTYTNCc1ZteEtlVmxyWkhkVk1rcFlZVWhhVjFKc2NGaGFSRVpMVmpGa2RWVnRlRk5pU0VKNlZsY3hOR013TlZkWGEyaHJVMFUxYjFsclZuZE5SbHBZWTNwV1dHSkdiRFpaVldSdlZqRmFjMk5IYUdGU1YxSlFWVzE0ZDFJeVRrZGFSMmhPVFVWcmVWWnRNVEJoYXpGWFZsaG9WMWRIZUZWWmExcDNWMVpzY2xwSE9WZGlSbkI1Vm0weFIxWldTblJsU0doV1lsUkdTRll3V2twa01EVldXa1pvYUUxc1JqTldhMlEwV1Zaa1YxSnVUbWxTYlZKWVZXeGtNRTVHV2xsalJYUlRZbFphU0ZaSGVITmhiRXB5WTBoQ1dsWkZTak5XTUZwclYwZFNTRkpzVWs1V01VcEpWbXhqTVZVeVNrZFRXR1JZWWtkb1dGbHNhRTVsUmxsNVpVaE9WMkpHY0ZaV2JYaGhWRzFGZWxGc2JGZFdSVzkzV1hwR1dtVkdaSEpYYkdocFlraENhRmRzWkRCa01VNUhWbTVHVTJGNmJIRlVWbWhEVTBac1ZscElUbFpOUkVZd1dWVmpOVll3TVZkalJsSldZV3R3VTFwRVFYaFRWMFpJWWtaT2FWTkZTbUZXTVdRMFZqRnNXRlJzWkZoaWJFcHlWVEJrVTJNeFduUk5WRUpPVFZkU2VWWlhlRTlXTWtZMlVtNXNXazFHV25aV01uTjRVakZPYzJGR1pHaGhNMEpKVjFSSmVGTXhTbGRXYms1WFlsZG9UMVl3Vmt0WFZsbDVaVVprV2xZd1ZqVldWM2hyVjBkS2NrNVdWbHBpUjFFd1ZtdGFZV015UmtaVWJHaHBVbTEzTUZZeWRGTlZNa1pXVFZoS2FWSkdTbGxaVkVaaFkyeHNXR1ZGZEZkTlYxSjZWbGQ0ZDJGRk1WbFJXSEJZVjBoQ1NGWnFTbE5TYXpGWFdrWldhR1ZzV2xsWFYzUnZVVEZPYzFwSVRsZGlXRkpQVlcweFUxTkdWWGxPVlhSb1ZtdHdTRll5TVVkV01rcElWVzVhVlZaRldtRmFSRVpyWXpKT1NHVkhiRk5pUnprelZqRmFWMWxYU1hoWFdHeFVZVEo0VTFsdE1UUlhSbHB4Vkd0T1ZGSnRlRlpWTW5oUFZqQXhWMk5FUmxkV2VrVjNWbFJLUjA1c1duTlJiR1JUWWtoQ1dWZHJVa2RoTVZsNFdrWnNhRkl3V2xSVmJYUjNWMVphUjFwRVVsTk5SRlpJVmpKMGIyRXhTWHBWYkdoVlZtMVNWRlV4V25kV2JVWkdUMVprYVZaWVFsZFdWekUwVlRGa1IxZHVUbXBTTW1ob1ZXeGtVMWRHVlhoWGJtUlRUV3RhU0ZaSE1YTlhSa3B5VjFSS1YySlVRak5hVlZVeFVqRldXV0ZHYUZoU01VcFFWbTB3ZUZVeVRrZFdia3BZWW0xU1lWWnRlSGRsYkdSeVYyczVhRTFyY0VoWk1HaHZWbXN4ZFZWWVpGZE5SbkJoV2tSR2EyTnRUa2RYYXpWcFlsZGtObFp0ZEdwbFJrMTVWV3RvVTJFeWFGRldiVEZ2VjFaVmQxWnJkRlJXYkd3MFZqSXhNRlpYU2xkWGEyaFhZbFJXV0Zac1pFdFdiR1J6Vld4V1YyVnNXakpXYlRFMFdWWmtTRlpyWkdGU00xSlBWbTEwZDFOV1duRlRWRVpXVFZaS2VsWXlkR3RXUjBwV1YyeG9XbFl6VWt4V01GcFRWbFpLYzFSdGNFNVdia0YzVjJ0V1lXRXhWWGxUYkdSVVlUTkNXVlp0ZUdGaFJtdzJVbXh3YTAxRVJsZFpWVnBoWVZkS1NWRnNiRmhXTTFKb1drUktWMk15UlhwaVIzaFVVakZLVlZadE1UUlpWMVp6V2toS1lWTkZOVmRVVlZKRFRsWmtkV05GWkZkTmEzQmFWVmQwTUZaV1duUlZhMlJoVmxad2NsbDZSbXRqYXpWWFdrZHNWMkV6UW1oV2FrWnFaREF4VjFKWWFHRlNWMUpYV1d0a2IyTldWblJOVms1cVZtMTRlVll5Tld0V01rcEhWMnBDWVZKV1NrUlpWV1JIVG14S2RXSkdWbWxTYkhBeVZtcEtORmxXV1hsVWExWlZZa2RTYjFsVVJuZGhSbVJ6VjIxMFUwMVZiRFJWTWpWUFdWWkplV0ZGT1ZkaVIyaEVWVEo0WVdNeVJrbGFSbEpPVm10Wk1WWnJXbTlpTWtaelUyeG9iRkp0YUdGWmEyUnZVa1phY2xkdVRtcGlWVnBIVmtjeE1GUnNXblZSYWxKWFZtMU9ORlJWWkVkV2F6RlpVMjFzVTFKcmNGbFdSbVIzVmpGV1IxZHVVazVXVm5CeldXdGFZV1ZzV2xobFNHUm9WbXR3TVZWWE1EVlhSMHBJVlZSQ1YyRnJjRlJWYlhNeFZqRmtkR1JHVG1sU2JrSlJWbTB3ZDAxV1JYZE9XRTVoVW14YVUxbHNVbk5WTVZKWFYyNWtUbEpzV2pCVWJGWXdZVWRLUms1VmFGcE5SbkIyVmpJeFJtVkhUa1ZVYkhCWFZtNUNiMWRVUm1GVE1rMTRZMFZvYWxJeWVGVlZiRlozVTJ4YWNWTnFRbGRoZWtaWlZXMTRhMVpIU2tobFJrNWFWa1UxVkZZd1duTmpNVlp5VkdzNVUySkZjRmhXTW5SWFpESktSMU51VGxoaVNFSmhWbXhhZDJSc1dYZFhhemxUWWtVMWVsWlhlRzlXTWtwWVdqTndXRmRJUWtoWlZFWktaVlpPY21KR1VtbFNNbWgzVjFkNFlWTXhWa2RYYTJSWVlsVmFjVlJWVWtOT1JsbDRZVWhPVldKR2NGbFdWM2h6Vm0xS1dWVnFUbGRpV0doWVdrVmtWMU5HU25OYVIyeFRZbGhqZVZZeFdsZGhNa2w0VjFob1ZHRnNjRlJaVkVwVFlVWmFjMXBHVGxaU2JGcDRWVEowTUZVd01WbFJhMmhZWVRGd1VGWnFTbGRrUm05NlkwWmthVmRGU2tsV01WcHJVbTFXUjFSc2JHaFNiV2haVldwS2IxZEdaRmhOVkVKclRXczFTRlp0TlZOaE1VNUlWVzVHVm1KWWFHaGFWVnBYWkVkU1JWRnNhRk5pU0VGM1ZteGtOR014YkZkWGJHaFZWa1ZhWVZadGVGZE9SbXQ1WlVkMGFtSlZXa2hYYTJSelZUQXhkR0ZFVmxkaVdFSkVXVlJHVG1WR1VuSmFSbVJwWWtad1ZWZFhkRzlSTWtsNFZXeGthRkpWY0hOWmExcDNUVVpTVjFWc1RsaGlSbXcwVlRKMGMxWXlTbGxWYldoWFZsWndZVnBXWkVkU01rWkhZMFprVTFaR1drWldiVEYzVWpGc1dGVnJXazVXVjNodlZXMXpNVlF4V25STlZFNU9WbXh3V1ZwVll6VmhhekZYWTBod1YwMXVVbWhXYTJSTFUwWldkR0ZHWkdoaGVsWlZWMVpXWVdFeFdYaGFTRlpoVW0xU2NGVnFSa3BrTVdSeVZtMTBhMDFXU25wWGExWmhWa2RGZWxGc2JGZGhNVnBNV1ZWYVlWSldTbk5qUjNoWFlUTkNZVmRVUW1GVE1rWlhWR3RhVkdKSGVGbFdhazV2VmtaV2RFMVdTbXhTYlZJeFZXMTRUMkZYUmpaV2JHeFhVbXh3YUZwRVNsZFdNWEJKVTJ4b2FWWldjSFpXYlhCRFZqQTFjMVpzYUd4VFIxSlpWVzE0ZDJWc1ZYbGtSRkpYVFZad1Ixa3dXa05XTWtaeVYyeG9XbVZyV2pOVmFrWjNVMGRLU0dKR1pHaE5NRVY1Vm0xd1IyRXdNVWRpUm1oVlYwZFNVRlp0TVZOalZsWjBaVWhrV0ZKc2NIbFdNakZIWVZVeFYxZHFRbUZTVjJoeVZtcEtTMUl4WkhGUmJVWlhWakZHTTFacVFtdFNNRFZ6VTI1S2FGSnRVbkJWYlhSM1UxWmFkR05GZEZOTmF6VjZWMnRvVTFVeVNsWlhiR2hoVmpOU2FGVXhXbUZYUjA1R1pFWk9UbFpYZHpGV1Z6RXdZVEZzVjFOWWJHeFNiRnBYV1d0YVlVMHhWWGxsUjBacVZtczFlRlpYZUd0VWJGbDZZVVpzV0ZZelVtaFpha1poVmpGd1JtRkhhRlJTVm5CWVYxZDBhMVV4V2tkaVJscFlZa2RTY1ZadGN6Rk5SbEY0V2toa1ZXSkdiRFpaVlZKWFZqSkdjbUV6YUZwV1JWcFRXbFZhVDJSV1VuUmpSbEpUVFRKb1dsWnJXbXRrTVVsNFZHdGtXR0pyV2xOV01HUnZWMVpXY1ZKdFJsUlNiWGhYVmpJeE1GWlhTa2RpUkZaYVZsWktURlpxU2t0WFZrWnlaVVphYkdFelFsQlhiRlpoVlRKU1YxZHVUbFppVjNoVVdXMTBTMDB4V25SalJVNVhZbFphUjFSc1ZtdFhSMHB6VTJzNVYyRXhjRXhaTVZwVFYwZE9ObEp0ZUdsU01VbzFWMVpXWVdFeFpITlhia3BxVWtWS1dGWnFUazVOVmxweFUydDBXRlpzV25oV1IzaHJWR3hhZFZGdWJGZGlXRUpJVjFaa1UxSnJPVmRoUjJoVFZrWmFXVmRYZUc5aGJWWkhWMjVPVm1FelVrOVZha0pYVGxaV2RFNVZPVmRXTUZZMVdsVmFUMWR0UlhsVmJscFhZbGhvYUZwR1pFOVNNWEJIV2taT2FXRXdjRXRXTW5oWFlURkplVkpZYUZSWFIyaFpXVlJLYjFsV1VsWmFSa3BPVW0xNFdGWXlNVWRXTURGeVRsVmtXbFpXY0haV2FrcExVakpPU0U5V1pHbFhSVXBOVmxkd1IxZHRWa2RWYms1cFVqSm9WRmxyVm5ka01WcFlZMFU1YVUxWFVsaFdNalZUVkRGa1NGVnNVbHBYU0VKSVZUQmFXbVZYVWtkYVJtUlRUVVpyZVZadE1ERlVNVnAwVTJ4c2FGSllhRlpXYlhoM1lVWlZkMVpZYUZkaVNFSklWakp6TVdGRk1IZFRiSEJYWWtaS1RGUnJaRTVsUm1SWllVWm9hR0pJUWxWV2JYUlhVekpHUjFadVNsZGlWVnBYVkZab1ExWXhXWGxOVkVKb1RWWndlbFl5Y0VOWlZrcFhZMFpDV2xac2NHaFpNakZQVWpKT1IxcEhhRTVYUlVwMlZtcEdZV0V4VW5SVldHUlBWbXh3YUZWdE1WTlhWbFp4VTIwNWEySkdjRmxVYkdocllXc3hWMkpFVWxkV00yaDJXVlJHVDFOR1ZuVlViR1JwVjBkb1RWZHNaRFJYYlZaWVZtdGFVRlp0YUZSVVZXaERWMFphZEUxWVpGWk5WMUo1VkZaV2ExWkhTa1pUYkdoYVZqTlNNMVpGV2xwbFJuQkdXa1pTVTAxR2NFbFhWRUpXVFZkR1dGTnNhR0ZTUm5CWVdXdGtVMDB4Vm5GU2JGcHNWbXhLV2xsVlpIZFZNVmw0VTIwNVYxWXpRa3hVYTFwaFZqRmFkVlJzWkdsaE0wSjZWbTB4TkdRd01VZFZiRnBvVWpOU2IxUlZVa2RsYkZsNVpFYzVWMkY2UmxsWlZXaGhWakF4U0ZWclpHRldiVkpJVldwR1lXTXlUa2RhUms1WVVsVndWMVp0TVhkU01XeFlWRmhzVldKc1NsUlpWRVozVm14c2NtRkZUbGhTYlhoNVZtMDFhMWRHU25OaVJGWmhVbGRTTTFaRVJtRmpNVTUxWWtaV1YySklRbmxYVm1RMFV6RlplVlJyWkdGU2JWSndWbXRXWVUxc1pISmFSRkphVm14d1dGVXlOVTloYkVsNlZXczVWMkZyV2t4VWJGcGhZMVpPY1ZWdGFFNVdiRmw2VmtaV2IyTXlSa2RUYWxwcFVtMTRXRmxzYUc5Tk1XeFdWMjVPVjFacmNIbFpNR1EwVlRKS1JtSXphRmRXUlhBMlZGWmFXbVZXVG5OYVJsSnBZbFpLV1ZkV1pEQlRNa1pIVm1wYVUySllVbFJVVm1oRFUyeGFTR1ZIZEdoV2JIQllXVEJhWVZkR1dYcGhSMmhZVm14d2NsVnFSbXRqYlVaR1QxWmtXRkpyY0RKV2JUQjRUVWROZDA1WVRsZGlSMmh6Vlcxek1WZFdiSE5XYm1SVVVtMTBNMVp0Y0ZOV01ERkZVbXhvV2sxSFVuWldha0Y0VTBaV2MyRkdXbWhoTVc5NlZsUkNhMVV4U25KT1ZtUmhVbTFTVkZscmFFTmhSbHAwVFVob2EwMVZNVE5VYkZadlZURmtTR0ZJUWxaaVZFWlVWbXhhYzFaV1RuTlViR1JYWWxob05WWXlkR3BPVmxsNVUydGthbE5JUWxoVVZ6VlNaREZaZDFkcmRHcE5hM0JHVmxkNGExUnRSbkpYYTJ4WVZteEtTRlV5TVZkU01WSjFVMjFzVTJKSVFuZFdha0pyWWpKV1YxZHVUbFpoTUhCelZXMXpNVmRHVm5ST1ZYUm9VbXR3TUZsVldtOVdiVXBIVjJwT1dtRnJXbkpXTUdSUFVteHdSMkZIYkZkaVNFSmFWbTEwYWsxV1RYaGlSbVJVVjBoQ1UxbHJXa3RXTVd4eVYydDBXRkp0ZUZkV01qRkhZVEZKZUZkcmJGWmlWRVYzVmtjeFJtVkhUa1ppUm1ScFZrVkdORlpzVWt0VE1VbDRWR3hzWVZKdGFIQlpWRTVEVjBaa1YxcEVRbHBXYkVwSVZteG9hMWRIU2xaWGJGWldZV3RGZDFSWGVGZGtSMVpJWkVaV2FWSnVRWGhXVmxwdllqRlplRmR1VG1wU2JFcFhXbGQwWVZsV2NGZFhhemxxWWxWYVNGWnRNVzloVmtwWlVXeG9WMDFXY0ZSVmFrcFNaVlphZFZSc2FHbGhNWEJWVjFkNGIxVXlUbGRWYkdSb1VsVTFWVlp0ZUdGTlJuQldWbFJXVjAxRVJubFpNR2h6Vm1zeGRXRkZlRmRoYTNCTVZteGFSMk5XVm5SU2JHUk9UVVJSZDFadE1YZFNNbEY0VTI1T2FsSlhhSEJWYlhoTFZrWlpkMVpyZEZwV2JHdzBWMnRTVTFZd01WaGxSbXhXVFZkb2RsWnFTa3RqTVU1MVZHeGFhR0V3Y0c5V2FrSmhZekpPYzFwSVVsTmhlbFpVV1d0V2QxZFdXblJOU0doT1VteHNOVlZ0Y0dGVk1rVjRZMFprV21KSGFIWmFSM2hoWkVkTmVtRkhjRmRpU0VGNFZtcEtOR0V5UmtoU1dHaHFVakpvV1ZsclpFOU9SbFp4VW1zNVZGSnJjSGxYYTJSM1ZUSktWMU51WkZkV1JVcFlWWHBHVTJNeFpIVlZhelZZVWpGS1ZsWkdXbUZTTURWSFZsaG9hRk5GTlZkVVYzUlhUbFphV0UxWE9WZGlWWEJXVlcxNFUxZHRWbkpYYm5CWFlrWndURmw2U2s5VFIxWklZa1pPYVdFd2EzZFdiWGhxWkRKV1IxTllhR0ZUUlRWWldXMXpNVmRHYkZobFJYUllVbXhLV0Zkcll6VmhNa3BIWTBod1dHRXhXWGRaVnpGSFRteGFjMkZHY0doTldFRjZWMVpXVm1WSFRYaFVia1pVWWtkb1dGUlVRa3RUVmxwelZXdGtXbFl3TVRSV01qVlhWbGRLVmxkc1VscGlSMUoyVm14YWExZEhVa2hQVmtwcFZtdFpNRlpxU2pCaE1XUklVMnRhVDFadFVsWldiVEZUVmtad1dHVkdjR3hTTUZwSlZERmFiMVV3TVVsUmEzQllWbXhhY2xWcVJtdGpNV1J5VjJ4b2FFMHlhR2hXYlhoaFpESkdSMWR1VGxoaGVteHhXV3hhUzFOR1draE5WemxwVWpCd1NGa3dXbmRXTURGWFkwWm9XRlp0VWxOYVZscExZMnhrY2s1V1pHbFdhM0F6Vm10YVUxUXhSWGhhUm1ScFUwVndXVmx0TVZOaU1WWjBaVWhrVGxKc1NsaFdNakV3VjBaS2NtTkljRnBOUjJoNlZtcEJlR1JYUmtaVmJHUm9ZVE5DVFZadGNFZFVNbEpYV2toT2FGSXllRlJVVmxaYVpXeGFjMVZyZEd4aVZscElWakZvYjJGc1NsaFZiV2hXWWxSR1ZGa3dXbGRqVmtweVpFWm9VMkpJUWtsV2FrbDRVakpHY2sxVlZsZGhNbWhZVkZaa2IyVnNXa1ZTYlVaWFZqQndTVlF4V25kaFJURlhZak53VjFKc1dtaFpla1poWXpGd1NWVnNRbGRpVmtwM1ZtMTRZVmRyTVVkWGJrWlVZbTFTVmxSV1duTk9SbGw1WkVkR1dGSXdXbmxVYkZwdlYyMUtTR0ZJV2xwTmJtaDVXbFpWZUZZeFVuTlZiRTVPVWtaYVNsWnFTakJoTWsxNFYydGtWR0pHY0ZsV01HaERWMFpzV0dSSVdrNVNiSEI0VlcwMVQxWXdNVmRYYkhCYVZsWndkbFl3V2twbFYwWklUMVprVjAweWFHOVhhMUpIV1ZaWmVWTnJiRlJpUjJod1ZteGFkMWRzV2xoTlNHaFBVakZhZWxZeWVHOWhNVWwzVjJ4YVdtRXhXak5hVjNoeVpESkdTRTlXWkdsV1dFSlhWbTB4TkZFeFdYbFNia3BUWVd4S1dGbHNhRTVsUmxweFUyczVVMDFyTlVoWGExcHJZVmRGZDJORVNsZGhhMXBvVm1wS1JtVkdVbGxoUmxacFVqRktWVmRYTVhwTlZsbDRZa2hLWVZKck5YQlVWbVEwVm14V1dFNVhkR2xTYkhBd1ZsZDRjMWRyTVVkWGJrcFhZV3R3VEZacVJtdGpiVXBIVjJzMWFXSkZiekpXYlRFd1lURk5lRlJyWkZkaWJGcFRXV3RrVTJOR1ZuUk9WVXBzWWtad2VGVnRNVWRYYkZweVlrUlNXR0V5YUZSWlZFWkxWbGRLUjFWc2NHaE5iV2hGVmtjeE5GbFhUbGRVYmtaU1lsZDRUMWxVUm5aa01WcDBUVVJHVlUxWFVrbFZNblJ2WVVaSmQxZHRSbHBXUlZveldWVmFVMVpXU25OWGJYUk9WakZKZUZaVVNYaE5SbEp6VjFob1ZGZEhVbGxaVkVaaFlVWnNWVkpzVG1wTlZUVjVWako0YjFkR1NYbGhSbXhZVmpOU2NsWlhjM2hTTVZwelZteE9hVk5GU25wV2JURjZUVmRXYzJKSVNsaGlSMUp2VldwQ2QxSXhhM2RYYms1WVVteHNObGxWYUdGV01VbzJVbXhvVm1GcldtaGFSbHBUWXpKR1NHRkZOV2xTV0VFd1ZtMTBZVmxYU1hoU1dHaFZZVEpTYUZVd1ZuZFhWbXh6WVVaT2FVMVdjSGhWVjNoclZHc3hXR1JFVGxkaVdFSkVWbXBCZUdOdFRrZFhiRnBYVFRCS1VWWXhXbUZaVmxsNFYyeHNhRkpzY0c5WlZFWjNWbFphY1ZKdGRGUk5WV3cwVmpJMVUyRldTWGxsUmxKWFRVWmFURlpxUm1GalZrcDBVbXhhVGxaWGR6RldiRnB2WWpGYWMxcEZhR2hTYlhoaFdXeG9iMVJHYTNoWGJtUllVakZLU1ZWdGVHOVdNa3BIWWpOa1dHSkdXblpaVkVaVFl6Rk9kVlJzVW1saWEwcFpWMWQ0YjFSck1WZFhibEpxVFRKb1dGUlhjekZUYkd0M1YyNWtWV0pGYkRWWGFrNTNWakpLV1ZGclRtRldWMUpRVm1wR1QyUldUblJoUms1cFZtdHdNbFl4V2xOUk1XUnlUVlZrV0dKc1NuRlZiR1JUVm14U1dHTjZSbGhTYkZvd1ZHeFZOVmRzV25KalNHeFZZa2RvUkZacVNrZGpiVTVKVm0xR1YySklRbTlYYTFaV1pVWmFWMUp1VW1oU1ZGWllWbXRXVm1ReFduTlZhMlJwVFdzeE5GWXllRzlWTVdSSVpVWmtXbUV5VWxSWFZscHpWbFpPZEU5V1RsTmlSM2Q2Vm1wS05HRXlSbkpOVm1ScVVrVmFXRlJYY0VaTlJteFhWMnQwYTFaclduaFdNbmhyWVZaSmVGSnFUbGhXYkVwTVZXMHhVbVF3TVZkYVIwWlRUVzVvVlZaWE1UUmtNV1JIV2tab2JGSjZiRmRVVjNoTFpXeFplV1ZIUmxoU01IQlhWakkxUjFkdFNrZFdXR2hXWVd0YVUxcFZXbXRrUjFKSVlVWmthVlpyY0V0V2FrcDNWREpSZUZkWWJGTmlhM0JaV1d4a2IxZFdXblJOVms1WFVteGFNRmw2VG05V01ERlhZMGh3VmsxcVJucFdha0Y0WkVkR1IxSnNaR2xXUlVsNlZrWmFZVkp0VmtkVmJsWlZZa2RvY0ZWcVNtOWxiRnBZVGxoa2FrMXJOWHBXVjNodllURkpkMWRzVmxaaVdHaFlWR3hhZDFac2JEWldiR1JPWVROQ1dGZFVRbUZqTVdSelYyeGthbE5GY0ZoVVYzQkhVakZ3VmxwRk9WTldiRXA2V1RCYWExWXlTbkpUYmxwWFlrZE9ORlJyWkVabFZsWnlXa1pTYVdGNlZuWldWekY2VFZaUmVGZHVVazlXVlRWVlZGWmFkMlZzWkZWVWJUbFZUVlZzTTFadGNGZFdiVXBaVlc1YVYyRnJjRXhaTWpGUFVqSktSMk5IYkZOaVNFSjJWbTF3UjFsV2JGaFViazVZWW10d2NsVnFTbTlXUm14elYydDBXRlpzY0hoVk1uQlRZVEF4Y21ORmFGZE5hbFpNVmtSR2ExTkhWa2RpUm5CWFVsaENWVlpHVWtkWlZscFhVMjVPYWxJemFIQldiRnAzVTFaa1dHUkhSbWhOYTFwWVZqSjBZVlpHV2taVGJHaGFZVEpTVkZSdGVIZFdiR1J5WTBkNFUySnJTa3RXYTJRMFlUSkdWMU5zVmxkaWJWSllXV3hvYjJGR2NFVlNiVVpxVFZkU2VsbFZWVEZXTVVweVkwaHNWMUp0VVRCWFZscHJVakZ3U1ZOdGFGTlhSa3BhVmxkd1EyUXhTWGhWYms1YVpXeGFXRlJYZEhkWGJGcFlZMFU1VjAxRVJqRlpWVnB2VmpBeFNGVnNhRlpOVm5CVVdYcEdkMUpyTlZoaFJUVk9VbGhDZGxadGNFZFpWbGw1VWxoc1ZGZEhhSEJWYlRGVFZsWnNWVkp1WkZoV2JYaDVWbTEwTUZZd01WaGxSbXhoVWxkU1NGbFhNVXRUUjFKRlZtMUdWMVl4UmpOWFZtUjZaVVprVjFKdVNtbFNia0p2VkZab1ExVldXbkphUkZKYVZtMVNXRlZ0TlU5aFZrcDBWVzVDVjAxR2NFeFpha1phWlVaa2RGSnNhR2xXYkhCS1ZsUktNR0V5UmtkVGJsSldZbXRLWVZZd2FFTlhSbGw0VjIxMFdGSlVSbFpXVjNoVFZHMUdObEpVUWxkaVZFRjRWV3BHVjJSR1RuTlhiR2hwVWpOb1dGZFhlRzlpTURCNFZXeGFXR0pGTlZoVVZtUlRaVlpSZUZkdFJsVmlSWEJIVmpKNGMxWXhXa1poTTJoaFVrVmFZVnBFUVhoWFZscHpWbXhrVTFadVFscFdNVnByVFVaSmQwNVZaR2hOTW5oUFZteFNjMVpHYkhOV2JVWlVVbTFTZVZac1VrZGhSa2wzVm1wU1dtRnJOWHBXYWtwTFZsWkdjVlZzVm1oTldFSTJWbTF3UjFReVVsZFZibEpUWWtaS1ZGbFVUa05OYkZweldUTm9UMUl4UmpWVk1XaHZZVlpLYzFkc1VscGlWRVpVVmpCYVlXUkZNVmRVYkdScFVteHZkMVpHV2xkaE1WbDNUVlZXVTJKdGVGWldiWGhMVmtaWmQxcEZXbXhXTUZwSVZsZDRkMVl5U2tsUmF6RllWa1Z3TmxSV1dscGxWa3B5V2tkd1UwMXVhRnBXVnpFd1pERlNjMWR1VW1wU1dGSlFWVzB4TkZkV1dsaGtSemxYVFd0V05WbFZhRWRXYlVaeVRsaGFWMkV4Y0doWk1uaGhaRVpLYzFWc1pHbFdhM0JoVmpKMFYyRXhTWGxTYTFwT1ZtMVNjVlZyVmt0V01WSllUbFpPYTJKR2NEQlVWbFl3VlRBeFdGVnFRbFppV0dnelZtcEdTMVl5U1hwalJtUlRZa1Z3U1ZacVNYaFdNVWw0WTBWc1YySkdXbkJWYWtaTFYxWmtWMVZyWkd0TlZtdzBWako0YjFSc1drZFRiVGxWVm14d1RGcFhlRnBsVlRWWFdrWmFhVkl4U2twV2JHUTBZekZrZEZKWWFHcFNNbWhoVkZjMWIxZEdhM2hYYXpscVlsWktTRlpIY3pGV01ERldZa1JTVjJKWWFIRmFWVlY0VTBaT2NtRkdUbGhUUlVwVVYxZDBhMkl4WkZkWGJrWlZZbFJzY2xsclduZFdiRlY1WTNwV2FHRjZSbGxXVjNCSFZtMUtXV0ZHVWxwV1ZsWXpXbFZhVDJNeFduTmhSbVJPVFcxb1dWWnJXbUZaVmxGNVZGaHNWR0V5ZUZWWmEyUnZZMFphYzFkdVpGZE5WMUpaV2xWYWEyRXdNVVZTYTJoYVlURndhRlpxUm10VFIwWkhZa1phYVZkSGFEWldSekUwV1Zaa1JrMVdhRkJXYldod1ZXMDFRMU5HV25GVGFsSlNUVlp3ZVZSV1ZtdGhiRXBaWVVkR1ZWWjZWblpaTW5oelRteEtkR1JIZEZOTlNFSkpWbXRrZWsxV1dYaGFSVnBVWWxkb1dGbHNhRU5UUm14VlVWaG9WRkpyTlZwWlZWcFBWMFpKZVdGSE9WZFdla0kwVmxSR2ExWXlTa2xUYlVaVFpXMTRlRlp0TVRSWlYxWnpXa2hLV0dGNmJGaFVWbHAzWld4VmVXVkhPVmROYTNCV1ZtMDFTMVl4U1hwaFJYaGFaV3R3VUZWc1drZGtSa3B6Vkd4a1RsWllRa3RXYlRGM1VURnNWMVJ1VWxaWFIzaFdXVlJHZDJGR1ZuUmxSMFpxVW14YWVGVldhR3RpUmtwelkwUkNZVlpYVWtoV01uaGhaRVpXY21KR1dtbFhSa3B2Vm0wd2VGTXhUa2RXYmxKUVZteGFXRmxzWkc5U1ZtUllZMFZrYUUxck5YcFdNalZUWVRGS2RGVnJPVmRpUjFGNlZGVmFXbVZYVWtoUFZscE9ZVE5DU1ZaVVNURlRNVkY0VjJ4V2FWSnRhR0ZaYTFwTFYwWldWVkpzVGxoU01WcEpWVzB4TUZVeFdrWlhhM1JZVm14YVYxUnNXbFprTURGV1drWm9WMUpWY0ZsWFZtUXdXVmRTYzJKRVdsTmlSbkJ6VlcwMVExSXhiRlphUkZKV1RXdHdXRlV5TVc5WFJscHpVMnRvWVZKRldsUlZha1ozVWpGd1IyRkhiRlJTVlhBMVZtdGFhMDFHYkZkVFdHaFlZVEpvYzFWdGN6RldNVkpZWkVoa1ZHSkdXbGxaTUZwUFZqQXhWMko2U2xaV00wSlVWbTB4UjJOc1pITmFSMFpUVWxWWk1GWnRjRWRrTVVsNVVtdG9hRkl5YUU5Vk1GWkxUV3hhZEdWSGRFOVNiWGhaVmxab2MxVXlSWGxWYkd4YVlURndhRlpyV25Oak1WcDBVbXhrVTJKWWFEVldNblJoVkRKS1IxZHVVbFppYlhoWVZGZHdSbVF4V25GUldHaHFUVmRTTVZscldtdGhWbVJHVTJ4R1YySllRa3hWYlRGWFVqRlNkVk50YUZOaVYyaFpWMWQ0WVZNeFZrZGFTRTVYWWxWYWNsUldWVEZYUmxsNVRsVTVWMDFyY0ZsYVZWcFRWbFphTmxKdVdsVldSVnBoV2xWYWQxSldWblJpUlRWb1RXNWplRlpzWTNoTlIwVjRZa1prVldFeGNGQldha3B2VmpGc1ZWSnRSbFZTYlZKWVZqSXhSMkV4U1hkT1JFcFdZbGhvVkZaVVNrdFRSMUkyVW14a1UwMHlhRzlXYTFKTFVqRlplRlJ1VmxSaVdFSlVXVzEwUzFkV1duUk9XR1JYVFZVMVNGWXhhSE5VYkZwWFkwaE9WbUpZYUROV01uaHpWbXh3UmxwR1pFNVNSVWt4VjFaV2FrNVdXWGxTYmtwVVltdHdXRmxYZEdGVlJsWnhVbXM1YTFac1NucFhhMlJ6VmpBeGRHRkVXbGROVm5CVVZXcEtUbVF3TVVsaFJtaFlVakpvV2xkWGRHdFZNV3hYVjI1U2ExTkZOVkJWYlhoelRrWnNWbUZGT1ZkTlZXd3pWbTF3VjFZeFdqWldhMmhYWWxSR1NGa3lNVTlUVm1SeldrVTFVMkpyU1RKV2JYQkRZVEZWZUZSclpGUmlhelZYV1Zod1YxZFdWbk5XYm1SWVZteHdNRmt3VmpCaVIwWTJWbXhzVm1KSGFIWldNR1JMWTIxT1IxRnNaR2hOVm5CTlYxWldZVmxYVFhoYVNGWmhVbXh3VkZscmFFTk9SbHBWVTJwQ1RsSXdXakJWTW5SaFZERmtTVkZzYUZWV2VsWjJXVEo0WVZOSFZraFNiWFJYWVRGd05sWnRNVFJoTVZsNVUydGFhbEpVUmxoWmEyUlBUa1phY1ZKcmNHeFNia0pLVmtjeGMxVXdNWFJoUmxaWVZqTlNkbFZVU2xKbFJtUnpZVWR3VTFZeFNsWldSbHByVlRGa1IxcElTbGhpVkd4V1dXdGtVMU5zVmxoamVsWlhUV3RhZVZWdGNGTldWMFY0WTBod1drMXFSa2hWYlRGVFVqSkdSMVJyTlZSU1ZYQmFWbTB4ZDFNd05VaFVXR2hZWW14S1ZWbHJaRFJpTVZaeVZsUkdWMkpHY0hwV01qVnJWR3N4VjFkcVFtRldWMmh5VmxSR1lXTnNaSFZqUm1ob1RXeEtObFp0Y0VkaE1VcHpWRzVPYVZKdFVrOVdiWFIzVWxaYWRHTkZkRk5pVmxwSVYydG9UMkZHU25OVGJUbFZWak5vVEZwVldtRlhSMDVHWkVkc1RsWXhTbGxXYWtreFZUSktSMVJyYUZaaVJuQlhXV3hvYjAweGNGWlhiRnBzVmpBME1sWnRlR0ZVYkVwR1YyeHNWMkZyYTNoYVJFWnJVMFpLV1dGSGNGUlNXRUpaVmxkd1QxUXdOVWRqUlZwaFVsZFNWVlp0TVZObGJHUnlXa2hPVjAxVmNGZFpWRTVyVmpKRmVWVllaRnBXUlZwTVdrVmFZV014Y0VkWGJXeHBVbTVDV0ZZeFpEQmhNa2w1Vkd0a2FWSnRlSEZWYlRGVFYxWmFkRTFXVGxoV2JrSkhWakl4UjFaWFNrZGpSRUpYVmpOU2RsWXlNVVpsVjBaR1pVWndWMVp1UWsxV2JURjZUVlpaZUZkdVRtcFNNbWhQVmpCV1IwNXNXWGxsUjNSUFVtMVNNRlp0ZUdGVWJGcHpWMnhPV21FeGNHaFdSRVpoWXpKR1JsUnJPVmRpVmtwYVYydFdZVlF4V25KTlZtUnBVa1UxVmxadE1XOVRSbHB4VTJ0MFUwMVZOWHBaVlZwM1lVVXhXVkZZY0ZoV1JXOHdWbTB4VjFJeGNFbFRiVVpUVFRCS1VGWnRjRWRUTURWeldrWldVbUpZVW5CVVZscExaV3hrY2xadFJsWk5hMXA2V1RCYWIxZHRTa2hoUmxKWFlURndXRmt4V2t0ak1rNUlaVVprYVZKWVFtaFdNVnBYWVRGSmVGZHJaRlJpYXpWeFZXNXdjMWRHV25WalJXUlBZa1pLV0ZZeU1VZFZNREZ5WTBWd1ZrMXFSblpXVkVaaFZsWmFjMkpHWkZOaVNFSnZWMnRTUjJFeFdYaFdiazVoVWpKb1ZWVnFSa3RXTVZwSFYyMUdhMDFzV25wV2JUVlRZV3hLY2s1V2FGcFhTRUpJV2xWYVlXUkhVa1ZWYkdST1VrVmFTbFpzWkRCT1JteFhVMjVPYWxKWGFHRmFWM1JoVFRGV2NWTnJPVlJTTUhCSVZrZHpNV0ZXV1hsVlZFWlhZbGhDU0ZkV1dscGxSMHBIV2tkc1UySldTbHBYVjNSclZURmFjMkpJVW10VFIxSlpWbTB4TkdWc2JGWlplbFpYVFZWd01GcFZXbmRYYXpGSFkwaEtWMUpGV21oWmVrcFBVbTFLU0ZKc1pGZE5WWEJLVm0xd1MwNUdaSFJWV0doaFUwVTFiMVZ0ZUhkVU1XeFlaVWRHVmxadFVsaFhhMUpUVmtVeFJWWnFRbFpOYmxKeVdWVmFTMlJHVm5WUmJHUk9VakZLTWxacldtRlpWbHBYVW01U1UySklRbGhVVlZKWFYxWmFWVk5VUmxWTmExcDZWVEZvZDJGR1NuTlRiVVphWVRGd00xVjZSbmRXYkdSMFVteGtWMkY2VlhoWFZFSldUbFpaZVZOcmFHdE5NMEpZVlcxNFlXUnNiRlZTYlVaVVVtczFlVll5ZUZOaFZrbDVZVWRvV0ZZelVuSlpha3BUWXpKS1IxZHNhR2xpVmtwVlZtMHhNR1F3TVVkalJWcFlZWHBzVmxsclduTk9SbFY1WTBkR1dGSnNjSHBXTW5oclZsWmFjMk5IUm1GV1ZuQlFXWHBHYTJSSFRrZFViV3hYVFcxb1lWWnRlR3BrTWxaSFZtNVNWbGRIYUdoVmJURlRWMVpzV1dOSVRsZFNiRXBZVmpJMWExZEhTa2hsU0d4WVlURktWRlp0YzNoU1ZrcHlZVVp3VGxJeWFHOVdiWEJIVjIxV2MxSnVTbWhTYldoWVdXeGFTMWRXV25SalJXUlhUV3hLV0ZaWE5VOWhSa2w1WlVab1ZtRnJOWFpYVmxwYVpVWndSVkZzY0ZkTlJFVjZWa2Q0YjFReFpFaFRhMmhvVTBWd1YxbFVSbmRVUmxsM1YyNU9XRll3TlVkWGExcFRWVEpLV1ZWWWNGZGhhMnd6Vkd4YVdtUXdNVlpXYkU1b1RXNW9XVlp0Y0U5aU1sSnpWMjVTVGxaWFVuRlphMlJUWld4YVdHVklaRlZpVlhCNVZGVm9iMVl5U2xsUmEyaGhVa1ZhVEZreWN6RldNWEJJVW14T1RtSnRhREpXYTFwWFlqRkZlRlZyWkZoaWJFcFBWVEJrYjFWR1ZuUmxSbVJQVW14d1NGbFZaREJXVlRGWFkwWnNWMVl6YUdoV2FrRjRVMFpXZFZkc1pFNVdia0pvVjJ0U1IyUXhUa1pQVm1Sb1VtMVNjRll3Wkc1TlZscHhVMnBDV2xac1JqVlZiVFZQVjBkS2NrNVdiRnBXTTFKTVdWVmFWMk14WkhOalIzUk9WbTEzZWxacVNqQk5SMFp5VFZab1ZtRnJXbUZVVlZwM1kyeGFTRTFWWkdwaVIxSjVXV3RhYTJGSFJYZGpSemxYVjBoQ1RGWkhNVmRTTWs1R1lrWmthVll5YUZWWFYzUnZVVEpSZUZkdVJsSmlWVnBWVkZkNFlWZEdaSEpYYlhSYVZtczFTbFZYTlU5V2JVcFpZVVJPVlZaV2NHaFZNR1JUVTFaU2RHRkhiRk5YUlVZelZtMTRhMlZyTlZkYVNGSlVZa1phVkZsdGVIZFhSbEpYVjI1a2FGSnRkRFJXTW5ScllURktjbU5JY0ZkV00wMTRWbXBLUzJOc1RuTmpSbVJwVjBWS1RGWkdXbUZWYlZaSFdraFdWbUpHU205VVZ6RnZWMFprV0UxVVFsUk5WMUpJVmxkNFlWbFdTbkpPV0VwYVlURndlbFJyV2xwbFYxWkpXa2RzVTJFelFYZFdiR1IzVVRGYWRGTnNiR2hTYkVwWVZXcE9iMkZHY0VaYVJrNVBZa1Z3ZWxkcldtdFZNVm8yWVROd1YwMVhhRE5WYWtaelZqRlNjbHBHVm1saE0wSjJWbGN4TkdReVRrZFhia3BoVWtaS1dGUldXbmROUm5CR1YyMTBWMUpVUmxoVk1uUnZWMnN4UjJOSGFGZE5SMUpNVm0xNGEyTXhWbk5XYkdScFZtdHdWbFl5ZUd0T1IwVjVWRzVPWVZOR1dtaFZiVEZUVkRGc1ZWUnJUbFJpUjFKNVdWVm9hMVZyTVZkaVJGWldUVzVvV0ZaWGVHdFRSMFpIWVVaa2FFMVdiM3BXVjNCSFpERmFjMXBJU2xCV00wSlBXVlJPUTFOV1duRlRXR2hxVFZaV00xUldXbUZoYkVwMFlVWm9XbUpHU2toVVZFWmhVbFpPY21OSGVGZGhNMEkxVmpKMFlXSXhaRWRUV0hCb1UwaENXRlpyVmt0V01WSlhWMjEwVTAxcmNFcFZNbmh2WVZkS1YxTnVjRmRpVkVVd1ZXcEJNVkl4WkZsaVJUVlhVbFZ3ZGxaWE1UUmtNbFpYWVROa1ZtRXlVbGhaYTFwelRteFdXRTFYT1ZkTmExcDVXVEJXYjFkck1YRlNhM2hWWWxob1NGbDZTazlUUjBaSVlVVTFXRkpWYjNsV2JYQkxUVVpaZUdKR1pGWlhSM2hXV1cxek1XTldWbk5hUms1b1VteGFNRlJXV2s5V01VcHpZMFJDVldKR1dsQldNRnBMWXpKS1JWVnNhR2hOVlhCVlZtMHhlbVZHV25SVGExWldZa2RTY0ZZd1drdGxWbHAwVFVob1ZFMXJNVFJXUnpWWFZsZEtSMk5GT1ZaaGExcE1WbXhhWVdSSFVraFNiRnBPVm0xM01GZFVRbGRoTVZwWVUyeHNhRkp0YUdGWlZFWmhUVEZTZEdWSFJtcFdhelV4V1RCVk5WWXlTa2hrTTNCWFVteHdkbFY2U2tkak1WSnlZVWQ0VTJKV1NsZFdiVFYzVmpGYVIySkdXbGhpVlZweFZtMXpNV1ZXY0VaWGJYUlhUV3RXTmxWWE1VZFdNREYxVlcxb1lWSkZjRWhWTUZwTFYxZE9SMU50YkZOV1dFSmhWakZhVTFJeFRYaFNXR2hXWWtkU1dWbHNWbUZqVmxKWVkzcEdVMDFYVW5sV01uaHJZVVphYzJKRVdscFdWMmhvVmpCa1MxTkdWbFZSYkdoWFlraENiMWRZY0VkaE1XUllVbXRvVTJKRk5WUldiR2hEWWpGYWRFMVlaRk5OVld3elZHeFdhMWRHWkVobFNFcFdZV3MxVkZscVJtRmtSMUpKV2tVMVUySnJTbGhYVmxaWFlURlplVk5zV21wU2JIQlhXV3hvYjFaR1duRlRhM1JZVmpCYVNsa3dXbmRVYlVwMFlVaHNXR0V4V21oVmVrcFRVMFphY21GSGJGTmhlbFozVjFaU1EyUXlSa2RYYmxKclVqTlNVRlZ0ZUhkbFZsSnpWMjEwV0ZJd2NIcFZNbmhUVjJ4WmVtRkVUbGRoTVhCNldUSjRkMU5GT1ZkaFJrNXBVbGhDWVZaclpEUmhhelZZVWxoc1ZHRXlVbkZWTUdSdlZqRlNXRTVXU210TlZtd3pWakl4UjJGck1WWk9XSEJhVFVad00xWnFSbUZrVmtaWlkwWmthVmRGU2tSWGExSkxWVzFSZDA1V1dsZGlSWEJ3VldwR1MyUXhXblJrUm1SWFlsWkdORmRyV210V2JVVjZWV3hhV21KR2NHaFZNVnBoVTBkU1NGSnNjRmRoTTBGM1YxWldiMUV4V1hsU2JrcFBWMFp3V0ZSWE5XOWhSbGwzVmxob1YxWnJXakJhUlZVeFZqSkZlbEZVU2xkaVdFSkxWRlphVm1WR1ZuVlViR2hvVFd4S1ZsZFhlRmRaVm1SSFlraE9hRko2YkU5VVZscExWakZaZVUxVlpHaE5WWEJXVm0xNGIxWXhTWHBoUjJoWFVucEdSMXBWV210V1ZrcHpXa2RzVTAxVlZqTldiWGhUVWpKRmVWVnJaRlJpUjNodlZXcE9RMVpHVm5OVmJHUllWbXh3U0ZadE1VZGhNREZ6VjI1d1dsWkZOWHBaYTFwS1pXeFdkVk5zWkdsV1JscEZWbFJDWVZsV1pFaFdhMmhyVWpKb1dGbFljRmRUUmxwVlUxaG9VMDFXYkROVVZtaFhWbTFLU0dGR2JGZGlWRVpVVldwR2QxWnNaSE5hUm1oWFRVWndTVlpzWTNoak1rWkdUVWhrVkdGc1NsaFphMXBMVWtac2NWSnJXbXhTYmtKSFYydGFZV0ZXU1hsaFNHaFhWbnBDTkZaVVJtRmpNVnAxVlcxNFZGSXhTbnBXYlRCNFZUSldWMWR1VW1wU1ZUVllXVmh3UjJWV2EzZFhiWFJYVmpCd1NGWXlOV0ZXTURGMVlVZG9WMkZyY0ZCVk1WcFBZekpPUjFwSGJGUlNWVzh4Vm0xNFUxRXlSWGhUV0doVllURndVVlp0TVZOaFJsWjBZM3BHYWsxWGVGWlZiWGhyVkdzeFYyTklhRlppVkVaSVZqSjRZV1JHVm5GUmJHUnBWMFpLZVZkV1pEUlRNV1JJVm10a1dHSklRbkJWYlhoM1lqRmFkR1JIUm1wTlYxSlpWa2QwYTFsV1NuTmpSbEphWVRKb1ExcEVSbXRqTVZwMFpFWk9UbUV4V1hwV1JscFhWakZaZVZOdVZsSmlSMmhXVm1wT1ExZEdXa1pYYlhSWFRWZFNlVnBGV2s5VWJGcFZWbXBhVjAxdVVtaFdha1phWkRBeFNXRkdVbGhUUlVwWlZtMTBWMU15UmtkWGJsSk9WbTFTV1ZWdGVIZGxWbVJ5V2tWa1ZrMXJjRmhWTW5oRFYwWmFjMU5zUWxaV1JWcFFWV3BHYTJOdFJraGxSazVPVW01Q00xWnJXbUZoTVZWM1RWVmtWMkpyTlc5VmJuQnpZakZzY2xadVRrOVdiWGhYVjJ0V2ExWXdNWEpqUldoYVRVWktVRlpxUVhoU01rNUpZa2RHVjFadVFubFhWRWw0VlRGT1NGUnJXazlXYlZKdlZGUkNSbVZXV25STlZFSm9ZbFphU1ZaR2FHOVdNV1JJWlVaV1dtSllVak5XYkZwaFkyeGFkRkpzYUZOaVdHaGFWMnRXYjFsWFJYZE5WbWhXWWtkb1dGUlhOVTVsUm14eVYyMUdhbUpWTlVwWk1GcHZZVVV4V1ZGc1ZsaFdiSEJvVlRJeFYxSXhVblZXYldoVFlsWktXVmRzWkRCVGF6RkhXa1pvYWxKWFVtOVVWbHB6VGtaa2NtRkdaRmRpVlhCYVdWVmFVMVl3TVVkalJYaFhUVVp3YUZZd1ZYaFdWbFowWkVVMVYxZEZTVEpXYlRCM1RWWlZlRlZ1VGxoaVIyaFhXV3RrYjFac1duTlhhM1JVVW14c05GWXlNVWRYUmtwVlZteHdXR0V4Y0hKV1IzaExVbXhrV1dGR2FGZGlSbkF5VmpGYVlXRXlUWGhhU0U1aFVtMVNiMWxyVm5kWFJtUllaRWRHYTAxcldraFphMUpoVmtkRmVWVnNVbFZXTTFKb1ZUQmFhMk5zV2xWU2JGWnBVbTVDWVZaV1pEUmtNVmw1VTJ4c1ZtSlhhRmhaVjNSaFlVWndSbGR0Um1waVNFSklWbGQ0YjFVd01YUmhSMFpYVFZkT05GcFhjM2hYUms1WllVWmthV0V4Y0ZkWFYzaFRZekZrUjFadVVteFRSMUp6VlcxNFlVMUdjRVpWYTA1WVVtdHdlbGt3VWtOV01WbDZZVWh3V0Zac2NFeFdha3BQVTFaT2MyTkdaRk5XVm10M1ZqRm9kMUl5UlhsVVdHeFRZVEpTY1ZWc1VsZFdSbXgwWkVWMGEySkdjREJVVm1oclZUQXhjbFpxVWxkU00xSjJWbFJLUm1WV1ZuUmhSbHBwVjBkb2IxWnFRbUZqTWs1MFVtdGFWR0pZYUhCVmJUVkRWakZhV0UxSWFGTk5hMVl6VkZaYWEyRnNUa2xSYkdoVlZqTkNXRlpWV21Gak1YQkdaRVpTVTJKR2NEVldSRVpoWVRKR1YxZHJaRmhoTVZwWVZXNXdSazFHYkZWU2JVWlhUVlZ3TVZaWGVFOWhWbGw2WVVaQ1YySlVRalJVVkVGNFZqRmtjMVpzVW1oaVJYQlpWa1phWVZZd05WZFdibEpxVWpCYWIxWnRkSE5PVm14V1YyMDVXR0pWVmpSWk1GSlBWbFphUmxkdGFGWmlXR2h5V2taYVUyTnJPVmhpUms1WVVsVlplbFpxU2pCV01rVjVWVmhvVm1Kck5WbFpiWFIzWTBaU1ZWTnNUbGhXYkhBd1dsVmtSMVl3TVZkVGJHaFhUV3BHU0ZaVVFYaFdhelZaWTBaa1RtRnJXWHBXYkZKTFV6Rk9WMUp1VG1sU2JXaFlXV3hhUjAweFpISmFTSEJzVW10c05Ga3dWbXRaVmtsM1YyeFNWMDFHV2t4YVYzaGhaRVV4V1dORk5WZGlWa28yVjFkMFlWbFdaRWhTYWxwcFVtMTRWMWxzYUZObGJGSnpWMjVPVjJKSFVqRldSM2h2VlRKS1NHUjZTbGRpUjAxNFZYcEdXbVZHWkhKWGJHaHBZVE5DV0ZkV1pEQmtNVkpIVm01R1UySlZXbkZVVmxwaFRVWnNjbGRyT1ZkTlZYQjZXVEJrUjFZeVNsbGhTRVpoVWtWd1dGVnRjekZXYkhCSFlVZHNhR1ZzV21GV01WcFRVekpKZUZWWWFGZGlhM0JaV1d4V1lWZEdVbGRYYTNSWFRWWndXVnBGWkRCWFJrcHlZMGh3V21FeFNsaFdNbk40VWpGa2MxRnNaRTVpYldodlYxUkplRlF4U1hsU2EyUmhVbFJXV0ZSWE1XOU9WbHAwVFZoa1ZFMVZNVFJXTW5oclZrZEtjbU5JVGxaaVdHZ3pXV3BHYzFaV1VuSlViRnBYWWtoQ1dsZFVRbGRoTWtWM1RWWmFhVkpHU2xoVVYzQlhWVVprVjFkcmNHeFdNVnBJV1ZWYVYxWXlWbkpYYkZKWFVtMVJNRmRXWkZOU2F6RldZa2RHVTAweWFGVldiWFJoV1ZaT1YxcEdhR3RTTUZwd1ZGWmFkMWRHWkhKV2JUbG9VbXRzTlZsVldtdFdWbHBYWTBkb1ZWWkZXbnBaTVZwTFl6RndTR1JHVGs1V2JrSk1WbXBLTUZsWFNYaFdXR3hVWVRGd2NWVnRNVk5YUmxweVZtNU9UazFXU25wV01qRkhWVEF4V0ZWcVJsZFNla1l6VmxSR1dtVnRSa2hQVm1ScFYwZG9lVlpzWTNoVmJWWkhXa2hXVTJKRmNGbFZha3B2VjFaa1dHVkdXazVXYXpWNldWUk9hMWRIU2xsVmJHUlZWak5vYUZwWGVGcGxWMVpHV2taa1RtRXpRbUZXYkdNeFV6RmFkRlp1U2xoaVJVcFhXVmQwWVdGR2NFZFhiRTVyVWpCYVNGWkhNWE5XTWtWNlVWaHNWMkpZVW1oWFZtUktaVVpLV1dKR1RtaE5iRXBhVjFaU1MxVXhaRWRpU0U1WFlsVmFZVlp0ZUhkbFJsWlhZVWM1VlUxVmNEQmFSVkpQVmpKS1dXRklTbGRpVkVaTVZtMHhUMUp0UmtkYVJUVnBZWHBDTkZadE1IZGxSa3AwVm10b1ZXRXlhRzlWYlhoM1ZERmFkRTVWVG1sTlZuQjRWVmQ0WVdKR1NuSmpSbWhXVFdwV1VGWnFTa2RPYkZwellVWndhRTFZUWpWWGJGWmhXVmROZUZadVNtdFNWRlpVVkZWYVdrMVdXbGhOUkVaVlRWWndTVlV5TlV0VU1WcHpWMjFHV21FeGNHaFpWVnBhWkRGa2RWUnNaRmRoTTBGM1ZsY3dlR0l4VlhsVGEyeFNZVEpvV0ZsWGRITk9SbFp4VW14d2EwMUVSbGhaVlZwaFlVZEZlR05HY0ZoV2JFcElXa1JLVTJNeFpITldiRTVwVmxad1ZWWkdXbXRWTWxaellrWmFXR0pZVWxkVVZWSkRUbFpzVmxkdE9WZE5WWEI2V1RCa2IxWXhXa1pqUlRsaFZsWndNMVV4V21Gak1WcDBZa1pvVTFaWVFsZFdha1pyVGtkSmVWTllhR0ZTYlZKb1ZXMHhiMk14Vm5SamVrWlhVbTE0ZWxZeWRHdFVNVXAwWlVoc1YwMXVhSEpXYlhONFkyMU9SbUZHY0U1U01taFJWbTF3UzFNeFpGZFZiR3hvVWpCYVdGbHJhRU5oUm1SelYyeGFiRkp0VWxoWk1GWnJWMGRHTmxac2FGcGlXRkpMVkZkNFdtVkdWbkpVYldob1pXeGFXVlpxUm05ak1WcElVMnRvYkZKNmJGZFpWM1IzWkd4c1ZsZHNaR3BpUm5Bd1ZXMHhiMVV5U2tkalJGSlhWbnBDTkZSVlpFZGphekZaVTJ4b2FFMXVhRzlXYlhoaFpERldSMWRyYUd4U1dGSnlWbTEwWVdWc2EzZFhiWFJWWWtac05GVnRjRTlYUmxwelUydG9WMkpVUmxoV2FrWnJaRlphYzFadGJGTk5iV2d6VmpGa01GWXlVWGxXYms1WVlrZG9UMVV3Wkc5V01WSlhWMjVPVDFKc2NGbGFWV1F3VjBaSmQyTkVRbGRXZWxaUVZqSXhSbVZXVmxsYVJsWlhVbFp3YjFkclZsWk5WbHB5VDFaa1lWSlVWbFJWYkZwM1YyeFplRlZyVGxaTlZWWTBWakZvYjFkSFNuSk9WbFphVmtWYVRGWXdXbk5qTVZaeVdrWlNVMkpZVVRGWGJGWnJUVWRGZUZkdVNrOVhTRUpZVkZkd1IyUnNiRlpXV0doWVZtdGFlbFV5ZUd0VWJGbDVXak53VjFkSVFraFdSekZYVWpGU2MySkhhRk5pVjJoM1YxZDBWMlF5VVhoWGJHaE9Wa1pLVlZSV1duZFRSbGw1VGxVNWFGSnJjRmRVYkZwclYyMUZlR05FVGxWV1ZuQXpWbTE0ZDFKV1JuTldhelZYVjBWR00xWXllRmRaVjAxNFYxaG9XR0pzU205Vk1GcDNWMFpzVlZOc1RsTk5XRUpZVmpKNGEyRnJNWEpqUldoYVRVZFNkbFpITVV0U2JVNUhWMnhrVGxZeFNYcFdWM0JIV1ZkU1IxWnNiR2hTYldod1ZXMTRkMVpXWkZoa1IwWnJUVlp3U0ZscmFFdFhSMHB6WTBoS1ZWWnRVbFJhVmxwaFpFVXhWVkZzV2s1U1JWbzFWMVJDVjJNeFduSk5XRlpXWW10d1dGUlZaRk5UUm10NVpVVTVhMUl3V2toWGEyUnpWVEF4Vm1OR1dsZGlSa3BFVjFaYWMxZEdWbkpoUmxaWVUwVktkbFpYY0U5Uk1rNUhWMjVPVm1KSFVsVlZiWGh6VGxad1JscEZaRmhpUm5CNlZUSndRMVpyTVhGV2EzaFhVak5vYUZWcVJrOWpNa1pIWTBkc1UyRXpRa1pXYTJRd1dWWlpkMDVZVGxSaWJFcHlWVzB4VTFReFduUmxTR1JQWWtkU1dWcEZaREJoVlRGWFZtcFdWazF1VW5wV1Z6RkxVMGRXUjJGR1pHaGhlbFl5VjFaV1lXUXhTbGRUYmxKclVtMVNUMVpxUmtwbFJscHpXVE5vYTAxV1ZqUldNV2h2VmtkS1dHRkdhRnBpUjJoRVZWUkdkMVpzV2xWU2JFNU9WMFZLUzFaVVNYaGlNVlY1VW1wYVYySnNjRmxXYWs1VFYwWndSVkp0Um1wTlYxSXhWbGN4TkZVeVZuUmxSbXhYVW0xUmQxcEVSbUZqTVdSMVZXMTBVMkY2VmxsV1JsWlRVakZrUjJFelpHRlNlbXhaV1d4YVlXVldXWGxPV0U1YVZteHZNbFZ0ZEc5V2JVcFpWRmhvVjJGcldsUmFSV1JIVTBkV1NHRkZOVmRpUjNjeVZtMHdkMlF5VmtoVldHaFZWMGRTVUZac1pHOVdWbGwzV2tjNVdGWnNiRE5YYTFKVFZqRmFkR1ZFUWxwTk0wSklWakJhWVdSSFZrbGlSbWhvVFZoQ1VWWnFTalJaVjAxNVUydFdWV0pJUWxoV2JYaDNWVlprV0dSSGRGUk5WV3cxVmtkMGMyRkdTbk5qU0VKWFlURmFhRlV4V210V01WWnlXa1pTYVZac2NFbFdNblJ2VXpKR1YxTnVUbXBUUlVwWVZGVmtVMlJzYkhGU2JVWnFUVlphZVZwRldsTlViRmw0VTJ4c1YySlVSVEJXYWtaWFpFWk9jbUZHV21sV1IzaG9WbTEwVjJOck1WZFZiRlpUWWxoU1dGUldXbUZsVm1SeVYyMUdhRlpzY0hwWk1GWnpWakF4ZFZWdGFGcGxhM0JJVldwR1QyUldWblJoUms1c1lsaG9XRlp0TVhkVU1rbDRWV3RrV0ZkSFVsbFpiRlpoVmtaU1YxcEVUazVpUmxvd1ZGWm9UMVpYU2tkalNHeGFUVVphZWxacVNrZGpiVVY2WVVaYWFHRXhjRmhYYkZwaFZESk5lRnBJVG1oU01uaFVWRmN4YjFkR1duUk5XR1JWVFZaS01GWnRkR3RXTVdSSVZXeHNXbUV4Y0ROWmVrWmhZMVpLZEZKc1VsZGlhMHBJVm1wSmVGSXhXbGhUYTJScVVrVmFWMVpxVGtOaFJsbDNWMjFHVTJKRk5URlZiWGhYWVZaS2RWRnRhRmhpUmxwb1dWUkdhMWRHVW5KYVJsSnBWakpvVUZkWGVHdGlNV1JYVjFob1dHSllVazlWYWtaSFRrWmFWMkZIT1doaVJYQjZXVEJhYzFkc1pFbFJibkJhVFc1b2FGcEZaRmRTYlZKSVpVZHNVMDB5YUZsV2Frb3dZakZSZUZkdVNrNVhSWEJ4Vld4b1ExWXhXblZqUldSVVVteHdlRlV5ZERCV1JrcHpWMnhhVmxZemFISldha1pMVmpKT1NHRkdhR2xTYkhCdlYxWlNTMVF5VFhsVWExcGhVakpvVkZSWE5XOWtNVnBZWlVjNVVrMUVWbnBXTWpWUFYyc3dlVlZ1VGxaaVdHaFlWR3RhYzJOc1pIUmtSbWhUVFVoQ05sWlVTVEZUTVZwMFUyeFdVMkpHU2xoV2JGcDNWMFp3UmxwR1pGUldiRXA1VkRGYWEyRlhSWGRqUld4WFlXdHZkMVpVUmtabFJtUlpXa1UxVjJKV1NuZFdWM1JXVFZaa1IxVnNhR3BTYlZKUFZGWmFkMDFHYkRaVWJUbG9UVlpzTTFZeWRIZFhhekZIWTBoS1dsWnNjR2hWYlhoclkyc3hWMXBIYUdoTldFSjJWbTB4ZDFNeFZYaFVhMlJVWW10d2FGVnFRbUZXUmxKWVRWYzVhMkpHY0VoV01qQTFWV3N4V0ZWdWNGZE5WMmg2V1ZSR1MyUkdWblJQVmxaWFlraENXVlpIZEdGV2JWWllWbXRvYTFKdFVrOVpWRTVEVGxaYVNHVkhSbWxOVjFJd1ZXeG9jMVp0U2tkVGJVWmFWak5TYUZacldtRmpNV1J5V2tkd2FWWnJjRWxYVmxaaFlUSkdWMVJyV2xOaGF6VllWRlphUzFKR1duRlJXR2hUVFZaYU1WWkhlRk5oVjBZMlZteFdXRlp0VVRCVmVrWnJVakZXYzJGSGNGTmlWa3BZVmxjeE5HTXdNSGhhU0VwWFlXdEtiMWxzVmxwTmJGcDBaVWM1V0dKVlZqUlpNRkpQVmpBeFIyTkdRbFppV0doUVdURmFhMk14Y0VoaVJtUlRWbXhaZWxacVJtOWtNVWw1VWxob1ZXRXlVbGhaYlhSM1lqRldkR042Um1wU2JHd3pWbTEwTUdFd01WZGpSbXhWVmxaS1NGWlhNVXRXTVVweFZXeG9hRTF0YUZGV2JYQkxVekZPUjFadVNsQldiSEJ2V1ZSQ2QySXhXa2RXYlVaWFlsWmFXVlpYZEc5aE1VcDBZVVpTVlZaV2NETlViRnBoVmxaT2NWVnRhRTVXTVVsM1ZsUktNR0l5UmtkVWEyUnFVbTFvVjFsclduZE5NV3hXVjJ4YWEwMVlRa2RVYkdRMFlWWmFWMk5GY0ZoaE1WcG9Wa1JHVTJNeFRuVldiRXBvVFc1b1dWZFhlRk5STURWSFZXNUtZVkpXY0hOV2JYUjNaV3hrY2xkc1RtaFdNSEJJV1RCYVUxZEdXWHBoUmxKYVpXdGFjbFZxU2t0VFZsSjBZVVpPVjFaR1dsZFdiR040VGtaWmQwNVdaRlppUjFKWldXeG9VMVl4VWxaVmEyUllVbXhzTlZrd1ZtdFdNREZ5WTBad1dsWldjRlJXTW5oaFl6Sk9TVk5zV2s1U01VcEpWbGR3UjFsWFRYaGpSV2hwVW0xU1ZGWnNXbkprTVZwMFpVZEdWazFWTVRSV01XaHZWMFprU0dGSGFGWk5SbFY0V1dwR1YyTldVblJQVm1SVFlsaG9ObFpxU2pCTlIwcEhWMjVPYWxKWGFGaFVWM0JIVTBac1ZWRllhRmRoZWxaWFdWVmFhMVJ0Um5OWGJGWlhZVEZLU0ZkV1pFOWphelZYV2tab2FWTkZTblpXUmxwdlVXMVdjMWRzYUdwU1YxSllXV3hhWVZZeFVuTlhiVVpXVW14d01GbFZhRU5XTWtwSFkwZEdWVlpXY0hKV2JGcEhaRWRTU0dKRk5WZGlXR1EyVm10YVlWWXlSWGxTYms1VVYwZDRiMVZxU205V01XeHlXa1pPVjFKc2NIbFdNbmhoWVRBeFdWRnJhRmRTTTJoUVZrZDRXbVZHVG5GV2JHUlRUVEpvYjFkV1VrZGhNVWw0Vkc1T1dHSkhhRmxWTUZaTFYxWmtXR1ZHVGxOaGVrWklXV3RhVjFWc1pFaGhSbEpWVm0xU1ZGWXllSE5XYkhCSlZHeGFUbUV6UWxsV1ZFbzBaREZrUjFkWWNGWmlhM0JZVm10V1lXTnNXbkZUYTNSVFRWWndlbFp0TVhOV01VbDZZVWRHVjJKSFRqUlVhMlJTWlZaYWNscEdhR2hOYldoUVZsZDBZVmxYU1hoV2JsSnJVMGRTYzFsclpEQk5NVnBZWkVVNVdHSkdjSHBaTUZwelZqRmFkR0ZJU2xkTmJtaGhXbGQ0VTJOV1ZuTmFSMnhYVWxad1VsWnNVa2RoTVZGNFUxaG9hbEpYYUhCVmJURnZWa1pTV0UxWE9WWk5WbkF3VkZWb2IyRXdNVlpOVkZKWFVtMW9kbFpzWkV0VFJsWnpWV3h3YVZkR1NYcFhWRVpoVmpKU1JrMVdaRlZpV0VKVVdXdGFkbVF4V2tobFJtUlZUV3R3U0ZZeU5VOWhiRXBZWlVkb1ZtSkhVbFJWTUZwaFkyeHdSbVJHWkU1V01VbzFWMVpXWVdJeVJrWk5XRkpvVW0xNFdGbHNhRzlqYkZZMlVtdHdiRlpzU25sWmExcExZVlpLZFZGdVdsaFdiV2d6Vm1wQmVHTXhaSFZWYlhCVFZqRktkbFpHV210Vk1VNVhWMnhvYTFJelVtRldiWFJ6VG14YVdHTjZWbGROYTFwNVZqSjBORlpyTVZkalIyaGFUVlp3VUZac1drdGpNVnB5VGxaa1RsWllRa3hXYlhoVFUyc3hWMVpZYUZoaWJFcFZXVlJLVTFaV2JISmFSazVhVm0xNGVWZHJZelZoTWtwSFUyeGFWbUpZYUROWlZFRjRWMFpXY1ZKc1pGTk5NbWg1VjFaYVlWbFdXWGxVYTFwb1VtMVNWRlZzV25kaU1WcDBZMFZrVmsxck1UUlhhMmhQWVZaS2NtTkhPVnBoTVhBelZqRmFhMVl4Y0VWUmJYQnBWbXh3U1ZkVVFsZFdNVlY1VTJ4YVdHSnJjRmRaYkdoT1pVWndXR1ZJVG1waVNFSkpWREZhWVZSc1NrWlhXR1JZVm14YWFGbDZSbXRTTVdSWlkwWmFhV0V6UWxsV2JYUlhXVlpXUjFadVJsUmhNWEJ6V1d4V2QxSXhVbk5YYlhSWFRWVnNObGxWV21GV01rVjRZMGRvV0Zac2NFOWFWbHBoWkZaU2RHRkZOVTVpUlhCaFZqRmtOR0l4VlhsVFdHaFlZbXhLYzFVd1ZURlZSbHAwVFZaT2JGSnNjRWxVYkZVMVZqQXhSVkp1YkZwTlJuQm9WbTB4UzFJeFRuSlZiR1JPVW01Q2IxZFljRXRVTVU1SFUyNVNVMkpIVWxoWmJYUkxUbFphZEdORlpHaE5WV3cwVlRGb2MxVXlSWGxoU0VKV1lXdHdkbGw2Um5OamJHUjFXa1pvVjJKSVFqUldWekI0VFVaU2MxTnVUbXBUUjNoV1ZtMTRkMk5zV1hkYVJWcHNWbXhhZWxscldtdFViRWw0VTJ4V1dGWnNXbWhXYWtwVFYwWlNjbUpHVm1sU01VcFpWMWQwWVdSdFVYaGFTRTVYWWxSc2IxUldaRk5UUmxsNVRsVTVWMUl3Y0VsWlZWcHZWakpHY2s1V1VsZFdWbkJvV1RGYVMyTnRVa2RhUm1Sb1RUQkpNbFl4V2xkWlYwVjRWVzVTVTJKck5WbFdNR2hEVjBac2MyRkZUbEpOV0VKWFYydGFUMWRHU25KalNHeFlZVEpTZGxaVVNrdFhSMFpIWWtab1YwMHlhRzlXV0hCSFlURlplR05GWkZkaVJrcHdXVzEwUzFWR1duUk5WRkpxVFVSV1dGWnNhSE5oTVVsNlZXMUdWMkpZVW5wVWJGcDNWbXhrZFZSc1pHbFdWbkExVjFSQ2IxbFdiRmRUV0hCb1VqSm9ZVnBYZEdGWFJtdDVaVVpPYWsxck5VaFhhMlJ6VlRBd2VWUnFVbGRpVkVWM1dWZHplRll4VmxsaFIyeFRZbFpLVjFkV1VrZGtNazVYVmxoa1YySnRVbGhVVm1RMFpXeGFXR1JIZEZkTlZYQjZXVEJvYzFZd01YVmhSa0pYWVd0R05GWXdXbGRqVmtwellVZG9UbGRGU2xaV2JYaFRVekZOZUZSc1pGTmlhelZvVlcweFUxZEdWbk5oUlVwc1lrWndlbFpYZEd0WGJGcHlZMGhzVlZac2NISlhWbHBLWlZkV1IxVnNXbWxYUmtsNlZtcEdZVmxXU1hoaVJGcFRZbGQ0VDFsWWNGZE9iR1JZWkVkR2FVMXJjRWhWTW5oelZtMUtjbGR0UmxwaE1YQlhXbFZhVm1ReFpIVlViR1JwVWpGSmQxWlhNSGhpTVZsNVVsaHdVbGRIYUZoV2JURlBUVEZTYzFkdGRGTk5WMUl4VmtkNGIyRldXWGxoUm14WVZtMVJkMXBFUmxkU01XUjFVbXhPYUdWdGVIbFdiVEY2VFZVeFIxWnVVbXhTVkd4V1dWaHdSMUl4YTNkWGEyUlhUV3R3VmxWc1VrTlhiVVp5VjJ0a1lWSkZSWGhXTVZwVFl6SkdTR0pIYUU1WFJVcFlWbXBHWVdFd05VZFVXR2hoVWxkU1YxbHJaRk5oUmxaMFkzcEdWMVpzV2pCYVZWcHJWREZhZFZGc1pGZE5ha1YzVm1wQmVGSldTblZpUm5CT1VteHdNbFp0TVhwbFIxSllVbXRzV0dKSFVrOVpWM1JoVkZaYVZWRnRkRk5OVlRWWVYydG9UMWxXU2xWV2JGSmFZbGhTVEZSc1dtRmtSVEZaV2taT1RtRXhXVEZXYTJNeFZERnNWMVJyWkZSaWF6VlhXV3hvVG1WR2EzZFhiRnByVFZad2VWa3dWVEZoVmtwMFpIcENWMDF1VWxSVlZFcEhVbXN4V1ZOck5WZFNhM0JaVjFkMGEySXlVbk5YYmtwaFVsaFNjVmxzVlRGVGJGWjBaVWRHYUZadFVrbFpWVlY0VmpKR2NsZHRhRmhXYlZKUVZtcEdWMlJXVW5OV2JXeFRUVzFvVmxZeFpEUlpWazE0V2taa1dHSnJXbFZaVjNoTFkyeFNXR1JJWkZSU2JGWTFWR3hWTldGSFNrWmpSV1JYVFc1b2RsWnFTa3RrVmtaeVdrZEdVMUpXY0c5V2JYaGhWREpPYzJORldsQldNbmhVV1cxMFNrMXNXbkZUYWtKYVZqQldOVlZ0ZUd0WFIwVjRZMFpvV2xZelRYaFdNVnB6VmxaS2NtUkdVbE5pV0doWFZsY3hOR1F5U2tkVGJsWlNZVE5DV0ZWdWNFZGtiRnBWVVZoa2JGSnJOWHBXYlhocllWWmtSMU51YkZkU00xSm9XVlJHV21WSFRrWmFSMmhUVFRGS1ZWWkdWbUZrTWxaWFYydGtZVkpHU21GV2FrWmhaV3haZUdGSE9XaFNhelZIVkd4ak5WZHRTa2RqUjJoaFZqTm9ZVnBXWkZkVFZsSnpZVWRzVjFkRlNrcFdNVkpEWVRKSmVHSkdaRmhpYXpWeFZXcENZV0ZHV25STlZrNVhVbXhXTTFac1VsZFdNREZaVVd0a1ZXSkhVblpXUjNONFVtMU9TRTlXWkdoaE1YQnZWbTF3UjFkdFVYZE9WbHBoVWpCYVZWVnNhRU5WUmxweFVXMUdXbFl3YkRSV2JUVlRZVEZLV1ZWdFJsZGlWRlpFVmpGYWQxSnNjRVphUm1oVFlUTkJlRlpXWkRCaE1XUklVbGhvYWxORmNGaFdhMVpIVGtacmVXVkhkR3BpVlZwSVYydGFUMVJyTVVWU1ZFSlhUVlp3YUZkV1dtdGtSbHB6WVVaT2FFMXNTblpXVnpCNFZUSk9SMWR1U2xkaE0wSlBWVzE0ZDFOV2NFWmFSV1JvWVhwR1dGbHJVbGRXYXpGMVZXNUtXRlpzY0V4YVJXUkhVakpLUjFkdGFHaE5NRWw1Vm0wd2VFNUdiRmhVYkdSVFlteEtjbFZxU2pSVU1WcDBUbFZPVDJKSFVsbGFSV1JIVmpBeFYxWnFWbFpOYWxaVVZtMHhTMk5zWkhOWGJHUnBWMGRuZWxkV1ZtRmtNV1JJVm10a2FsSXphRmhXYTFwaFYyeGtjbFp0Um1oTlZrcDZWako0YzFWc1pFaFZiR3hhWVRGd2FGbFZXbXRXTVdSMFVtMXdUbFl4U2pSV2FrbzBZVEpHV0ZKWWNGSmlSM2haVm1wT2IyUnNXa1ZSVkVaVFRWZFNNVlZ0ZUZOaFIxWjBaVVphVjJKWVFrTlVWbHBQVWpGd1NWTnNhR2xYUmtwM1ZsZHdRMVl3TUhoWGJsSnFVbXMxV0ZSVlVrZFhWbHBYWVVkMFdHSkdjRWRXTW5NMVdWWmFWMk5HUWxkTlYxSk1WV3BHWVdSSFJrWk9WMnhUVjBWR05WWnRNVFJoYlZGNVZtdGtWMWRIZUZaWlZFcFRWMVpaZDFwR1RsaFdiWGhXVmtkNFQyRnJNVmRqUkVKaFZsZG9jbGxyWkV0VFJsWnpWMnhrVTJWclJYaFdiWEJIVXpGYVYxTnVUbUZTYmtKUFZXcEtibVZzV25GUmJYUlRZbFphU1ZaSGRHdGhSa3AwVld4b1ZtSkhhRVJXUmxwaFpFVXhWVlZ0YUU1aGVrVXhWbGN4TUdFeGJGZFRXR3hzVW0xNFYxbFhkSGRqYkZKMFpVZEdhMUl4U2tsVmJYaDNWakpLV1dGR2NGZGhNWEIyV1dwS1IyTXhUbk5hUm1ocFVqRkthRmRXVWt0aU1VcEhWMWhrV0dKck5YRlpiRlpoVWpGYVNHTjZWbWhXYTNBd1draHdSMWRIUlhoWGJrWlZZa1p3YUZWdGMzaFdNWEJIVlcxc2FXRXdjRnBXYTFwclpERlplRlpyWkZoWFIxSm9WV3hvVTJOV2JGbGpSbVJZVm14YU1GcFZaREJoUmtwVlVteG9WMkpZUWxSV2FrWmFaV3hXZEdGR2FGZGlTRUpvVjJ4V1lXUXhUbGRXYms1VllsZDRWRlJXVm5kVlZscDBZMFZPVjAxVk1UUlZNV2h2VjBkS2NrNVhhRlpoTVhCTVZtMTRVMVl4WkhKa1IzaHBVbXhaTVZkclZtdE5SbVJIVTFoa2FsSlhlR0ZXYkZwM1pHeGFkRTFWV214U2JWSXdXVlZhZDFZeFduVlJibXhYWWxoQ1NGbFVTbE5TTVU1MVZHMW9VMkY2Vm5aV1JsSkRVMnN4UjFkdVVtcFNXRkpRVlcxNFIwNVdWblJsUjNSWFVqQndlVmt3YUVkV2JVcFZVbFJDVjAxV2NHaFpNVnBUWXpGU2RHRkdUbWxTYlhRMVZteGpkMlZGTVVkV1dHUk9WbTFTY1ZWclZtRldNVkpZVGxjNWEySkhlRmhXTWpGSFZqQXhjazVWYUZwTlJuQnlWbXBCZDJReFRuSmlSbVJZVTBWS1NWWnJVa2RUYlZaSVZHdGFhVkpzU25CVmFrWkxWMVphV0dWSFJtdE5WbXcwVjJ0YWIySkdTblJWYkd4YVYwaENTRnBYZUdGa1JUVldUMVprYVZaV1dYcFdSM2hoWWpGYVYxZHVUbXBTUlhCV1ZtcE9iMWRHYkRaU2JHUnFZa1pLZWxsVldrOWhWazVHVTFSS1YwMVdTa1JYVm1SR1pVZEtSMXBHYUdsaGVsWjRWbGQ0YjJJeFpFZFZiR1JZWW0xU1QxUldXbGROTVdSeVZsUldWazFFUmxoV01qVjNWakZKZW1GSVNscFdiVkpIV2tSS1QxSXlUa2RhUjJ4WFVsVnNObFl5ZUZkV2F6RlhVMWhzVkdFeVVtaFZiVEZ2VjFaV2NWSnJkRlpXYkhBd1dsVmtNRlpyTVhKT1ZtaFhZbFJXVkZaSGVHRk9iVXBKVW14V1YySklRbTlXUmxaaFZURlplRnBJU2xCV2JXaFVXVlJPUTA1c1dsVlRhbEpwVFZac00xUldhRWRXTWtweVkwZEdXbFpGV2pOWlZWcDNVbXhrYzFwSGRGZE5TRUpKVmpKMFZrMVhSbGhTYWxwU1lXeEtXRmxzVWtOT1JuQllUVlprVTAxVk5YcFhhMXBUWVZkRmVsRnVXbGRXZWtGNFZWUkdVbVZHV25WVmJYaFVVakZLVUZkWGRHRmtNREZIWVROa1YyRnJTbGRVVjNSM1YwWlplV1JJVGxkTlZXdzJWbGMxZDFZd01VaFZhM2hXVFVad1dGbDZSbGRqTVdSMFlrWk9hV0V3V1RKV2JURjNVakZzV0ZKWWFHRlNiV2hXV1ZSR2QyRkdWbkZUYlRsVlRWZDRXbGt3Vm1GVWJFcHpZa1JXWVZKWFRURldiRlY0WTJ4a2NtRkdXazVXTW1nMlYxWldZVk14V2xoVGEyUmhVbTVDV0ZWc1duWmxiR1JYVm0xR1dHSldXbGxXYlhSdlZUSktXVkZyT1ZkaVdHZ3pWR3hhWVdOc2EzcGhSMnhPVm10d05sWlVTakJaVmxwSFdrVnNVbUpIYUZkWmJHaHZUVEZaZDFkdVRsZFdhM0I2V1RCa05GWXlSalpXYWxaWVZteGFjbGxxUm1GU01VNXpWbXhrYVZJeWFGcFdiWEJQVlRKT2MxZHNWbE5pVlZwVVZGWmtVMWRzWkhKWGJUbG9WakJaTWxadE5XOVhSbGw2Vlcxb1lWSkZSalJXYWtaM1UxWk9kRkpzVGxOaE0wSmFWbXRhYTAxSFVYaFViazVYWWtkb2MxVXdaRk5YVmxaMFRWWk9WR0pHV2xsYVZWWlBWMGRLVmxkdWJGZE5ha1oyVmpKemVHUldVbkZWYkdSb1lURnZlbFpVUW10VU1VbDRWVzVTYVZKdFVrOVpiR1J2VFd4YWRFMVVRbHBXYkd3MFdXdGFhMkZXU25SVmJHeGFWa1Z3VkZZeFduTmtSMUpJVW14a1UySllhRFpXYlRCNFVqSkdjMWR1VGxSaVIzaGhWRlJPUTFOR1duSlhhM1JyVWpGYVNGZHJXbXRVYlVaeVZtcE9WMkpVUmpaYVZXUk9aVVp3U1ZadGJGTmlWa3BRVjFjd2VHSXhTbGRYYmtaU1lsaFNWVlJXVm5OT1JtUnlZVVpPYUZKcmNIcFpNR2hQVjJ4YVJrNVZVbGRXVm5CeVdYcEdZV1JHU25Sa1JUVlhWa1phV2xadGVHcE5WbEY0VjFoc1ZHSkhhSE5WYlRGdlZteGFkV05GWkd0aVJuQllWakl4UjJFeFNsVlNiRnBYVm5wR2VsWkhlR0ZXTVdSWlkwWmtVMDB5YUZsWFZsSkhZVEZKZUdORldtaFNNbWhVV1d4b2IyRkdaRmRWYTJSWFlsWmFTRll5ZUZkVk1rcEdUbFpzVm1GclJqUlViWGh6Vm14YVZWWnNaRTVoTTBKTFZsWmFiMkV4V1hoVFdIQm9VbTFTVmxsclduZGpiRlp4VW1zNVdGWnVRa2xaTUZwUFZqQXhkR0ZHY0ZkaE1YQnhWRlprU21WR1duSmFSbWhZVWpOb2VsWlhjRU5aVmxwSFlraE9WMVpGV2xWVmJYaDNWMVp3VmxwRVFtaFNhM0JXVlcxNGQxWnNXalpSVkVaWFRVZFNSMXBWV210a1ZrNXpXa1prVTFadVFrMVdNbmhoV1ZaVmVWUnVUbUZUUlhCUlZtMHhVMk5HV25Sa1NHUk9UVlpzTkZZeWVFOVZhekZ6VW1wU1dHRXhjSEpXTUdSTFl6Rk9jazlXV2s1U01Vb3lWbXRTUjFZeVRYaFdia3BoVW14S1ZGbHJaRE5OVmxwSVpVZEdWVTFXYkRSVk1XaHJWakpHYzFkc2FGZGlia0pZVlRCYVlXUkZNVlprUm1SWFlUTkNObFpzWkRSaE1WSnpVMjVXVW1KR1dsaFpWM1JMVmpGU1YxZHRkRk5oZW14WVYydGFZV0ZXU2xWV2JtUlhWa1ZLV0ZVeWMzaGpNV1IxVW14U2FHRXdjR2hXYlhCRFZqQTFWMVp1VWs5V2F6VllWV3BDZDFOR2EzZFhhMDVYVFd0d1NWWlhlRk5YUmxwelkwZG9XbVZyV25KYVJscDNVMGRHUjFSdGJGUlNWV3QzVm0xNFlWbFhTWGxTV0d4VVlUSlNXVll3WkZOWFZteFZVMnhPV2xac2NIcFdNalZyWVRKS1NHVkdaRmRpUjJoMlZtcEtTMVpyTlZaYVJuQm9UVmhDZVZaclpEUlpWMUpYVW01U1VGWnRhRmhaYTFaM1UxWmFjVk5ZYUZkTlZXdzBWMnRvVjFZeVNraFZia0pXWWxob00xcEVSbUZYUlRGVlVXMTBUbUpGV1RCV2FrbzBZakpHYzFOc2FGWmlSbHBXVm0weFUxWkdXWGRYYkhCc1ZsUldXRlpIZUZkaFZrcFpVV3RvVjJGcmJ6QldSRVpoVmpGa2RWUnNhR2hoZWxaWlZrWldZV1F4YkZkalJtUlhWa1ZhV0ZSV1drdE5SbXhXVmxSR1YwMVdiekpaVlZKWFZqQXhXRlZZWkZwaGExcExXbFZhYTJNeGNFZGhSMnhUVFZWd1YxWXhaREJoTWtsNFYxaG9WbUpHY0ZsWmJURlRZakZXZEU1VlRsTk5WbkI2VmxkMGExWXdNWEpYVkVwYVlURndkbFpxUVhoa1ZsSlpZVVp3VjFac1dYcFhhMUpIVkRKT2RGUnJaR0ZTVkZaWVdWUk9RMUpzV25GU2JVWmFWbXh3TUZadGRHdGhiRXBZWlVaYVdtRXlVblpaYWtaVFZqSkdSbFJzYUdsU01VcFpWbXhrZWs1WFJsWk5WbWhXWVRKb1dGbHNVbGRUUmxweldrVjBWMVl3Y0VoWmExcGhZVlphUmxacVdsZFNiVkV3Vm1wS1UxSnJNVmRYYlVaVFRXMW9VRlp0ZUc5Uk1EVlhXa1pXVW1KVWJISlVWbHAzWlZaU1YyRkdaRmRXYlZKSldWVmFiMWRzV1hwVmFrNVhVbFp3VjFwVldtdGpiSEJJWTBVMWFHVnNXa3BXYWtvd1lUSk5lRmRZYUZSaVJuQnZWRlJLVTFkR1VsaE9WemxxWWtoQ1dWUldXbXRWTURGWlVXdGtXR0V4Y0ZSWlZtUkxVakpPUjFkc2FGZGlWMmQ2Vm0xd1IyRXhTWGxUYTJ4VVlsZG9WRlpzVWxkWGJHUllaRWQwVmsxWFVsaFpNRlpoV1ZaS1JsTnNhRnBYU0VKSVZqQmFjMk5zVm5OVWJHaHBWbFpaTVZkV1ZtRlJNV1J6VjJ4a2FsSllhR0ZVVnpWT1pVWmFjVkp0ZEdwTlYxSXdXV3RhYjFVd01YUlZWRXBYWWxSR00xVnFSbk5XTVZwWllVWm9XRkl5YUc5V1ZFSmhVekpPYzFadVVrNVdlbXhZVlcweE5HVldaSEpWYXpscFVqQndTRmt3YUc5V2F6RjFVV3RTV2xaV1ZqUldNRnBYWTFaR2MxZHRiRk5OYldkNVZqRmFhMDVHVG5SV2JHaFRZVEpTYjFWdE5VTlhSbEpWVW10d2JHSkdjSGxXYlRGSFZqQXhjazVXYUZkU2VsWk1WbFZhWVdOck5WbFJiR1JwVWpKb1JWWlVSbUZYYlZaWVZXdG9VMkpYYUU5V2JYUjNUbFphUjFkdFJscFdNRnA2VlRJMVYxVnRTa2hoUjBaWFlURmFNMVpVUm5kU1ZrcDBaRVprVGxZeFNqVldSM2hyVGtaWmVWTnJXbXBTTUZwWlZtMTRZV0ZHV25GVGEyUllVbXMxZVZkclpIZFZNa3BKVVd4d1YySllRbEJXVkVwSFVqRmFjVmRzVW1obGJYaFZWa1phWVdRd01WZFhhMmhPVm5wc1YxUldXbmRXYkZwMFpVaGtWMDFyY0ZaVmJGSkRXVlpLUm1OR2FGWmhhMXBvV1hwS1IxTkhWa2RVYXpWVFltdEtXVlpxUm10TlJteFlWVmhvV0dKck5WbFpiWGhMVlVaWmQxcEdUbGhTYkVwWFZsZDBhMkpHU25OalJFSmhWbFp3VUZZd1pFdFdiRnB4Vld4d1RsSnNhM2RXTVZwaFV6RlplVlJyWkdoU2JrSnpXVlJHZDFkV1pGbGpSV1JhVmpBeE5Ga3dWbTloVmtweVRsaENXbFpGU2pKYVZscGhaRWRPUm1SRk9WTk5SbGw2VmtkNFYyRXlSbGRUYmxKV1lrWndZVlpyVm5ka2JGcDBaVWhPVjFack5YcFdSekZ2VlRKS1IyTkVVbGRXUlhBelZsUkdXbVZHVG5WVmJYaFRZa2hDV1ZaWGNFOVZNVlpIVjFoa1dHRXpVbkpWYlhoaFpXeFplV1ZIUmxkTmJGcDVWakowYzFZeVNsbGhSbVJoVmxad1lWcFdXazlqYkZweldrZHNVMkpyU2xGV01XTjRUa1pOZVZac1pGaGlhMXBUV1d4b1UxWldVbGRhUms1VVZteGFNRnBGWkRCaFJrcHlZMFJDVjFaNlZrUldha0Y0VTBaV2RWWnRSbGROTW1odlYydFdhMVV4VGtkVGJrNWhVbFJXY0ZWc2FFTlRNVnAwVFVob1RsSXdiRFZWYkdodlZrWmtTVkZzVGxwaVdGSk1WbXBHVTFac1pIUlNiRlpUWWtaWk1GWnFTWGhTTVZsNFYyNUtUMVp1UW1GV2JHUlRUVEZhU0dWSFJtcE5WMUpXVlZkNGEyRkhSWGxrUkZKWFlsaENTRlpxU2xOU01WSjFVMjFvVTAweWFGVlhWM2hyWWpKR1IxcEdhR3RTTTFKd1ZGWmFkMU5HYkhKWGJVWllVakJ3ZVZSc2FFZFdNa3BaVldwT1lWWXphRmRhVmxWNFZsWldjMWRyTldoTk1FcE1WbXhhWVdJeVNYaFhXR3hUVjBkNFYxWnJWa3RaVm14WVpFaGtWRkpzY0hoVmJYTTFZVEZhYzJOSWNGWk5ha1o2Vm10YVMxWnRUa2hTYkdScFZrVkpNRlpIZEdGVWJWWkhVMnhzYUZKc2NIQlZha1pMVjJ4a1dHUkhPVkpOYXpFMFZtMDFVMkpHU1hkWGJrNWFZVEZ3TTFSVlduZFdiR1IwWkVkb1UyRXpRbGRXVnpFd1pERmFjMWRxV2xkaWJrSllXVmQwWVZSR2JEWlRhemxVVWpCYVNGa3daRFJoUlRGSFYxUkNWMkpVUmpOVmVrWlNaVVpPV1dGSFJsUlNWRlp2Vmxkd1MwNUdaRmRXYmxKclUwZFNXVmxyV25kbFZsbDVUVlJDVldKRmJEUlZiWEJUVmpGSmVsVnVTbGRoYTFweVZUQmtWMU5XU25OWGJXeFRUVlZ3VmxadGNFTlpWbFY0V2tWb1ZtRXllR2hWYlRGdlkwWldjVlJ0T1ZoU2JIQXdWRlpvYTFack1WaFZhMnhXVFc1b2FGWnFTa2RqTVU1MFVteFdWMVl4U2pKV2ExWmhXVmRTU0ZSWWNHaFNiRXBVV1d0YWQwNVdaRmRXYlVaYVZqQmFXRmRyVm05aFJrcDBaVVpzVjAxSGFFUlZNRnAzVWxaS2NtTkhlRk5OUkZaSVYxWldhMk14VlhsVGExcHFVbXhhV0Zsc2FHOWtiRlpWVTJ0a1UwMVhVakZXVjNNeFZqRktjbU5JV2xkU2JWRXdWV3BCTVZJeFdsbGhSMmhUWlcxNFdWZFhkR3RWTVU1WFkwWmFXR0pWV2xsWmJGWjNWMnhzVmxacVVsZE5SRVpJV1RCb2QxWXlTa2RqUlhoaFVteHdNMVZxU2tkU01YQklZa1pvVTAxdFRqVldiWEJIV1ZaWmVHSkdaRlpYUjJoWlZqQmtiMVpXYkhSamVrWnFWbXhXTTFsVlZrOVhiRnB6WTBod1YwMXFSa2hXYlhoTFl6Sk9TV0ZHV21sV1JWcEpWMVprZW1WSFRuSk9WbHBvVW01Q2IxUldhRU5YVmxwMFkwVjBWRTFWY0RCV1IzUmhWakpLU0ZWdVFsWmlXRkl6Vld0YWEyTXhXblJrUmxacFZteHdTVmRVUWxkak1WbDVVMnhzVW1KR1NtRlphMXAzVkVad1JWSnRSbXBXYTFvd1drVmtjMVJ0U2tkalJteFhZV3RyZUZaVVNrZGpNVTV6WWtaYWFWSnJjR2hYVjNSaFpESkdSMWRZWkZoaVZWcHlWV3hTVjFZeFVYaFhiWFJYVFVSR1NsVlhkREJXTVZwMFZGaG9WbFpGV21oYVJWcFBZekZhYzFwSGFFNVdXRUpaVm10YVlWbFhVWGxTYTJSWFltdGFWRmxyWkZOalZteHlZVVZPVkZKdGRETldNakV3WVVaS1ZWSnFSbGhXUlRWMlZtcEtTMU5HVW5GVmJGWlhWbTVDTmxadGNFZFpWMDV6WTBWa2FGSXllRzlhVjNoaFRrWmFjMVZyVGxkTlZURTBWakZvYjJGV1RrWk9WbVJhWVRKU1ZGWnJXbGRrUjFaSlZHczFUbFp0ZHpGV1JscFhZVEpHU0ZOclpHcFRSM2hXV1d0a2IyUnNXblJsUm5Cc1lsVmFTbFV5ZUd0Vk1EQjVZVWRvV0dKR1dtaFdSRXBQVmpGd1NWUnRSbE5OYldoMlZrWmtkMkl3TUhoWFdHaFlZa1UxVkZSWGRGZE9SbHBJWkVkMFYxSXdjSGxXTW5oelYyMUtTRlZVUWxkaE1YQlVWbTE0YTJSV2NFaGlSVFZYWW10R00xWXhVa05XYXpWWFYyNUtUbGRGY0ZsWlZFcHZWMFpzY2xwSE9XcGlSbXd6VjJ0V01GWXlTa2hWYWtaV1RXNW9hRmxWWkVabFIwNUlUMVprVjAwd1NrbFhhMUpIVXpKTmVWUnJXbWxTTUZwVVZGY3hiMWRXWkZkVmF6bFNUVlpzTkZZeU5WTlViR1JJVlcxR1YySllhSHBVYkZwV1pWZFdSMXBHV21sV1ZuQTJWbFJLTkZsV1pITlhhMXBZWVdzMVlWUlhOVzlYUm10NFYydDBhbUY2YkZoWlZWcHJWR3hPUmxOcmRGZE5WbkJZVjFaYVVtVkdaRmxpUmxKb1RXNW9WRmRYZEc5Uk1XUkhWV3hrWVZKcmNISlVWbVJUVjBaa2NsZHJkR2xTYkhCNVdUQm9jMWRIUlhoalNGcGFWbTFTUjFwVlpFOVNNVnB6WVVaa2FWSllRbEpXYkZwVFV6RlNkRlpyWkZoaWJGcFhXV3hvUTJNeGJGVlNibVJzWWtad01GUldVbE5oYXpGRlZteG9WMVl6YUhKV2JURkxVbXMxVjJGR2NGaFRSVXBKVm1wQ1lXTnRVWGhXYmtwaFVtMVNjRlZ0TVROTmJHUlhWbTFHYVUxV2JETlVWbFpyWVd4SmVXRkhSbUZXTTFKb1ZsVmFjbVZYVmtkYVIzUlRZVE5DTmxaclpEUlVNVmw1VTI1S1ZHSklRbGhaVjNSMlRVWmFjVkp1VGxoU2EzQmFXV3RhWVdGV1NYaFRiR2hZVm5wR05sUldaRWRTTVZwMVZXczFWMlZ0ZUZsV1Z6RTBVekZrVjFWc1pGcGxiRnBXVkZkMGQxTkdiSEpWYkU1WVVqQldORlV5ZEZOV01ERjFZVWRvWVZKWFVsaFZha3BIVWpKR1NHRkZOVmRpYTBreFZtMHhkMUV5UlhoVVdHeFZWMGRvVmxsdGVHRldWbXh5VjI1a2FVMVhlRnBaTUZwclZqRmFjMk5FUWxwTlJscHlWbTF6ZUZZeVNrVlZiR1JPWVd4YVdWWXhXbUZUTWxKSFZtNVdVbUpHY0hCV01HUnVaVlprY2xWclpHaE5hekUwVmpJMVUyRXhTbFZXYkZKYVlUSlJlbFJXV21GWFJURlpXa1p3VjJKR1dURldWRW93WWpKS1IxTllaRmhpUjJoaFdWUkdkMDB4VWxWU2JHUnFZa2RTTUZWdE1YZFdNa1Y2VVdwYVdGWkZTbkpVYTJSSFZqRmtjMXBIY0ZOWFJVcGFWbTB4TkZsWFJrZGlSbFpVWVRKU1dGUldhRU5TTVd4V1drYzVWMUpyYkRaWlZWcDNWakpLV1ZWc2FHRlNNMDQwVldwR2EyTXhXbk5WYldoc1lrWndObFpzWTNkTlZrVjRWRzVPV0dKSGFFOVdNRlV4VmpGU1ZsVnJaRTVXYlhoWFZqSTFhMVl3TVZkaVJGcFdWak5TVUZac1dtRlhSbFp6WVVad2JHRXhjSGxYYTFwaFZqSlNTRlpyWkZWaGVsWlVXVzEwU21WV1duUmtSMFpYVFZaV05GWXhhRzlXVjBWNVZXeG9WMDFIVW5aWmFrWlhaRmRPU1ZSc2FGZGlSbkEwVmxaak1XRXlTa2RYYms1VVltNUNXRlJYY0ZkVlJsbDNXa1YwVjJKVk5VaFpNRnByVmpBd2QxTnNSbGRpV0VKRFdsVmFTbVZXVW5KaVIzQlRZbFpLVUZadGNFZFRNVlpYVjJ4b1RsWkdTbkpVVmxaelRrWnJkMVp0ZEZkV01IQlpXbFZhYzFadFJuSmpTRnBhWVd0YWFGa3hXa3RqTVZKelUyczFWMDB5YUdGV2JHUTBZakpKZUZkWWFHRlNWMmh2VlcxNFlWbFdiSE5oUlRWc1VtMTBORll5ZUd0aE1VbDRWMnR3V0dFeGNISldSM2hoWkZaR2NWVnNaR2hOYXpSNlZrZDRhMUl5VWtkVWJrcGhVak5DVlZWcVNtOVhSbHBIV1hwR1ZtSldSalJXTWpWSFZrZEZlVlZzUWxwaE1Wb3pXbGQ0V21WWFZraGtSbVJPVWtWSk1WZFdWbXBPVm1SSFYyNU9hbEl5YUdGV2ExWmhWVVpWZDFkcmRHcGlWVnBJVlZkNGEyRldXbkpqUkU1WFlrZE9ORlJWWkZKbFJsWnpXa1pvYVZJeWFGQldWRUpyWWpGWmVHSklUbGhpVlZwWlZXMTRkMWRXVW5OV2FrSllZa1p3ZVZrd1VrTlhiRnBZWVVWU1YyRnJjRXhWYWtwUFVsWlNjMXBGTlZkaWEwbzFWakZvZDFJeVVYaFRiR1JYWW1zMWNWVnRNVk5qUmxaMFRsVk9WR0pHY0RCWk1GWXdWR3hKZDFacVVsZE5hbFpVVmxSR2ExTkhWa2RhUm5Cb1RXeEtWVlp0TVRSWlYwMTRXa2hLYTFKdGFGUlpiWFJMVjJ4a2MxWnRSbHBXTUhCSVZqSjRWMVl5U2toVmJXaFdZa1p3TTFsVldtRldWazV5WkVaU1YyRXhjRFJXYlRFMFlqRlplRk5zV21wU1JYQllWbTE0UzFOR1pGZGFSazVUVFZaS01WWkhNWE5WTWtwSlVXNWFXRlp0YUROV2FrWmFaVVp3UjFwR1dtaE5iRXA1Vmtaa2VrMVhWbk5YV0d4UFZsZFNWMVJYZEhkV01WbDVUbFZrVjFac2NEQlpWVlpUVm1zeFIyTkhhR0ZTVjFKUVZHMTRTMk14Y0VaT1YyaE9WbTEwTlZadGVHRmhNRFZJVlZob1dGZEhlRlZaVkVwVFZsWnNWVlJ0T1ZkaVIzaFdWVzAxYTJKSFNrZGpTR2hXWWxSV2NsWlVTa3RXYkdSeVlVWmtVMDB5YURKV2JGSkNaVVphZEZSclpGUmlSMUp3Vm10V1NtVnNaSE5XYlhSVVlsWmFTRmt3Vm1GWlZrbDVaVVpTV21FeGNETldiRnByVjBkV1IxcEdjRmRpUlZrd1ZteGtOR0V5UmtkVGJGcFBWbXhhV0Zsc1VsZFNSbHB4VW14d2JGWlVSbFpWVnpGdlZUQXhTVkZzYUZoV1JVcFlXV3BHYTJOck1WWmhSMmhVVW01Q1dWZFdaREJaVm14WFkwWm9UbFpYVWxSVVZsWmhaV3hyZDFkdGRHaFdhelZIVlRKek1WWXlTbGxSYTJoWVZteHdTMXBXV2xOak1YQkhZVWRzYUdWc1duWldiR04zWlVaVmVGZHJaRmhpYkZweFZXNXdjMVF4VWxkWGJtUnNZa2Q0VjFsVlpEQldhekZGVW14c1YxWXpRa1JXYWtwTFYxWldkVk5zYUZkaVNFSlJWbGN3ZUZReFRrWlBWbVJZWWxkb2IxUlVRa3BsVmxwMFRWUkNXbFpzYkRWV1YzUmhWREZhYzJOR1dscGhNbEoyVmpCYWMyTnRSa1pUYlhST1ZtNUNTVlpxU2pSVU1WcHlUVmhLVjJGck5WWldiWGgzWkd4YWRFMVZXbXhXTUZwSVdWVmFkMkZXU25KalJteFhWa1ZLYUZkV1dtRldNVkoxVTJ4b2FWZEhhRmxYVjNSaFpHMVdSMWRzYUU1V1JrcFlWRlphYzA1V1ZYbGtSM1JvVmxSQ05sVlhlSE5YYlVWNFkwZG9XbFpXY0hKV2FrWjNVakZTYzFSdGFHeGhNWEJhVm0wd2VFNUdiRmhTYkdSVVlteGFVMWxyVmt0WFJteHpWV3RLYkZKc1dsWlZiVFZQVmpBeFdGVnVjRmhoTWxKSVZsUkdTMk50VGtkaFJtUlRZa2hDYjFkWWNFSk5WbGw0VjJ4c2FWSXphRlZWYkZKWFpHeGFXRTFVUW10TlJFWklWako0YjJKR1NYZFhiR2hWVmpOU00xWnRlRmRrUjFaSFZHeGtUbEpGV2tsWFZFSmhZakZrY2sxV1pHcFNXR2hvVld4YWQxUkdjRVphUlRsVFlYcFdXVmxWVlRGWFJrcFdZMFV4VjJKWVFraFpWRUY0VWpKS1IxcEdXbGhTTW1oWlZtcENhMDVHV2tkWFdHUm9VbFUxVjFSV1pEUmxWbGw1VFZWa1dGSnJjSHBWTW5odlYwZEZlR05GZUZwV1JVWTBWbXBLVDFOWFJrZFhiV3hYVW14d1VsWnRNWGRSYlZaSFdrVmtWMkpyTlhGVmJUVkRWMFphZEU1VlRteFdiVkpZVmpJeE1GWkZNVlpqUkVKWFVqTlNlbGxXV2t0a1JsWnpZVWRHVjAweFNtaFdSbVEwV1ZaSmVGcElVbE5pU0VKWVZGVlNSazFHV1hsa1J6bFhUVlp3TUZVeWVITldiVXBIVjJ4a1dsWXpVbWhXUlZwYVpVWmtkRkpzVGs1V01VbDNWbGN3ZUdReFVuTlRhMlJZWWtkNFdWWnJWa3RYUm1SWFYyeHdiRkp0VW5sWGExcHZZVlpKZVdGR1pGZGlXRUpRVmxSQmQyVkdaSFZTYkU1cFlUTkNlVlpHV21Ga01ERkhWVmhvV0dKWVVsWlphMVozVWpGWmVHRkhPVmhTYkhCNlZqSXhiMVpzV2taWGJVWmhVa1ZHTkZZeFdrdGpNVkowWWtaT1RtSlhhSFpXYlhSaFlXc3hXRk5ZYkZWaWF6VnZWRlJLTkZReFduTmFSazVYVW14S1dGbFZWazlXUmxwMFpVaHNWMDFxUVRGV2JYTjRVbFpLY1ZGc2NGZFdiRlY0Vm0xd1MxSXlUbk5hU0U1V1lrWndjMWxVUWxkT1JscFlZMFZrVjAxWFVsbFZNblJyVmpKS1NHRkdVbFZXZWtaMlZtMTRXbVZHYTNwaFIzaG9aV3RhV1ZacVNURlVNa1pYVkd0YWFsSXlhRmRaYkdoT1pVWnJkMWRzVGxkTlYxSjVXa1ZhYjFVeVNsZFRiVVpZVmtWS2FGWkVTa2RXTVU1MVZHMXdWRk5GU21oV1JsWmhVekZLUjFwR1pGaGlWVnBaVlcxNFlXVldiRlpYYlhSVllsVndNRmxWWXpWWFJtUkpVV3Q0Vm1WcldreFdha1poWkZaU2MyRkhhR3hpUm5CYVZtdGFhbVZIU25SV2JHUllZbXhLVDFaclZrdGlNVkpYVm01a1RsSnNjREJhUldNMVZqRlpkMVpxVmxkV00yaFVWakl4Um1WV1ZuTlZiSEJPVW01Q2FGZHJVa2RrTVU1R1RsWm9iRkl5ZUZSWmJYUkhUVEZaZUZWclRsZE5hMVkwVjJ0V2IxWkhTa2hWYkZKYVZqTm9URll3V2xOWFJUVllUMVpvVTJKSVFsZFdWRW93VFVaVmQwMVlTazlXVjFKV1ZGWmFkMk5zYkZkWGJVWlRUVmRTZVZadGVHdFZNbFp5Vmxoa1YwMVdjSEpXVkVaTFkyc3hWMWR0YkZOTmJXaFZWMVpvZDFZeFZrZFhibEpPVmtaS2NsUlZVbGRYUmxsNVpFZDBXRkl3Y0ZkV01qQTFWbFphYzJORVRsWk5WbkJZV2tWVk1WWnRVa2RhUms1T1UwVktZVll4V2xkWlYwVjRXa2hTVTFkSGFIRlZhMVV4V1ZaYWMxZHVaRmRTYkhCNlZqSjBNR0V4V25OVGJuQmFWbFp3VUZaSGVFdFNiRnBaWWtaa1RsWnVRbGxXTVZwclVtMVdWMU51VG1GU2JFcFpWV3BLYjFac1pGZGFSRkpyVFZkU1NGWlhlRzlVTVZweVRsYzVWbUpVUmxSV01GcHJZMnhhZEdSR1pFNVNSVnBoVmxaa01HRXhaRWhTV0docVVteEtZVlp0ZUhkVVJtdzJVMnM1VTAxcmNFaFpWVnByWVZaS1dWRnJjRmRpUjJnelZXcEdTMlJHV25KaFJsWm9UV3hLV2xkWGRHdGlNa2w0Vld4V1UyRXpVbk5XYlhoM1YxWlNWMkZJWkZWaVJtdzBWako0YjFkdFJYbGhSWGhZVm14d1VGVXdXbGRqTVhCSFZteGtUazFWYkRaV2JGSkxUa1paZUZwRmFGZGhNbmhXV1d0a2IxWkdiSEphUkU1T1lrWndlbGRVVG05aFZURllaVVpvVmsxdVVtaFdNR1JMVW14T2MyRkdjRmROTVVwdlYxUktOR013TlhOVGJsWmhVbXhLVkZsVVRrTk9iRnB6V2tSU1ZrMVdWalJXTW5oelZXeGFSbU5HYUZwaVIyaDJXVEo0ZDFKV1NuSmFSM0JvWld0YVdWZFdWbUZoTWtaWVVtcGFWMkpJUWxsV2JYaExWRVpzY1ZOck5XeFNiSEJhVjJ0YWExWXhTbGRqUm5CWFZucEZNRnBFU2xkU01WcHpZVVU1VjAweFNsaFdSbFpUVWpGa1YyTkZXbFpoZW14WVZGVlNSMlZHVmxkVmEyUlhUV3RhZVZWdGNGTlhhekZ4VW14Q1ZtSlVSa2hWYWtwUFVtczFWMVJ0YUU1TlJYQlVWbTB3ZDJReVVYbFdhMlJWVjBkb2FGVnRNVzlXUm14VlUyMDVhVTFXV2pCYVZXaHJZVlV4V0dWR1dsWmlWRlp5VmpCYVlXUkdWbk5YYkZwT1ltdEtWVlp0TVhwbFIwNXlUVlpXVm1KSFVuQldhMXBoVmxaa1YxZHRSbFJOYkVwSVZtMDFUMkZHU25OalNFSldZbFJXUkZZeFdtRlNNVlp5V2tad1YwMVZjRXBXYlRFd1lqSkdjMU5ZY0doU2JFcFlXVlJHZDJGR1ZYaFhiWFJZVWpGS1NWVnRNVzlVYkZwMFpIcENWMDF1VWxoWmFrcExVakZPZFZSc1VtbFNNbWhYVm0xNGExVXhXa2RYYmtwWVltdHdjMVZ0TVZObGJHUnlXa1JDVmsxRVJsZFpNRlp2VjBkRmVGZHRhR0ZTUlZwaFdsWmFUMk50U2tkVGJXaHBVbTVDV2xZeFpEUlZNVXAwVlZob2FWSnNXbFJaYTFaM1l6RldkR042Ums1V2JIQXdXbFZXTUdGR1duSmlSRnBhVmxkTk1WWnFTa3RYVjBaSVlVZEdVMUpZUWxGWFdIQkhZVEpTVjFOdVRsUmlSMmhVVkZjeGIxZHNXbkpYYlhSc1lYcEdXRlpITlU5aFZrNUdZMFpzV21KR1NucFpha1pYWXpGV2NscEdhR2xTYkhCYVYyeFdWMkV4V1hkTldFcHFVbGRvVjFSWE5WTmtiRmwzVjIxR2FrMXJOVWRhUldSSFZqRmFkVkZzVmxoWFNFSk1WWHBHVDFOR1VuSmFSbFpwVmpOb1dWZFdVazlSYlZaWFYyNVNhMUl3V21GV2FrSnpUa1pXYzJGSGRGVmlSMUpIVkd4YWMxZHRTbGxWYWs1WFlXdGFlbFpzV2s5ak1WSnpZVVpPYVZKWVFtRldNV2gzVkRKSmVGVllhRlJpYkVwWFdXMHhORmxXV25OWGJGcE9WbXhzTTFZeWRIZGhNREZ5VGxWa1dtRXhjRE5XYWtaYVpEQXhTV0ZHWkdsWFIyaHZWakZhWVZkdFZrZFZibFpWWWxkb1ZGbHNXa3RrYkdSWFZXdGthMDFzV2xoV01qVkhWVzFLV1ZWc2FGVldiRlY0VldwR1VtVkdaSFJrUm1oVFRVWnJlVlp0TVRSaU1WbDVVbGhvV0dKSFVtaFZhMVpoV1Zad1ZsZHVaRk5XYTFwNlZqSnpNVll3TUhsaFJuQlhZbFJGTUZscVNrNWxSbHBaWVVkR1UxWXlhSHBXVnpCNFZURnNWMkpHVmxSaVJUVnlXV3RrVTFkR1dYbE9WVGxYVFZad2VWa3dVa05XYlVwWlZGaG9WMUl6YUhKVmJYaFBZekpLUjFwSGFHaE5ibU4zVm14a2QxSXlSWGhUV0doVllrZDRhRlZzVW5OV1JsWnpZVVZPV0ZadFVsbGFWV00xWVZVeFdGVnJhRnBoTVhCeVZqQmtSbVZzVm5OaVJtUnBWMFpLYjFkc1pEUmpiVkY0V2toU1VGWXlhRmhaVkU1RFRteGtWVkZ0UmxkTlZtd3pWRlphYTJGc1NYbGhSbWhWVmpOQ1NGWXdXbGRqVmtwMVdrWlNWMkpJUWpaV2JUQjRZekZrUjFOc1dtcFNiSEJZVkZaa1VrMUdiRlZUYTNCc1VtNUNSMWRyWkVkVk1rcFhVMjA1VjFZelVsaFZla1p6VmpGa2RWVnRjR3hoTVhCV1ZsY3dlRTVIVmxkWGJHaE9WbGRTV0ZsWWNFZGxWbXQzVjIxMFYwMUVSbmhXYlhSdlZqSktSMk5IYUZwbGEzQlFWVEJrUjFJeFduTmFSbVJwWVRCWk1sWnRNSGRsUlRWSVVsaHNWV0pyY0ZGV2JURlRZVVpXYzFWc1pGaFNiRXBZVm0wMWExWkdXbk5qU0hCWFZqTlJkMVpFUmt0ak1rcEZWV3hrVGxZeWFEWldiWFJyVXpGSmVGcElUbFppUjFKdlZGWmFkMVJXV25GUmJVWnFUV3N4TlZWdGRHRlZSbHBWWWtaU1dtRXlhRVJVYTFwaFYwVXhTV0ZGTlZOTlJtOTNWbFJLTUdNeFZuUlNXR3hvVW0xb1ZsWnFUa05UUm5CSVpVZEdWRkl4V2tsYVJWcFBZVlpLVlZacVdsaFdSVXBvV1ZSR1UyTXhaSFZXYkVwcFVteHdXVlpxUW05Uk1VNUhWMjVTVGxadFVsUlVWbVJUWld4c2NscEhPVlpOUkVZeFdWVmFZVll4V1hwaFNGcFdWa1ZhY2xacVJuZFNNa1pJWlVaT2FWWnJjRzlXYlRCM1pVWlZlRnBGWkZoWFIzaFFWbTF6TVZac1VsZFhibVJYVFZaS2VsWXllRTlXTVZwelkwaHdXazFHU2xCV2JGcGhWakpPU1dKSFJsZGxhMXBSVmxkd1IyUXhTWGhqUlZwUFZtMVNjRmxVUW5KbFZscHhVbXhPVWsxcmJEVldSbWh2V1ZaT1JtTkZPVmRpUjFKVVdURmFWbVF4V25WYVJtaFRZbGhvV2xkclZsZGhNVkY0VTI1V1VtRXlhRmhVVnpWdlkyeHNXR016YUZkaVIxSXhXVEJhYjJGRk1YTlRhbHBYWVd0S2FGVXlNVmRYUmtweVlrWm9hVkl4U25kV1YzQkNUVWRXYzFwSVRsZGlWVnBXV1d4YVIwMHhVbk5YYms1WFZqQndSMVJzYUVOWGJHUkpVV3hvVjAxdWFISldNR1JUVTBkU1IxZHJOVmRpYTBwS1ZtMXdTazFXVVhoaVJtUlVZVEZ3VlZsWWNITldiRnAwWlVoa1RrMVlRbGxhVldRd1ZqRmFjMU5xUWxWTlZuQllWa2Q0WVZkV1JuRldiR1JUWWtoQ1ZWWnRjRWRYYlZaSFZHNUdXR0pIVW5CVmJGWjNWMVprV0dSSGRGWk5Wa3BJV1ZST2MyRnRWbkpYYkdoVlZteHdNMXBYZUhKa01YQklUMVpXYVZaWVFraFhWRUpoV1ZaWmQwMVdaRlJoTVVwWlZtMTRkMk5zY0VaWGJHUllWakJhU1ZWdGVGTlZNV1JHVTJwU1YySkhVVEJXVkVaYVpWWlNjbHBHWkdsaVJYQlJWbTE0VmsxV1ZrZGlTRXBZWW0xU2MxVnRlRmRPUm14V1dYcFdWMkY2UmtaVmJYaHZWMjFGZUZOc1FsZGlSbkJvV1hwS1QxTkhSa2RqUm1ScFUwVktUbFpzWkhkU01WRjVWRmhvYWxKWFVsaFphMlJUWXpGc2NsZHVaRmRpUm13MFZsZDBNRlF4U1hkV2FsSlhUVmRvZGxkV1drOVNiVTVIVW14a2FWZEZNVFJYVkVKaFZqSk5lRlp1VGxoaVdHaFVXV3RvUTA1V1dYbGtSazVXVFZkU2VsWXhhR3RYUjBwSVlVWmtWVll6UWxoV1ZWcHpWakZhV1ZwSGVHbFNWbkEyVjFaV1lXUXlSa1pOVm14U1lYcEdXRlpyVmt0aFJteFZVbXh3YkZJd05VZFdNbk0xVmpBd2VXRkdWbGhXTTJob1ZUSXhWMUl4WkhWVWJVWlRVbXR3VjFaR1pEQlpWbVJIVmxoc1QxWllVbTlaYTFaM1pWWlZlV1ZIT1ZoaVZYQklWVEowYTFsV1NrWlhhazVXWWtad1RGa3ljelZXTVZKeVRsWmtUbFpYZHpCV2JYaHFaVVUxUjFaWWJGTmhNbWhVVmpCa1UyTldWWGRYYm1SWVVteGFNRnBWYUd0aFJrcDBWV3hvVjJKSGFIWldWRUY0VmpKT1IyTkdjR2hOYkVWM1ZteFNRbVZHU1hsVWEyeFlZa2RvV0ZSVVJrdFhSbHBIVjIxR1ZVMVdiRFZXUjNSclYwZEtTR0ZJUWxkTlJuQk1WakZhWVdSRk1WVlZiWFJvWld0YU5sWnFTVEZWTWtwSFUyNUtUMVp0ZUdGV01HaERVMFpTVjFkdVRsZGlTRUpKVkRGYWExUnRSWHBSYlVaWVZteGFWRlpFUm1Ga1JrcDFVMnhvYUdGNlZsaFdSbFpyVlRGYVIxWnVSbE5pYlZKVlZXcENkMU5HV2tobFJ6bFdUVlp3V2xWWE1VZFdNa3BWVVdwT1lWWldWalJWTUZwTFYxWndSazlXWkZkTlZYQmhWbTF3UTJFeVNYaFhXR2hwVTBaS2NsVXdaRk5XYkZKWFYyeGtUazFYVW5sV01uTTFWakF4VjJOSWNGcE5SMmg2Vm1wS1MxWldXblZUYkdST1VtNUNUVmRZY0VkaE1sSllVbXRrWVZKck5VOVVWbFozVld4YWRHVkhkR3hpVmxwSVZqRm9iMVpYU25OWGJrWldZbFJHVkZrd1dsZGtSMUpKV2taU1YySldTbGxXYkdRd1lURmFSazFZU2s1V1JrcFlWVzV3VjFkR2JGWlhhM1JyVW14YWVWUXhXbmRXTURCNFUyMDVWMVpGV21oWFZtUk9aVVphZFZOdGRGTmhlbFozVm0weE1GZHJNVmRYYmtwaFVrVktjVlJYZEdGbGJGVjVUbFpPYUZKcmNEQlpWV1J2VmpKR2NrNVdVbGhXYkhCVVZqQmtWMU5IVWtoalIyeFRZa2hCTVZZeWRGZFpWMFY0Vlc1U1UyRnNjRlJXYTFaTFYwWlNXRTVXVG10aVJsa3lWVEowYTFZd01WWk9WbkJhVFVad1RGbFdXa3RqYlU1SFlrWm9WMDB4U205V1dIQkhZVEZKZUZwSVZsVmlSMmh3Vm14YWQxWldXa2RYYlhSV1RXeGFlbGRyYUV0WFIwcDBWV3hvVlZac2NETlZha1phWlZkU1NWUnNaRTVoTVhBMVYxZHdUMkV4WkhSU2JrcHFVbGhvVjFsWGRHRlZSbGw0VjI1a1UwMXJXa2xaYTFwUFZHMUtXR0ZHY0ZkaGExcG9XVlJCZUZJeFVsbGhSMFpUVmpGS1dGZFhNWHBOVm1SWFlraE9WMkpWV2xsV2JYaGhaVVpXVjFWclRsVmlWWEJJVmpKd1ExbFdXbGhWV0dSYVZsWndhRmw2U2s5U01rNUhWMnhrYkdFeGNFcFdiVEYzVXpGS2RGWnJhRlZoTW5oWldXdG9RMkl4YkZWU2JtUnBUVmRTV2xrd1ZtdGhSVEZ5VGxod1dHRXlhRkJaVlZwS1pWZFdSMVZzVmxkbGExb3lWbXBLTkZkdFZrZGFTRkpyVWxSV1ZGbHNhRzlYYkZweVdYcEdWVTFyV2tkVVZXaHpZa1pPUmxkdGFGZGhhelZVV1ZWYVdtVkdaSE5hUjNCWFlURndWMVpYTVRSVU1WSnpWMjVLYWxKR2NGaFpWM1J6VGtaU1ZsZHNjR3ROUkVaYVZUSXhkMVpHU1hwaFJtaFhVbTFOZUZscVFYZGxSbVIxVW14U2FFMHhTbHBXYlhCRFdWWk9jMVp1VWs1V1YxSllWRlphZDJWc1dYaFZhMDVYVFZac05sVlhkRzlXTVZwR1YyNUtWMDFHY0V4Wk1uaDNVMGRHUjFSdGJGZE5iV2hYVm0xMFlWVXhUWGxUV0doaFUwVTFXVll3Wkc5aFJsWnlWbXQwYVUxV1NsZFdWM2hyVmtaYWMxWnFVbHBXVjAweFZtcEJlR050VGtsaVJtUk9ZbTFvVVZacVNYaFRNVWw0V2toU2FGSnRVazlWYlRWRFZsWmFkR05GWkdoTmJFcFlXVEJXWVZReFduSk9XRUphVmtWS00xWXhXbUZqVms1eFVXeGtUbUV4V1RCV2FrWnZZakZhU0ZOdVNtcFRSVnBYVkZWa2IxSkdXWGRYYkU1WVVqQTFTRmRyWkRSaFZrcDFVV3BTVjFaRmIzZFVWVnByVWpGa2RWTnNhR2xpYTBwWlZtMXdUMkl5VG5OWGJrWlRZVE5TV1ZadGRHRmxWbEpYVjIxMFYwMXNXbmxWTVZKRFZqSkZlRk5yYUZkU1JWcHlWV3BHVTJSV1RuUlNiRTVwVmpKb01sWXllR3RPUm14WVZWaG9ZVkp0YUhOVmFrNVRZMFpTVjFkcmRHeGlSbXcxVkd4YVQxWlhTa2hWYTJ4WFZqTm9WRlpzV21Ga1JsWnpWV3hXVjFadVFtOVhhMVpXVFZaYWNrOVdaR0ZTTW5oWVZqQldTMU14V1hsbFJtUnBUVlZzTkZZeU5WTldSMHBIVjJ4U1dtRXhjRXhYVmxwelYwZFNTRkpzWkZOaVNFSTBWbFJLTUdFeFZYbFRhMlJVWW01Q1lWWnNXbmRqYkd4WFYyczVVMkpGTlRCVmJYaHJWR3hhY21ORlZsZGlXRUpNVlcweFYxSXhjRWxUYkdob1pXeGFXVmRYZEc5Uk1WWlhWMjVTYkZJelVuQlVWbVJUVTBaYWRFNVdaR2hpUlhBd1ZsZDRjMVp0U2xsaFJFNWhWbXh3Y2xreWVHRmpWa1p6VjJzMVUxSldjRmxXYTJRMFlqSlJlRnBJVWxOWFIyaHhWV3BLYjFsV1duUmxTR1JWVW0xME5WUldWVFZWTURGeVkwVm9XR0V5VW5wV01GcExZMjFPU1Zkc1pHaGhNWEJ2VjFaU1IxWnRWa2RWYmtwaFVtMW9jRmxVVGtOaU1WcFlZMFZPV2xac2NFaFphMmhUWVRGS1dWVnNiRmRpVkVaVVZqQmFZVmRIVWtoa1JtaFRUVVpyZVZaWE1UQmlNVmwzVFZoR1YyRXlhRmhaVkVwVFUwWnJlV1ZGT1d0U1ZHeFlWbTE0YTJGV1RrWlNhbHBYWWxoQ1NGZFdXbHBsVmxaeVYyczVWMkpJUWxKV2JUQjRWVEZhUjFWc1dtaFNWVFZZVkZaa1UxZFdjRVphUkVKV1RVUkdXVlpYTlhkV01ERjFWVzFvVjAxSFVreFdNR1JIVTBaS2MxcEhiRk5pYTBZMlZqRmFWMWxYVG5SV2EyUmhVMFZ3Y2xWcVRrTlVNVmwzVm10MFZHSkhVbmxXYlRGSFZsVXhWMU51Y0ZkTmFsWllWbGN4Um1WWFZrZGhSbFpYWld4YVZWWnFRbUZoTVZsNFdraE9hbEl6YUZSWmJGcExXVlprV0dSSFJsVk5WMUpJVmtkMFlWWkhTa2RUYkd4WFlXczFWRmt5ZUhOalZrcDBaRVpPVG1FelFrbFhWbFpyVFVaYVIxTnVWbEppYlhoWVZXMTRkMkZHY0VWU2EzUnFUVlp3TVZaWGN6RldNVmw0VTI1YVdGWnRhRE5WYWtaclZqRmtjMkZIY0ZOV01VcFpWa1phVjJNd05YTmlSbHBvVWxoU1dWbHJXbmRYVmxwWVpFYzVWMVl3Y0ZwWlZXUnZXVlpLV0ZWcmFGWmhhM0JJVlRCa1MxSXhVbkpPVm1SWFlsaGplVlp0TUhoa01VbDRZa1prYVZKdFVsbFpiWGhMVjBac1ZWTnRPVmRpUjNoV1ZXMDFhMWRHU25SbFNHeFhZa1pLU0ZsV1ZYaFdNVTV6VjJ4YWFWZEdSak5YVjNSaFV6SlNSMVp1VG1sU01GcFVWbTAxUTJJeFduSmFSRkpZWWxaYVNGZHJhRmRoYkVwMFZXNUNWbUZyY0haVWJYaGhZMnh3UlZWc2NGZGhNbmN3Vm10ak1WUXlSbGRUYms1cVUwVktXRlJWV25kVVJsSjBaVWRHVkZJeFdrbFZiVEYzVkd4YWRWRnFXbGRoYTJ0NFZrUkdjMVl4VG5WVmJGcG9aVzE0YUZadGRGWk5Wa3BIVmxob1dHSllVbGhXYlhSaFRVWndSbHBJVGxWaVJuQXdXa2h3UjFZeFdqWlJXR2hXWld0YWNsVXdXa3RYVjA1SFYyMXNWMDF0YUZwV01XUXdXVmRSZDAxSWFGaFhSMUpaV1cweFUxWkdVbGRhUms1c1ZteEdORmRyVWtOV2F6RkZVbXhvV2sxR1ducFdha3BHWlZaV1ZWRnNjRmRTV0VKSlZtcENZVk14WkZkalJXaHFVbXMxY0ZWc2FFTlhiRmw0V2tSU1ZrMVZWak5VYkZaclZtMUtjbU5HYkZwaE1taEVXWHBHWVdSSFZraFNiR2hwVWpOb1dGWnFTWGhOUm1SSFUyNUthVkpHV21GV2JGcDNUVEZaZDFkdFJrOWlSWEI0VmpKNFYxWXlTa2xSYm14WFZqTkNTRmxVUm10V01rNUdZVVpPYVZKVVZucFhWM2h2WWpBMVIxZHVTbGhpVlZwdlZGVlNWMU5XV25SbFIzUllVbTFTU1ZwVlZUVldNa3BJVld4U1YwMVdjRmhhUldSVFUxWndTR1ZIYkZOTk1VWTJWbTE0YTAxR1VYaGFTRTVZWW10d2NWVnRNVFJYUmxwMFRWYzVhbUpHY0hoVk1uUXdWakZhY21OSWJHRldWbkJ5V1ZaYVlWSnNaSE5TYkdSWFpXdEpNRlpYY0VkVGJWWlhWVzVLYUZJeWVGUlVWelZ2Wkd4YVIxWnRPVkpOVlRFMFZqSTFVMkZzU2xoVmJVWlhZbFJGTUZZd1duTmpiR1IwWkVab1UySldTa3BYYkZaaFdWWmtjMWRyV2xoaVYyaFlXV3hvYjJWc2EzbGxTR1JUVFZaS2VsbFZXazloVmtwWlVXeG9WMkpHU2t0YVJFRXhWMFpLYzFkck5WZGlWa3A0VmxkMFYxTXhXbk5YYmxKc1VsaFNXRlZ0TVRSV01WcHpZVWM1YUdKVldUSldiWGgzVjJzeFIyTklTbGRTZWtaSVdYcEdhMk14U25OYVIyeFlVbFZ3VGxac2FIZFNNVTE1Vkc1S1QxWnRVbWhWYWtwdlZrWnNkR1JGZEd0aVJuQklWMVJPYjJGVk1WWmpSbWhYVFc1b1dGWnJaRWRqTVU1MFVteGthR0V3V1RCV1IzUmhZVEpPZEZKclpGVmlWMmhQVm14b1ExWXhaRmhrUjBaV1RWZFNlbFl5ZEdGaFZUQjZVV3hhVjJKR2NETlpWVnB5WlVaa2NrOVdaRmRoTTBJMlZtcEtlazFXV1hsVGEyUm9UVEpTV0ZsWGRIWmtNVnB4VTJzMWJGSnNjREZXVjNoVFlVVXhjMU51YUZkV00wSkVWMVphYzFZeFpIVlRiR1JwVmxad2RsWlhNVFJUTVZwelZtNVNiRk5IVW05VVZWSkhWMVphV0dORlRsZGlWWEJXVlcxd1QxWXhTWHBoUjBaaFZsWndVRll4WkVkU01YQkdUbGRzYVZKWVFqSldiVEV3VlRGSmVGZHVVbGRpUjFKV1dXMTBkMk5HVm5Sa1NHUnFVbXhhZUZaSE1EVlhSMHBIWTBSQ1ZWWnNTbFJXTW5oYVpVWk9kV05HWkU1aWJFcFpWbXhTUzFNeFNuUlVhMnhWWWtad2NGWXdWWGhPUmxwSFYyMUdWMkpXV2xsV2JYUnZWVVpaZVdGR2FGVldWMmhFVkd4YVlWWldUbkZWYld4T1ZqRktTVlpxUm05a01rWkhWR3RrYWxJd1dtRldhazVUVFRGVmQxZHNaR3BXYTNBd1drVmtkMVJzV25WUmFscFhZa2RPTkZscVJsTmpNWEJHVjJ4U2FHSklRbGxYVjNSclZEQTFSMk5HYUdwTk1taFpWVzE0ZDJWc1pISlhiVVpvVmpCWk1sWnRlSGRYUmxsNllVWm9XRlp0VWt0YVZWcHJaRlpXZEdSR1VsTk5WWEEyVm0wd2QyVkZNVVpOU0doWVlrZG9UMVpzWkZOWFJsSldWV3RrV0ZKdGRETlpWV2hyVmpKR05sSnFSbGRXZWxab1ZtcEtSMk50VGtaaFJuQk9ZbTFvZVZkclZtRlRNbEpIVTI1T1lWSnRVbkJaVkVKMlRWWmFjVk5xUWxwV2JYaFlWbFpvYzFaWFNuSmpSa1pYWWxSR1ZGbFZXbGRqTVZaeldrWldUbFpzY0RaWFZsWlhWREZhZEZOclpHcFNSVXBXVm14a2IyUnNXa1ZTYTNSclVqRmFTRmxyV210V01rcFlZVVJLVjAxV2NHaFZla1pyVWpGYWRWUnRiRk5pYTBwMlZrWmtORk13TVhOWGJrcFdZVEpTWVZacVFURmxiRmw1VGxWMGFFMVZjREJXVjNodlYyMUZlRmRxVGxkTlZuQm9XVEZhVDJOV1ZuUmhSVFZYWVRGcmQxWnRjRXBOVmxGNVVtNU9WR0V4Y0ZWWmJHUnZWMFpzY2xwR1RtdGlSbkJYVmpJMVQxWXlTa2hWYm14aFVsZFNNMWxWWkZkak1XUnpZVVprVG1Kc1NtOVhWbEpIVlRKU1IxUnVWbFppVjJoVlZXcE9iMWRXWkZobFJ6bFNUVlpLU0ZadGNHRlZNa3BaVld4c1ZtSllVak5hVmxwelZteHdTRTlXV2s1aE0wSkxWbFprTkZFeFdYaFhhbHBTVjBkb1YxWnJWbmRUUmxaeFVtNWtWRlpyTlhwV01qRnZWRzFLUm1OSE9WZGlWRVl6VlZkemVGWXhjRVphUm1ocFlrVndVVlp0ZUZOak1XUkhWMjVHVW1KdFVsbFdiVFZEVmpGWmVXVkZPVmROUkVaR1ZXMTBiMVl3TVhWVldHUlhZa1p3YUZsNlNrOVRSMFpIWTBkNGFFMVlRbHBXTVZKS1pVWlZlRk51U2xCV2JWSldXV3hrYjJNeGJGVlNiR1JPVFZad01GUldhR3RWTURGeVlrUldWazFYYUhaWFZscExWMFpXZEdGR1dtbFNNVVYzVm14U1IyTXlUbk5hU0ZaaFVtMW9WRmxyVm5kWFJsbDVaRWR3VDFac1ZqUlZNalZQWVZaS1JrNVdhRlZXTTBKWVZsVmFjMWRGTVZaa1JsSlRZa1p3TkZaWE1UUmlNa1pHVFZac1VtRnJjRmhaYTFwTFZFWldObEpyY0d4V2JFcDVWbTE0WVdGV1NYaFRiR3hZWWtkUmQxWnFRWGRsUm1SeVdrWmthVlpXY0ZsWFYzaGhXVlprUjFkcmFFOVdWR3hoVm0xMGQyVldVbk5aZWxaWVlsVldOVmxWVmxOV01ERjFZVWhLVjJGcldsaFpNbmgzVTBkU1JrNVhhRTVYUlVwTFZtMHhkMUl5U1hsU1dHaGhVbGRvVkZZd2FFTldNV3h5V2tjNVdGSnRlSHBaVldNMVZHc3hXVkZzYkdGV1YxSklWakJhU21WR1pISmlSMFpUVmpGS01sWnRjRXRUTVZsNFZHNUthbEp0YUZoWmExcDNZakZrV1dORlpGaGlWa1l6VkZaYWExbFdTWHBSYkZKVlZucEdkbFl3V210WFIxWkhWR3hPVGxZeFNrbFdiVEF4VWpGVmVWTnVVbFppUmxwWVdXeG9UbVZHVWxaWGJHUnJVakZhUjFReFpHOVdNa1Y2VVZob1YxWnRVak5WZWtaYVpEQXhWMkZHV2xoU01VcFpWMVprTUdReFZYaGpSbHBZWW0xU1ZGUldhRU5UUm14V1draE9WazFFUmpCWlZWcEhWakpLVlZKWVpGZGhhMXBQV2xWa1MxSXhjRWRoUjJ4cFVsaENObFpzVWtOV2F6RlhWbXRrVjJKc1NuTlZNR1JUVkRGV2RHVkZkR3hpUm13MVdUTndWMkZHU25KalJscFdZbGhvY2xZeU1VdGtWa1p5WlVaa1RtRnJXa2hYYkZaclZERk9TRkpyWkdGU01taHZWRlJDUzFSc1duUmpSV1JhVm14c05WWkhlR3RXYlVweVRsZG9WbUZyY0haWmFrWlRWakpHUmxSdGJFNVdiWGN4VjJ4V2ExSXlSa1pOVm1SWFlXeEtWMVJYY0ZkVVJscFdWMjFHYTFKc1dqQlpWVnBoWVVkRmVVOUlaRmRpV0ZKb1dYcEtVMU5HVm5KWGJYQlRWa1phZDFaWE1ERlJiVkY0V2taV1VtSkhVbkpVVmxwTFpXeFplR0ZIZEZWaVJuQklWVEo0YzFkc1drWmpTRnBYWVRGd2FGa3hXazlqYlZKSVkwZHNWMVpHV2twV01XUXdXVmRSZUZwRlpGVmhNWEJWV1ZkNGQxZFdXblJsUjBab1VteHdlRlV5Y3pWaGF6RllWV3BHVjFZemFGQlpWbHBMWXpKT1IxWnNhRmROTW1neVZteGtlbVZHV1hoalJXeFZZa2RTY0ZWdE5VTlZWbHAwWTBWT1dsWXhXbGhXVjNoclYwZEtWbGRzV2xWV2JIQXpWV3BHVm1WVk1WaFBWbVJPWVROQ1NWZFVRbE5VTVd4WFUxaHdhRkl5YUZoWmExcDNVMFpaZUZwRlpGUlNNVXBJVmtkek1WVXlTbkpUYTNCWFlsUkdNMVY2UVRGVFJrcFpZa1pPYVZJeFNtOVdWM2hyWWpKSmVGWnVWbXBUUlRWWlZXMTRTMWRHV1hsT1YzUm9VbXR3ZWxsclVsZFdWbHB6WTBoS1YxWkZSalJXYWtaUFpGZE9SMk5IYUU1aVJXOTVWbTE0VTFNeFRYaFViR1JUWW14YWFGVnRNVzlYUm14eVZtNWtWbFpzY0ZoV1YzUXdWakF4Y2sxVVVsaGhNbWhRV1ZWYVNtVnRSa2RWYkZaWFZtNUJlbGRzV21GWlZrbDRXa2hTVTJKWVVrOVdiRkpYVTFaa1dHUkhPVlJOVjFKSlZUSjBiMVp0U2toVmJVWmFZVEZ3YUZSVVJsTldiR1IwVW14b1UwMVdjRXBYYTFaaFlURlplVk5yYkZKaGJIQlpWbXRXUzFaR1drVlNiazVYVFZkU1dsa3daRzlWTURGMFlVZG9XR0pIVVhkYVJFWlBVakZhV1ZwR1pGZFNiSEJhVmxkd1EyUXhUa2RYYTJocVpXdGFXRlZ0ZEhkV01XdDNWbXBDVjAxcmNGWlZiWEJQVm0xV2NsSllhRlpOUm5CUVZqRmtSMUl5UmtkaFJrNU9UVzFvV0ZacVJtdE5SMFYzVGxWa1dGZEhhSEJWTUZwTFkyeFZkMXBHVGxoV2JGb3dXbFZvYTJKR1duTmpSRUpWVm14YWNsWnFSa3RXVmtwelkwWmFWMDB5YUhsV2JYQkNaVWRPVjFOc2JHRlNia0pZVld4YWQyRkdaSEpWYTNSVlRWVndNRlZ0ZEd0WlZrcFZWbTVDV2xkSVFrZFVWVnBoWkVVeFdWcEdVazVXV0VGM1ZtMHdNVlF4VlhsVGJrcFlZa2RvWVZsVVNsTldSbXQzVjIxR2FtSkdjSHBaTUdRMFlWWktkVkZzYkZkTlZrcFFXV3BHV21Rd01WZFhiV3hUVW10d1dWWlhOWGRXTVdSSFYyNU9ZVkpZVWxoWmEyUlRaV3hhZEdWSFJtaFdhMncxV1ZWV1YxZEhSWGxWVkVKWVZteHdjbFZ0YzNoV2JVcElZVVpPYVZORlNsRldNVnB2WkRGWmVGUnNaR0ZTYldoeVZXNXdjMVpzVWxoa1IwWlVVbXhXTkZsVmFHdFdiVXBXWTBoc1drMUdjR2hXYWtwTFYxZEdSVlJzVmxkU1ZuQm9WMnRTUjJFeVVraFZhMmhxVWpKNFZGbHJhRUpOYkZwMFpFZDBUMUp0ZUZoV1Z6VlBWa2RGZUdOR2JGcGhNbEV3VmpGYVlXTnNXbkprUjNScFUwVktSMVpYTUhoU01rWjBVbXBhVTJKSVFsZFpiR2h2WTJ4c1ZsWllaR3hXTUZwSldWVmFhMkZXWkVaVGJFWllWak5DU0ZaVVJrcGxSbkJKVm14V2FWSXlhSFpXUmxKSFV6SldSMWRyWkZoaVZWcGhWbXBHWVdWc1pISmhSWFJhVm1zMVIxUnNXbXRXVmxsNlZXcE9ZVlpzY0ZoYVJXUlBVMFpLYzFwRk5XaE5NRXBMVm0xNFlXSXlSWGhhUldSWVltczFjVlV3YUVOWFJteFlaRWRHYW1KR2JEUlhhMVpyVmtaS2NtTkljRmRXTTJoUVdWVlZkMlF4VG5OVmJHUnBWa1ZKZWxkc1ZsWk5Wa2w1VTJ0a1lWSnNjRmxWYWtwdlYyeGtXRTFZY0U1V01HdzBWbTAxVDFZeFdrWlhiR2hYWWxob2FGUlZXbE5XTVdSeVQxZHNVMDFJUWtsWFZFSlRVVEZzVjFkc2FGWlhSMUpZVkZWa1UxUkdWbkZUYXpsVVZqQTFTRmRyWkhOWFJrcFdZMFp3VjJKVVFqTmFWVnBPWlVaU2NtRkdUbWhOYm1oV1YxZDBiMUV4WkVkVmJGWlVZbFJzVmxadE1WTldiRlY1VGxoa1ZXSkdjSHBaYTFKWFZtMUtXVlZ1U2xwV00yaE1Xa1ZhVjJOck9WZFdiR1JwVW01Qk1sWnJZM2hPUm14WVZXdGFUbFpzV2xOWmEyaERWMFpzY2xwRVRrNVdiSEI1VjFod1IxWlZNVmhsUm1oWFVqTlNhRlpFUm1Gak1rNUlVbXh3VjFKV2NGaFhiRlpoWTIxUmVGcElUbUZTTTFKVVZtdGFZVmRHV25KYVNIQlBWbXhzTlZVeWRHOWhNbFp5VjJ4c1dsWkZXbWhaTW5oWFkxWktkRkpzVG1obGExcGhWbFJLTkdJeVJsZFRXR3hvVW0xb1dGVnRNVTVsUm14eFUyeGthazFYVW5wWlZWVXhWakZrUjFOc1dsZFdla1V3VjFaa1YyTXlTa2xUYkdocFYwWktkbFpYY0VOWGF6RnpWMjVTYkZKdFVsaFVWM1JoWlZaVmVVMVhPVmhTYkhBd1ZsZDRRMVl5Um5KWGJFSmhVbXh3VkZsNlJtRmtSMHBIVkdzMVYxZEZTbE5XYlRCM1pVVTFSMVpZYUZoWFIxSlFWakJWTVZkV2JIUmtSMFpYVm0xNFdWcFZWakJoYkVwelUyeHNZVkpYVWtoV1ZFRjRWakZPYzJGR1pHbFhSMmg1Vm0xd1FtVkhUblJVYTFwcFVtNUNXRlp0TlVOTmJGcHhVMWhvVkUxVmJEUldSelZMV1ZaS2MxZHNhRmRpVkZaRVdXcEdhMVpXU25SU2JFNU9WakZLV1ZkVVFsZGlNa3BIVTI1S1QxWlViRmRVVlZwaFZFWlZkMWR0Um10U01EVkhXa1ZWTlZVeVNrWlhWRVpYVm5wRmQxZFdXbE5qTVhCR1YyczVWMkpHY0doWFZsSkxWV3N4UjFkWWFGaGlWVnB4Vm0xNFMyVnNXa2hsUnpsV1RXdHdlVlV5ZEd0V01WcEdZbnBDV2xaRldtRmFSRUY0VmpGd1NHTkdUbWxoTUhCdlZqRmFVMU14Vm5KTlZXUllZa1phVkZsc2FGTldSbEpYVmxSR1RsWnRVbmxXTWpFd1ZqQXhjMWR1YkZaTlZrcEVWbXBLUzFJeFRuSmhSbVJUVWxad2FGZHNXbUZVTWs1elkwVmthRkl5ZUZSVVZsWjNUVEZhYzFwRVVsWk5WbXcwVjJ0YWExZEhSWGxWYkd4YVlrWmFhRmt5ZUZOWFIxWklVbTE0YVZJemFGZFdhMk40VFVaa1IxTllaR3BTYkhCaFdWUkdkMlJzV25OWGJVWnFUVmRTZUZaSGVHRmhSMFY0WTBSV1dHRXhTa2hYVm1SUFZqRmFkVlJ0UmxOV1JscDJWa1pTUTFNeFpFZFhiazVhVFRKb1VGVnFRbk5PUmxsNVRsWk9WMUl3Y0VsYVZXTTFWbXN4UjFkcVRsaFdiSEF6VmpCa1UxTkdTbk5hUms1cFlUQndTVlpxU2pCV01rVjRWbGhzVTJGc2NGaFphMlJ2VjBaYWNWUnRPVlpTYkhCNFZXMHhNRlV5U2taT1dIQmFWbFp3Y2xsV1dtRlNiRTVaWTBab2FFMVZjRTFXYlhCSFV6Sk9jazVXWkZoaVZWcFVXV3hrYjJReFpGaGtSbVJyVFZkU1dGZHJXbXRXYlVWNlZXNUNWVlp0VWxSVk1GcHpZMjFHUjFSdGFHbFdiSEExVm1wS05HTXhXWGxUYkZaVFZrVktXRmxzYUc5WFJuQkdWbGhvVjJKSVFraFhhMlJ2WWtkRmVHTkhSbGROYm1oWVYxWmFjMVl4WkhWVGF6VllVbXh3ZGxaWE1UQlRNV1JIWWtab2ExSXdXbFpWYlRFelRXeFdkR042Vm1oaGVrWjVWakowYjFkSFJYbFZibkJYWVd0YVRGWnFTazlTYlU1SFdrZHNWMUpXYkRaV2JHaDNVakZTZEZaclpGWmlhelZvVlcxek1XTkdiRlZVYTA1cFRWWndXVlJWYUc5V2F6RnlUbFZvVjAxWGFISldha3BHWld4V2MyRkdaR2xYUjJkNlZrWldZVlV4V25SU2EyaFFWbTFTVkZaclZtRlhSbVJZWkVaT1YwMVdiRFJWTVdoM1ZtMUtjbU5IUmxkaVJuQXpWa1ZhZDFKc1pITmFSM0JvWlcxNFdWZFVRbXRqTVdSSFUxaHNhRkpVVmxoWmJHaERVMFprVjFkdVRsaFNiRnA1V1ZWYWEyRkZNWFJoUmxaWVZqTlNhRlY2UmxKbFJtUjFWV3MxVjFKVVZsQldWekUwWXpBMVYyTkZXbHBsYkZwWVZXeFNSMlZXV1hsa1J6bFhZWHBHZUZadGVFTlhiRmw2WVVWNFlWSlhVa2hWYWtacll6RndTR0ZGTlZkaVZHc3lWbXBLTUdFd05VZFhibEpYWVRKU2FGVXdXa3RXUm14ellVWk9WMUpzY0hsV2JURkhWMnhhZEZWc1dsWldla1YzVmtSR1MyTXhXbkZXYkZwcFYwVktiMVp0Y0V0VE1VNUlWbXRrYUZKdVFtOVVWM2hMVlVaa2MxWnRSbHBXYkhCWVZrYzFTMWxXU25KT1ZUbFhZa1pLVjFwVldtRmpNWEJGVld4d1YwMUdjRmxXVkVadll6SkdSMU51VW14U2JXaFhXV3hvYjJGR2JGWlhiWFJYVFZkU2VsWkhlRTlVYkZwMVVWaG9WMkV5VVRCWmFrcEhWakZrYzFwSGNGUlNNbWhaVmxjeE5HUXlUbk5YYkZaU1YwZG9WRlJXV25kTlZscFlUVlJTVjFKcmJEUlZNbmh6VmpGS2MxZHNVbFpoYTFwUVZXcEtTMU5XU25OV2JXeFlVbXR3V2xacldtdE5SbGwzVGxWa2FFMHlVbTlWYWtKaFYxWnNjMVp0Um14V2JHdzFXbFZrTUZkc1duTmpTSEJhVFVad1JGWXljM2hrVjBaRlZHeGFUbEl4U2xGV1YzQkhWVEpTU0ZOclpGVmlSMmhVVm14b1FtVldXblJOU0dSclRXeGFSMVJXVm10WFJtUklZVVphVjAxSFVsUldSRVpXWkRGd1NFOVdhRmRpV0dnMVZtcEplRkl4V1hoVGJsSnNVa1ZLVmxadGVIZFZSbGwzVjJ0MGFrMVZOWHBaYTJSSFZURlplRk5yYkZkaVdGSm9WMVprVG1WR1RuVlNiRnBwVWpGS1VGZFhNSGhpTVZaWFYyNVNhbEpWY0hOVmFrRXhUVVphU0dSSFJtaFNhM0F4VlZkek5WWnRTbFZXYTFKVllsaG9hRnBGWkU5U2JWSkhWV3MxVjJKclNscFdiRkpMVGtkTmVHSkdaRlJpYkZwVFdXdGtiMVl4YkhKWGJtUk9UVlpzTTFZeU1UQmhhekZZVldwQ1ZtSllhRlJXUjNoYVpVWk9jMk5HWkdoTmJFWXpWMWR3UzFJeFNYaFVibFpVWVhwc1dGbHNaRzlXTVZwMFRWUlNXbFpVUWpSV01XaHZWMGRLU1ZGdVRsWmlWRlpFVlcxNFlWZEZNVmxVYkZacFVtNUNObFpxUmxOUk1WbDVVMnRvVmxkSFVtRldhMVpoWTJ4VmQxZHJPV3BpVlZwSldWVmFVMVV4V2tkWGJHeFhUVlp3Y2xSVldrNWxWa3B5V2tab1dGSXhTbHBYVnpGNlRWWmtWMWR1UmxKV1JWcFVWRlprVTJWV1dYbGplbFpvVW14d2VWa3dVa2RXYkZsNlZXcE9WMDFIVWt4VmFrWnJaRlpPYzFac1pGZE5WWEJLVm14a2QxSXhVWGhhUm1ScVVsZFNhRlZxU205aU1YQllaVWRHYVUxV2NIbFdNbmhyVjJ4YWRHVkdiRmRpVkZaUVZqQmtTMk5zWkhOVmJIQm9UVzFvUlZkWWNFZGpNazV6V2toU1UyRjZWbFJaYkdodlYwWlplV1JHWkdoTlZuQjVWRlphWVdGc1NuVlJiR1JYWVdzMWRsVXdXbUZqVmtwMFVteE9hVkpVVlhkWFZsWmhZakZaZVZOc1pGUmlSVnBaVmpCb1ExTkdjRVZTYXpsWFRWWmFNVlpIZUc5aFZsbDZZVVpzVjFKc1NreFpha1poWXpGa2RWVnRjRk5XVkZaWlZrWmFWbVZGTlVkYVNFcG9VbFJzV1ZWcVFuZGxiRlY1WTNwV1YwMXJWalJaTUZZMFYwWmFjMk5IYUZwTlZuQk1XVEo0ZDFKck9WZFViV3hUWWtkME5GWnRkR3RPUmxweVRsWmtZVkpYVWxWV01HUlRWMFpzV0dWRmRGcFdiRXBYVmpJMWEyRXlTa2RpUkZaVlZteGFhRmxyV21Gak1XUjFZMFprVjAweWFIbFdhMlEwVXpKU1YxSnVUbGRpUjFKd1ZqQldTMU5XV1hoWGJYUldUVlZzTkZaSE5WZFdiVXBaWVVaU1ZWWjZWblpXYkZwclYwZFNTR05GT1ZkV1JVa3dWbXBHYjJNeVNrZFRibEpXWWxSc1ZsWnRlR0ZsYkZKeVYyeHdiRkl3V2tsVU1WcHZWVEF4U1ZGcVdsZFdSVzh3V1ZSR2EyTXhaSEpYYlhCVFlrVndXVmRYZUc5aU1sWnpZVE5zYkZJelVuSldiVFZEVTBaWmVXVkZPV2hXYXpWSFZURlNRMVl5U2tkVGEzaFZWbFpXTkZWcVJtRlhWbkJHVGxaa2FWWXlhRmxXTVZwclRVWk5lR0pHWkZoaWF6VlpXVzB4VTJJeFZuUmxTR1JzVW14YU1GcEZVa05XTURGRlVtNXNWV0pHV25wV2JGVjRWakpPU1ZOc1pHaGhNRmw2VjJ0U1IxUXlUblJUYTJSaFVqSjRWRmxVVGtOVWJGcDBaRVpPVTAxWFVqQldiWFJyV1ZaT1IxZHNhRnBoTVhCb1dUQmFWMk5XVG5SUFYzUk9WbTVDV2xkc1ZtRlVNVmwzVFZoT1ZHSnVRbGhVVnpWVFkyeFpkMXBGZEZkV01IQklWa2Q0VjFZeVNsZFRiRlpYWVd0S2FGWXlNVmRXYXpWWFdrWldhVll6YUZWWFZsSkxUVEF4YzFkdVRtRlNSa3BUVkZaYWQwMUdWWGxsU0U1WFlsVndNVlZYZUdGWGJGcEdWMnBPV2xaV2NHRmFSRVozVWpGd1IxVnNUazVXV0VKS1ZtcEtNRmxXVVhoVmJrNVZZVEZ3VlZsVVRrTlhSbEpYVjJ0MFUxSnRVbGhYYTFVeFlrWktkVkZyY0ZkU00yaDJXVlZWZUZkV1JuTldiR1JvWVRCd2VWZFhjRWRoTVVsNVUydGthRkl6VWxSVVZWcDNaR3hhV0UxRVJsSk5WV3cwVmpJMVQyRkdTalppUm1oVlZsWktTRll3V2xabFYwNUdWR3hvYUdWcldrcFdiR014WkRGWmVGZHJXbXBTV0doWFZGWmFkMU5HYkRaVGEyUlRUVmhDU1ZscldrOWhWMFYzWW5wR1YyRnJiM2RXVkVaS1pVWmtkVlZzWkdoTmJFcGFWMWQwYTA1SFRrZFdibEpzVWxoU2NGUldXa3RYUm14V1ZtczVhVkpyY0hwWk1GcGhWbXhhTmxKWVpGZFNSVnBNV1hwS1MxSldWbk5hUm1ST1RXMW5lVlp0ZEZOU01XeFdUbGhTVkdFeVVsbFphMXAzWTBaWmQxcEhOV3hpUm5CV1ZXMHhSMkV3TVZkalNIQmFUVVphYUZkV1drdGtSMFpIVld4d1YxSlhPVFpXUmxaaFdWZE9WMVJ1UmxKaVNFSllXV3RrTTJWc1drZFhiVGxYVFd0YVNGWkhkR0ZoYkVwMFlVZEdWMkZyTlZSVVZFWmhVbXhrYzFkdGVGTmlWa28xVmpKMGEyUXhVblJTV0hCU1lUSjRXRlJYTlZOaFJteFZVbXhPYW1GNlJsZFdNakYzVlRGa1JsTnNiRmhXTTFKeVZsUkJkMlZHV25GWGJFNXBVbFJXZVZaWE1UUmtNbFpYV2toS1dHSkhVbTlXYWtKM1UwWnJkMWRzWkZoU2JHdzJWbGMxUzFZeFdrWmpSa0pXWVd0YWNsWXhXbmRUUmtwelZHMTRhVmRIYUdGV2JUQjNaVVUxU0ZWWVpFNVdWMUp4VlcxNGQxbFdjRmhsUjBaWFRWZDRXbGt3Vm10WFJrcDBaRVJPVjJKVVFURldha0Y0VWxaS2RXRkdaR2xYUjJoVlZtcEplRkp0VmtoVWExcHNVakJhVkZadE5VTlhWbVJ5Vm0xR1ZFMXJNVFJaTUZadllWWktkR0ZHVWxwV1JXOTZWRmQ0WVdSRk1WbGFSa3BPVmpOb1dWZFhkR0ZoTVd4WFUyeG9hRkp0VW1GV2ExWjNaR3hhY2xkdVRtcGlTRUpJVmtkNFYxUnNXWHBoUm1SWFZucEZNRnBFUmxOak1XUjFWRzF3VkZORlNscFhWbEpIVXpGYVIxZHVUbGRYUjJoWlZXMTRZV1ZHVmxobFIwWm9WbXRzTlZsVlVrdFdNa1p5VTI1S1ZtVnJXbkpWTUZwTFkyeHdTR0ZHVG1saE1IQmFWbXRhVTFJeFRYbFRXR2hoVW0xU1dGbHNWbUZYUmxKWVkzcEdXRkpzY0VsVWJGWXdWMnhhY21OSWJGVmlSMDB4VjFaYVlVNXNTbFZSYkdST1ZtNUNiMWRVUm1GVU1XUllVbXRvYWxKVVZsaFphMXB5WlVaYWMxVnJjRTVXYXpFMFZqSjBiMVpIUlhsaFNFNVdZbFJHZGxkV1duTmpiSEJJVDFaT1UySklRa2hXYWtvMFZERlplVk5yYUZaaWJrSmhWRlZrVWsxR1dsVlJXR2hVVm10YWVWbHJXbXRVYlVwelUyMDVWMkpHU2toWlZFWktaVVpXZFZOc2FHbFNhM0IzVmxkd1MySXhaSE5YYmxKT1ZrWktWVlJXV21GVFJsbDVaVVprVmsxcmNIbFViRnB2VmxaWmVsUllhRlpOUm5CNlZtMTRkMUpXUm5OWGF6VlRVbFp3U2xZeFVrTlpWbXhYVjFob1dHRnNjRlJXYTFaTFlVWldjbFpyWkU5U2JGcDRWVEp6TlZVd01WaFZibkJZWVRKU2RsbFZWWGhUVmtaeFUyeGtUbFl4UlhkV2JYQkxWVzFXUjFSc2JHaFNiSEJ3V1Zod1YyUnNXbFZSYlhSV1RWZFNTRlpYZUd0V01rcHpZMFU1V21FeGNHaGFWM2hoVjBkU1JrOVdaRTVTUlZwSFZsY3hNR0l4WkhKTlZXUllWMGRTV1ZadGVIZGhSbkJHVjJ4a2FtSlZXa2hXTWpGelZqRktWMk5HV2xkaVIxSXpWV3BLVW1WR1VuSmhSbEpvVFd4S1YxZFhlR3RPUjBsNFZXeGFhRkpWY0hOV2JYaDNUVVpTVm1GSGRHbFNhMncwVlcxd1UxWnJNVmhoU0ZwWFRVZFNURmw2Ums5ak1rWkhZMFprVTFkRlNsWldiVEI0VGtkTmVWVnJhRlpoTW5ob1ZXMHhiMWRHYkhOaFJ6bFBWbXh3TUZSV1VrTlViRXB6WWtSU1YwMXFWbEJXTUdSTFpFZEdSMXBHY0dsU01taFVWMnRTUjJNeVRuTmFTRkpUWWxoQ1QxbFljRmRUVm1SWVpFZDBVMDFXYkRSV01qVlhWVzFLZEdWR2JGZGlXR2hNVlZSR2QxWnNaSE5qUjNoVFlsWkplRlpYTVRSWlYwWlhVMWhvVkdKSGVGaFZiWGhMVkVac2NWTnJjR3hTYlZJeFZsY3hkMVV4V1hoVGJscFhVbXh3VjFSV1drOVdNVnAxVlcxMFZGSlVWbGxXYlhCRFpERk9jMVpzYUU1U1JscFlWbTE0ZDAxR2JGWldiRTVZWWxWYWVWWXlNVzlYYXpGWFkwVm9ZVkpXY0V4WmVrcFBVakZ3Ums1V1pGaFNWWEJOVm0wd2VFNUhSWGROVldoVVYwZDRWRll3Wkc5V1ZteDBZM3BHYWxac1ZqTldiWFF3VjBaS2RHVkliRmhoTWsweFZsUkdTMk14V25GVWJHUk9ZV3RXTTFadGNFZFpWMDV6V2toR1VtSkdjSEJXTUdSdlpWWmFjbHBFVWxoaVZsb3dWVzEwYTJGV1NuUlZiVGxhVmtWck1GcEVSbXRXTVZaeVdrZG9UbFpVVmtsV1ZFbzBZekpHYzFOWWJHaFNiRXBoV1d0a1UyUnNXWGhYYlhSWFRWaENTbGt3VlRGV01ERldZMFJhV0ZZelVtaFhWbHByVTBaT2MxZHNhR2xoTTBKWVYxWmtNRmxYUmtkV1dHaFlZbTFTVkZscmFFTlRiR1J5V2tjNVYwMXJWalpWVm1odlZqRmFkRlZxVGxoV2JIQmhXbFphVDJNeFduTlViR1JUVmxoQ1dsWnNaREJXTVd4WFlrWmthbEp0VWxsWldIQnpZMVpzYzFadVpGUlNiRlkxV2xWa01GWnJNVmhWYTJSV1RXNW9NMVpxUVhoWFJsWlpXa1pvVjJKV1NsUlhiRnBoVlRKU1YxVnVUbGhpVjNodlZGUkNTMWxXV1hoWGJFNVZUVlZXTlZaR2FHOVdNa3B6VTJzNVYySllUWGhXUkVaaFpFZFdTVnBHVWxkaWEwcFlWakowVjJFeVJrZFRiazVxVTBkNFlWbFVSa3RoUmxsNVpVZEdWMDFyTlVwVk1uaHJWR3hLZFZGdGFGaGlSMUV3Vm1wS1RtVldTbkpoUms1cFVsUldWVlp0TURGUk1EVlhWMjVPWVZOSFVsUlVWM1JYVGxaYVdHVkhkRmRpVlhCNVZHeGpOVlp0Um5KaWVrSmFUVVp3YUZwRlpGTlRWbkJIV2tkc1UySnJTVEpXYWtaVFZESkplRlZZYUZSWFIyaFVXVmQ0WVZkR2JITmhSemxxWWtac00xWXlNVEJXUmtsNFYydHdWbUpVUmtoV2FrRjNaVmRHU0U5V1pHbFdSVlYzVm14U1IxZHRWa2RhU0ZaWFlsVmFWRlJVU205a01WcFlUVWhvVGsxRVJsaFhhMmhMVmpKS1dWRnNRbGRpV0doNlZHeGFWbVZYVmtoU2JXaHBVbGhCZUZaV1kzaFNNVmw1VTJ0b1ZtSkdTbWhWYWs1dllVWnJlRmRyZEd0U2EzQjZWa2N4YzFZeFdrZFhhMnhYWVd0dmQxbFVSa3BsUm1SWllVWm9hV0pHY0ZSWFYzUlhXVlprVjFkdVNsZGliVkpRV1d0YVMxZEdXWGxsU0dScFVtdHdNVlZYZEhkV01WbzJVbTV3VjFaRmNFaFViWGhoWkZad1IxcEdaRk5XV0VKYVZteG9kMUZ0VmtoVVdHaGhVMFphVjFsc2FHOVdSbEpXVjI1a1dGSnNjRWhXTW5ocllXc3hSVlpyYUZkTlYyaDJXVlZhUzA1dFNrZGlSbHBwVmtWYVZWWlVSbUZqTVZwelkwVm9VRlp0VW05YVYzUmhVMVprVlZGdGRHbE5WbXcxVlRKMGEyRnNUa2xSYlVaaFZqTlNNMVV3V2xka1IxWkhWRzF3VGxadVFqVldSM2hoWVRKR1dGSllaR2hOTWxKWVdXeFNSbVF4YkZWUlZFWlRUVlpLV2xscldsTmhSVEYwWVVaYVdGWnNTa3hXVkVwUFZqRmFkVlZyTlZkU2EzQlpWMWQwWVdRd01VZGpSbHBYWVd0S1YxUldWbmRsYkd0M1lVaE9WMDFyY0VsWlZXaGhWakpHY2xKcVVsZGhhM0JRVlRGa1IxSXhjRWRhUlRWT1lsZG5NVlpxUm1GWlZteFhWRzVTVjJKSFVuQlVWRTVEWTFaV2RFMVhPVmhTYlhoNVZqSTFhMkZWTVZkalJuQmFUVVphY2xZeWVGcGtNRFZaWWtaV2FWSnVRbmxXTVZwaFUyMVJlRnBJVGxaaVNFSndWVzAxUTFSV1pISlZhMlJhVmpBMVdGVnROVk5oTVVsNVpVVTVXbFpGYjNwVVZWcGhZMVpPY1ZWc1pFNVdiRzkzVmxSS05GbFdaRWhUYTJob1VteHdXRmxYY3pGa2JGcEdWMnhhYkZKdFVqQlZiWGh2VlRBeFZtTkZiRmROYmxKb1dWUktSMVl4WkhOaVJrcG9UVzFvV1ZaWGNFOWlNbEp6Vm14V1UySlZXbkpWYlhNeFpWWnNWbHBIT1ZaTlZuQjVXVEJhYTFkR1dYcFZiV2hoVWtWd1NGVnFSbXRrVmxKellVZG9iR0pZYURSV2JUQjRUa1pzV0ZadVRsaGlSMmh4V2xkMFlWZEdVbGhrU0dSWVlrZFNWbFpITVRCV01ERnlZMFp3VmxZelVUQldiR1JHWlVkT1NGSnRSbGRXYmtKdlZtcEdhMU14U1hoVmJsSnBVakpvYzFsclduWk5SbHAwWlVkd2EwMXNXa2xWTVdodldWWktXRlZ1UWxaTlJsVjRXV3BHVjJSWFRrbFViRlpPVm10d1dWWnFTVEZVTVZKeVRWWmthVkpHV21oV2JHUlNaREZzVmxwRmRGTk5helZLV1d0YWQxUnNTWGxoUkZwWFlXdEtjbFZ0TVZkV01WcDFVbXhXYVZJeFNsVldSbEpMWWpKSmVGZHVSbE5pVlZwVVZGZHpNVmRHV25ST1ZUbGFWbXRzTlZwVldtOVdiVXBIVjI1c1lWSkZXbWhaTW5oM1VsWkdjMk5HWkdsVFJVWXpWbTB3ZUUxSFJYaGlSbVJWWVRGd1VGWXdWa3RXTVd4ellVWk9UazFYZEROV01uaHJZVEZKZUZOcmNGaGhNWEIyVm1wS1MxWXhUbk5qUm1ocFVteHdlRlpIZUd0U01WcHlUVlpzVkdKSGFHOVVWekZ2VjJ4a1YxVnJaR3ROYXpWNlYydGFhMWRIUlhwVmJrcFdZbGhvYUZSV1dsZGtSMVpIV2taa1RtRXpRa3RXVmxwdlpERmtTRk5yYUZaV1JVcGhXbGQwZDFWR2JEWlRhemxUWWxWd1NGWnRNWE5WTWtweVUyeEdWMkpVUlRCWmFrWkdaREExVjFwSFJsTmlSbkJVVjFkNFYxbFdXWGhWYkdSaFVtczFWVlZ0ZUhOT1JteFdZVWQwVjAxcmNGZFpNRlp6VjJ4YVYyTkljRmRoYTNCTVZqRmtSMUpXVW5OaFJtUnBVMFZHTmxadE1IaE9SMFY1Vld0a1ZHSnNTbkpWYlRGVFkwWldkRTFFVms1TlZtdzFXa1ZhYTFkc1duTlNhbEpYVm5wV1VGWnJaRXRqTVdSelZHeHdhRTFzUlhkV2FrSmhZekpPYzJORlpGVmhlbFpQVm0xNGQwNUdXbGhOUkVaVlRWWnNOVlZ0Y0dGVk1rcElZVVpzV2xaRldqTmFSM2h6VmpGa2NtTkhlRmROUm5CTFYxWldZV0l5UmxkVFdHaFRWMGRTV0ZSV1duZGhSbXhWVW10d2JGWnJOWGxaYTFwVFlWWkplV0ZJWkZoV00yaG9WWHBLVjJNeGNFZGhSM1JUVFVad2VGWkdWbE5XTVdSSFlUTmtWMkpWV2xsWmJGcGhaV3haZVdWSE9WZFdiR3cyVmxjeFIxWldXWHBoUm1oaFVsZFNVRlZ0ZUhkU01YQkdUbFprYVdFd2EzbFdiWGhUVXpBeFIxWllhRmhYUjNoVldXdGFZVlpHYkZWVWJUbFlVbXhLV0ZkcldrOVdSa3B6VjJwQ1ZWWnNjSEpXVkVGNFkyczFWbHBHVm1sU01VbzJWMVphWVZkdFZsaFNhMlJWWWtkU2IxbFVSbmROYkdSeVZXdGtWR0pXV2toV2JYaHpZVlpLYzFkc2JGWmhhM0IyV2xWYVlWZEhWa2hrUmxwT1lURndTVlp0TURGVk1rWjBWbTVLV0dKR2NGWldiVEZTVFVad1dHVkhkR3BpUm5CV1ZtMTRWMVJzV25WUmFscFlWa1ZLVkZWVVJtRldNV1J6WVVkb1ZGSllRbWhYVmxKSFpERlNSMWR1VGxoaVZWcHhXV3hXWVZOR1pISldWRVpYVFVSR01GZHFUbk5XTWtwVlVsaGtXRlp0VWtkYVZWcFRZMjFHUjFSdGFFNWlSWEJaVmpGa01HSXhSWGxVYTJSWVYwZFNXRll3Wkc5VlJsWjBaVWhrVGxKdVFsZFhhMVpyWVVkR05sSnNiRmRXTTFKNlZtcEtTMWRXVm5WWGJHUlhVbGhDVFZacVJtRlNNazV5VDFaa1lWSXllRmxWYWtwclRteGFjbGt6YUU5U2JYaFpWbGQwWVZSc1dsZFhiRkphWWtkU2RsWkVSbUZrUlRWV1ZHczVWMkpJUWtsV2FrbDRVakpHUmsxWVNsaGlia0pZVldwT1UyVnNXbGhOVlhSVVVqQmFTVlZ0ZUhkaFJURlpVV3N4VjFaRlNtaFdiVEZTWlVad1NWVnNUbWxYUlVwUVZtMHdNVkV4YkZkYVJtUlhZbFZhYjFSV1drdGxiRmw1WlVaa1YwMXJXbnBXTW5odlZsWmFObFpzVWxwV1ZuQjZWbXhhVDJOc2NFZGFSVFZYVmtaV05GWnNVa3BsUjFGNFZsaHNWR0pIZUc5VmJURTBWMVphY1ZSc1RtcGlSbkJHVlZaU1IxVXdNVmRqU0doWFRXNW9VRmxWVlhkbFJrNTFZVVprVTJKSVFqSldWbEpIVkRKTmVGcElTbWhTVkZaWVZtcEdTMWRHV2tkYVJFSnJUVmRTU0Zac2FITmlSa3AwVld4c1ZtSllhSHBVYlhoelZtMUdSbVJHYUdsV1ZuQTFWbXBLTkdJeFdYbFNia3BZWW10d2FGVnRlSGRXUm5CR1YydDBhazFXU25wV1J6RnZWR3N4Um1ORVNsZGlWRUl6V2tSS1YxSnJOVlpoUmxwWVVqTm9XVmRYTVhwTlYwWkhWbGhrVjJKdFVuQlVWbHBoWld4c1ZsZHJPVmhTYTNCNldUQm9iMVpzV2paV2JrcFhZVEZ3YUZsNlNrOVNNa3BJVW14a1YySnJTbEpXYlhCRFlURk5lRlJyWkZkaWEzQnhWVzE0ZDFkR1VsVlRiVGxXVm14c05GWXlNVWRXUlRGV1kwaHdXR0V5YUZSWlZWcExaRlpHZFZSc2NGZFNWbTk2VjFkd1IyRXlUbk5YYmxKVFlrWktUMWxZY0VaTlJscHpXWHBHVkUxV1JqUldNalZUVm0xS2NsTnRSbGRoTVZwTVdsWmFkMVl4WkhSU2JYUlRUVlp3U1ZaclpEUlZNa1pJVm01S1dHSkhlRmhaVkVaM1pHeHNjVkp0ZEZSU2F6VXhWa2Q0VTJGV1NuSmpSMmhYWWxoQ1VGbHFRWGRsUm1SMVUyeG9hV0Y2Vm5oWFYzUnJWVEpXVjJORldsaGlWR3hYVkZkMGQxZHNiRlpWYkdSWFRXdGFlVmxVVG05WGJGcEdWMnhTV2sxdVRqUldha1ozVWpKR1NHSkhiRmhTTW1oaFZtMTBZV0V5VVhoVFdHaFZZVEpTV1ZsdGRHRlZNVmwzV2tjNVdGWnNXakJhVldSSFlrWktjMWRzYkZWV2JGcHlWbTF6ZUZZeVRrVlNiRnBYVFRKb1NWWnFRbUZaVjAxNVZHdG9hRkp0YUZoWmEyaERZakZhZEdORlpGVk5hekUwVmpJMVQxWkhTbGhsUmxKVlZucEdkbFl5ZUdGak1YQkZWV3hrVG1KRldURldWRVp2WWpGa1IxcEZhR2hTYlhoaFdXdGFZV0ZHV1hkWGJrNXFUVmRTTUZWdGVHOVZNa3BIVjFSR1dHSkdXblpXUkVacll6RmtkVk50YkZOU2JrSllWbTF3VDJJeFdrZFhXR3hPVmxad2MxVnRNVk5sUmxwSVpVZDBWV0pHY0RGVlZ6QTFWMGRGZUZkdVNsZFdSVnBMV2xWYWQxTldUbkpQVm1ScFZtdHdVVlp0TVRSaU1VWnlUVmhPV0dKc1NrOVZNR1J2VlVaV2RHVklUazlTYkhCNldWVm9UMVl4U1hkV2FsWmFWbFp3Y2xZeU1VWmxWbFoxVjJ4a2FWZEhhRzlYYTFaclZqRk9WMk5GV2s5V1ZGWlpWV3hXZDFkc1duUmpSWEJzVWxSR1NWVnROVk5XUjBWNVlVWmtXbUpVUlRCV2JYaFRWakZ3UjFSdGRHbFNia0pYVmxjd2VGSXhWWGxUYTFwUFZteHdWMWxzYUc5a2JGcHhVMnQwVTAxck5VaFphMXB2VmpBd2QxTnJiRmRoYTJ3MFZtcEdTbVZIVGtaaVJrNXBVakpvZDFaWGVGTldNV1J6VjJ4b2FsSlhVbFZVVm1SVFUwWmtjbUZGT1ZwV2EzQkhWVEl4UjFZeVNsVlNiRkpXVFVad2Vsa3llRmRrUmtwelYyczFhRTB3U21oV2JYaHFUVlpKZUZkc1pGaGliRXBYV1d0YVMyRkdXblJsU0dSWFVtMTNNbFZ0TVRCaE1VcFZZa1pvV0dFeGNGQlpWVlYzWkRGT2MySkdaRTVXYTNCRlZqRmFhMVJ0VmtkYVJteHBVbXhLY0ZWdGVIZFdSbVJYV2tSU1ZFMVdjSHBaYTFwWFZUSktkRlZ1VGxwaE1YQXpXbFZhVjJSSFZrWlBWMmhwVmxoQ1MxWldaREJpTVdSSVVsaHNWbUp1UWxoV2ExWkhUa1p3UmxwRlpGTldiVko2VjJ0a2MxVXdNVlpXYWs1WFRWWndWRlZxUm1Ga1JscHlXa1pvYVdFelFtOVdWekI0WWpKT1IySkdWbE5pYlZKWVZtMHhVMWRXY0ZaWGJYUllZa1p3ZWxrd1ZtOVdNVmw2WVVoS1YwMUhVa3hWTUZwWFl6RkdjMXBIYkZkU2JIQkdWbTB4ZDFJeGJGaFZhMmhWWVRGd1ZsbHJaRk5VTVZaeVZtMUdVMDFXY0ZsVVZsSlRZVlV4V0ZWdWJGVldiRnAyV1ZWYVMxSnJOVmRoUm5CWFRURktTVlpIZEdGWGJWRjRZMFZhWVZKc1NsaFVWVkpYVTFaWmVXUkhkR2xOYTFwSFZGWmFjMVZ0U25OalJtaFZWbnBXVkZZd1duTldWa3B5WTBkNFUyRjZWalpXTW5SaFdWZEdXRk5yV21wU2JGcFpWbXBPVTJOc1dsVlNiRXBzVW14YWVsWXllR0ZoUlRGWlVXNXdXRll6VW1oWmVrRXhWakpPUjFkc2FHbFhSa3BhVjFkMFlXUXlWbk5pU0VwV1lrZFNXRlJXVm5kTlJteFdZVWRHV0ZKc2NIcFpNRnBEVm0xS1dWUllhRmRoYTFweVdYcEtUMU5IU2tkVWF6VlhWbnByTVZadE1IaE5SbFY0VTFob1dHSnNTbGRXTUdSdlYxWnNkR1JJWkdwaVJsb3dWRlphVDFaVk1WZGpSRUpWWWtaYVRGbFVRWGhYUmxaMVkwWmthVlpGV2tsV2JYaFdaVVpaZVZSclpHRlNiRnBZV1d4a2IxUldaRmRYYlVaVVRWVnNORlpITlU5WlZrcDFVVzA1VlZZemFFeFVWM2hyWTJ4d1JWVnNjRmROUkZaWlZtdGpNVk15UlhoVGJrNVVZa1pLWVZsVVJuZE5NVkowWlVkMFYwMVdjREJWYlRFd1ZHeGFkR1I2UWxkV1JXOHdXWHBHVjJSR1RuSmFSbWhwVWpKb2FGZFhkR3RpTVVwSFZsaGtXR0pWV25GV2JYTXhaVlpTYzFwRVVsZE5hMVkyVlZkd1YxZEdXbk5YYldoV1ZrVmFZVnBXV2s5amJHUjBZMFpPYVZKdVFtRldiVEYzVkRGVmVWSnJaR3BTVjJoUFZtMTBkMk14Vm5ST1ZVNVVZa1pXTlZwVlpEQmhSbHB5WWtSU1ZrMXVhRVJXYWtaaFRteEtWVkZ0UmxOU1ZWa3dWbGR3UjFsV1pGaFRhMmhyVW1zMVQxUldWbmROYkZsNFdrUkNWMDFzUmpOVVZsWnJWMGRLU0dGSVRsWmhhMHBvVmpCYVUxZEhVa2xhUm1ScFVteHZkMVpIZUd0U01WbDRWMjVPYWxKWFVsaFVWM0JIWkd4a1YxZHJkRmhTYkZwNldWVmFZVlJzU25WUmF6RllZVEZhY2xaRVJrdGphelZYV2tkR1UxWkdXbGxXYlRWM1lqQTFSMWR1VW1wU1YxSmhWbTE0YzA1R2JISlhiWFJvVm10d01GWlhlSE5XTURGSVZXeFNWMUpGV2xkYVJFWjNVbFpXZEdKRk5WZGlSemt6VmpKNFYyRXhTWGhhUldSVVlteEtjMVV3YUVOWlZscHpWMjVrVmxKdGVGbFVWbFl3VlRBeGNrNVZjRnBXVm5Cb1dWWmFhMUl4VGxsalJtaFhUVEZLYjFZeFdtdFVNbEpIVlc1S2FWSXllRlJaYkdSdlpHeGFSMWR0T1ZKTlZuQllWMnRhYTFkSFNsWlhiRlphWWtad2FGVXdXbUZUUlRWV1QxZG9WMkV6UVhkV2JHTXhVVEZaZVZKWWFGaGhNbWhXV1ZSR2QyRkdXbkZTYkdScVlraENTRll5TVhOV01rcEpVV3R3VjJGcmIzZFpha1phWlVaa2NtRkdVbWhOYldoWVYxY3hNRk14V1hoaVJtaHJVakJhVmxWdGVITk9SbGw1VFZWa1ZrMUVSbGxXVnpWM1YwZEZlVlZxVGxkU00yaE1WV3BHYTJOdFNrZGFSMnhYVWxWWk1GWnRlRk5TTVZaMFZtdGtZVk5GTlZoWmJHUTBWa1pzYzFkcmRGZE5WbkF3V1RCVk5WWnJNVVZSYWxKWFlrZG9jbFl3WkV0amJVNUpVMnhXVjJKV1NsVldSbFpoVmpKU1NGWnJhR3RTYkZwd1ZXeG9RMU5HV25GVGFrSnFUVlpzTlZVeWVITmhSazVIWTBkR1dsWXpVbWhYVmxwM1ZqRmtjbVJHYUZkTlJuQktWMVJDWVZReVJsZFRiR3hTWWtoQ1dGUldaRkpOUm14eFUydHdiRlpyY0hsWGEyUjNWVEZhZFZGc2NGaFdiRXBRVmxSS1QxWXhWbk5hUm1SWFVsWndlbFp0TVRSVE1sWnpWMWhzVGxaRlNtOVZiWGgzWlZaU2MxWnRkRmRpVlhCSldWVm9kMVl5Um5KalJYaFhZa1p3VEZZeFduZFNNazVIV2taT1dGSlZjRlpXYWtvMFZqRnNWMkpHWkdGU2JXaFVXVlJLVTJGR1ZuRlRhbEpxVW14YWVsbFZWazlXTURGWFlrUlNWMDF1YUZCV1ZFRjRZekZLY1ZWc2FHaE5XRUo1VjFaYVlWUXhTblJVYTJob1VteHdjRll3VlhoT1JscHhVbTFHVjAxc1NrbFdiWFJ2VlRKS1dXRkdVbHBoTW1oRVZUSjRhMk5zV25OWGF6bFhZa2QzZWxaR1dtRlpWMFp6Vkd0c1VtSlZXbFpXYkZwM1RURndXR1ZIUm1wTlYxSXdWVzB4ZDFSc1dYaFRXR2hYVmtWdk1GcEVSbHBsUms1eldrZHdVMlZ0ZUZwV2FrSnZVVEZPUjJKR1ZsUmlSVFZaVlcxNFMyVldaSEphU0dSV1RVUkdNRmxWV2tOV01rWnlVMnhvVm1WcmNGUlpla1pyWkZaV2NrNVdhRk5OVlhCWFZtdGFZVlp0VmtaT1ZXUlhWMGRvYjFVd1ZURlhSbHB4VVd4a1QxSnRkRE5aVlZaUFZqSktWbU5HV2xaaVdHaFVWakp6ZUZJeVRrZGhSMFpUVmpGS1dWWlVSbUZrTVVsNVVtdGtZVkl5ZUZWVmJGWjNWRVphY1ZOcVFsZE5hMVkwVlRGb2IxZEhSWGhqUlRsWFRVWmFNMVpFUm1GamJHUnlaRVpvVTJKR2IzaFhWRUpoWVRGa1IxTnVUbXBUUjNoWldWUkdXbVF4V2xWUldHaFhZWHBXVmxWdGVHRldNREI1WVVjNVdGWnNjR2hWTWpGWFYwWktjbGRzWkdsU01VcDJWMVpTUjJReVNYaFhXR2hZWWxWYVZWbHNXbUZUVmxwSVpFZEdWMDFyY0VoWk1HaERWbTFLV1ZWcVRsZFdWbkJvV2tWa1YxTkZPVmRUYXpWWFRWVndXbFp0Y0VwTlZrbDRWMnRvVTJKcmNGVlpiRlpoVjBac2MyRkhPV3hpUmtwNlZqSjRZV0pHV1hoVGEyeFZUVlp3Y2xsV1dtRlhWa1p5WWtaa1YxSlhPSGRXTVZwaFYyMVdWMVJ1VG1sU01taFVWRmN4YjJGR1duUmxSMFpyVFVSQ05GWXhhR3RaVmtwMFZXeFNWVlp0YUVSVk1WcDNVbXhrY2s5V1ZtbFNia0Y0Vmxaa01FMUdXWGxUYTJoVllXeEtWbGxVU2xOU01YQldWMjEwV0ZZd2NFaFdWekZ6VlRBeFZtTkdaRmROVm5CVVZYcEtTbVZHY0VaYVJtUnBZVEZ3VjFkWGVGTmpNa2w0Vm01U2JGTkhVbFJaYTFwaFRVWndWbUZIZEdoV2EzQjZXVEJvYzFaWFNraGhTSEJYVFVkU1IxcFZaRTlUVm1SelkwWmthVk5GU205V01uaGhZVEZKZUZOWWJGTmhNbEp2VlcweFUxUXhVbGRXYm1ScllrWnNOVnBGV2s5Vk1ERllaVVpvVmsxWGFIcFdhMlJHWlVaa2MySkdjR2hOVmxZMFYxUkNZVmxYVFhoYVNGWmhVak5vVkZsc1drdFhiR1J6Vm0xR1dsWnNTbnBXTWpWTFZERmFkR0ZIUmxkaE1WVjRXVEo0WVdOV1NuUlNiRTVwVWpGS05sZFdWbUZXTVZsNVUydHNVbGRJUWxoVmJYaDNZVVphY1ZKdGRGUlNiSEI1V1d0YVYyRldTWGhUYkVKWVZteEtVRlZVUms5ak1XUjFVMjFHVkZJeFNsaFdSbHBoWkRGa1IxZFliR3hTTTFKdldXdFdkMVpzYkhKYVJ6bFhUV3R3U0Zrd1VrOVhiRnBYWTBkR1lWWldjRE5WYlRGVFVqRlNjazVXYUZOV1dFSk1WbXBHYTAxR2JGZFZXR2hXWW10d1QxWXdXa3RoUmxKVlUycFNXRkp0ZUhwWlZXTTFZVzFLUjFOdWJGZE5ha1pJV1ZjeFIwNXNTbk5oUm1ob1RWaENNbFpxUW1GVGJWWllVbXRrYWxKdGFGaGFWM1JXWkRGYVdXTkZkRlZpVmxwSVZqSTFWMVV5U2taalNFSlhZa1p3TTFZeWVHRmtSVEZWVld4d1YxWkZXa2xYVkVKaFdWWnNWMU5zYUZaaWEwcFhXVmQwUzAweFZYZFhia3ByVFd0YVNsZHJXbXRVYkZwMFpIcEtXRlpzV25aVmVrWmFaVlpPY2xwR1pHaGlSWEJvVmtaa2QxSXhWa2RXYmtaVFltMVNWRlJXV25kTlJteFdWbFJHVjAxWFVrZFZNbk0xVmpKS1ZWSnFUbFpXUlhCSFdsVmFUMlJXVm5OYVIyaE9ZbGRvV0ZZeFdsTlRNa2w1VTFob1YySnNTazlXYlhNeFYwWldkR1ZGZEZkaVJsWTFWRlZTVjFZeFduTmpTSEJhVFVaS1JGWXljM2hTTVdSWldrWmthVkpzV1RCV2JUQjRWREZPV0ZSclpHRlNNbmhZVlcxNGQxVnNXbkZTYlVaYVZtczFNRlp0ZUc5Vk1rVjRZMFpHVjJKVVZrUlpNRnBYWTFaS2NtUkZOVmRpU0VKSlZqSjBVMVV4WkhOWFdHUlBWMGhDWVZSVldtRlhSbHBZVFZWMFZGWnJXbnBaVlZwM1ZqRktXRTlVV2xkU2JIQm9WMVprVDJNeGNFbFZiRUpYVFc1b1VGWnRNREZSTVU1elYyeFdWRlpGV2xWVVZscEhUa1paZVU1V1RtbFNhMnd6VmpJeFIxWXlSWGhYYldoWFlXdGFNMVp0ZUd0a1ZrNTBaRVUxVjAxVmJ6Sldha293WVRKUmVGVnVUbGhpYkZwVFZqQmtiMWRHVWxoT1ZrNW9VbXh3ZUZWdGVFOWhhekZZVldwR1YySllhRXhaVmxwUFVteE9jMkpHWkZkbGExVjNWMnRTUjFsV1NYaFhiazVYWWtVMWNGWXdXa3RsUmxwSFYyMTBWazFFUmxoV2JHaHpZa1pKZWxWdE9WWmhhMG96VldwR2NtUXhaSFZVYkdoVFlrZDNNbGRXVm05WlZtUjBVbTVLYWxKclNtRmFWM1JoWTJ4d1IxZHJkR3BOVmxvd1dWVlZNV0ZXU2xsUmJFNVhZV3RhY2xSVlduTlhSbFpaV2tVMVYySldTbGxYVnpFMFV6Sk5lRlp1VWs1V2F6VlpWVzE0UzFkV2NFWmhSM1JYVW10d01GcEZVazlYUm1SSlVXeG9WMkZyUmpSWk1qRlBVakpPUjFkc1pFNU5WVzk1Vm0weGQxTXhTWGxVYmxKVllUSlNWMWxyV25kVU1WWjBUbFZPV0ZadFVsWlZNbkJUWVVVeGMxTnJiRmRXTTFKeVZteGtTMWRIVmtkV2JGcHBVbXh2ZWxac1pEUlpWMDVYVTI1U2ExSlVWbFJaYkdodlYyeGFjMWR0T1dsTmExcFlWVEkxVTFadFNsaGhSbVJhWWtaS1NGWnJXbHBrTVdSMVZHMXdUbFpzYjNoV2EyUTBZVEZWZVZOcldtcFNiWGhZV1ZkMGNtVkdiRlZUYTNSVVVtczFlVmRyWkhOVk1VcHpZMFprV0ZZelVtaFdiWE40VmpGa1dWcEdhR2hOTUVwNVZrWmFZV1F5VmtkWGJsSnNVMGRTV0ZSV1duZE5WbFpZWTBWMFYwMXJjRnBaVldSdlYwWmFjMk5IUm1GV2JIQlVXVEl4UjFJeFVuUmlSazVwVTBWS1lWWnRNSGRrTURGWFVsaG9ZVkp0VW1oVk1GWjNWMFpzYzJGR1RsaFNiRXBZVm0wMWExUnNTbk5qUm14aFVsZE5NVmxWWkV0U2JVcEZWbTFHVjFadVFsVldiWEJMVW0xV1NGUnJhRk5pUmxwWVZGUktiMkl4WkZsalJXUlhUV3MxTUZaWGRHRlZSbHB5VGxVNVZtSllhSGxhUkVaaFpFZE9SbHBIYkU1aE1uY3dWbXBLTUdFeGJGZFRiR2hvVTBVMVYxbFhkSGRrYkd4V1YyMUdhbFpzU25wV1IzTXhWR3hhZEdRemNGZGhhMnQ0VmtSS1IyTnJNVmxUYkdob1RXNW9WMVpHV21Ga01rNXpWMnhXVkdFelVsUlVWM014VTBaa2NsZHRkRmROYkZwNVZtMXdUMWRIUlhoVGEzaFdaV3RhUzFwVldsTmtWbHB6Vlcxc1dGSlZjRlpXYkdRMFdWZFJlRnBHWkZoaVIyaHhWV3hTYzJOR1VsZFhibVJVVW0xNGVWWXlNVEJYUmtsM1ZtcGFWMVo2VmtoV01qRkxVakZhV1dGR1drNWliV2cxVjJ0U1IyRXlVa2hWYTJSaFVsUldWRlZzVm5KbFJsbDRWMnhrV2xZd01UUlhhMVp2VlRGa1NHRkdWbHBXUlhCMlZqQmFjMk14Vm5KYVJtaFRZa1p3TkZaWE1ERmhNVnBIVjI1T2FsTklRbGhaYkZKSFpXeGFWVkZZYUZkaVZUVklXVEJhYTJGV1NYaFNXR1JYVFZad2NsWlhNVmRTTVdSMVUyMUdVMkpYYUhaV1JtUTBVekZrYzFwR2FHeFNiVkpoVm0weE5GZEdXWGxPVms1VllrWndlVlJzYUU5WGJVVjVWVlJDVjJKWWFHaFZNRlY0VmxaR2MxcEZOV2hOTUVwWlZtMHdlR1F4VVhoWGJHaFVZVEpTY1ZVd2FFTlhSbXh6Vld0a1ZWSnNiRFJXTW5ocllXeGFjMU5xUWxaaVdHaHlXVlphVDFKc1RuUlBWbVJPWW0xb2IxZFdVa2RYYlZaSFZXNUthRkpzY0c5VVYzaExZakZhV0dORmRFOVNiVkpJVmpGb2ExWXlSWHBWYlRsV1lsaG9lbFJyV2xwbFYxWklaRVprVGxKRldsbFdiVEYzVlRGWmQwMVdhR2hUUm5CWVdWUktVMVJHYTNsamVrWllWbXR3ZWxZeU1YTlZNREYwV2pOc1YySllRa1JYVm1ST1pWWlNXV0pHVG1oTmJXaFNWbTF3VDFFeVRrZFdia1pWWWtWd1QxWnRNVk5sYkZwMFRWVmtWMVpVUm5sV01qVnpWbFphYzJOSVdsZGlWRVpNV2taYVIyTXlTa2RqUm1SVFYwVktWbFl5ZUd0T1JteFhWMnhrVldKcmNISlZiWE14VkRGYWNWSnJkRnBXYlZKV1ZWY3hSMkZGTVhKWGEyeFdZa2RvZGxsWGVFdFNiVTVIWWtad1YxSldjRTFXVkVKaFZtMVdWazFXWkdGU2F6VlBWakJXUzFOV1pGaGtSM1JwVFZaV05WVXllRzloUms1SVZXeHNWMkpVUm5aVVZFWmhZMVpLZEZKdGNFNVhSVXBKVjFaV1ZrMVdXWGhUYkZwcVUwZDRXRlZ0ZUhkaFJuQkZVbTEwVTAxcmNFcFZNakZ2VlRGa1IxTnNiRmRTYlZGM1drUkJlRkl4WkhOaFJUbFhWakZLV1ZadE1UUmtNbFp6WVROa2FGTkhVbGhXYlhoM1VqRlplVTVWZEZoaGVrWXhXVlZvZDFaWFNsbGhSMmhhWld0YWNsa3ljekZXTVhCSFlVWk9WMVl6VVRGV2JURjNVakZWZUZKWWFHbFNiV2hWVmpCa2IxZFdXWGRhUms1VlRWWnNNMVl5TVVkaFZURlhWbXBPVjJKVVZuSldNRnBMWXpKT1NXSkdaR2xYUmtwNVZtdFNSMU15VFhsVWExWlNZa2hDVDFSVVFrdFRWbHB4VVcxR1dHSldSalZXUjNSaFlWWktjMk5JUWxkTlIxSjJXbFphWVdSSFRrWmtSbEpPVmxSV1dWWlhNREZXTVdSSVUydG9WbUpyU2xoVVZXUlRaR3haZUZkc2NHeFNiVkl3VlcweGQxUnNXblJrZWtKWFRXNVNkbFpxUm1Ga1JrNXlXa1pvYVZaSGVGZFdiWEJQWWpGU1IxZHVSbE5pV0ZKWlZXcEdTMU5XY0VaWGJVWlZZbFZaTWxadGRITldNa3BWVVZob1ZtRnJXbGRhVmxwTFYxZE9SMWR0YkZOTlZYQmFWakZrTkZVeFNYaFhhMlJxVW0xb2MxVnFUbE5qVm14eVYyMUdiR0pHY0VsYVZXUXdWbGRLUm1ORlpGZE5ibWg2VmpCYVdtVnNWbk5WYkdSWFVsWndhRmRyVWtKbFJtUlhVMjVPWVZJeWFFOVVWekZ2V1ZaYWRFMUlhRTlTTVVZMFZsZDBhMkZGTUhsbFJUbFhZa1pLZWxac1dtRmtSMUpJVW0xNGFWSnRkekZXUmxwdlZERmFjazFZU2xkaGJIQlhWbXBPYjAweFduRlRhM1JYVm10YWVGWlhlRmRoUlRGelUydG9XR0pHY0doV1ZFWnJWMFpLY2xwSGFGTk5ibWgzVmxkNGIxRXhXbk5YV0doaFVrVktXRlJYZUVkT1JscFhZVWM1V0ZJd2NIcFZNalZQVm1zeFNGVnNVbGRXVm5CNldUSjRhMlJXY0VobFJrNXBVbXhyZUZZeFVrTlpWbEY0V2tWb1ZHRXlVbkZWYTFaTFYwWmFjVlJzVG14aVJuQXdWRlpXTUZaR1NYZFhhM0JhVFVad00xbFZWWGhYVmtaeVRWWm9XRk5GU2sxV2ExSkhVMjFXU0ZScldtRlNNMEpVVkZjeGIxVkdXbkZSYkdSVFRVUldlbFl4YUc5WFIwcElWVzFHVjJKWWFETlVWVnBoVmpKR1NFOVdjRmRoZWxaSVZrZDRhMkl4V25SVGJGWlRZbXh3V0ZsVVJuZFdSbHB4VW0xMGExWnVRa2hXVjNoUFlWWkplbGt6YUZkTmJsSllXVlJHU21WV1NuSlhhelZZVWxoQ1dsZFdVa3RPUm1SSFlraE9WbUpIVWxoVmJURTBaVlpaZVdSRVFsaFNiSEI2VmpJMWQxZHNXbGRqUkU1WFlXdGFURll4V2tkak1WWnpXa1pPYVZKdVFuWldNVnBUVWpGa2RGWnJaR3BTVjNoV1dXeG9RMVpHVWxWVGJUbFhWbTFTV1ZwVlpFZFdSVEZGVm01d1YwMVhhSHBaVkVaS1pXeFdkVk5zVmxkaVNFSlpWa2QwWVZkdFZsWk9WbHByVWpKb2NGVnNhRUprTVdSelZtMUdhVTFYVWpCVk1uUnJWa2RGZUZOc1dscFdSVm96V2xkNGNtVkdaSEpQVjNCT1YwVktTbGRVUWxaTlZsbDVVMnRvVUZaR1NsaFphMXBMVkVaU2NscEZjR3hXYTNCNVZqSnpNVmRHU2xWV2JGcFlWbnBDTkZscVJtdFNNVnAxVlcxNFZGSXhTbHBXVnpBeFVURktjMVpZYkd4U00xSnZXVmh3UjFkV1dsaGxTR1JZWWxWV05WWldVa05XTVZwR1YyMW9WazFIVWxoVk1WcHJZekZ3UjFwRk5VNWlWMmhYVm0xNFlWVXhSbkpOVm1SWVYwZDRWVmxVU2xOWFZteHlXa1pPV0ZKc1dqQmFWV2hyVjBaYWMyTkZhRmROYWtaSVdWUktSMDVzU25WalJtUnBWa1phVVZkV1ZtRlRiVlp6Vm01T2FWSnNjSEJXTUdSdVpXeGtjMXBFVW1waVZrWTBWakkxVTJFeFNuVlJiR2hhWVRKb1JGWXhXbXRXVmtaelZHeFdUbFp1UWpWV1JscGhZVEpHYzFOdVVtaFNNRnBXVm01d1YxUXhjRlpYYlVacVZtdHdlbFpITVhkVWJGcHlZMFJhVjAxdVVuSlpla3BIVW1zeFZtSkdTbWxTTW1oWlYxZDRVMUV3TlVkVmJGcFlZbXMxV0ZSV1pGTlhiR3h5VjJ4T1dGSnJiRFpaVlZwaFZqSkdjbE51U2xwaGExcG9WbXBHYTFkV2NFaFNiRTVzWWxob1lWWnNZM2RsUlRWR1RWVmthbEpzY0ZoWlYzUkxZakZzYzFadVpGUlNiR3cxVkd4b2ExZEhTa2RqUm1oYVRVWndSRlpxUVhoU01rNUlZVWRHVTFZeFNsbFdWM0JMVkRGSmVWUnJXazlXYXpWd1ZUQldTazFXV25STlZGSldUVlV4TkZaR2FHOVdSbVJJWlVaYVdsWkZjRlJaTUZwWFpFZFdTRkp0Y0ZOaVJuQTBWbFJKZDA1WFNrZFhiazVxVWtWS1lWUlZXbHBrTVZweVZsaG9WMkpWY0VaV2JYaHJWVEF3ZUZOcVdsaFdiVkV3VlhwS1UxSXhXblZUYkVKWFltdEtkMVpxUW10aU1WSlhWMnRrWVZKR1NtRldha1pMVWpGU1YxWnVUbWhTYTNCNVZHeG9RMVl5U2xsaFJFNVdUVlp3YUZreFdrOWpWbFowWTBVMWFFMVlRa3BXYkZKS1RWWlJlVkp1VGxWaE1YQlZXV3RrYjFac1duTmFSazVYVW01Q1NWcFZaRWRXTURGWVZXcENWbUpVUmpOV2FrcEdaV3hHV1ZwR1pGZGxhMVYzVmpGYVlWVXlVa2RUYmtaWVlrVTFXRlZzVm5kWFZtUlhWV3QwVldKV1draFdNblJYVlRKS2NrNVdhRlZXYkZWNFZGWmFZVmRIVmtoU2JXaFhZVEozTVZkV1ZtdGlNV1JIVjFod2FGTkdjRmhXYTFaaFZrWldjVkp0Um10V2JGb3dXbFZhVDFSc1NuVlJhbFpYWWtkU00xVnFSbk5XTVZKeVdrWm9hRTF0YUhwV1YzaFRZekZhYzJKSVNsaGliVkp6Vm0xNGMwNUdiRlpoUjNSWFRVUkdWMWxyVW1GWGJGcFhZMGhhVjAxdWFHaFZiWGhyWXpGd1NGSnNaR2xUUlVwU1ZqSjBZVmxXVVhsVWJrcFFWbTFTYUZWcVNqUldSbGwzVm10MGEySkdjSGhWYlRGSFZtc3hWbUpFVmxkV2JXaHlWa2Q0VDFOSFJrZGlSbkJwVjBaSmVsWnFSbUZqTWxKSVZHcGFVMkpIYUZSWmEyaENaREZrY2xadE9XaE5hM0JJVmpJMVYxVnRSWGxWYkdoVlZucFdkbGt5ZUhOV2JHUjBVbTF3YVZaVVZrdFhWRUpoWkRGU2MxTnVTbXBTZW14WVdXeG9RMVJHVmpaU2JVWlhUVlZ3TVZWdGVHRmhWa3AxVVc1YVdGWnNTa2hhUkVaclZqRndSMVpzVW1saWEwcDZWbGN4TkdNd05VZGhNMlJYWWxoU2IxVnRkSE5PVm5CV1YyeE9XR0pWY0ZwV1YzUTBWakF4VjJOSGFGcE5ibWh5V2tWYVMyTXlUa2RhUjJoc1lURldNMVp0TVRCaE1ERklVbGhvWVZKWGFGVlpWRXBUVjFac2NsZHJkRnBXYlhoNVZqSXhSMkZHU25OaVJGSlhUV3BHU0ZsWGVHRmpiR1J4VVd4YWFWZEhhRkZXYTJRMFYyMVdSMVJ1UmxkaVIxSnZXVlJLTTAxR1dsaGpSWFJUVFZWc05GZHJhRmRXYlVwSFkwYzVWVlo2Um5aV01GcGhVakZzTmxKc1ZrNVNSbHBKVm1wSk1WSXhXa2hTV0hCV1lrWmFWMWxzYUc5aFJscDBaVVprV0ZJeFdrbFVNVnByVkcxRmVsRnJkRmRXYlU0elZHeGFhMUl4WkhKWGJYQlRVbTVDYjFadGVHRmtNV3hYWTBaa1dHRjZiSEZaYkZaaFUxWnJkMWRyT1doU01WcDZWakp3VDFZeVNrZFRhMUpYWVd0YVQxcFZXbmRUVmxKellVWm9VMDF0YUhaV2JHUXdWakZOZUdKR1pGaGlhMXBVV1ZSS1UxVkdWblJsU0dSVVZtNUNWMWRyVWtOWFJrcHlZa1JPV2sxR1ducFdha1poVG14S2RWZHNaR2xXUlZwSVYyeFdhMVF4U25SV2EyUmhVakpvVDFZd1ZrdFdiRnAwVFVob1QxSnNiRFZXUm1odllXeEtXRlZ0T1ZaaVZFWlVXVEJhVm1ReFduSmFSVFZPVm0xM01WZHJWbUZoTWtaR1RWWmFhVkpHU2xoVVZtUnZaR3hhY2xkdGRGUlNiRm94VlcxNFlXRldTWGhUYkZaWFRWWndhRlpVUm1Gak1YQkpWbTFHVTAweFNuZFdWekF4VVRBMVIxZHNWbFJoYTBwUFZXMTRWMDB4VWxkWGJVWlZUVmRTU2xWWE1VZFdNa3BIWTBST1drMXVhR2hXYkZwTFkyMVNSMXBGTldobGJGcExWbXRTUjFsWFJYaFhXR3hYWW10d1dGWXdaRk5YUmxKWFYyNWthbUpHY0VsVVZscHJWa1pLYzFOdWJGZE5ha1pJVmxSS1MxSXlUa2xYYkdocFVqRkZkMVl4V21GaE1WbDRXa2hXVm1GNlZsUlZiRnAzVmtaa1YyRklaRk5OYkZwNlZqRm9jMVF4V2xWaVJteGFWMGhDUkZSc1duTldiR1J5Vkd4a2FWWllRbGRXVjNoVFVURlpkMDFWWkdwU01GcG9WbTB4VTFkR1ZYZGFSazVUVFd0YVNGWkhjekZWTWtwSVpFUlNWMkZyV21oV2FrWnpWMFpLV1dGSFJsUlNhM0JWVm1wQ2EySXlUbGRXYmtaVVlsUnNXVlZ0TVRSbGJHeFdXWHBXYUZKcmNEQmFTSEJMVm0xS1ZWSllaRnBXUlZwTVdUSXhUMUpXUm5OalJtUlhZbXRLVWxZeFdtRmhNVXAwVlZoc1ZXRXhjSEpWYlRGVFZERnNkRTFYT1ZoV2JHdzBWakl4TUZVeVNsZFhhMmhhVFVaYWFGZFdXa3RqTVU1ellrWmFhR0V6UWpKV2JURTBZVEZaZUZadVNtdFNiSEJQVm0wMVEwNXNaRmhrUnpsVVRWZFNTVlV5ZEd0aGJFcFZZa1pvV21KSGFIWlVWRVpXWlVaa2RWcEdaR2xTYmtJMFZsWmtOR0V4VlhsU1dHeHJUVE5DV0ZWdGVIZFdSbVJYVjIxMGExSnJjRnBaVldSM1ZrWktkVkZ0YUZkaVdHaG9WbXBCTVZJeFpIVlNiRkpvWlcxNFZWWkdaREJrTVU1SFdraEtXR0pVYkZoVmJYUjNWakZyZDFadVpGZE5hM0JXVlcxd1QxWnRWbkpYYkZKaFVsWndhRmt5ZUhkVFIwNUhWR3hrVGxaWVFYcFdiWGhyWkRGUmVGSllhRmhoTWxKd1ZUQldkMkl4Vm5OV1ZFWnFZa2Q0ZVZZeU5XdFdSa3B6WWtSV1lWWlhVWGRaVlZWNFVsWktjMkpHWkZkTk1Vb3lWbXBDYTFKdFZraFVhMnhZWWtoQ2IxUldhRU5VUm1SeldrUlNWMDFyTlhsVU1WcHJWakpLU0ZWc2FGcFdSVFZFVlRKNFlXTXhWbkpVYkhCWFlsWkpkMVp0TVRSWlZsRjRWMjVPYWxORmNGZFpiRkpIWkd4YWNsZHNUbGRpUjFKNldUQlZNVll5U2tsUmFscFhUVzVTVkZaVVNrZFdhekZYWVVaYWFHRXdjRmhYVjNScllqSlNjMWRZWkdGU1YxSnhXVmh3VjFkV2JGWlhiWFJvVWpCWk1sWnRjRXRYUmxwelYyMW9WMDFxUmxOYVZXUlBVbXhrY2s5V1pFNU5iV2d6Vm0weE5GbFhVWGhVYkdSWVltdGFWVmx0TlVOVU1WcDBaVWhPVDFac1ZqVlViRll3VmpGSmQyTkZjRlpXTTJoMlZteGFZV015VGtabFJscG9UVmhDYjFkVVJtRlRNazE0V2toU2JGSnJOWEJXYlhSM1lVWlplRmRzWkZwV01HdzFWVzE0YjFVeVJuTmpSbWhhWWxSR2RsWXdXbUZrVjA1R1ZHczVVMkpJUWxkV1Z6QjRVakpHY2sxWVNtcFNWMmhZV1d4b2IxWkdiRmRYYTNSWFZteHdlbGRyV210Vk1rcEpVV3BLVjFac1NraFdNakZYVWpGd1IySkhiRk5XUmxwWlZtMXdSMU15VW5OYVJtUm9VMGRTVkZSV1pGTlhSbGw1WlVjNVZVMVhVa2xXVjNodlZsWmFjMWRxU2xWV00yaFlXa1ZWTVZkR1NuTmFSVFZYVmpOamVWWXhXbGRaVmtWNFYyNVNWR0pIZUc5VmJYUkxXVlp3V0dSSFJtaFNiWGN5VlcwMWExVXlSalpXYkd4YVlUSlNlbFpxUVhoa1JtOTZZa1prYVZkRlNrbFhWbEpMVlcxV1IxVnNiR2hTYkZwd1dXdFdkMWRXWkZkVmEzUldUVlp3V0ZscmFFdFpWa3BIVTI1Q1ZWWnNjR2hVVlZwVFZqRmtjazlYYUdsU1dFSTJWbXBKTVdJeFduUlRiR3hXVjBkU1dGUlZXbmRoUm5CR1YyeGthazFyV2toWGExcHJWR3N4VmxkWWNGZGlWRUkwV2xjeFYxSXhaRmxpUmxab1RXNW9lRlpYTUhoVk1rNUhWMjVLV0dKVldsZFdiVEZUVjBaYWRFMVZaRmRTVkVaR1ZtMXdRMVpyTVhWVmJrcFhZbFJHVEZWcVJtdGpNa1pIWTBkb1RtSlhhRVpXYkZKSFdWWnNWMVJyYUZaaE1taFVXV3RvUTFkR1VsZFdibVJVWWtad2VsZHJVa05XTURGWFYycENWazF1VW5aV2JURkxZMnhPYzJGR2NHaE5iRW95VmxkMFlWWnRWa2RhU0ZKclVtMVNXRmxVUm5aa01WcFlUVWhvYWsxV1NucFdNalZUWVRKV2NsZHNhRmRoTVZveVZGVmFZV05XU25OalIzaFhZVE5CZUZaVVNucE9WbGw1VTJ4b2FGSXlhRmxXYWs1VFkyeHNjVk5zVG1wTmEzQklWako0YjJGWFJqWldiRVpZVmpOU1dGcEVRWGhTTWs1R1YyMUdWRkl4U25aV2JURTBaREZrUjJFelpGZGlhelZZVkZkMFlXVldiSEpWYkU1WVlsVmFlVll5ZUZOWlZrcFhZMFpDV2sxdWFISmFSV1JQVWpGU2RHSkhhRTVUUlVwb1ZtMXdSMkV3TVVoU1dHaFdWMGRTVUZac1pGTldNV3gwWkVoa1dGWnRlSGxXYlRWcllXc3hWMWRxUWxWaVJscFFWbXRhUzJSR1ZuVmlSbVJPWVd0YVNWZFdWbUZYYlZGNFdrWldWR0pIVW5CV01HUnZZakZhY1ZGdFJsaGlWbHA2Vm0wMVYxWkhTa2hWYkdoV1lrWndNMXBXV21GWFIwNUdXa2RvVG1KRmNGbFdiVEF4VXpGV1IxZHVVbFppUjJoWVdWUkdkMkZHV25SbFIwWnJVbFJHU2xsVlZUVlZNREZXVjFSR1YySlVRWGhXUkVaelZqRlNjbGR0Y0ZOaVZrcG9WMVpTUjFadFZrZFhXR1JZWW1zMVdWWnFRVEZTTVdSeVYyczVhRlpyY0hwWmFrNXJWMGRGZUZkdVJsVmlSbkJoV2tSQmVGWXhjRWhpUjNob1RUQktXbFl4WkRSaU1rbDRVMnRrV0dKcldsUlpiRlpoVmtac2MxWlVSbE5OV0VKWFZqSXhSMkZHU1hkV2FscFdWak5vU0ZacVJscGxiRVp5WVVaa2FHRXpRbEJYYkZwaFZUSk9jMk5GYUZOaVJUVnZXbGQ0WVZkc1duTlpNMmhQVWpGR05GVXhhRzlYUjBwelUyczVWMkV4V2t4WmFrWlRWbXhXYzFwR1VsTmlSM2N3VjFaV2IxUXhXWGhYYmxKV1lUSjRZVlpzV25kbGJGbDVUVlYwV0ZZd1drZGFWVnByWVVVeFdWRnFXbGhXUlc4d1YxWmtVMVl5VGtaYVJtUm9aV3hhV1ZkWE1UQlNNREI0VjFoc2JGSnRVbkJVVjNSWFRrWmtjbFp0ZEZoU01IQjVWR3hvUjFadFJYaFhhM2hYWWxob2FGbDZSbXRqYlZKSFZXeE9hVk5GU1RGV2JURTBZakpKZVZKdVVsUmhNbWhYV1ZkMFlWbFdiRlZTYm1SWVVteHdlRlV5ZERCV1JscHlWMnBHV21FeGNISlpWbHBMWTIxT1JrMVdaRmROTUVwTlZtdFNTMVF5VG5KT1ZtUmhVakJhVkZSVlduZFdWbVJZVFZSQ1ZFMXNSalJXTW5odllXeEtXVlZ1UWxWV2JIQXpWakJhV21WVk5WWmtSbVJPWVROQ1dGWnFTWGhTTVZsNVUyeHNhRkpGTlZoVVZWcDNZVVpWZDFaVVJsZGhlbXhZV1RCYWEyRkZNSGRTYWs1WFRWWndXRmRXWkVwbFJtUnpXa1pvYVZJeFNuaFdWM1JXVFZaWmVGVnNXbGhpYlZKdlZXMHhNRTVXY0ZaaFIzUldUVlp3ZWxZeU5YZFhhekZIWTBoS1dsWnNjRXRhVjNoeVpXMUdSMXBIYkZOaE0wSk9WbXRhVjJFeFNuUldiR1JVWW14YVZsbHJXa3RqUmxaeFUyMDViR0pHY0ZsVVZXaHZZVlV4V0dWR2FGZE5hbFpNVm1wS1MxWnNaSFJQVmxwcFYwZG9ObFpHVWtkWGJWWllWbXRhVUZZeWFIQldiR2hEVTJ4YWMxbDZSbXBOVjNoWVZUSjRiMVp0Um5KT1YwWlhZa2RTVkZZd1duSmxWMVpJWkVkd1RtRXpRa2xXTW5ScllqSkdSazFZUm1oU1JUVllXV3hvYjFaR1ZqWlNhM0JzVW0xU1dsbFZXbGRoVjBZMlZtNWtWMVo2UlhkYVJFcFBVakZhZFZKc1ZtbFdSM2hhVm0wd2VGVXhaRmRqUmxwYVpXeGFiMVpzVWtkWFJtdDNWbTA1VjAxcmNGWldiWFJ2VmpGWmVtRkhhRlppV0doeVdrWmFTMk14V25OYVIyeFhZVE5DVjFacVNqUmhNRFZJVWxoc1ZXSnJOV2hWTUZwTFZWWmFjVk50T1ZoU2JYaFdWVEp3VDFSc1NuTmpSbHBXVFc1Q1ZGWnFRWGhXTWtwRlZXeGFUbUZzV2xGWFZtUTBVekpTU0ZKclpHbFNiVkp3Vm10V1lWWldXbkZSYlVacVRVUldlbFV5TlZOaE1VbDZVVzVDVjJKR2NETlZNbmhyWXpGYWRGSnNWazVoTVhCS1ZtMHdNVlF4WkVoU2JrcFBWbTFvWVZsVVNsTlZSbEp5VjJ4T1YySklRa2hWTWpFMFZUSktWMU50UmxoV2JGcHlXV3BHVTJOck1WbFViRkpwVTBWS1dsWnRNSGhpTURCNFlrUmFVMkpZVWxSVVZscGhaV3hzVmxwRVFsZFNhMncwVlRKNFlWWXhXalpTVkVKYVpXdEZlRlpxUmxkak1YQkhZMGQ0YVZKdVFscFdhMXByVFVkUmVGZFlhR2hOTWxKWVdXeFNjMWRXYkZsalJXUlVVbTEwTTFZeWVFOVdNREZ5WTBaYVZtSllVVEJXYWtGNFYwWldjbUZHV2s1U01VcEpWbGR3UzFReFNuSk9WbWhwVWpKNFdGUlhlRVpsVmxwMFRWUlNhRTFzUmpSVk1XaHZWbXhrU0dWR1pGcFdSWEIyVm14YWMxWldUbk5VYkdScFVqTm9OVll5ZEdwT1ZsbDRVMjVPYWxOSVFtRldiRnBoVlVac1ZWTnJkRk5OYXpWR1ZWZDRWMVl4V1hsaFJFcFhZVEZLU0ZVeU1WSmxSbVIxVW14V2FWSnNjRmxYVjNSaFpESldWMWR1VWs1V1JrcHZWRlpWTVZOV1ZuUmtSM1JvVW10d01WVlhlRzlXYlVwSVlVVlNWVll6YUdoWk1WcEhaRVpLZEdORk5XbFNXRUpMVm0wd2VFMUhTWGhXV0d4VVlUSm9WMWxZY0hOWFJteFlZM3BHYTJKR1NucFdNakZIWVd4YWNrNVdjRnBXVm5CUVZrZDRZV1JIVVhwalJtUlRZa2hDYjFkV1VrdFNNazE0Vkc1S1dHSkdTbkJXYWtwdlYxWmtXR1JIZEZaTlZuQklWbXhvYTFkSFNsWlhia1phWVRKU1ZGcFdXbmRTYkhCSldrWldhVlpXYTNsV2JURXdZekZaZDAxWVZsWmlWMmhoVm10V2QxTkdXbkZTYm1SVFlrZFNlbFpYTVhOVk1rcEpVV3h3VjAxWFVYZFhWbHBPWlVaV2NscEdaR2hpU0VKVlYxWlNUMVV5VG5OV2JsSnNVbGhTYzFadE1UUmxWbVJ5WVVVNVYyRjZSbmxaTUZaM1ZteFplbUZGVWxkTlJuQm9WRzE0UjJOV1ZuTmpSMmhvVFZoQ1ZsWnRNWGRTTWtWNVZXeGtWMkpzU25GVmJYTXhWMFpTVjFadVpFNWlSbkI1VmpJeFIxWXdNWE5TYWxaWFlsaG9jbFp0TVV0amF6VlhZa1p3YUUxc1NsVldha1poVmpKT1YxSnVWbUZTYkVwWVdXdG9RMWRzV2tkV2JFNVhUVlpzTkZZeU5VOWhiRXBHVTIxR1YySkdjR2hXYTFwaFkxWkdXV0ZHWkU1aGVsWktWMVpXWVdFeFVuTlRXR2hVWWtWYVdGWnVjRVpOUm5CRlVtdHdiRkpzV2pGVk1uTTFWakF4ZEdGSWNGaFdiRXBJVm1wQmQyVkdaSFZWYlhoVFlYcFdWbGRXYUhkU01XUkhWbGhvYUZKNmJGbFZiVEZUVTFad1ZsZHNaRmhpVlZZMVZsWlNRMWR0Um5KWGJHaGhVbGRTV0ZWdE1WTlNNa1pIVkcxc1dGSXlZM2hXYlhCTFRVZEdjazVXWkZkWFIyaFZXVzF6TVdOV1ZYZGFSRkpZVW14S1dWa3dWbXRXUmtwMFpVWmFWbUpZVWpOWmExcExaRVpXZFdKR2NGZFdia0l5VjFaV1ZtVkdaRmRTYkd4cVVtMVNjRll3Vmt0U1JtUnpWbTFHVlUxVk5VaFdiVFZIVjBkS1JtTklRbFpoYTFwTVdrUkdZVmRIVGtaYVJrNU9Va1ZKTUZacVJtOWlNV1JJVTJ4YVdHSnJXbFpXYlhoM1pXeFNjbGR0UmxSU1ZGWlhWREZhYTFSdFJYcFJiSEJZWWtaYWFGWlVSbXRqTVhCR1lrWkthVkl5YUdoV2JYaGhaREpPYzFkdVJsTmlSMUp4V1d0b1ExTkdhM2RYYlhSVllrVndNVlZYZEhkV01rcFpVV3QwVlZac2NFdGFWVnBoVjFkS1IxVnRiRk5pYTBwaFZqRmtNRmxXVFhoWGJrNVlZbXRhVmxsclZURmlNVlowWlVkR2JGSnNXakJhVlZZd1lWWktjbU5FUWxkV00wSkVWbTB4UzFaV1NuVlhiR1JvWVROQ1NGZHNaRFJTTVdSWVVtdGtZVkp0VW5CV2JYUlhUVEZaZUZwSVpGTk5WMUl3Vm0xNGExWkhTbk5YYkZaYVlrZFJNRlpFUmxOWFIxWkdaRVpvVjJKSVFscFhhMVpoWVRGa2MxZFlaRmhoTW1oaFZtdFZNV1ZzYkZoak0yUnNWakJhU0ZadGVHdGhSMFYzWWpOd1YxWkZXbWhhUkVaTFl6Sk9SbFpzV21sV01taFZWbTEwVjFsV1RYaFhiR1JoVWtaS2NsUldXbk5PVmxWNVpVWmtWazFXY0VkVk1uaHpWakpLVlZKc1VsZFdSVm96Vm0xNGEyTXhVblJqUjJ4VVVsVndTbFl4V2xkaE1rMTVVbXhrVkdKSGVGTlpWM2gzVjBac2NscEdTazVTYlhoNFZXMTRZV0pHV25OVGJuQllZVEpTZWxacldrdFhWa1owVDFaa1YyVnJXVEpXUmxwclZHMVdSMXBJVmxaaVdHaFVWakJhUzFkc1dsaE5WRkpxVFVSV1dGbFVUbmRoYkVwMFZXeG9WVlpXU2toVmJYaFhaRVUxV1ZSc2FHaGxhMXBKVm1wS2QxUXhXWGxUYkd4b1VqQmFhRlpxVG05WFJtdzJVMnRrVTAxWVFrbFpWV1J2VkdzeFJtTkZPVmRpV0doeVdrUkdUbVZHVmxsaFJsWm9UVzFvVlZkV1VrdFZNa1pIVm01R1ZHSlViSEJVVmxwTFYwWnNWbFpyT1doTmEzQklXV3RTVjFsV1NsZGpTRXBYVFc1b2FGbDZSbUZqVmxaellVZG9UbGRGU1hsV2JYaFRVekZLZEZac1pGZGlhelZaV1d0b1EyTkdWbkZTYTFwclRWWndNRnBGWkVkaGF6RnpVMnRzVjFZelVtaFpWRVpMWkVaV2RWRnNXbWxXUlZZMlZrWldZVmxYVGxkVWJrWldZa1phVDFadGVIZE9WbHBIVjIwNVZVMVdWalZWYlRWUFZrZEtTR0ZHV2xkaVZFWlVXa2Q0ZDFOSFZrbFViR2hUVFZad1NGZHJWbXROUmxWNVUydGthVTB5VWxoVmExWmhZVVprVjFwRlpGaFNhelV4VlRKNFUyRkhTa2xSYkd4WVZtMVJkMWRXWkVkU01YQkhXa2RHVTJGNlZsWldWekUwWkRKV1YySkdXbGhoZW14dlZtMTBjMDVXYkZaWGJHUllVbXhzTmxaWE5XRldiRm8yVW14T1lWWldjRE5WTVZwUFl6RndTR0pHYUZOaE0wSlNWbTE0YW1WRk5VaFZXR3hYWWtkU1YxbHJaRk5pTVZaellVWk9XRkpzU2xsYVJXUkhZa2RLU0dSRVRsaGhNVnB5Vm1wQmVHTnRUa1poUm5CT1VqRktNbFpxU25wbFIxSllVbXRvYUZJd1dsUldiWGhhVFVaYWRFMUlhRlpOVld3MVZXMTBhMWxXU1hsbFJsSmFZbGhTUjFwVldtRmpWazV4Vld4a1RsWXphRnBXVjNodllqRmtSMXBGYUZaaGVteFhWRlZrVWsxR2JIRlNiR1JyVmpBMVNsWkhlRzlXTWtwSlVXcFdWMkpVUVhoWlZFWlNaVlpPY21KR1NtbFNNVXBaVmtaa2QxSnRVWGhYV0dSWVlUTlNjVlJXVlRGTlZteHlWMjA1YUZKVVJscFZWM0JMVjBaYWMyTkhhRlpOYWtaWVZXcEdVMlJXV25SU2JFNXBWbXR3V2xZeWVHdE5Sa2wzVGxWa1dHSkhVbGRaVkVwVFZteFNXR016YUU5U2JWSjVXVlZhYTFZeFdYZGpSV3hhVmxkb1JGWnFRWGhTTWs1R1pVWmtWMkpJUW05V2FrSldaVVprV0ZScmFHeFNhelZZVlcxNGQxTnNXblJqUldScFRXc3hOVlZzYUc5V1IwWnpZMGhDVm1KVVJuWldiWGhoWTFaU2MxUnNhRk5pUlhBMlZtcEpNVlF4V1hsVGEyaHJaV3R3V0Zsc2FHOWpiR3hYVjIxR1dGWnJXakJWYlhocllWWkplRk5ZY0ZkaE1VcElWakl4VW1Rd01WZFhiVVpUVFRCS1ZWWkdZM2hpTWtaSFdraE9ZVkpGU21GV2FrRXhaV3hyZDFadGRGaFNNSEF3VmxkNFUxWldXbk5qUjJoaFZqTm9hRlV3VlhoWFZsSnpXa1pPYUUwd1NsbFdNVkpEVmpKUmVGZFliRlJpUmxwVFdWZHpNV0ZHV25OWGJGcHNVbXhXTTFZeWREQlhSbGwzVjJ0b1dHRXhjSFpXVkVGNFZtMU9SMUpzWkdsV1JVa3dWa2QwYTFWdFZrZGpSV1JoVWpKNFZWVnRkSGRWVmxwMFpVWmFUbFp0VWtoV1YzaHJXVlpLUjFOdVRscGhNbEV3Vm1wR2ExZFhUa2RhUjJoVFRVaENXRmRVUWxkaU1XUjBVbGhvVkdKSGFGaFVWM0JIVjBacmVXTjZSbGhXYXpWNldUQmFhMVV4V2xkaE0yUlhZa2RSTUZkV1duTlhSbEpaWWtaU2FFMXNTbHBYVjNoclRrWmtWMVp1UmxSaVZHeFFWbTE0YzA1R1dYbE5WV1JZWWtad2VWUldVbGRXTVVwMFlVaHdWMkpIVWtkYVZtUkhVakZLYzFwSGJGZFNWbkJXVm0xd1ExbFhUWGxVYms1WVlteGFhRlZ0ZUV0WFJteHlZVVZLYTAxWFVsWlZWM2hyVkd4S2MyTkdiRlpOYm1oeVZqQmtSbVZYUmtkaFJuQnBVbXR3V1ZacVFtRlpWbHBYVkc1S2ExSnJOVTlaV0hCWFV6RmFWMXBFVWxwV01GcFlWVEZvYzJGR1NsZFhiR3hhVmtWYVRGVXdXbXRXTVdSMFpFWlNVMkpJUWpWWFZsWmhWREpHVjFwRlpGUmlSVXBZV1d4b1ExTkdWalpTYXpsWFRWZFNNVlZ0ZUZOaFIwcEdZMGhrVjFKc2NHaFZla3BYWXpGa1dXSkhkRk5OTVVwWlZsZHdRMlF5VmxkV1dHeHNVakJhV0ZSWGRIZFhiR3hXVldzNVYwMVZjRmhaTUdSSFdWWktSbGR1U2xwbGExcHlXa1ZrVjFJeGNFZGFSazVwVTBWS2FGWnRNSGhOUjBaMFZtdG9WVmRIYUZoV01HUTBWa1paZDJGRlRsWk5WM2g1VjJ0ak5WZEdTbk5YYm1oWFVucEJNVmxWV2t0a1IxWkhWMnhhYVZkSFozcFhWM1JoV1ZkT2NrNVdiR3BTYmtKdlZGZDRTMDFzV25OVmEwcHNVakZLU1ZWdGRHdGhWa3AwVld4b1ZWWkZXa3hXTVZwYVpVWmtkR1JHWkU1aGVrVXdWbTB3TVZZeFduUlRiR3hvVW14S1dGUlZXbmRVUm5CV1YyMTBXRkl4U2tsVU1WcExWR3hhVlZacmJGZE5ibEoyVlhwR2MxWXhVbkpYYXpsWFlsWktWMVp0TUhoVk1WcEhWbTVHVTJKR2NITlZiWGhoWlZaa2NsZHRkRlZpVlZZMlZWZDBjMVl4V2taaU0yUlZZVEZ3YUZZd1drdFhWMFpJWTBaT2FWWnJjSFpXYlRFMFdWZFJlVlJ1VG1wU1YxSlpXVmh3YzJOV2JGbGpSbVJZVW14d1dWcFZWVFZXVjBZMlVtcENXR0ZyTlhwV2FrcExWMWRHU1ZOc1ZtaE5XRUkyVm0xd1IxVXhaRmhTYTJoVFlrVTFXRlJXVm5kWlZsbDRXVE5vVDFKck1UVldSbWh2VmpGa1NGVnRhRlppV0UxNFZqRmFZV1JIVmtoU2F6VlRZbXRLV0ZZeWRGZGhNa1pYVTI1S2FsTklRbGhVVnpWRFVrWmtWMWRyZEZkTlZUVjVWbGQ0YTJGV1pFWk9SRUpZVmtWc05GWkVSa3BsVmtweVdrZEdVMVpHV25kWFYzUlhaREExVjFkdVVrNVhSMUpUV1d4YVlWTldXbGhsUnpsV1RXdFdOVlpYZUU5WGJVVjVZVVZTVjAxR2NHaGFSV1JYVWpKT1JrNVdUbWxUUlVwWVZteGpkMlZHU1hoV1dHUk9WMFZ3VDFacldrdFhSbXh6Vld4a1ZsSnRVbGhXTW5SM1lrWlplRmRyYUZwaE1YQm9XVlZrUm1Wc1JuRlRiR1JvWVRGd2IxWnFTWGhXTVdSSFYyNUtZVkl3V2xSVVZ6RnZWVVphZEUxSWFFNU5SRVpZVmpJMVMxZEhTbFZpU0VKVlZtMVNWRlV4V2xabFZUVldaRVpXVGxadGR6RlhWbFpoWVRGa2RGTnJaRlJoTW1oWVdWUkdkMlZzYTNoWGEzUnFUVlpLZWxsVldrOVViRnAxVVd0c1YwMXVVbGhYVm1SR1pVWmFXV0pHVW1sU01VcFdWMWQwYjFFeFpGZGlSbFpUWWxWYWIxVnRNVFJXYkZaMFRWUkNWMUpyY0hsWk1HaHZWakF4ZFdGR1FscFdiSEJMV2xaa1IxTkhSa2RhUms1cFVtNUNkbFl5ZEZOVE1VbDRVMWhvWVZOR1dsUlphMXBMWWpGU1YyRkZUbXhpUjFKWldrVmtSMWRzV1hoWGJuQllZVEpvVEZZd1pFdGtSbFowVDFaYWFWSnJjRWxXYWtvMFZqRlplVkpyYkdGU2JWSlBXVlJPUTFsV1dsZGFSRUpwVFZac05GWXlkR0ZYUjBwWVlVZEdZVll6VW1oWlZWcDNVakZrY2s5WGRGTmhNMEkyVm10amVHTXhXWGxTV0hCU1YwaENXRmxzVWtOT1JsSnlXa1Z3YkZKcmNGcFpWV1JIVmtaS1ZWWnRPVmRXUlVwWVdrUktTbVZHV2xsYVIwWlRZWHBXV0ZaR1dtRlRNV1JIVjFoc1QxWXpVbkJWYWtKM1UwWnNjbFZzVGxoaVJuQlpXVlZvUzFkc1dsZGpSWGhhVFdwR1VGVnFTa3RTTWs1SFdrWmthV0V3YkRWV2JURjNVMjFXUjFSWWFGVmhNbWhVV1ZSS05GZFdiSEphUms1WFVteHdNRlJzVms5VU1WcDBWVzV3VjAxcVJYZFdha0Y0Vm0xS1JWVnNjRTVTYkhBeVYxWmtORk14V2xkWGJrNW9VbTFTY0ZaclZrWmxSbHBIVld0a1dHSldXbGxXYlhScldWWkplV0ZGT1ZwWFNFSkhWRlphWVZkRk1WVlJiV3hPVm0xM01WWlVTVEZUTWtaelUyNU9XR0pIYUdGV2ExWmhZVVpTVlZKc2NHdE5WMUl4VmtjeGQxUnRSWGhqUlhCWFVrVmFjbGxxUmxabFZrNXpXa1pTYVZJemFGbFhWbVF3WkdzeFIyTkZWbFJoTTFKVVZGWlZNVTFXVlhsamVsWlhUV3R3ZVZVeU1XOVdNa3BaWVVkb1lWSkZXbWhWYWtwTFVqRndTRkpzVGxkTlZYQlNWakZrTUZsWFVYbFdiazVZVjBkNGMxVnVjSE5YUmxKWVpFaGtVMDFYZEROV2JUVlBWakF4V0ZWcmNGWldNMUV3Vm1wR1MwNXNTbk5oUmxwb1lURndlVmRyV21GWlYwMTRWMjVTYVZKck5VOVdiR2hDWld4YWNWSnRkRTlTYlhoWVZrWm9iMWxXU2xoVmJHeGFWa1Z3VkZZeFduTmpNVnAwVW0xd2FWSnJjRnBYYkZaclVqSktTRk5yWkdsU1JscFdXV3RhZDFWR1duTmFSWFJUVFdzMVNGbHJXbXRXTURCNVlVUktWMkpZUWt4VmVrWktaVVpTZFZOdGFGTmlWa3BRVmxjd01WRXhaRWRhU0U1WVlsaFNWMVJXVlRGVFZscFlaRWQwV2xacmNGWldiVEExVmxaYVJsTnJlRlpOYm1ob1dYcEdWMk50VWtaUFZrNU9Vak5qZDFadGNFZGlNa2w0V2tWb1UySnJOWEZWYlhoTFdWWmFjbFpVUm10aVJuQjRWVzAxVDJGck1YSlhhMnhWVFZkU00xbFdXa3BsYkd0NllrWmtWMlZyUmpSWFZsSkhWbTFSZDAxV1pHbFNhM0J2VkZjeGIxZFdXbGhPV0dSVFRXeGFlbFl5TlVkVmJHUklZVWhLVm1GclNtaFZNRnBoVTBkV1NHUkhhRmRpU0VKSVZtMTRiMkV4WkVkWGJrNVVZVEExVmxadGVIZFRNWEJYVjJzNWFtSklRa2xWYlhoUFlWWlplV0ZFVGxkTlZuQjJXa1JHV21WV1RsbGhSbWhwVW14d1ZGZFhkR3RWTWs1elZXeGtXR0p0VW5OWmEyUTBaVlpzVmxacVFsaGlSbkI1V1RCb2MxWlhTa2RqU0ZwWFlXdHdURll4WkVkVFIwWklVbXhrVjJKclNuWldiRkpEVm0xV1IxcEdaR3BTVjJodlZXeFNWMVpHVm5OWGJtUllZa1pzTkZaWGRFOVdhekZXVm1wU1YwMXVhSEpXTUdSTFkyczFWMVpzY0doTldFSk5WbXBDWVZsWFRuTlhia3BoVWxSc1ZGbHJhRU5PUmxwVlUyNXdUMVpzY0VoV01XaHJWREZhV0dGR2FGVldlbFpQV2xWYWMxWnNjRVprUms1T1lYcFdTRlpIZUdGaE1WSnpWMjVXVW1KSGVGaFVWbHAzWVVaYVNFMVdaRk5OV0VKS1ZrY3hSMVV5U2taalNHUllWbTFvTTFacVJtdFNNWEJIWVVkMFUwMHhTbGhXUm1SNlRWWk9SMWR1VWs5V2F6VldWRlphZDFZeGEzZGhSVGxZWWxWV05Ga3dVazlXTURGWFkwUk9WbUpZYUROVmJYaDNVakpHU0dKR1RtbGhNR3Q1Vm1wR2EwMUdWWGhXV0doaFVsZG9WRll3WkRSaU1WWjBaRVYwV0ZKc1NsZFhhMXBQVmtaS2MxTnFRbFZXYkZsM1ZsUkJlRll4WkhWalJtUnBWMGRvZVZadGNFdFNiVlp6VW01S2FWSnRVbTlVVm1oRFYxWlplRmR0Um1wTlZtdzBXVEJXWVZkSFJqWldiR2hhWVRGd00xWXdXbXRYUjFKSVQxWktUbFl4U2tsWFYzUnZVekZrU0ZOcmJGSmhlbXhZV1d4b2IwMHhXWGhYYm1SWFlrZDNNbFp0TVc5Vk1WcEdWMnBXVjJGcmEzaGFSRVpoWTJzeFdWSnNaR2hOTW1oWlZsZDBWMWxXYkZkalJtUmhVbGRTVkZSWGRHRlRSbXQzV2toT1ZrMXJWalpWVjNSM1ZqQXhkVlZ1U2xWaE1sSlRXbFZhVTJOdFJrZGFSMmhPWWtWd2RsWnNZM2RsUmxWNFdrVmthVkpzV2xaWlZFRXhWVVpzY2xkdVRrOVdia0pIVjJ0V2EyRkdTbFZTYkdoV1RXcFdNMVpxUVhoalZscHpZVVprVjJWcldrbFhXSEJIWVRKTmVWSnJaRmhpVjJoUFZtMDFRMlJzV25STldHUlRUVlpXTlZaR2FHOWhiRXBYWTBkb1ZtSlVSbFJXUkVaaFl6RldjMXBGT1dsU2JYY3hWMnRXYTAxSFJYZE5WbVJYWVd4S1YxUlhOVzlYUmxweFUydDBWRkl4V2toWlZWcDNZVlpKZVdGR1ZsZGhhMHBvV1ZSR1dtVkhUa1phUmxacFYwVktVRlp0Y0VkVE1EVlhWMjVTVGxaR1NsWlVWM1JoVTFaYWRFNVdUbWxTYXpWSldsVmFiMVl5U25WUmEyaFZZbGhvVkZacVJtRlhWMFpIV2tVMVYySnJTbWhXTVdRd1lUSlJlVk5yYUZSaE1sSnhWVzB4TkZkR1ZuUmxTR1JZVW01Q1JsVnRNVEJoYXpGWFkwaHdXbFpXVlhoV1ZFWkxZekpPUjJKR1pGTmlTRUp2VjJ0a2VtVkhUWGhYYms1b1VqTkNWRmxZY0ZkWGJHUllaVVprV2xZeFdsaFdNV2h6WWtaS2NrNVdhRnBpUmxwb1dsWmFjbVF4V25GVmJHUnBWbFp3TlZkVVFsZGlNVnB5VFZWb1ZtSkhhRmRaVjNSaFYwWnNObEpzVG1waGVsWllWMnRhYjFVeFdsbFJha3BYWWxSQ00xcEVTbEpsVmxaWllrWmthRTFZUWxGV2JYaHJWVEZhYzFkWVpHRlNSa3BaVlcweE5HVldaSEpYYXpsWVVteHdNRnBWYUhOWFIwVjVWRlJHVjJKR1ZqUldha3BMVWxaU2MxcEhiRk5oTTBKS1ZtMHhkMU14VFhoVWEyaFhZVEo0Y1ZWdE1WTmpSbHB5Vm0xR1ZGWnRVbGxhUldRd1ZrVXhWbUpFVmxkU00xSllWbGN4UzFOV1JuSlBWbHBwVjBkb1dGZHNWbUZaVjFKSVZHdGFWR0pZYUZSWlZFNURWMVphVlZOVVJsTk5WbFkxVlRKMGMxVnRTa2hoUm1oYVZqTlNNMXBIZUZabFJtUjBVbTEwVTAxV2NFcFdWekUwWkRGWmQwMVZWbE5XUlVwWVdWZDBjbVZHVm5GU2JVWnJVbXMxZVZkclpIZFdSa3BXWTBac1dGWnNTa2hYVm1SSFVqRmtjbHBHYUdsV1ZuQlpWbTB4TUdRd01VZFdibEpzVW1zMVZsbHNWbmRTTVd0M1ZtNWtWMDFyVmpWV1ZtaHJWMnhhUmxkdGFGZE5SbkJNV1RGYWEyTXhjRWhpUms1cFUwVktXbFpxUm10TlJteFhZa1phVGxOSGFGbFpWRXB2WXpGV2NWRnRSbXBXYkhBd1drVm9hMVJzU25WUmEyUlhZa1pLU0ZadGMzaFNWa3B5WWtkR1ZGTkZTa2xXYlhCSFYyMVdkRkpyYkZoaVNFSnpXVlJHZDJJeFduRlJiVVpVVFZkU1dWVXlkR3RYUjBwWVpVYzVWVlp0YUVSV01WcGFaVVp3UlZGdGFFNVdiRmt3Vm1wS01HRXlSbGRVYTFwWVlrWktZVmxVU2xOV1JtdDRWMnhPVjAxWFVqQlZiWE14VmpKS1NWRnJjRmRTYkhCMldWUkdZV05yTVZsVGJYQlRWakpvYUZaR1ZtRlRNa1pIVjI1R1VsZEhhSEpXYlhoaFpXeGFXR1ZIZEZkTlZYQllXVEJqTlZZeFdrWlRiV2hYVWtWd1VGbDZTazlTYlVaSVkwWk9hR1ZzV2xwV2ExcFRVekpKZVZOWWFGaGlhM0JaV1d0a1UxbFdXblJOVkZKWVVteHdNRnBGWkRCaFJscHlZMGh3V2sxSFVuWldiVEZMVTBkR1IxVnNaRTVTYmtJMlYxaHdSMWxXV2xkVGJrNVdZa1UxY0ZZd1pHNU5WbHB4VTJwQ1YwMXJWalJXTVdoclZHeGFkRlZ1UWxaaE1YQm9WMVphWVdNeFpIUlNiWGhwVW01Q05GWldXbTlpTVZsM1RWaEtUMVpYZUdGV2JGcDNZVVpzY2xwRldteFNNRFZKV1ZWYWIyRldTblZSYlRsWFlURktTRmxVUm10U01WWjFVMjFvVTAwd1NsVlhWbWgzVmpKUmVGcEdaRlpoTURWeVZGWmtVMlZzV1hoaFJ6bGFWbXR3UjFVeU1VZFdNa3BaWVVST1ZWWldjR2hXYWtwSFUwVTVWMk5HWkdobGJGcEpWbXRrTkZsWFNYaGFTRkpVWVRKb2IxVnRlRXRYUmxKV1YyNWtWMUpzY0hoVmJURkhWakZhY21OSWNGcFdWbkJRV1ZaYVNtVnNhM3BoUm1Sb1RXeEZkMVp0TVhwTlZtUkhVMjVLWVZKdGFIQlpWRTVEWlVaYVZWRnRkRTlTYkhCNldXdG9TMWxXU2paaVJtUldZbGhvZWxSc1dsTldNVnAwVW0xc1UyRXlkM3BXUjNoWFl6RmFkRk5zYkdoU2JXaFlXVmQwZDFSR1ZYaFhhMlJyVWxSc1dGbFZXbXRWTVZwMVVXNWFWMkpIYUROVmVrWldaVVpPV1dGR1ZtbGlSbkJZVjFkNGEwNUdXa2RYYmtwWVlsVmFXVlp0ZUhkTlJuQkdXa1ZrV0ZJd1dUSlZiVFYzVmpBeFdHRklXbGhXYkhCUVZUQmFWMk14WkhOV2JHUk9UVlZ2TWxaclpEQlpWbVIwVm10b1UyRXllRlpaYTJSVFZrWlNWbUZGVGs5V2JIQkpXbFZrUjFZd01WaFZha0pXWWtkb2VsWnRNVXRqTWs1SFlrWmthVmRIWjNwWGJHUTBZMjFXV0ZacmJHRlNhelZQVm0xMGRtUXhaSEpXYlhScVRWWldNMVJXV21GaGJFcDFVV3hvV21KSGFFUldSVnBUWTJ4a2MxTnRlRk5pVmtwaFYxWldZV0l5UmxoU1dIQlNZbTFvV0ZaclZrdGpiRkp5VjIxMFYwMXJjRWhXYlhoVFlWWktWVlp1Y0ZoV00xSnlWR3RhYTFJeFpGbGlSM1JUVWxWd2RsZFdhSGRTTWxaWFZXNU9WMkpZVWxsWmJGWlhUa1pyZDJGRmRGaGlSbkJZVm0xd1UxZHRWbkpYYTNoYVRWWndWRmw2Um5kVFIwWkdUbFprV0ZKVmNGQldiVEUwWWpKUmVGTllhRlZpYkVwWVdWUktVMk5XVm5OYVJGSllVbTE0ZVZkcldrOWhiRXB6VjI1d1dsWldXbEJaVkVGNFZqSk9SMWRzV2xkTk1taDVWbTEwVm1WR1pFZFdia3BvVW0xb2IxUldhRU5OYkdSWVpFZEdWRTFFVmpCVk1uUnJWbGRLUjFkc2FGcGhNWEJZVkd0YVlWWldSblJTYlhCT1lYcFdObFl5ZEc5Vk1WVjVVMnRvYUZKc1NsWldiR1J2VWtaa1YxZHRSbXBOV0VKR1ZsZDRZVlJzV1hoVFdHUlhWa1Z2ZDFsVVJscGxSbkJHWVVkb1UySldTbGRXYlRWM1ZqSlNjMkpHV2xoaVJuQnlWRlpvUTFOR1pISlhhemxWWWtad2VWa3dVbUZXTWtwVlVXcFNXbVZyV2xkYVZWcDNVbXhrYzFWdGJGTk5iV2hhVmpGa05GVXhSWGROU0doV1lrZFNhRlZzVWxkak1WWjBUbFZPVTAxWGVGZFdNbmhQWVVaS1ZWSnVjRlpOYWxaMlZtcEdXbVZzUm5KbFJuQm9ZVE5DU1ZaWGNFZFpWMUpYVkc1T1lWSXllRmhXYlRWRFRrWlplRnBFUWxwV2JYaFpWbTEwYTFZeVNuTlRia1poVmpOb2FGbHFSbE5XTVdSMVdrZDRhVkp0ZHpGWFZFSlhWREZrU0ZKcVdsTmhNbWhoVkZWYWQxSkdXbkZTYTNCc1lrWktlRlpYZUd0aFZscEdWMnhHVjFZelFraFhWbVJPWlVkT1JtRkhhRk5XUmxwYVZsZDRWMlJyTVZkWGJrWlVZV3hLYjFSWGVHRk5SbHAwWkVkMFdGSXdjSGxaTUZVMVZqSktTRlZVUWxwaGExcFlXa1ZWZUZkRk9WaGlSVFZYWVROQ1lWWnJaRFJoYXpWWVUydGtWR0pyTlhGVmJURTBZVVphYzFwR1NtdE5WbkF3V1hwT2IxWXdNVmhWYm14YVZsWndjbGxXV21GU01XUnlZa1prYVZKcmNFMVdWekI0VmpKTmVGZHVWbFZpVjNoVVdXeGFTMlF4V25GUmJYUnBZbFphZWxZeU5VZFZNa3BXVjJ4a1ZWWXpUalJVYTFwclkyMUdSbVJHV2xOaVNFRjNWbXhqZDA1V2JGZFhXSEJXWWxkb1ZsbHJXbmRqYkZwelYydGthazFXU25wVk1uTXhWakF3ZVdGR2NGZGlXRUpNVkd0a1JtVkdjRVphUjBaVFZqSm9XRmRYZEd0aU1XeFhZa2hLV0dFelVsVlZiWGhYVFRGWmVVNVZkR2xTYkd3MFZqSjBhMWxXU2xkalNGcFhZV3RHTkZWcVNrOVNiVTVIV2taa2JHRXhWak5XTVZwVFVqRlZlVlJ1U2s1V2JYaFhXV3hrYjFaR1ZuUmxTR1JZVm0xU1dWcFZXazlWTURGRlVXcFNWMkpZUW1oV1ZFcEdaV3hHZFZSc1dtbFhSVEUwVmtaYVlWWnRWbGhXYTFwVllrZFNUMWxVVGtOWGJHUlhWbTA1YTAxV2JEUldNV2gzVlcxRmVtRkdXbHBXUlZveldWVmFWMk5XVG5Ka1JrNU9WbTVDTmxac1pEUmhNVlY1VTJ0c1VtSkZXbGhaVkVaM1lVWmtWMXBHU214V2JIQXhWa2N4UjFVeVNrZGpSbVJZVmpOb2RsWlVSbUZqTWtwSlUyeG9hV0pXU25wWFYzUmhaREF4UjJFelpGaGhlbXhaVldwQ2QxWXhXblJqUms1WVlYcEdTVmxWVmpSV01ERkhZMGRvV21WcmNGQlZiVEZYVWpGd1NHRkhhRTVOUlhCVFZtMTRhbVZIVm5KT1ZtUllWMGRvY1ZWc1pHOWpSbFp4VTJwU2FVMVdTbGRaVlZaUFYyeGFjMk5FUWxWV1YyaDJXVlJCZUZadFNrVlZiR1JPVmpKb05sWnRNSGhTYlZaWVVtdGtXR0pJUWxoVVZFcHVaV3hhZEdSSFJtcE5helY2VmpKNFYxVXlTa2hWYkZKYVlrZG9kVnBFUm10amJGcHpXa1UxVTJKV1NrbFdha2t4VkRKR2MxUnJhR2hTYlZKV1ZtMTRkMVJHVlhkWGJrNVhZa1p3V2xsVldtOVZNa3BIWTBSV1dGWnNXbWhaVkVaVFpFWktkVlJzYUdobGExcGFWbTB3ZUZWck1VZFhhMVpUWVhwc1ZWVnRkSGRsVm1SeVdrVmtWazFyY0hsVk1qVnJWakZhTmxKWVpHRlNSVnBRVm1wR2QxTldUblJTYkU1VFlUTkNZVll4WkRSWlZrbDNUbFZrWVZORmNHOVZiR2hUWWpGU1YxWnVaRTVTYlhoWFZqSXdOVmRIU2tkalJXUlhUVzVDVEZkV1dtRldNazVKVTJ4a2FWSnVRa2xYYTFaaFV6Sk5lVlJyWkdGU1ZGWlZWV3hXZDFSR1duUmxSM1JQVWpCc05WVnNhSE5WTWtweVRsWldXbUpZVWpOV01WcHpZMnh3UlZWc2FGTmlXR2cyVjFaV2FrNVdXbGRUYms1cVVsZFNXRlJYTlc5amJHeFlaVWRHYW1GNlZscFpNRnByVlRBd2VXRkdSbGRoTWxFd1YxWmtUMlJHVGxsalIyaFRZbFpLV1ZaWGVHdE5NREZIV2tab2FsSlhVbGhaYkZwaFYwWlZlVTVWWkZoU01IQkpWbGMxUTFkdFNrZGpSWGhYVFc1b2FGcEZWVEZYVm5CSFZHMXNWMkV4YTNkV2JUQjRaREZzVjFkcmFGUmhNbWhYV1d0YVMxWnNXblJOVms1WFVtNUNXRll5TVRCaGJVcEpVV3RrV0dFeGNISldWRXBHWlZkU05sRnNaRmRTVnpoM1YxaHdSMWR0VmtkVWJsWldZa1p3V1ZWcVJrdGhSbVJ6V2tSQ1UySldXa2hXYlRWSFZrZEZlbFZzVmxkaVdFMTRWRlZhYzFac1pISlBWbVJPVmxkM01sZFdWbXBPVmxsNVUyeFdVbUZzU2xaV2JHUlRWVEZ3UlZGWWFGZGlTRUpJV1ZWa2MxVXdNWFJoUmtwWFlsUkZNRlpVU2s1bFJuQkhXa2RzVkZKWVFscFhWekI0VlRGYVIxVnNaRmhoTTFKeldXdGFkMDFHYTNwalJtUlhUVVJHV0Zrd2FIZFhhekZJWVVST1YwMXVUalJWTUdSSFVsWlNjMXBIYUdoTlJtdDNWbTF3UTFsV1dYbFVXR2hUWW1zMVdWbFljRmRXUmxKWFZtNWtWMkpHY0hwWGEyaHJWa1V4Vm1KRVVsWk5WMmgyV1ZkNFMxZEhSa2hQVmxwcFVtdHdXVmRYY0Vkak1rMTRZMFZvYWxJemFGUlphMmhDWkRGYVIxWnRPV2hOYTFZelZGWm9UMVV5Um5OWGJHaGFZa2RvVkZwSGVHRmtSMVpJWkVaU1UwMUdjRXBYVmxaaFdWWlNjMU51VmxKaGVrWllXV3hvYjJGR2JEWlRhemxxVFZoQ1NsWlhlRTloVmtsNFUyeFdXRll6YUhaWmFrRXhZekZrV1dKSGRGTk5NRXBSVm0weE5HTXdOVmRXV0d4clVqTlNiMWxyVm5kU01WVjVaVWRHVjAxcmNGcFpWVkpQVmpGYVYyTkhhRnBsYTFweVdUSXhVMU5IVWtkYVIyaE9WMFZGZUZadGNFdE5SbXhZVWxob1ZtSnNTbFZaYlhoTFlqRldkR1JIUmxoV2JIQXdWRlphUzFSc1NuUlZiR2hZWVRGVk1WbFhjM2hYVmtaeVkwWmFhVmRIYUUxWFZscGhWREZLYzFSdVRtbFNiVkp3Vm10V1IwNUdXbGRWYTNSWFRWWnNORmt3Vm10aFJrbDZWV3hTVlZaRldreFdiWGhoVWpGa2RHUkdXazVXTVVwSlYxWlNUMkV4V1hsVGEyaFdZa2RvWVZscldtRk5NVlY0VjIxR1dGSXhXa2xVTVZwcllWWmFXVkZyYkZoV1JVcFVWa1JHV21Rd01WZGFSM0JVVWxoQ1dWZFdaREJaVm1SSFlUTnNUbFpyTlZSVVZscDNUVVpzY2xkdGRHaFdhelZIVlRJeFIxWXlTbFZTYWs1V1RXNU9ORlpxUm10WFYwWkhZVWRzVTAxdGFGZFdNVnBUVXpGVmVWUnNaRmRYUjFKWVdWUk9VMWxXV25STlZGSlhZa1phTUZSV1ZtdFdWMFkyVW14b1drMUdjSHBYVmxwaFYwWldjbUZHY0ZkU1ZuQk1WMnhXWVZReVRuUlNhMlJvVWpKb1QxWXdWa3RXYkZwMFpFZDBUMUp0VWpCV2JYUnJWbGRLY21OSVFsWmlWRVpVV1RCYVYyTldTbkpYYlhST1ZqRktXbGRVUWxkaE1WcHlUVmhLVGxaR1NsbFpWRXB2VkVaa1YxZHJkR3BOVlRVd1ZERmtSMVl5Vm5KV1dHUlhZV3RhYUZsVVJtdFRSbHB5V2taV2FWSlVWblpYYkdRd1dWWk9WMWR1VG1GU1JrcGhWbTB4VTFOV1ZYbGtSMFpWVFZad01GbFZXbUZXTWtwVlVteFNWMkV4Y0ZSV2JYaHJaRlp3UjFSdGJGUlNWWEJNVm0xMGEwNUdiRmRWYmxKVFYwaENVMWxVVGxOWFJscDBUVlU1VDFKc1duaFZiWGgzWWtaYWNrNVliRnBXVm5Cb1ZqQmFTbVZHVG5SUFZtUlhUVEZLV1ZZeFdtRmpNVmw1Vkd0a1lWSnRhRzlhVnpFMFpVWmFSMWR0Um10TmJGcDZWMnRvUzFsV1NqWmlSemxXWVd0YWFGcFhlRnBsVlRGV1drWmtUbUV6UWxkV1ZtUjNWVEZhV0ZKWWJGWmlSVFZvVm0xNGQxWkdjRWRYYkU1cVRWaENTVmxyWkhOVk1XUkdVMnhLVjJKVVFqUlVhMlJLWlVaYVdXRkdhR2xTTVVwYVYxY3hORk14VmtkWGJrNVhWa1ZhV0ZadGVHRk5SbkJXWVVkMFdGSnNjREZWVjNoclYwZEZlRk5yVWxkaGEwWTBWV3hhUzJOc1pITlhiV3hZVWxWd1JsWnRNWGRTTVd4WVZXdG9VMkV4V2xaWmEyUlRZakZzVlZSclRsUldiVkpXVlRKd1UyRkZNWEpOVkZKWFlsUldVRll3WkV0WFYwWklUMVpXVjJKWGFFVldiRnBoVjIxV1dGWnJhRk5pU0VKWVdXdGFXazFXV25KWmVrWlZUV3RhZWxVeWVHOVdiVXBIWTBkR1dtRXlVbE5VVlZwaFkyeGtjMVJzYUZOV1JWcGFWa1JHYTAxSFJsZFRibFpTWVd4d1dGUlhOVk5rYkd4VlVtMUdWMkY2UmxoV01uaHJZVWRLUjJOR2JGZFdNMEpRVmxSS1QyTXhaRmxhUjBaVFYwWktlRlpHV2xaTlZURlhWMnRvYkZJd1dsWlphMVozWld4YWRHTkdUbGROYTFZMFZUSjBiMVl4V2taWGJVWmhWbGRTVUZWdGVIZFNNVnAwWWtab1UwMXRhR0ZXYWtaclRVZEZkMDFJWkU1V2JWSlpXVlJLVTFkR2JISldWRVpZVW14S1dGWXlOVTlVTVVwelZtcFdZVlpXY0hKV2JYTjRZMjFPUlZKc1dsZE5NbWg1Vm0xNFlWbFZOWE5YYmxaWVlraENUMWx0TVc5aFJtUnpWMnhhYkZKc2NIcFhhMmhUWWtaS2NrNVlRbGRpV0ZKNlZHdGFZV1JIVGtaa1JUbFRUVVpaTUZac1l6RlVNVnBIV2tWb2FGSnNXbUZXYTFaMlRVWlplRmR0Um1waVJuQXhWakp6TVZVeVNsbGhSbVJYVmtWdk1GWkVSbHBrTURGWFYyMXdVMUpXY0ZsV1Z6VjNVakF3ZUZkc1ZsSlhSMmh5Vm1wQ1lWTkdXblJsUnpsWFRVUkNORlV5TURWV01rWnlZa1JTVjJGcmNFOWFWVnAzVWpKS1NHSkdUazVOVlhCV1ZqRmFiMlF4V1hoWGJHUllZVEpTYUZVd2FFTmpNVlp6Vld4a1ZGSnNiRFJaVldNMVlVWktjbUo2U2xwaE1rMHhWbXBLUzFkV1ZuRlViRnBPVW01Q05WZHJVa2RoTWxKR1QxWmthRkl5ZUZoV01GWkxVekZaZUZkc1pGcFdiRlkwVmpGb2ExUnNXbGhWYmtaV1lXdHdkbGRXV2xOV01XUjFXa1prVTJKclNraFdiWGhUVmpGWmQwMVdaRlJoYTBwaFdWUkdkMVZHV2tobFIwWllWbXRhTUZWdGVHdGhWbHBHVTFod1dHRXhTa3hXYWtaTFkyc3hWMWR0UmxOaVNFSmFWbGR3UzJJeFduTlhia1pTWWxoU1YxUldaRk5UUm14eVYyMDVhVkpyYkROV01uaHZWbFphYzJORmVGZE5WbkJVV1hwR2MwNXNXblJoUjJ4WFYwVktTbFl4WkRCVk1WRjRXa1ZvVTFkSGFGbFpiWFIzV1ZaYWRXTkZaRlZTYkZZelZqSjRhMkZzV25KWGJuQmFUVVp3Y2xacVNrdGpiRTUxVjJ4a1RsWnVRbTlXTVZwaFZHMVdWMVZzYkdoU2JXaHdXVlJHZDFkR1pGaGtSM1JwVFdzMVNGWnROVk5VTVZwV1RsaENWVlp0VWxSV01GcGhWMGRTUlZGc1pGZFdSVnBaVjFkMFUxVXhXWGhYYWxwWFlrZG9XRmxyWkZOVVJsVjNXa1ZrVkZaclducFhhMVV4VlRBeFZtSXpiRmRpVkVVd1YxWmFjMVl4VGxsaFIwWlVVbXR3VlZkWGVHOVZNVkY0VjI1T1ZtRXhjRTlWYlhoM1pVWlZlRlZyWkZkaGVrWllWVEkxZDFZd01YVlZiV2hYWVRKU1RGa3lNVTlTTVdSeldrZHNXRkl5WkRaV01WcFhXVmRSZUZkWWFHRlRSVFZXV1d0a1UxUXhXblJPVlVwclRWWndXVlJXVWxOaFZURlhWbXBPVlZac1ducFdWekZIWXpKT1IyRkdjRmROTVVsNVZrWldZV014V2xkVGJsSlRZa2RTVDFacVJrcGxSbHB5V1ROb2EwMVdWak5VVm1oVFlVWktObUpHYUZkaGF6VkVWbFZhYzJOV1NuUmtSazVPVm14dmVGWnNZM2hPUmxWNFYydG9iRk5IYUZsV2FrNXZZVVpXTmxKck9WTk5WMUo2V1ZWa05GVXhXa2hsU0ZwWFlsUkZkMXBFUVhoV01WcHpXa1phYUUxc1NsbFdSbFpUVWpGa1YxZHNaR2hTTTFKWlZXMTRkMDFHV2xoa1IzUmFWbXh3ZWxrd1ZqUlhiVlp5WTBWb1ZtRnJXbGhhUldSTFVqRlNjazVWTldsV01sRXhWbTB3ZUU1R1ZYaFNXR3hUVjBkb1dGWXdaRzloUmxaMFRWWk9XRlp0ZURCYVZWWXdZV3N4VjFacVRsaGhNWEJRVmpCYVlXTXhaSEZSYlVaWFZqRktTVmRYZEdGVE1rMTRWMjVHVjJKVldsUldha3B2WlZaa1YxZHRSbFJOYXpVd1ZrZDBWMVV5U2tkalJtaFZWa1ZhUzFwWGVHRmtSMDVHV2taU1RsSkdXalpXVkVreFZqRmtTRk5yYUZaaVIyaFhXV3RhWVZsV1VsWlhiVVpZVWpBMVIxcEZXbGRVYkZwVlZteHNXRlpGU2xoWlZFWnpWakZPZFZWc1dtaGxiWGhYVm0xNFlWbFZNSGhXYmxKc1VtNUNjMVpxUmt0VFJscElaVVYwYUZac2NIcFpNRlp6VmpKR2NsZHVXbHBoYTFwNlZtcEdVMk5zWkhKUFZtUk9ZbGRvV1ZZeFdtdE5SMUY1Vlc1T1dHSnJjRmxaYlhNeFkxWlNWMXBHVG14V2JrSkhWMnRTUTJGR1duSmpSRVpXVmpOU2VsWnFTa3RXVmtwVlVXeGtVMUpXY0ZoWGExSkNaVVphYzFkdVRsVmlWMmhQV1d4a2IySXhXbkpYYkdSYVZqRkdOVlZ0ZEd0WFIwcHpVMnM1VjJKR2NETlpla1poWkVkV1NGSnRlR2xTTTJnMVZtcEpNV0V5UmtkWGJrcHFVMGhDWVZsWGN6Rk5NVnB4VTJ0MFYxWnJjRlpWVjNocllVZEZlbEZzVmxkV1JVcG9WMVprVDJSR1NuSmFSa3BwVWpGS2QxZFdVa05rTVdSelYxaG9ZVkpGU25CVVZsWlhUVEZTYzJGRk9WaFNNSEI1VmpKNFUxZHRSWGhXV0doWFZrVmFWRlpxUm5kU1ZsWnpZVVpPYVZKc2EzaFdNbmhYWVdzMVYxZFliRlJpUm5CWVdWZDRkMWxXV25OWGJtUnFZa1p3ZWxZeU1VZGhhekZ5VGxWYVYxSXphRE5XYWtaaFpGWkdjVmRzWkZObGExVjNWbXRTUzFReVRuSlBWbVJoVW14YWNGWnFTbTlsYkdSWVpFZEdhMDFYZUZoV01XaHZXVlpLUmxOdE9WVldNMDQwVkd0YVdtVkhSa2hrUmxacFVtNUNObGRVUW1GaU1XUnpWMWh3VlZkSGFGaFVWVnAzWld4c05sSnNaR3BpU0VKSFZHeFZNVll5U2toa1JGWlhZa1p3YUZscVNrcGxSbVJ5V2taU2FXRXpRbmhXVnpBeFVURnNWMWR1VGxoaWJWSnlXV3RhYzAweFdYbGtTR1JwVWpCd1YxWXlkRzlYYlVWNFkwaGFWMkZyY0ZoWk1uaGhZMVpTYzJGSGFFNVdXRUpPVm0xMFUxTXhVblJXYTJSaFUwWmFXRmxyV21GalJscHpWMjVrVjFac2NGbFVWbEpEWVRBeFdGVnVjRmROYm1oMlZrZDRUMU5IUmtkUmJGcHBVbXR3U1ZaVVFtRlpWbVJHVGxaYVVGWnRVazlaVkVaeVpWWmtXR1JIY0U5V2JIQXdWVEo0YzFadFJuSk9WMmhYWVdzMWRscFhlSEpsVjFaSFdrZHdhR1Z0ZUZsV01uUldUVmRHUmsxSVpGUmlSMmhZV1d4U1EwNUdVbkpYYTFwc1VtMVNXbGxWV2xOWFJrNUdVMjVhVjFZelFreFpha3BIVWpGYWRWUnRSbE5oZWxaYVZsY3hORmxYVm5OWFdHeHJVak5TYjFsWWNFZFhSbXQzWVVoa1dGSXdWalZXVnpWM1ZqRmFSbU5GZUZwTmJtaFFWbXhhUzJNeGNFaGhSMmhPVjBWS01sWnRNVFJWTVVsNFZHNVNWMkV5VWxkWmEyUTBZMFpXZEdWSVpHcFNiRnA0VlcxME1GWXhXblJWYkd4VlZtMW9NMVpIZUdGa1JsWnlZVVp3YUUxdGFFMVhWbFpoVXpGYWNrNVdaR2xTYlZKd1ZqQmtiMWRXV2tkVmEyUmFWakZLU1ZaWGRGZFZiVXBZWlVaU1dtRXlhRVJVYlhoclZsWkdkRTlYYkU1V2JrRjNWbFJLTkZZeFZYbFNXR3hvVW0xb1lWWnJWbUZYUmxKeVYyeGthazFYVWpCVmJURXdWakF4UlZacmJGZE5ibEp5V1hwR1dtVkdUblZVYlhCVFlraENXVmRYZUc5Vk1WcEhWbTVHVTJKck5WbFZiWGhMVjJ4c1ZsZHNaR2hXTUZreVZtMDFZVll4V2paUmFsSlhWa1Z3UzFwVlpFdFNNVnB6Vm0xb1RsSkdXbHBXYkdOM1pVWlZlVlp1VG1GVFJYQlhXV3RWTVZkV2JISlhibVJzVm14S2VsWnROVTlXTURGV1lrUmFWMVo2Um5aV01GcGhZekpPUm1SSFJsZGlWa3BaVmxjeGVrNVdXWGhqUldocFVtczFiMVJVUWt0WlZscDBaVVpPVWsxWGVGaFphMXByVmxkRmVXRkdhRnBXUlhCMlZtdGFjMk5zY0VkVWJGWk9Wak5vVjFaWE1ERmhNV1JIVjI1T2FsSnNjRmRVVmxwTFUwWmFkR016YUdwaVZUVkhXVlZhWVZSdFJuTlhiRVpYWWxoU2NsVjZSbXRUUmtweVdrZG9VMkpyU2xsV1JsSkNaVVUxUjFwSVNtRlNSa3B4VkZaYWQyVnNaSEpoUm1SWFVqQndXbGxWV2xOWGJVcEhZMFYwWVZKRlduSlpNbmhoWkVaS2RHSkZOVmRpUm10M1ZtMXdTMDFHYkZkYVJXaFRWMGhDVjFsclpEUlhSbXh6WVVjNWFGSnRlRmRXTWpWclZURmFjbU5JY0ZwTlIxRXdWbFJLUzFZeFRuRldiR1JvWVRJNGQxZFhjRXRTTVZsNFZXNUtXR0pHU25CVmFrNXZWMVprV0dWSE9WWk5WMUpJV1ZST2MxUnNXblJWYkZKVlZtMVNWRnBYZUdGa1IxWkdUMWRvVjJKSVFsbFhWRUpoWkRGWmVGZHFXbE5YUjFKb1ZXdFdSMDVHV25GU2JVWllWakJ3U1ZwVldrOWhSMVp6VjJwS1YySlVRalJVYTJSU1pVWlNjMXBIY0ZOaVNFSmFWMWN4ZWsxV1pGZFdibEpzVTBad1QxbHJXbUZYUm14V1dYcFdWMDFyY0VoWk1GWnJWMnN4UjJOSVdsZE5ha1pZV1RKNGEyTXlSa2RqUjNob1RWYzVObFpzWkhkVE1VbDRWR3RvVTJFeWFITlZha28wVjFaV2NWTnRPV2hTYkhBd1dUQldhMkZGTVVWU2EyeFdZa2RvY2xaSGVFOVRSbFp5VDFaa1RsSnNWalJXYWtKaFl6SlNTRlpyV210U2JGcFBWbTB4TTJWc1duUmxSazVUVFZac00xUldXbXRXUjBwSVZXeG9WMkZyTlZSWk1uaGhZMnh3Um1SR1RrNVdNVW8yVjFkMGExSXhXWGhYV0d4b1UwZDRXRmxzYUVOUk1YQldXa1U1YTFKc1NubFhhMXB2WVZaS2RWRnNiRmhXTTJoeVdXcEJlR014WkZsaFJtaHBWbFp3VmxaR1dsZGtNREZIVjJ0b2ExSXdXbTlWYlhSM1pXeHJkMWw2VmxoaVJuQkhWakp3UzFsV1dYcGhSMmhYVFVaV05GWnNXbGRrUjBaR1RsZG9iR0pHYTNoV2JYUlRVakZzV0ZKWWFHbFNiVkpWV1cxNFMxWXhiSFJrUlhSWFRWWktWMVl5TVVkV1ZrcDFVV3RzWVZaWFVraFpWM2hoWTIxT1JWRnNXbWxXUlZveVZtdGplRk14U1hsVWExWlhZa2RTVkZscmFFTmlNV1JYVld0a2FrMVdiRFJXUnpWUFlVWktjMk5JUWxwV1JWb3pWakJhYTFkSFVraGtSbHBPVm01Q1NWZFhkR0ZaVm1SSVUydG9WbUpyY0ZkWlYzUkdaREZTV0dWR1pHdFNNVnBKV2tWYVlWUnRSWHBSYTJ4WVZrVktWRlpVUmxwbFJtUjFWV3hXYUdKRmNGaFhWbVF3V1ZkR1IxWnVSbE5pV0ZKeVZtMTRZVTFHY0VaWGF6bFdUVlp3U0ZZeU1VZFdNREZYWTBaU1ZtVnJjRXRhVlZwaFkyeHdSMkZIYkdobGJGcDJWbXhrTkdFeFZYaFdhMlJwVTBWd1dGbHRNVk5qTVd4eVdrUlNWMDFXYkRWVWJHUXdZVVpLY21KRVRsZE5Wa3BNVm1wS1MxZFdSbkpsUm1Sb1lUTkNTVmRVU2pSVU1sSlhWRzVPV0dKWGVGaFZiRnAzVjJ4YWMxcElaRk5OYkVZMFZrZDRhMWRIU25KT1Z6bFdZV3R2TUZacldsTldNVnAxV2taa2FWSnRkekZYYkZaclRVWlNjMU51VW14U2JXaFlXV3hvVTJOc1pGZFhhemxUWWxVMVNGZHJXbmRXTVVwVlZteFdWMkpZYUdoV1ZFWmFaVVprZFZadFJsTldSbHBWVjFkMFlWZHJNVmRhU0VwWFlsaFNUMVZ0TVZObGJGbDVUbFYwYUZacmNFaFdNakZ2VmpKS1NGVnVXbFpoTVhCaFdsWmtWMU5HU25OVWJXeFRWa1paTUZadGRHcGxSa2w0Vmxoa1RsTkhlRzlWYm5CelYxWnNWVkp0Um1waVJuQkdWVzEwTUdGck1WZFhha1pYVW5wR1NGWlVSbUZTTVdSMVYyeG9hVkl4UmpOV2JUQjRWakZKZUZwSVZsWmlXR2hVVkZWYWQyUXhXa2RhUkVKcVRVUldTRll4YUhOaVJrbzJZa1pvVm1GclNsaFViRnBoVjBVMVZscEdaR2xXV0VGNFZsWmpNV1F4V1hsU2JrcFlZbTVDV0ZsclduZFVSbkJHVjJ0MGFrMVdjSHBXUnpGelZqSkZlbEZ0UmxkaVZFWXpWWHBCTVZJeFZsbGhSMFpUVmpGS1ZsWnFRbXRpTVZwWFlrWldWV0V3TlZsV2JURTBWbXhWZVdWRmRHaE5SRVpZV1RCV2MxbFdXbGhWYTJoYVZqTk9ORmt5Y3pGV2JVWkhZMGRvVGxkRlNqVldiWFJxWlVaTmVWUllhRlZpYkZwd1ZXMHhVMVpHYkhKWGJtUnNWbXh3V1Zrd1ZtdFdSVEZ5VGxoc1ZWWnNjSEpaVmxwTFl6Rk9kVkZzWkU1U2JIQk5WbTE0WVdFeFpFaFdhMmhUWWtaS1QxWnFSa3RYVmxweFUycENhRTFYVWpCV2JUVkxWMGRLUms1V1dsZGlWRVpVVm10YVZtUXhaSE5qUjNoWFZrWmFXRmRyVm1GaU1WVjNUVlZzVW1KSGFGaFpWM1IyVFVac05sSnRSbXRTYXpWNldXdGtiMVV3TVhSaFJtUlhZbGhvYUZwRVNsZGpNV1IxVlcxNFUwMHhTbmxXYlRBeFVURk9SMWR1VWs1WFJUVlhWRlphYzA1c1pGVlViWFJYVFd0d1NGVXlkRFJaVmxvMlVteG9WbUZyV2pOVmJURkhVakZTYzJGR1RrNWlWMmhvVm1wR2EwNUhSWGxUV0doaFVsZFNjRlZ0TVc5amJGWnhVVzFHYWxadGVIbFdNakZIWWtaS2MxWnFWbHBOTTBKWVZtMXplR050VGtaalJscFhUVEZLTWxadGNFZFRNRFZ6VTI1V2FsSnRVbGhWYkdoRFZGWmtWVk5xVWxWTmF6RTBWVEkxVDFsV1NYbGxSbEpWVm14YVdGUlVSbHBsUm5CSldrWk9UbFpZUVhkV2JGcHZZVEZTYzFkdVRtcFNNbWhYV1d4U1IyUnNhM2RYYms1WFZteEtlVlpIZUc5V01rcFhVMnh3V0dKR1duRlViRnBYWTJzeFdWTnJOVmRTYTNCWlYxZDRVMVl4V2tkWGEyaHNVakJhVkZSV1ZURmxiR3h5VjIxMGFGWnRVa2xYYWs1M1ZqRmFSbGR0YUdGU1JWcE1XWHBLUzFKV1pITmFSMnhUVFZWd1VWWnRNVFJoTURCNVZtNU9ZVkpzV2xOWmJGSnpZMnhTVjFkdVpHeFdiRXBZV1ZWYWEyRkdTbkpPVldSYVRVWndkbFl5ZUZwbGJGWnhWR3hrVTFadVFYcFdWM0JIWVRKT2MyTkZhR3RTYlZKUFZXdGFZVk5zV1hoWGJHUmFWakJXTlZWdGVHdFdWMFY0WTBaV1dtRXhjRE5XTUZwell6SkdSbFJzVGxOaVdHaFhWbGN4TkZNeVNrZFRiazVVWW01Q1dWbFVSbmRYUm14WFdrVjBVMkpWTlVwWk1GcHJWakpXY2xkVVNsZFNiSEJ5VmtSR1NtVkdjRWRpUjBaVFRVWndWVlpHVWtkVE1WWkhWMnRrV0dKVlduSlVWM2hoVjBaa2NtRkZkRmRpVlhCSFZHeGFjMWR0UlhoalJFNWhWak5vV0ZwRlpFOVNNWEJIV2tkb2JHRXhiRFJXYlhocVRWWnNWMWRZYUZoaE1YQlpXVzEwZDFZeFVsZFhibVJVVW01Q1IxWnNVbGRXTURGWVZXcENXbUV4Y0ZCWlZtUkdaREpPUlZOc1pHbFdSVWt3VjJ0U1IxTnRWa2hUYTJSb1VteHdjRlZxU205V01XUlhWV3RrYTAxcldraFdiVFZUWWtaSmQxZHNhRlppVkVVd1dsWmFXbVZWTlZaa1IyeFRZa2hDTmxkVVFtRmlNVmwzVFZoR1VsWkZXbUZXYlhoWFRrWnJlV1ZIZEd0V01EVklWMnRWTVdGSFNrZGpSa3BYVFZad2NsUnJXazVsUms1MVZHeFdhV0Y2VmxwWFYzUmhXVlprUjJKSVNtaFNWWEJ6V1d0YWQxTkdXbGhrUjNSb1lYcEdXRmxyVWxOWFIwVjVZVVY0V2xZemFFdGFWekZIVWpGV2MyTkdhRlJTVlhCYVZtdGplRTVIUlhoWFdHaFlZbXhLVkZsc1pEUlVNVnAwVFZST1RsWnNjREJVVlZKSFZrVXhWMkpFVmxaaVZGWk1Wa1JHWVdSSFJrZGFSbkJYVFRBeE5GWnRkR0ZqTVZweldraE9ZVkpVYkhCVmJHaERUbFprVlZGdGRFOVNiRlkxVlcxd1lWWXhaRWhoUm1oYVlrWktSMVJWV21GU1ZrNXlXa1prVGxaVVZqWldiVEUwWVRKR1dGTnNaRlJpUjNoWlZtMHhVbVF4VmpaU2JYUlRUVlp3ZUZZeWVFOWhWa2w0VTJ4V1YxSnNjSFpWVkVaUFVqSktSMWR0UmxOU1ZYQllWa1pXVTFJeFRrZGhNMlJvVTBVMVdWVnRlSGROUm14V1ZXczVWMkpWV25sV01qVkxWbTFHY2xkdVNsZE5WMUpJVlRCa1IxSXhVbkpPVlRWWFYwVktiMVp0TVRSaE1sRjRVbGhvWVZORmNFOVdNRlV4WTBaVmQxWnVaR2xOVmxwNlYydGFUMWRHV25SbFNHeFlZVEZ3VUZaclpFdFNNV1J6WWtkR1YxWnVRbEZXYlhCSFYyMVJlRmR1UmxaaVNFSlBWV3BLYm1Wc1duUmpSWFJVVFZkU1dWVnRkRzloUmtsM1YyeFNWMkpZYUZkYVZWcGhaRWRPUmxwR2NGZE5SRlkxVmtkNFlXRXhiRmRUV0d4c1VtMTRWMWxYZEdGU01YQlhWMjFHYTFKVVJsWlZWekZ2Vkd4S1IxZHJjRmRXUlZwMldXcEdWbVZHY0VaaFIyaFRUVzFvV0ZaR1ZtRldiVlpIVjFob1dHSnJOWEpWYWtFd1RXeFdkR1ZIT1ZkTmEzQmFXVlZhYTFZeFdrWmlSRTVWWWtad2NsbDZSbXRrVmxaMFpVWlNWRkpWY0c5V2JURTBZVEZTY2sxV1pHbFRSWEJvVld4b1UxWkdVbGhqZWtaVVlrZDRWMVl5TVVkaFJscHpZMFZvVjAxcVZucFdha3BMVWpGT2NsUnRSbGRXTVVwUlYxUktlazFXV1hoYVNGSnBVbXMxY0ZVd1ZrdE5NVnAwWTBWT1YySldXa2RVYkZaclYwZEtjMU51U2xaaGEwcG9WbXhhVTFkSFRqWlNhelZUWWtoQ1NsZHJWbXRTTWtaR1RWWmFhbEpGU2xoV2JuQlhVa1phY1ZGWWFGTk5WMUo1V2xWYWExVXhXblZSYlRsWFZqTkNTRmxVU2xOU01VNTFWR3hXYVZZemFGbFhWM1J2VVRGa2MxZHVUbFpoTTBKUFZtMTRSMDVXVm5Sa1IzUlhVakJ3ZVZSc1dsZFhiVXBaVld0NFYyRnJXbnBXTUdSVFUwWktjMVpzVG1sVFJVa3lWbTF3U21WRk1VZGFSV1JVWWtaYVZGbFVUa05aVmxwelYyNWthRkpzY0VsYVZXUkhZVEZhY2xkdWNGcGhNWEJ5V1ZWa1JtVlhVa1ZWYkdSb1RWVndTVmRZY0VkWGJWWkhWVzVXVTJKSGFIQlZha1pMWkRGa1YxVnJPVkpOVm13MFZqSTFVMVJzVGtoaFJtUlZWbXh3TTFVd1dscGxWVFZYVkcxc1UyRXpRalpYVkVKdlZERlplVkp1U2xoaE0yaFhXV3hvYjFkR1dYZFdXR2hZVWxSc1dWbFZXbXRoUlRCM1UyMW9WMkpHY0hKYVJFWmFaVVprV1dKR1RtbGhNMEozVjJ4a01GTXhiRmRqUm1oclVqQmFjVmxyV2xkTk1WbDVaRVJDV0ZKc2JETldNblJ2VjJ4YVdGVnVXbHBXVjFKWVdYcEdhMk15VGtkYVIyeFhVbFpzTmxadGRGTlNNVlowVlZoa1QxWnNjR2hWYlRGVFkwWnNjbFp1WkZaU2JIQXdXbFZhVDJGck1WZGpSV2hYVFdwV1ZGbFVSa3BrTVdSMVZHeHdhRTFzUlhkV2JYQkhWMjFXVmsxV1ZsSmlWMmhVV1d0b1EwNVdXa2hsUm1Sb1RWWndlVlJXYUZkVmJVcEhVMnhvV2xZelVqTlZha1ozVm14d1JrOVdVbE5OUm5CSlYxUkNZV0V4VlhoWGJsWlNZWHBXV0ZSWE5WTlhSbVJYVjJ4d2JGSnVRa2haVlZwVFlVVXhjMU50T1ZkV00wSk1XV3BHVW1WSFNrbFZhelZYWlcxNFdsWnRNVFJqTURWSFdraEtWbUV3TlZsWmExcDNUVVp3VmxkdVRsZE5WV3cyVmxjMVMxZHNXbk5qUmtKV1lsUkdVRlV3VlRWV01XUjBZa1pPYVZKc2EzZFdha1p2WkRGSmVHSkdhRlpoTW1oWVdWUktOR0ZHVm5OVmJHUlhVbTE0ZVZadE5XdFVNa3BJVld4b1YySlVSWGRXUjNoTFl6SktSVlJzVmxkaVYyaE5WMVprTkZNeVVraFNhMlJoVW01Q2NGVnFTbTlTVmxwMFpFZEdXbFl3TlZoVk1qVkxZV3hKZW1GSVFsZGlSbkF6VlRKNGExWXhXblJTYldoT1lURndXVlpVUm05aU1WcElVbXBhVTJKSGVHRldhMVpoVFRGc1ZsZHNaR3BXYXpWNVZHeGtORlV5UmpaV1dHaFhZVEpPTkZWcVJsWmtNREZaVm0xb1UySkdjRmxXVnpFMFpERmtSMWR1UmxKWFIxSnpWVzB4VTAxV1draGxTR1JWWVhwR01GbFZXa2RXTVZvMlVsUkNXbVZyUlhoV2FrWnJZMnh3U0dGR1RteGlXR2hhVm10YWEwMUhVWGxXYms1WFYwZDRVRlpzYUZOWFJteHpWbTVrVjJKR1dqQlViR1JIVmpBeFJWSnJhRnBOUjJnelZtcEtTMUl5VGtkUmJHUnBVbTVDV1ZkclZtdFdNVWw0WTBWb2FWSnNTbFJXYkdRd1RsWmFkRTFZWkZOTlZsWTBWbFpvYzFVeFpFaGhSbVJhWWxoTmVGWXhXbk5rUjA0MlVtMXdWMkpHY0RaV01uUnFUbFprUjFOdVRsUmlSM2hXV1d0a1RrMVdiRlpYYTNScVRXczFSMVl5ZUdGaFZscEdWMnRzVjJKWVFreFZha0V4WXpGa2RWUnRhRk5pYTBwMlZrWmFiMUZ0Vm5OWGJsSnFVbFZ3Y2xSWGVHRlRSbHBJWlVoT2FHSkZjREJXVnpWRFZtMUtXV0ZFVGxwaGExcHlXVEo0VjJOc2NFZFZhelZvWld0VmQxWXhVa05XTWsxNFYyNVNWR0V4Y0ZCV01GWkxWMFpTVmxkdFJsVlNiR3cwVmpJeE1GWXdNVmRYYm14WVlUSlJkMWxXV21GamJHUlZVV3hrVG1Kc1NqSldXSEJIVjIxV1YxUnVUbGhpUjJod1dWUkNkMVl4V25STlZGSnJUVmRTU0ZaWE5VdFhSMHBaVlc1R1dtRXhjRE5VVlZwWFpFZFdTRkpzVm1sV1Zsa3dWMVJDVTFsV1dYaFhhMXBwWld0S1lWbFhkR0ZaVm5CWFYydDBXRll3V2toWlZXUnpWakF4ZEdGR2NGZGhNWEJZVjFaa1VtVldXblZVYkdocFlYcFdXbGRXVWs5Vk1rNVhWV3hrVjFaRldrOVZiVFZEVmpGWmVVMVVRbWhTYkhCNVdUQlNRMVpWTVZkVGJGSlhZV3R3VEZZeFpFZFRWazV6Vm0xb1RsZEZTVEpXYlhCRFdWWk5lVlJZYUdwU1YxSlhXV3RrYjFaR1VsVlRiVGxPWWtad2VsZFVUbTlVYkVwMFpVWm9XR0V4V25KWlZscFBVbXMxV0U5V1dtbFhSVEUwVm1wR1lWWXlVa2hXYTJScVVsUldjRlZ0ZUZwTlZtUlZWRzVrVjAxV2JETlVWbFpYVlRKS2RHVkdXbHBoTVhCb1drZDRXbVZYVmtoU2JHUk9WbTVDVjFaWE1UUmhNa1pJVWxod1VtRXllRmhWYm5CR1RVWmtWMXBHVGxkTldFSktWa2N4YjFVeVNsZFRiRUpYVW14d1dGcEVRVEZXTVdSMVUyMUdVMUpWY0ZsWFYzaGhXVlpPUjFaWWFHaFRSVFZZVldwQ1YwNVdjRlpYYkdSWVlsVldOVlpYZUZOWGJVWnlWMnhTVjJKR2NFeFpNakZUVTBkR1IxUnRiRlJTVlZsNlZtcEtORll4YkZkVldHaFhWMGRTVDFZd1ZURlhWbXgwVGxWT1dsWnNjSGxXYkZKSFlXMUtSMkpFVGxoaE1WbDNWbXBHV21ReVRrWmlSbHBwVjBkb2VWZFdXbUZoTVU1SFlqTndhbEp0VW05WlZFWjNZakZrV1dORlpGcFdNREUwV1RCV2MxWnRTa1pUYkdoYVlrWndURlpWV21GWFIxSkhXa1p3VjJKV1NsbFdNblJoVmpGV2RGTnJhRlppUlVwWFdXeG9iMDB4V1hoWGJGcHNWakZhU2xaSE1XOVZNa1Y2VVZoa1dGWnNXbkpaYWtaaFpFWk9jbHBIY0ZOaVZrcHZWbTE0WVdReVJrZGhNMmhZWVROU2NWUldhRU5UVm10M1ZsUkdXRkpyY0ZkWk1GWjNWakpHY21JelpGZGlXRTQwVmpCYVMyTXhjRWRoUm1oVFRUSm9NbFpzWTNoTlJrMTRXa1ZrYVZORk5XOVZiRlV4VmxaV2RFMVVVbGRpUmxwWVdWVmpOVll4U25KalNHeGFUVVp3TTFZeWVHRldNazVKVTJ4a1RsSnVRa3hYYkZwclVqRkplR05GWkdoU2JWSlBWRlpXZDA1V1duUmxSazVUVFd0V05GWXhhSE5XUjBWNVpVWmtXbUpIYUhaV2ExcFRWbXhrZFZwSGVGTmlTRUphVmtaYVUxVXhaSE5YV0doWVlUSm9XRmxyWkc5bGJHeFlaVVYwYW1GNlZsbFVNVnByWVZaS2NtTkZiRmRoYTBwb1dUSXhVbVZXU25KaVIwWlRZbFpLVUZkV1VrOVJNVmw0VjI1U1RsSkZXbFZVVm1SVFRVWldjMkZIT1doaVJYQmFXVlZrYjFadFNrZGpSRTVYVFVad2VsUnRlRTlqYlZKSFZHczFhR1ZzV2tsV2EyUTBXVlpSZVZKc1pGUmlhelZaVm10V1MxZEdiSE5WYTA1UFVtNUNSbFZ0ZEd0aE1VcHpZMGhzV2xaV2NGaFdNRnBLWlZkR1IxcEdhRmRsYTFreVZrWmFhMVF4U1hoWGJsWldZWHBXV0ZsWWNGZFhiRnBZVFZSU1ZFMVdjSHBXYlRWVFlURktSbE5zV2xWV00xSXpWVEJhY21ReFZuSlViSEJYWWtoQ1dsWnNaREJpTVdSelYyeGtWMkZzU2xoWmJGSkhWRVpXYzFkc1pHcE5hMXBKV1ZWVk1XRldXWGxoUm1SWFlsUkZNRlpVUms1bFJsSlpZVVpTV0ZJeWFHOVdWRUpXVFZkSmVGWnVVbXhTTUZwWlZXMTRZV1ZzV25ST1YzUlhWbXh3ZWxrd1ZuTldWbHB6VTJ4U1YwMXVhR2haTWpGTFVsWldjMkZIYUU1aVYyaFdWbTE0VTFNeFRYaGFSV2hUWVRGd1VWWnRNVk5qUmxweVYyMUdVMVpzY0hoVmJURkhWMnhaZDA1WWNGcGhNVXBvVmxSS1MxSXhUbkpQVm1Sb1lYcFdNbFpxUm1GWlZscFhWRzVHVm1KSFVrOVdiVEV6VFZaYVZWTnFRbWhOVm5CSlZUSjBiMkZHU25OalJtaGFZVEZ3TTFSVVJsTldWa3AwVW14T2FWSXhTalpXTW5SV1RsZEdWMU5zYkZKWFIxSlpXVlJHWVdGR2JIRlNiSEJyVFVSR1YxWnRlR3RoUlRGMFlVWndXRlpzU2toWFZtUlBZekpLU1ZKc1RtbFNWRlo1VmxjeE1HUXhaSE5pUmxwaFUwZFNWMVJYZEhkbFZsVjVaVWhPVjAxcmNGcFdWM2h2V1ZaSmVsUnFVbFpoYTFvelZXcEdkMUl5UmtoaVJtaFRZVE5DV0ZadGVHcGxSVEZJVlZoa1RsWnRVbGhXTUdRMFl6RldkR042Um1sTlZuQXdXa1ZvVDFReVNraGxSbVJZWVRKTk1WWXdXa3RqTWs1SlkwWmFUbUpzU2pKV01WcGhVekZLYzFwSVRsWmlSbkJ2V1ZSR2QxZFdaRmxqUlhSVFRWVTFTVlp0ZEd0V1YwWTJWbXM1VjJKSGFFTlVWVnBoWkVVeFNWcEhlRk5OVm5BMVZrWmFZV0l4V1hsVGJrcFBWbTE0WVZaclZuZGtiR3cyVW14a2ExWXdOVXBXUjNodlZUSktSbU5HY0ZoaE1WcDJXVlJHVm1Rd01WZGhSM2hVVWpKb1dWWlhOWGRTYlZGNFYxaGtXR0V6UW5KVVYzTXhVakZzVmxkdGRGVmlWVnA2VmpKemVGWXdNVmRqUjJoV1pXdGFURnBGV2xOamJHUjBZVVpPYVZORlNqSldNVnBUVWpKU2RGWnVUbGhpUjJoUFZUQmtiMVpHVWxkV2JrNVBVbTFTZVZsVldrOWhSbHB5WWtSV1lWWldjRlJXTWpGTFYxWldjbVZHYUZkaVNFSnZWMnRXYTFVeFRrZFRiazVxVW0xU2NGWXdaRzlYYkZwMFpFZEdhVTFyYkRSV01uaHJXVlpLV0dGSE9WWmlWRVpVVjFaYWMyTXlSa1pPVjNoVFlrZDNlbFpxU2pSa01rVjNUVlpzVW1FeWVGWlVWbHAzWkd4YWNWTnJkRk5OYTJ3MlYydGFiMVl4U2xWV1dIQlhWak5DU0ZaVVNrNWxSbkJKVm14V2FWZEZTbFZXVjNoWFpESkplRmR1VW14U00xSlhWRlpWTVZOR1dYbE9WV1JXWWtkU1NWbFZXbTlYYlVwSFZsaG9WbUpZYUZoYVJXUlhVMFpLYzFwRk5WTlNWV3QzVm14a05HSXlSWGhYV0d4VVlrZDRVMWxVU205WFJsSllZMFZrV0ZKdGR6SlZiVEZIWVRGYWMxTnFRbHBXVm5CUVdWWmFZV050VGtWVGJHUk9WbTVDVlZaclVrZFNiVlpIVm01T1lWSXdXbFJaYkdodlpVWmFXR1ZIT1ZaTlZuQjZWbGQ0YTFZeFdrWlhiR3hXWWxob00xWXhXbE5qTVZwVlZteGtUbEpGV2pWWFZFSmhZekZzVjFkc2FGVldSVnBZV1d0YWQyRkdWblJsUlRscVlsWmFTRmRyV210VWF6RjBZVWhhVjAxV1NreFVhMlJHWlZaV2NscEdVbWxpUlhCMlZsZDRVMVl5U1hoVmJHaFBWak5DY2xSV1duZE5SbkJHV2tSQ1ZVMVZiRE5XYlhCVFZqQXhjVlpzVWxkaE1sSk1XVEl4VDFJeFJuTmFSMnhYVWxad1ZsWnFSbUZaVjAxNVZGaHNVMkV4Y0ZCV2FrNXZWa1pzY2xwRVRrNVNiSEI0VlRGb2IxVXdNWEpXYWxKV1RWZG9kbFpyWkVabGJFWnpZVVpXVjJWc1dsQlhiRlpoWXpGWmVGcElTbXRTTTFKWVdWUkdkMWxXV1hsa1IwWm9UVlpXTlZVeWRITlZiVVp5WTBac1YySllhRXhWTUZwelZsWktjazlXVGs1V2EyOTRWbXRrTkdJeVJsZGFSVnBVWWtaYVdWWnFUbE5rYkZaVlVtMTBVMDFZUWtoWlZXUTBWVEpHTmxac1ZsZFNiVkV3VlhwS1YyTXhaRmxpUlRsWFZrZDRXbFpYY0VOa01WbDRWMWhzVDFaWVVsaFpiRlozVjJ4c1ZscEhPVnBXYkhCNldUQlNUMVl5U2xsaFJFNVdZbGhvTTFWcVJtdGphelZYV2tkc2FFMUdhM2RXYlRFMFdWZEZkMDVWWkZoWFIyaG9WV3hrVTFkV2JGVlNibVJZVm0xNGVsZHJZelZXTURGWVpVWnNZVkpYYUhKV2FrWkxZekZhY1ZSc1pFNWliRVl6VjFaamVGTXhUbGRTYmtwcFVteHdjRll3Wkc5VlZscHlXa2h3YkZJeFNrbFZiWFJYVmxkS1NGVnVRbGROUmxwTVZXeGFhMVl4Vm5KYVJtUk9ZWHBXTlZaR1dtRlpWbXhYVTI1U2FGTkZTbUZXTUdoRFYwWlpkMWR0ZEZkTlZscDVXa1ZhWVZSc1dYaFRhMnhYWWtkUk1GbHFTa1psUms1WldrWm9hV0Y2VmxsWFYzaHZZakZTUjFkWVpGaGlTRUp6Vm14U1IxSnNXblJsUjNSVllrWndXVnBFVG5kV01rcFZVbXBPVjJGclduSlpla1pyWXpGd1NHTkdUbWxXTW1oYVZtdGFhMlF4U1hoVFdHaHFVbTFTV1ZsclpGTmpiRnAwVFZaT2JHSkhVbmxXYkZKSFZtc3hjbU5JYkZaTlZrcE1WbXBCZUdSV1ZuTmhSbVJwVjBVME1GWnRjRWRoTWxKWFZXNU9XR0pYZUhCVmJHaERUVEZhYzFwRVVsWk5WbXcwVjJ0V2EyRldUa1pPVnpsV1lXczFWRlpWV25OamJHUjFXa1UxVTJKRmNGbFdiR1EwVkRGWmVWSnFXbE5pUjFKaFdWUkdTMVpHV25GUldHaHFWbXh3ZWxaWGVHdGhSVEZ6VTJ0b1dHSkdjSEpWYWtaUFZqRldkVlJzYUdsV00yaFpWbGQ0WVdSdFZsZFhibEpxVWxkU1lWWnFRWGhPUmxsNVpVZDBWMUl3Y0hsVWJGcHpWMnhrU1ZGc2FGZE5SbkI2V1hwS1IxTkZPVmRoUjJ4VFltdEtTbFp0Y0V0T1IwVjRWVzVPVkdKck5YRlZiR1J2VjBaU1dHTkdaRlZTYkd3elYydFdNR0V4V25KWGFrSldZbGhvV0ZacVJtRmtWa1paWTBab1YySkdjRzlXTVZwaFZERk9SMWR1U21GU00wSlVWRlJHUzFWR1dsaGtSbVJhVm1zeE5GZHJXbXRXTWtwV1YyNUNWVlpzY0hwVWJGcFdaVmRTU1ZSc1dtbFdXRUYzVjJ4V1lXSXhXWGROVldob1VsWktWMVJWV25kWlZuQlhWbGhvVjAxWVFraFdSM014WVVkV2MxZHJiRmROVjFGM1YxWmFVbVZXU25OYVJsSnBVak5vVkZkWE1IaFZNV1JIVjI1R1ZXRXdOVlpWYlRFMFpVWlZlV1ZGZEdsU2EzQXdWbGMxZDFkc1dsaFZhazVYVmtWYWNsVnFSazlrVm5CSFdrWk9hVk5GU25aV2FrWmhXVmRGZUZOWWFHcFNWM2hWV1d0a2IyTkdWbkZTYTNSWVVtMVNXVnBWV210aE1ERllWVzV3VjAxdWFIWlphMXBMWTJzMVYyRkdaR2xYUjJkNlYyeGtOR050VVhoV2JrcFFWbTFTYjFwWGRHRlhWbVJWVVcxMGFVMVdiRFZWYlRWTFlXeEtXR0ZHWkZWV2JIQXpWbXRhYzA1c1RuSlBWazVPVjBWS1NsZFdWbFpOVjBaWVUyeGFUMUpGU2xoWmJHaERWRVpTY2xkc2NHeFdhelZhV1ZWYVQxZEdTWGxoUm5CWFlXdEtjbFJyV21GV01rcEpVMjFHVTFKcmNIZFdSbHBoV1ZkV1YxZHVVazlXTTFKdlZXMTBkMlZzV1hsT1dFNVhUV3R3VmxWdGRHOVdNREYxWVVkb1lWSnNjRWhaZWtwSFVqSkdTR0ZGTlZoU1ZXOHhWbTB3ZUUxR2JGZFVXR2hZWWtkb1ZWbFVTbE5pTVZaMFRWWk9hbEpzYkROV2JHaHZWREZLZEZWc2FGZGlWRVYzVm1wQmVHTnJNVlZWYkdob1RXMW9UVmRXVWtkVE1sSkhWbTVXVW1KSFVrOVZiVFZEVkZaa2MxZHRSbWhOYXpWNlZtMDFTMWxXU25SaFNFSlhZbGhvTTFZeFdtRldWazVWVW14U1RsWXhTa3BXVnpGM1dWWlplVk5yYUd4U2JWSmhXV3RrYjFaR1VsVlNiSEJyVFZkU01GcEZXbTlWTVZwR1YyMUdXRlpGU2xkVVZscGFaVlpPY21KR1NtaGlTRUpaVjFaa01HTnRWa2RYYkZaVFlrVTFjVlJXWkZObFJsbDVUVmhPVjFKcmNGcFZWekZ2VjBaYWMxTnJhR0ZTUlZwVVZXcEdhMWRXY0VkaFIyeFVVbFZ3TmxadE1YZFJhekZHVFZoT1dHSnNTbk5WYWs1VFZteHNjMVpzWkU5aVJscFpXa1ZvVDFZd01WZGpSV1JhVmtVMWRsWXlNVmRqYkdSMFVtMUdWMVp1UWxGWFZFWmhZVEpOZUZWdVVtaFNNbWh6V1d0YWQxbFdXblJOU0doT1VteHNOVlpXYUc5V2JVVjVWVzA1VlZaRmJ6Qlpla1pYWXpGV2RWUnRjRmRpU0VGM1YyeFdWMDFIU2toVGEyaFdZbTE0V0ZSWGNFWmtNV3hXVjIxR2FtRjZWbGRYYTFwaFZHMUtjbE5zVmxkaVdFSk1WVzB4VjFZeFduTldiRXBwVTBWS1dWWlhlR0ZrTVZKSFdraE9WMkpWV25KVVZsWjNaV3hyZDFadGRGZE5hM0JaV2xWak5WbFdXWHBoUjJoaFVqTm9hRmw2Um5KbGJIQklaVVpPVGxJelkzaFdiRkpIWWpKSmVWSnNaRlJpYXpWWldXdFZNVmxXYkhOVmEyUlhVbXhzTkZZeU5VOWhiVXBKVVd0b1YxSXphSFpXYWtwTFkyeE9jbUZHWkU1aWJFcFZWbFpTUzFJeFNYaGFTRTVYWWtVMWNGVnFTbTlYVmxwSFdYcEdWazFzU25wV01XaHpZa1pKZDFkc1VscFhTRUpZVmpKNFZtVlhWa2hQVm1ST1lUTkNTMVpXWkhwbFJsbDVVbTVLVkdKWGFGaFpWM1IzVkRGd1YxZHJkR3BpU0VKSVdWVmtjMVl3TUhsaFJscFhUVlp3VkZaRVJrWmxSbkJKVkd4b2FXSkZjSGhXVjNodlZURldSMVp1VWs1V1JrcFpWVzE0ZDFOV2NFWmFSV1JYVmpCd1NGa3dhSGRYYXpGSVZXNWFWMkpVUmt4V2JGcExZekZXYzFwR1RsTldia0V5VmpGU1MwNUhSWGxWYkdScVVsWndVVlpxU2pSV1JteDBaRVZ3VGxKc2NIcFdWM1IzVkd4WmQxWnFVbGRpUjJoeVZrZDRZV1JIUmtkYVJuQlhVbGM0ZDFadGNFZGpNazV6WTBWb1VGWXpVbkJWYlRFelpXeFplV1JHWkU1U01Gb3dWVEo0WVZReFdsaGxSbVJhWWtkb2RsUlVSbk5XTVdSeVkwZDRWMDFHY0VkV1ZFbzBZVEZWZVZOc1pGTlhSMUpaV1ZSR1MxTkdaRmRhUlRWc1VqQTFSMWxyV2xOaFZscFhZMFpXVjFKc1NrUlZla1pYVWpGa2RWVnJOVk5TVm5CVVZrWldVMVl4WkVkWFdHeHJVbnBzY0ZWdGRITk5NVmw1WlVkR1YxWnNjSHBaTUZwdlZsWmFSbGRzVWxkaVZFWklWVEZhVTJSSFJrZFViV2hPVFVWd1dWWnRlR3BsUlRWSVUxaG9ZVk5HU2xSV01HUTBWakZzY2xaVVJtaFNiRnA1Vm0weFIyRkdTblJrUkZKWFRXNVJkMWxYTVV0V2F6VldZa2RHVjFadVFubFhWbHBoVXpKU1YxSnVVbWhTYlZKUFZtMDFRMWRXV1hoWGJVWllZbFphV0ZVeU5VOVpWa3B6VTI1Q1dtRXhjRE5XYTFwclYwVXhWVlZ0ZEU1V01VcEpWbXBKTVZJeFdsaFRhMXBQVm0xNFYxbHNhRzlaVmxKWVpVWmthMUpVVmxkVU1WcHJWR3hLUmxkc2JGZGhhMnQ0V2tSR2EyTXhaSE5oUmxwWVVqRktXVmRXVWtka01VMTRZMFphV0dGNmJISldha0ozVTBaa2NsZHJPV2hXYXpWSFZUSTFZVll5Um5KWGJXaFlWbTFTUjFwVldrOVhWMFpJWTBaT1YwMHlhRmRXTVdRMFZqRnNWMWRyWkZkaWF6VllXVzB4VTFkV1duUmxTR1JZVm0xME0xWnRjelZoUlRGRlVteGtXbUV4U2xSV2FrRjRZMVphYzFWc2NGZE5NbWhOVm0xNGExTXhTWGxTYTJScVVtMW9WVlZzVm5kVGJGcHlWMjFHV2xac2JEUlhhMVp2Vm0xRmVXRkdSbGRpVkVaVVZrUkdWMk5zV25SU2JGSnBVbTVDTmxZeWRGTlJNVkY0VTI1T2FsTkhlRlpXYlhoaFkyeHNXR1ZGZEdwTlZUVXdWVzE0VjFZeVNrbFJXSEJYWVd0S2FGbDZRVEZqTVZKMVUyeENWMkpGY0ZWV1JsWmhaREZPUjFkcmFHeFNNMUp4VkZaYVYwNUdaSEpXYlVaWFVqQndSMVJzV205WGJVcElZVVZTVjFKV2NGUlpNbmhyWkZaU2MyRkdUbWhOTUVwb1ZqRmFWMWxXV1hoYVJXUlVWMGQ0YjFWdE1WTlhWbHB4Vkd4T2FtSkdjRlpWYlRGSFZUQXhjbU5GY0ZkV2VrVjNWbXRhU21WR1RuTmFSbVJUWWtoQ2IxZHJVa3RXTVVsNFYyeHNhVkl6UWxSWldIQlhaR3hhZEdWR1RsTk5WMUpJVm14b2MySkdTWHBWYkd4V1lXdEtXRlJyV2xabFYxWkdWR3hrVGxaWGR6SlhWbFpYVGtaa2RGWnVTbXBTV0doWFdXdGFkMWRHYkRaVGF6bFRUVmhDU0ZkclZURmhWbGw1V1ROb1YySlVRak5hVlZWNFVqRmtkVlZzWkdoTmJXaFhWMWN4TkZNeFduTmlSbFpUWWxWYVYxUldaRFJsVmxsNVRsZDBWMVpVUmxoWk1HaHZWbXN4Y1ZGVVJsZFNSWEJNVldwS1QxSldSblJTYkU1WFRWVlplbFp0TVRCV2JWWklWRzVLVGxac1dsZFphMlJUVmtad1dHVkhSbFpXYlZKWVZtMHhSMVpGTVhOVGJHaFdZbFJXV0ZaWE1VdFRSbFp5VDFaYWFHRXhjRTFXUm1RMFdWZE9jMXBJVWxOaVYyaFBWbTB4TTAxR1duRlRWRVpXVFZaV05WVXlkRzloUms1R1UyeG9XbUpIYUZSWFZscFRWbXhrZEZKdGNGZGhlbFkwVm14a05HRXhVbk5YYms1WVZrVmFXRlpyVm5aTlJtdzJVbTFHYTFKcmNIaFdNakZ6VlRKS1dHRkhhRmRpV0VKUVZrY3hWMUl4WkhOV2JFNXBVbFJXV2xaWGNFZFpWazVYWTBWYVdHSlViRmRVVlZKSFZqRnJkMVp1WkZkTlZYQkhWakl4YjFZeFdrWlhiRkphWld0YWNscEdXazlqTWtaSFlVWlNVMVpZUW1GV2JYaHFaVVUxU0ZWWWJGTmhNbEp3VlRCV1lWWldiRlZUYkU1WFVteEtXRlpzVWtkaVIwcElaVVprV0dFeFNsUldiWE40WTIxT1JtTkdXbGRsYTFveVZtMXdTMU14WkZkV2JrNW9VakJhVkZWc1duZGlNVnBZWTBWMFUySldXakJWTW5SdllrWktjazVZUWxaTlJscE1WRzE0WVdSRk1WbGFSazVPVmpOb1dWWlVSbTlpTVZweldrVm9hRkp0ZUdGV01HaERaV3haZDFkc1RsaFNNVXBJVjJ0Vk5WVXlTbGxoUkZKWFlUSk9ORlJWV2xwa01ERlhWMjFzVTFKdVFtaFdiWGhyVlRKU2MxZFliRTVXVjFKeFdXeFZNVkl4YkZaWGJYUm9VakJXTkZrd1drZFdNa1p5VjI1S1ZtRnJXa3RhVlZwWFpGWlNkR0ZHVG1obGJGcFJWbTB4TkdJeFJYbFNhMlJZWW10YVZGbHNhRk5VTVZaeFVXeGtUMUpzY0RCVWJGWXdWbGRLUjJOR2JGZFdlbFpJVm0weFMxSXlUa2hoUm1Sb1RWaENObGRZY0VkWlYxSkhVMjVPWVZKck5YQlZiR2hEVjJ4YWRFMUlaRTVXTUZZMFZsYzFUMWRIU25KT1dFWldZVEZhVEZsVldtRmpNV1J6WTBkMFRsWXphRmhXYWtsNFVqSkdjazFZU2s5V1YyaGhWbXhhZDAweFdraGxSWEJzVmpCYVNWUXhXbXRoVm1SR1Uyc3hWMWRJUWtoWlZFWnJVakZPZFZOdFJsTk5iV2hWVjFkNGEySXhaRmRhUm1oclVqQmFXVmxZY0VkVFJtUnlWMjVPYUdKRmNGbFdWelZMVmxaYWMxZHVjRlZpUm5CWVdrVmtVMU5HU25OV2F6VlhZbXRKTWxac1VrdE9SbFY0VjJ4a1dHRnNjRlJaYlhoM1YwWlNXRTVYT1doU2JYUTFXbFZrTUdFeFNYaFRhMlJWVFZad1VGbFZaRmRqYkZwWldrWmthVmRHU25sV1JsWnJVbTFXVjFOdVNsaGhlbFpWVldwT2IxZEdaRmhrUjNSUFVtMTRXRmxyYUU5aFJrcFZWbTVPVm1KWWFIcFVWRVphWlZVeFZscEhhR2xTYmtJMVZtcEtkMUl4WkVoU1dHeFdWa1ZLV0ZsWGRIZFVSbFp4VW0xMFYxWnJjSHBYYTFwUFlWWktkVkZzV2xkaVZFWXpWV3BHYTJSR1ZsbGFSVFZYWWxob1ZsZFhlRzlSTVZwSFlraEthRkpWTlZsV2JURlRWMVp3VmxsNlZtaFdWRVpYV1RCV2IxWXdNWEZXYkVKWFRVZFNURlp0ZUd0ak1WWnpZMGRvVG1KRmNGWldhMXBoV1ZaYWRGWnNhRmRoTW1oVVdXeGtiMVpHVWxaWGJIQk9VbTFTVmxWWE1VZFdNREZYWWtSV1ZrMXVhSHBaVlZwS1pWZEdSMXBIUmxkTk1VbDZWbTEwWVZadFVYaGFTRXByVWpOQ2NGWnNXbmRUYkdSWVpFZEdWVTFyV2xoV01qVkxZV3hLZFZGc2FGcFdSVm96Vm10YVYwNXNTbk5UYlhST1VrWmFXVll5ZEdGaU1rWllVMnRhYWxKclNsaFdhMVpMWTJ4YVZWTnJPV3BOVmxwNlZqSjRZV0ZGTVhOVGJIQlhWbnBGTUZsNlFURlNNa3BIVjIxb1UxWkhlRmxYVm1oM1VqRmtWMWRzYUd0VFJUVlpXV3RhZDFkR2EzZFhiRTVYVFd0YWVWVnRjRk5XYXpGSFkwWm9XbVZyV2xoWmVrWjNVMGRHUms1V2FGTldXRUY1Vm0xd1IxVXhUWGRPVldoVFYwZDRWbGx0ZUV0V01XeFZVMnhPYUZKc1dqQlVWbHBQWVd4S2MxWnFUbGRpV0ZJelZrY3hTMUl5VGtsaFJscE9ZbXRLUlZadGNFdFNNRFZ6VTI1T2FWSnNjRTlaYlhoTFpWWmFkR1JIZEZSTmF6RTBWa2MxVjFaWFNrZGpSVGxXWVd0YVIxcEVSbUZqVmtwMFVtMXdUbFp1UWxsV1ZFa3hWREpHYzFOWWNGWmhlbXhZV1d4U1JtVnNjRmhsUjBacVZtczFlRlZYY3pGVk1ERkhZMFJXVjFKc2NIWlZla1pTWlVaa2MxcEhjRk5pVmtwb1YxZDBhMkl5VW5OVmJGWlRZbFZhVlZWcVJtRlNNV3QzV2tSU1ZrMXJXVEpXYlhCVFZqRmFSbUo2UWxwV1JYQklWVEJhUzFkV2NFaGpSazVzWWxob1dsWnRjRU5pTVVWNFZHdGtZVkp0VWxsWmEyaERZekZXZEdWRmRFNVdiSEJKVkZab1QxWnJNVVZTYWtKYVZsWndXRll3V2xwbGJVWklZVVphYkdFeGNGbFdWM0JIWVRKU1YxWnVTazlXYlZKVVZteG9RMDVXV25KWGJVWmFWbXN4TkZaSGRHdFhSbVJJWlVoS1ZtSnVRbnBaTUZwWFpFZFNTVnBIZUdsU00xRjZWMVpXVms1V1dYbFRiRnBxVW14d1YxbHNhRzlXUmxwMFl6Tm9VMDFyTlVsWlZWcGhWR3hLYzFacVVsZGlXRUpJV2tSR1NtVkhUa1pYYXpsWFRXMW9VRlpHVmxka01VMTRWMjVHVTJKRk5WTlVWbVEwVjFaYVIyRkhPVmhTTUhCNlZUSjRWMWRzV2taalJsSlhUVlp3ZWxZd1pFOU9iRXB6WVVaT2FWSnVRVEpXYlhCS1RWZEZlVkpyWkZSaWF6VnhWVEJvUTFkR1VsaE9WazVxWWtkNFZsVnRkREJXTVZsM1kwVm9XbFpXY0hKV1J6RkxZMnN4VlZWc2FGZGlSbkJZVjJ4V1lXRXhXWGhUYms1WFlrWktjRlZxUmt0VlJscDBZMFZrVTAxRVFqUlhhMXB2WVd4S1dGVnNhRnBpUm5Cb1ZqQmFWbVZWTlZaUFZuQlhZVE5DTmxaVVNURlJNVnAwVTJ4V1YyRXhTbWhXYkZwM1lVWlpkMXBGT1ZOaVZrcEpXV3RWTVZZeVNuSlRWRXBYWWxoQ1MxUldXbEpsUjBwSFdrWlNhV0V6UW5oV1YzaFRZekZaZUdKSVRtaFNlbXh2VlcwMVExZFdjRlpYYm1ScFVteHNORll5ZEhOWlZrcFhZMGhhVjFaRmNFZGFWM2hIWXpGd1IxcEhiRmRTVmxZelZqRmtkMUl5UlhoVWEyUlVZa2Q0YjFWcVRrTldSbFp6Vld4a1dGWnRVbGhYYTFKRFlUQXhWMU5yYUZkaVIyaHlWbXBHWVZJeFpITldiR1JvWVRCdmVsWlVRbUZoTWs1eldraFNhMUl5ZUZSVVZWcGFaV3hhY1ZKc1RsSk5WbXcxVlRKNGMxWnRTa2RUYkdSYVZqTlNNMVZxUm5kV01XUnpXa2R3YVZORlNrbFhWbFpyWXpKR1YxTnVWbEppUjFKWVZGWmtVazFHYkhGU2ExcHNVbTFTZWxkcldtdFhSa2w0VTJ4c1dGWnNTbEJXVkVwS1pVWmFkVlZ0ZUZSU01VcFdWbGN4TkdRd01VZFZiR1JYWWxoU1dWVnFRbmRUUm14eVZXeE9WMDFFUm5oV2JYQlBWakpHY21ORmVGZGlSbkJvV1hwR1IyTXhjRWhoUjJoT1YwVkpNVlp0ZUZOUk1rVjRVMWhvVkZkSGFGbFpiWE14VjFac2MxcEVVbGhTYkZvd1dsVm9hMVV5U2tkalNIQlhWak5TVUZZeWVGcGtNREZWVld4a1RtRnNXbEZXYWtKclV6RkplRnBJVGxaaVNFSndWV3BHUzAxc1duUmtSMFpXVFZad01GVnRkR0ZXVjBwSFUyeG9XbUpHY0V4V2FrWmhWakZ3UlZWc1ZrNVdNVW8yVm1wSk1WUXlSbGRUYTFwUFZteHdXRmxzYUc5Tk1YQklaVWRHYTFJeFdrbFZiWGhQWVZaS1ZWWllaRmRXZWtVd1dWUktSMUpyTVZkYVIzQlRaVzE0V1ZaR1dtRmtNa1pIWTBWV1UySklRbk5WYlRWRFUyeGFXR1ZGT1doV2JWSklWVEo0YzFkR1dYcFZiV2hoVWtWRmVGbDZSbXRrVms1elkwVTFUbUpYYURSV2ExcGhXVlpaZDAxSWFGWmlSbkJ2VlRCVk1XSXhWblJrU0dST1VtMTRWMVl5TURWV01WcHpZMFJDVjFZemFGQldiRnBoVmpKT1NWTnNaR2hoTVhCNVYxUktlazFXWkVoV2EyUlZZbGQ0VlZWc1ZuSmxWbHAwWTBWMFRsSnRlRmhaYTFwdlZUSktTRlZzVmxkTlIxSjJWbXhhYzJSSFZrbGFSbWhUWWtoQmVGZFVRbUZoTVZKeVRWWm9hMlZyY0ZkWmJHaHZWRVpzY2xkcmRHdFNiRnA0VlcxNGExWXlWbkpYV0hCWVZqTlNjbFZ0TVZkVFJsSnlXa2RzVTJKV1NsVlhWM1J2VVRKSmVGcElTbFpoTWxKV1ZGWmFjMDVXV2toa1IwWllVakJ3U1ZaWGVHOVdiVXBaWVVST1YwMVdjSEpXTUdSVFVqRndTR1JGTldsU2JrRXlWakZhVTFReVJYaGFSV2hVWW10d1VGWnFRbUZYUm14ellVYzVUazFXYkROV01uaDNZa1phVlZac2NGaGhNWEJ5VmtjeFJtVkhUa1ZXYkdoWFVsVndXVlpIZEdGWGJWWlhWRzVLWVZJelFsUlVWekZ2WVVaa2MxcEVRbHBXYXpWSVdXdFNZVlpIUmpaaVJsSlZWbTFvUkZWcVJsTmpNVnBWVW14YVRsWllRalZXYWtadlpERlplVk5zYkZKaE1taGhXVmQwZDFVeGNGWlhhemxZVmpCYVNWbHJXazloVmxsNVlVWnNWMDFXY0ZSVmFrcFNaVVphY2xwR2FHbGlSWEJRVm0weGVrMVhUbGRYYmxKc1VqQmFUMVZ0ZUV0WFJsbDVZM3BXYUZJd2NFZFpNR2gzVjJzeFIxTnJVbGhXYkhCTVZqQmtSMU5XVG5OalJtUnBVbXhyZDFadE1YZFRNVkY0Vkd4b1UyRXlVbGxaV0hCWFlqRnNjbGR1WkU5V2JIQXdXbFZrTUdKSFNsZFhhMmhXVFc1b2NsWnJaRXRqYlU1SVQxWmFhVlpGV2xWV2JYUmhWVEZhVjFOdVNtdFNNbmhQVm0wMVEwNVdXbk5hUkVKb1RWZFNlbFl4YUc5V1IwVjVaVVprV21KSGFGUmFWM2hoWXpGd1JtUkdUazVoZWxaS1ZrUkdZV1F4V1hoVGJHaHFUVEpTV1ZsVVJrdFRSbVJYV2tVNVYwMVZjREZXVjNoUFlWWktkVkZzUWxkaVZFSTBWRlJCZUZJeFpGbGlSM1JUWlcxNFdWWkdXbXRWTVU1WFZtNVNhbEl3V2xoVVYzUjNaVlpWZVdWSGRGaGlSbXcyVmxjeGIxWXhTbGRqUjBaaFZsWndjbHBGV2t0a1IwNUhXa2RvYkdKR2NHOVdha1poVmpGYWNrMVdaRmRYUjFKUFZteGtVMk5XVm5KWGJVWllVbXhhTUZwVmFHdGhSa3AwWlVob1ZrMXVVWGRXVkVGNFZqRk9kV0pHY0ZkV01VVjNWbXhTUzFNeFRsZFNiazVwVW0xb1dGUlVTbTlOYkdSWVkwVjBVMDFWYkRWVmJHaDNZVlpKZW1GR1VsVldWbkF6Vm0xNFlWZEhUa1phUm5CWFlUSjNNRlpzV205aU1XUklVbXBhYVZKc2NHRlpWRVozWld4U2NsZHNXbXhTTUZwSldrVmFhMVJzV25SUFNHeFhWak5vVkZWVVJscGxWa3AxVTJ4b2FWWldjRzlXVjNSWFVqQTFSMVpZYUZoaWJWSlVWRlphWVUxR2JGWmFTRTVXVFd0d2VWVXlNVzlXTWtaeVYyNUtWVlpXY0hwV2FrcExVakpHUjFSdGFFNWlSWEF6Vm14a01GbFhVWGhYYkdScFUwVndXRlpyVm1GWFJsWjBUVlJTV0dKSGRETldNakV3VjBaS2NtTkVRbGRXZWxaNlZtcEJlR1JYUmtkUmJIQlhWbTVDYjFkWWNFdFVNVWw1VW10a2FsSlVWbFJaYlhSTFVteGFkRTFZWkZSTlZURTBWMnRhYjFVeVJYbFZiVGxXWVd0S2FGWnJXbGRqTVdSMVdrZG9VMkpXU2paV2JUQjRVakpHUmsxWVNrOVhTRUpoVkZWYVlXTnNaRmRYYTNCc1ZqRmFTRlpYZUd0aFJURlpVVzA1VjFJelVtaFhWbVJQWXpGd1NWVnNUbWxTTVVwMlYyeGtNRmxXWkhOWGJsSk9Va1ZhVmxSV1duTk9SbVJ5Vm0wNWFWSnJOVWRXTW5oclYyeFplbFZyZUZwV1ZuQmhXa1JHYTJNeFVuTmhSazVPVmxoQ1RGWnFTakJoTURWSFYxaHNWR0V4Y0hGVmExcDNWMFpTV0U1V1RsaFNiWGhXVlcweE1GWkdTbkpPV0hCWFRXNW9jbGxWWkV0U01rNUhZa1prYVZkRlNsRlhWM0JIV1ZaSmVGcElWbE5pUlhCWlZXcEtiMVpXV2tkYVNIQk9WbXR3ZWxZeWRHOWlSa2w2Vld4YVdtRXhXak5hVjNoYVpVWldjbFJzWkU1aE0wSlhWbGQ0VTFFeGJGZFRhMXBZWVROU2FGWnRlSGRVUm10NVpVaGtWRkpyY0hwV1IzTXhZVmRLV0dGR1pGZGlWRVl6VlZSR1dtVkdVbGxpUmxKWVVqSm9XbGRYTVRSVE1WRjRWbGhrWVZKck5YRlVWbHBoWld4YVdHVkhkRmRTYkhCNldUQmFiMWRzV2xoVVZFWlhZV3R3VEZadE1VOVRWMDVIVjJzMWFXSlhhRlpXYlhCS1pVWk5lRnBHYUZOaE1YQnpWVzAxUTFReGJIUk5WemxZVm0xU1ZsVXljRk5oUlRGeVRsUkNWMVl6VW5KWlZWcExaRVpXZFZGc1drNVNiSEJKVmtkMFlWZHRWa2RXYmtwVllrZFNUMVpzVWtaTlZscFZVMnBDYUUxV2NFbFZNalZMVkRGa1JsZHNaRnBpUmtwSFZGVmFZV1JIVmtoU2JYUlRUVlp3U1ZacVNucE5WbGw1VTJ0c1VtSkhVbGhXYTFaMlpERlNWbGRzY0d4V2F6VjZWakp6TlZZeFdYaFRiSEJZVm14S1NGcEVRWGRsUjBwSFYyeGtXRkl5YUhoV1JscFhaREpXUjFkcmFHeFNNMUp2Vm0xMGQyVldhM2RXYkU1WVVqQndTRll5TVc5V2JWWnlWMjFHWVZaV2NETlZNVnBoWXpGd1NHSkdaRmRpYTBwWFZtcEdhMDVIUlhsVFdHaGhVbTFTYUZWdE1XOWpiRloxWTBoT1ZrMVdTbGhYYTFwUFYwWktjMkpFVm1GV1YwMHhXVlZrUzFKdFRrZGpSbVJYVFRKb1dWWnRlR0ZYYlZaelZXNUdWbUpHV205VVZtaERZakZhY1ZGc1drNVdiSEI1VkRGYWEyRkdTbkpPVlRsV1RVWmFURlV5ZUdGa1IwNUdZMGQwVGxKR1dsbFdha28wWVRGa1NGTnJhRlppUmxwaFdWUktVMlJzYkZaWGJVWnJVakZhU2xkclpHOVZNa3B5VTJ0b1YySllhSFpaYWtaV1pVWmtkVk50Y0ZSVFJVcFlWa1pqTVZSdFZrZFhia1pTVjBkb1dGbHNWVEZUUm10M1YyMTBhRlp0VWtsWlZXaHpWakZKZWxWdVNsWmlWRVpZVlRCYVQyTnNjRWhTYkU1cFVsaENNbFpyV210T1JrMTRWMjVPWVZKdGFITlZiWE14WTFaU1YxcEVVbGhTYkd3MFdWVmtNR0ZHU25KalJtUlZZa1p3V0ZadE1VdFhWMFpHWlVaa2FHRXhjR2hYYkZwV1RWWmtTRlZyWkdGU1ZGWnZWRlJDUzFkV1duUmpSWFJPVWpBeE5GbHJXbXRXUjBwSVZXNUdWazFHV2pOV01GcHpWMGRTU1ZwR1RrNVhSVXBaVm0xNFUxWXhXa2RYV0dScVVsZG9XVmxVU2xObGJGcHhVbXQwVjAxWFVscFpNRnByWVZaa1NHRkdWbGRXTTBKSVdYcEdXbVZHY0VkaVIyaFRUVVp3VmxaWE1UUmtNV1JIV2tab2ExSXdXbkpVVjNSelRrWnJkMWR0T1ZWaVJuQklWVEkxUTFaV1duTmpSRTVWVmxad1ZGWnFSbGRqTVZKMFlVVTFVMUpXY0VoV2JHTjNUVmRSZUZwSVNrNVdWMUp4VlRCV2QxZEdiRmhrUjBab1VteGFlRlZ0TVRCaGF6RnlZMFZvVjAxcVJuWlpWVlY0VTBVNVZWZHNaR2xTYTNCSlZqRmFhMVJ0VmxkVmJsWlZZbFZhVlZWdGRIZGxWbHBZWTBWMGFVMVhVa2haYTFwWFZrWmFSMU51VGxkaVZFWlVWakJhWVZkSFRqWldiV2hPVWtWYVdWZFhkRk5XTVZweVRWaFdhRk5JUWxoV2JuQkhVakZ3V0UxVlpGTk5WMUo2V1RCYWExVXhaRVpUYkZwWFlrZG9NMVZxU2xKbFJtUjFWRzFHVkZKVVZtOVdWekI0WWpGa1IxVnNXbWhTVlRWVlZtMTRkMDFHVWxaaFJ6bG9WbFJHV0ZVeWNFTldhekYxWVVoYVdsWldjRXhhUldSSFVqSkdSMVpzWkdsVFJVWTJWakZTUzA1R1ZYbFViazVoVTBaYVZsbHJaRzlXUm14WlkwWmtXbFp0VWxoV2JURXdZVEF4VjFacVZsWk5ibWgyV1ZWYVMyTnNUbk5oUm5CcFVtdHdTVlpITVRSVk1WbDRXa2hTYTFKdFVrOVpWRTVEVXpGYVZWTnFVbWxOYTFwWVZqSjRhMkZzU25KVGJHaGFZa1pLUkZScldsTldiRnBaV2tkNFUySldTbUZYVjNSclpESktTRk5yWkdwVFJuQllWbTV3UmsxR2JEWlJXR1JzVWpCV05sZHJXbXRoVm1SSFUyeHNWMkpZUWtSYVJFWlBVakpGZWxwSGFGTlhSa3BaVmtaV1UxSXhUbGRYYkdoclVucHNXVmxZY0VkTlZscEhZVWM1VjAxRVJsaFpNR2hMVjIxV2NsZHFUbFppV0UxNFZqQmtTMU5IUmtobFIyeFRWbTEzTWxadE1IaGtNVWw0Vmxob1ZXSnNTbGhaVkVwVFZqRlpkMXBIT1ZkaVIzaDVWMnRqTlZZeVNraGxSbHBXVFdwQk1WWnFSa3RrUjFaSllrWm9hRTFZUWxGV2FrSmhVekpOZUZSdVRtbFNiRnBZV1d4VmQyVkdXbkZSYlhSVVRWVnNOVlpIZEhOaGJFcDBWV3hvVlZaRldraFVWRVpoWTJ4V2NscEdVazVoZWxWM1ZtdGtNRll4Vm5SVGEyaFdZa2RvWVZsclpGTmtiRkpZWlVkR2ExSXhXa2xhUlZwVFZHMUdObFpxV2xkTmJsSjJWa1JLUjFJeFRuVldiRXBwVmtkNFYxWnRjRTlpTVZKSFZXeG9iRkl6VWxoV2JYUmhUVVpXZEdWSGRGVmlWVmt5Vm0xNGMxWXlSWGxVV0doWFZrVmFXRlZxUm10a1ZsWnpWMjFzVTAxdGFHOVdNVnBUVXpKSmVGTnJaRmRYUjJoWldXeFdZV05XV25SamVrWllZa2Q0VjFac1VrZFdhekZ5WTBWd1ZsWXphSFpXYWtaTFl6Sk9TVmRzWkZOU1ZuQnZWbFJDWVZNeFpGaFRhMlJZWWxkNFZGbHRkRXRpTVZsNFYyeE9VMDFzUmpWVmJYUnJZV3hLV0dGSVRsWmhhelZVVmpCYVUxWXhjRWRVYlhoWFlsaFJlbFl5ZEZOVk1WbDNUVlZXVTJKSGFHRlVWVnBhWkRGYWNWSnRSbXRTYkZwV1ZWZDRkMVl4U2xsUmEyeFhZbGhDU0ZwRVJrdGtSa3B5WVVaT2FHVnNXbEJYVnpCNFlqRnNWMWRZYUZoaVJUVlVWRlpWZUU1R1draGtSM1JZVW0xU1NWcFZWVFZXTWtwVlVteFNWMDFXY0ZoYVJXUlhVMVp3U0dWR1pHbFhSMmhaVm0xd1MwMUdVWGhYV0dST1YwVndjVlZzWkc5WlZsSldWMjVrVTFKc2JETldNakZIWVRGSmQxZHJXbGRTTTJoeVdWVmtSbVZIVGtkU2JHaFlVMFZLU1ZkV1VrdFViVlpYVTI1S1dHRjZiRmhaYkZwTFZsWmtWMVZyT1ZKTlYxSjZWakkxUzFkSFNsbFZhemxXWWxob2VsUlVSbE5qTVZwMFpFWmtUbFl4U2twWFZsWnFUbFphZEZKdVNrOVdiRXBZV1d4b2IxWkdXbkZTYm1SVFRWWktlbFpIY3pGV01rcEhZVE5vVjJFeGNHaFdha3BHWlVad1JtRkdVbWxTYmtKNFZsZDRhMDVHYkZkWGJrNVlZbFZhV0ZWdGVIZE5SbXcyVkcwNVZrMUVSbmxVYkZaM1Yyc3hSMk5JU2xkU00yaExXbFZhVDJNeVNrZGFSbVJUVm01Q2RsWnRlRk5UTVZWNFZHdGtWMkpyY0doVmJYaGhZakZ3V0dWSFJsaFdiVkpaVkZaU1ExWkZNVlpPVm1oWFRXcFdWRlpIZUdGU01VNTBUMVp3YVZKdVFtOVdWM0JIVlRGWmVGZHVVbXRTYldoVVdXeGFTMU5zWkZkV2JYUnBUVlp3TUZVeWRHOVdiVXB6WTBac1YySllhRE5XYTFwaFl6RmtjazlYZEZOV1IzaFpWMVpXWVZReVJsZFRibFpTVmtWYVdGbHNVa05PUmxKV1ZsaG9WRkpyY0RGV1YzaFRZVVV4ZEdGSWNGZFdla1V3V2tSR1dtVkhTa2xVYldoVFpXMTRkbFpYTUhoT1IxWlhWMWhzYTFKRlNtOVVWbHAzWlZaWmVVNVlUbGhTTUZZMFdUQlNUMVl5Um5KWGJVWmhWbFp3VUZreFdrOWpNWEJJWWtaT2FFMHdTa3RXYlhodlpERkplR0pHWkZoWFIyaG9WVEJhWVZac2JITmhSVTVYVW0xNGVsZHJZelZYUmxwelkwVm9WMVl6VW5KV2ExVjRZekZrYzJGR2FHaE5XRUl5VjFaa05GTXhaRWRXYms1aFVteGFXRmxyV25kT2JGcElaVWRHVjAxck1UVlZiWFJ6V1ZaS2RWRnNhRnBXUlc5NldsZDRZV05XVG5GVmJGcE9WbTEzZWxaR1dsZGhNa1p6VTJ4c2FGSnRhRlpXYm5CWFpHeHNWbGRzY0d0TlZuQmFXVlZhYTFZeVNrZGlNMlJZWVRGYVYxUldXbFpsUms1eldrZHdVMkpyU2xsWFYzaHZVVEZOZUZWc1pGaGlSbkJ6VlcxNFlVMVdXa2hsUnpsb1VsUkdXbFZYZUdGWFJsbDZWVzVLVjFaRlducFdha1pyVjFad1NHRkdUbGRXUmxwWFZteGplRTVHYkZoV2EyUlhZbXhLVUZac1VuTmlNV3h6Vm01a1ZGSnNiRFZVYkdoUFZqRmFWVkpzYUZwTlIyaG9WbXBHWVZKdFRrWmxSbHBPVW14VmVGWlVSbXRUTVVsNFkwVm9hVkp0VWxSV2JGcHlaREZhY1ZOcVFsWk5WV3cwV1d0YWIxWldaRWhoUjJoV1RVWmFNMVl4V25Oak1rWkdWR3hrVTJKWWFEVldiVEF4WVRGa1IxTnVVbFppUjJoWldWUkdTMUpHYkZWUldHaFhUVmRTZVZsVldtdGhWbHBIVjJ0c1YySllVbkpWYlRGWFl6RmFkVlJzV21sU2JIQlpWMWQwYjFFeVNYaFhhMlJYWWxWYWNWUlhjekZsYkdSeVlVWk9hRTFWY0hwWk1GVTFWMnhhUms1VlVsWmxhMXBvVm1wR2QxTldjRWRWYXpWWFlsaGplRlpzVWt0T1JsbDRWbGhvV0dFeGNGVlphMlJ2VjBac1ZWSnRSbWhTYkZwNFZXMDFhMVl5U2toVmJuQlhVbnBGZDFacVNrdFNNazVGVjJ4a2FHRXlPSGRYVjNCSFZtMVJkMDFXYkZaaVYyaFVWV3hTVjFkV1pGaGtSM1JWVFVSV1NGWlhOVXRaVmtweVkwaE9WMkpZVWpOYVZscHJZMnhrZEdSSGFGZE5TRUpJVjFSQ2IyUXhXWGhYYTFwVVltdHdXRlpyVm5kVE1YQldWMjFHYTFac1dqQmFWVnBQVjBaS2NtTkhSbGRpUjA0eldsVlZNVkl4WkZsaFJtaHBZa1Z3ZUZkc1pEUlpWbVJIVjI1R1VtSnRVbFJVVm1Rd1RURmFXR1JGT1ZoaVJuQjZXVEJhYzFkc1dsaGhSRTVYWVd0R05GcEdaRWRUUjBaSFdrVTFVMDFWY0VwV2JHUjNVakZKZVZSWWJGVmhNbEpvVlcweFUxUXhXbk5oUlU1VVRWWndNRnBGWkhkaVJrcFZWbXRvVmsxWGFIcFdiR1JMVTBaV2MyRkdjR2xYUlRFMFZtcEdZV015VFhoalJWWldZa2RvVkZsclduZE9iRnAwVFZSU2EwMVdTbnBWTWpWUFlXeEtSbE50UmxWV1ZuQm9WbFZhYzFac1dsbGhSbVJvWld0YVYxWnNaRFJoTVZKMFUyNVNhRk5IZUZoWmJHaFRZMnhXTmxOck5XeFNia0pLVm0xNFQyRldTblZSYm1SWFlsaFNhRmRXV2t0V01YQkhZa2R3VTFZeFNuaFdSbHBoWkRGa1IxZHNhRTlXV0ZKWVZtcENkMU5XV2xobFJ6bFlZbFZXTlZsVlZsTldNa1p5VjIxb1YyRnJXbmxhVnpGSFVqRlNjazVXWkU1V1Z6aDVWbTB4ZDFJeVNYbFRXR2hZWVRKb1ZWbFVTbTlqTVZaMFRWWk9WMkpHY0RGWk1GcHJWakZLZEdWR1pGZE5hbFpRVmpCYVNtVkdaSEphUjBaVFZqRkplbGRXVm10V01rMTRXa2hPYUZKdFVsUlZiRnAzWWpGWmVGZHRkRk5OVm13MFYydG9TMWRIU2taT1ZteFdZV3R3ZGxZeFdtRlhSMDVHVDFaYVRtRXhjRWxXTW5SaFlURnNWMU5zVm1sU2JXaFdWbTE0ZDFSR1VsZFhiR1JyVWpGYVIxcEZaRzlXTWtWNlVXcGFXRlpGU21oVlZFWmFaVlpPYzJKSGFGTk5iV2haVmtaak1WUXdOVWRYYmtaVFlsaFNjbFp0ZUV0TlJsWjBaVVU1VmsxV2NGcFZWM0JMVmpKRmVHTklTbFZXVm5CNlZtcEdkMUpzY0VkYVJtaFRUVEpvVWxadE1IaGxhekZZVkd0a1YySnNTbkpWTUdSVFl6RmFkR1ZGZEd4aVJtdzFWRlZTVjFkR1NYZGpSV2hhWVRGS2FGWnFSbHBsYkVaelVXeGthR0V6UWtoWGJGWnJWREZPV0ZOcmFGTmlSVFZVVm0wMVEwNVdXWGhoU0dSVFRWWldOVlpHYUhOVk1rVjVWV3hhV2xkSVFsaFdNRnB6WkVkU1JtUkdWbGRpU0VGM1ZrWmFVMUV5UmtoVGJHUllZVEo0V0ZWdE1XOWxiRnBWVTJ0MFZGSnNXbnBXYlhoclZHeEplRk5xU2xkaVdHaG9Wakl4VW1WSFRrWmFSbFpwVWpKb1ZWZFhkR0ZrYlZGNFdraE9WMkpVYkc5VVYzUlhUbFpWZVdSSGRHaGlSWEJZV1RCYWExWldXalpXYkZKYVZsWndlbGt5ZUd0amJWSklaRVpPYVZKdVFUQldiR040VGtkRmVWSnNaR0ZTVjJodlZXeFNSMWRXV25SbFIwWlhUVmhDVjFkclZURmlSa3B6VTJwR1YxSjZSa2hXVkVwTFYwZEdSMkpHWkZOaVJYQkpWbGh3UzFZeFdYaGFTRlpWWWxWYVZWVXdWa3RsYkZwWVRWUkNhazFFVmxoV2JHaHpZVEZKZWxWdFJsZGlXRkl6VkZWYWMxWnRSa1pVYkdSb1pXdGFTVlpxU2pCT1JteFhWMWh3YUZJeWFGaFVWVnBYVGtaVmVGcEZaRk5OVjFKNVZHeGtjMVV5U25KVGEzUlhZbFJHTTFWcVNrcGxWbEpaWWtaU2FFMXNTbGRYVmxKTFlqRlplR0pJU21GU2VteFlXV3RhZDJWR1draGxSVGxWWVhwR1dGbHJVbE5XTURGeFZteENWMkZyY0V4Vk1GcFhaRmRLUjJGSGFFNVhSVW8xVm0xMGEwNUdUWGhUYms1aFUwVTFjRlZ0TVZOWFJsWnpXWHBXVGsxV2NFbGFSV1JIVjJ4WmVGTnJhRmROYWxaWVZtdGtTMWRXUm5OVmJIQlhVbFZ2ZWxacVFtRmhNV1JJVm10b1VGWnNXbTlhVjNSaFYxWmFjVk5VUmxaTlZrcDZWako0YzFadFNrZFRiRnBYWVdzMVZGbFZXbFpsUm1SMVZHeGthVkp1UWxkV1Z6RTBWakpHVjFOc2JGSmlWVnBZVm0weFVrMUdiRlZTYkhCc1ZtczFlbGxyV21GaFZsbDVZVVp3VjJKVVFqUldWRVpQVWpKRmVtSkhjR3hoTVhCWlZrWmFhMVV5VmxkVldHaFlZbGhTV0ZSVlVrZFdNV3QzWVVkR1YwMXJjRWxXUjNCUFdWWmFXRlZyZEdGV1ZuQllWakZrUjFJeGNFZGhSazVPVmxoQ01sWnRlR3BOVjFGNVZGaG9ZVkpYVW5CVk1GWjNWMVpzVlZSc1RsaFNiRXBZVmpJMWExZEdXblZSYTJSWVlURktSRlpxUVhoV2JVNUpZMFp3VGxJeVozcFdiWEJDWlVkU1YxSnVTbFppUjJoWVdXdG9RMkl4V25GUmJVWldUVlp3V0ZVeU5VOVpWa2w1WlVac1ZtRnJjSFpXUjNoYVpWZFNSMXBHY0ZkaVIzY3hWbXRqTVZVeFZYbFNXR3hXWWxkb1YxbHJXa3RYUm10M1YyNU9hbUpHY0hwWk1HUTBZVlpLZFZGWVpGZFNiRnAyV1ZSS1MxSXhUblZUYld4VFVteHdXVlpYTlhkV01WWkhXa1prV0dGNmJGUlphMlJUWld4WmVXVklaR2hXYTNCNldUQmpOVll5U2xsVmJXaFhZV3R3VDFwVlduZFRWbHAwVW14T1YxSXphRE5XYkdSM1VqRk5lRmRZYUZoaVJscFVXV3hTYzJOR1VsZFhiR1JPVFZaS1dGWXlNVWRoUmxweVkwVm9WazF1YUhaV2FrcExaRlpHYzJGR1pHaE5XRUkyVm0xd1IyRXlUblJWYTJocVVqSm9jMWxyV25kWFZscHlWV3RrV2xadGVGbFZiWFJoVkd4YWRHVkdUbHBpUjFKMlZqQmFWMlJIVmtsYVIyaFRZbFpLV1ZZeWRGWk9WMFp5VFZac1VtRXpRbGhXYWs1dlZVWnNWMWRzY0d4V01GcElWVmQ0YjFZeVNrWmpSVEZYVW14S1ExcFZXbHBsUm5CSlZHMW9VMVpHV2xWV1YzaGhaREZaZUZkclpGaGlWVnBZVkZWU1YxTkdaSEpoUlhSWFRXdHdWbGxyYUVOV2JVcFpWVzV3VldKR2NIcFdiWGhyWkVaS2MxcEZOV2hOVm10M1ZtMXdTMlF4VVhoaVJtUlVWMGhDYjFVd1ZuZFhSbXhZWkVkR2FtSklRa2hXTWpWclZUQXhjbGRyYUZkU00wMTRWbXBHYTFKc1RuSk5WbVJwVjBWS1RWWkdWbUZqTVdSSFZHeHNhRkp0VWxsVmFrNXZWbXhrV0UxVVFtdE5WbkJZV1d0b1MxbFdTa2RUYkd4V1lsUkZNRnBYZUdGWFIxSklaRVpXYUdWcldsbFdha28wV1ZaYWRGTnNiR2hTUlRWaFdWUkdkMVJHYTNsamVrWlhWbXR3ZWxZeWN6RmhWMHBZV2pOc1YwMVdjR2haVkVaT1pVWndSbUZHVG1oTmJFcDRWbGN3ZUdJeFpFZGlTRXBYWW0xU1ZWWnRNVk5sVmxwWVpFUkNWMDFFUm5sVVZsSlRWMGRGZVdGR1FsZGhhM0JNVldwR1QyUldSbk5YYldob1RWaENUbFl5ZUZkWlZteFhVMWhvWVZORk5WbFpXSEJYVjBac2MxZHJkRTlpUjFKWldrVmpOVlpGTVZoVmEyeFdUVzVvZWxadE1VdFRSbFp6VjJ4a2FWZEhaM3BYYkdRMFZUSk5lRnBJVmxWaVIxSndWVzE0ZG1ReFdsaE5WRkpvVFZaS2VsWXlOVmRWYkdSSVZXeG9XbUV4Y0ROV2ExcFhWbFpLZFZSc1pFNVdWRlkwVm1wS05GUXlSbGRUYkZaWFlsUnNXRmxzVWtaTlJuQkZVbXhrVTAxclZqWlphMlEwVlRBd2VGTnViRmRXTTBKRVdrUkdUMUl4WkhKaFJUVllVbFJXV0ZaR1dtdFZNVWw0Vmxob2FGTkhVbGhVVjNSM1ZteFdkR05GT1ZkaVJuQkhXVEJXYTFsV1duTmpSa0pYVFZkU1RGVnFSbmRUUjBwSFZHczFWMWRGU205V2JYQkhZVEF4UjJKR1pHbFNiVkpZVmpCa2IyTkdWWGRXVkVaWVVtMTRlbFp0TVVkWGJGcHpZMFJDWVZaWGFISlphMlJMVWpKT1IySkhSbGRXTVVZelZtcENZVk15VG5SVWExWlNZbFZhV0ZacVNtOU9iRnB4VTJwU1dsWnNiRFZXUjNSclZXMUtTVkZzYUZkaVZGWkVXV3BHYTFaV1RsbGhSbFpPVmxkM01GZFVRbGRoTWtaelUyeFdWMkpHU2xaV2JuQkhaR3hXZEdWSFJtdFNWRVpXVmxkNGQxWXlTbGxoUm5CWFlrZFJkMWxVUmxwbFZrNXlXa1pvYVZKVVZtaFhWbEpMVlRGYVIxZHJWbE5pVlZweVZXeFNWMVl4V2toTldFNVZZa1p3TVZWWGVHdFdNVnAwVlZSQ1dGWnRVa3hWYWtaUFpGWldjMWR0YkZOTmJXaHZWbXRhVjFsV2JGaFViazVZWW10YVZWbFVUbE5XVmxaMFpVZEdUbEpzUmpSV01uaHJWakF4Y21ORmNGWldNMEpvVm1wR1MwNXNTbFZSYkdoWFlsWktVRmRzVm1GWlYxSlhWRzVTYWxKck5WaFZiWGgzVjJ4WmVGZHNUbFJOUkVJelZGWldhMWxXU25SaFNFcFdZV3RLYUZscVJsTldNV1IxV2taU1YySkdXVEZXUjNoV1RsWlplRk5ZWkdwU2JIQmhXVlJHZDJOc1dYbE5WVnBzVm14YU1WWXllR3RoUlRGWlVXNXNWMkpZUWtoWlZFcE9aVVpXZFZSdFJsTk5ibWhWVmtaYVYyTXdNSGhYYms1YVRUSlNjMVZzVWxkVFZsWjBaVWQwVjFJd2NIbFViR2hIVm0xRmVHTkVUbGROUm5CNldYcEtSMU5GT1Zoa1IyeFRUVEpuTUZac1kzaE9SbXhZVTJ0a1ZHSnJjRkJXYlRWRFdWWmFjMWR1WkZkU2JYaFhWbXhvYjJGck1WWk9WRUphVmxad2NsWlVTa3RTTWs1SVQxWm9hRTFWY0VsV01WcGhVMjFXUjJORmJGZGlSa3B3VldwS2IyUnNXa2RWYTJSVVRXeGFTRmRyV205aVJrcHpZMFU1VjJKWVRYaGFWM2h6WTJ4a2RGSnNhRk5OU0VKaFZteGtORmxXWkhSU1dHaHFVMGhDVmxaclZtRldSbXQ1WlVaa2FtSkdTbnBaVlZwUFlWWk9SbE5yYkZkTlZrcEVWbFJHYzFZeFpITmFSbWhwWVhwV2VGWlhNVEJUTVZsNFlrWm9hMUl3V205VmJUVkRVMFpaZVUxVlpHaGhla1pZVmpKd1ExZHRSWGhqU0VwWFVqTk9ORnBGWkVkU01YQkhXa2RzVjFKVmJEWldNbmhYVm0xV1IxUnJaRmRpUjNodlZXMHhiMkl4VWxobFJYUllZa2RTV1ZSV1VsTldSVEZ5VGxab1YySlVWbEJaVlZwTFkyczFWMkZHVmxkaVNFSk5WbXBDWVZsWFRYbFNhMmhRVm14YVQxWnNhRU5PYkdSVlVXeE9VazFYZUZoV01uaHJZV3hPUm1OR2FGcGlSa3BJVmtWYVlXUkhWa2hTYlhCWFlsWktObFl5ZEdGaE1rcElVMnRrYWxKVVZsaFpiRkpHVFVaa1YxZHVUbGhTYkZwNVYydGFhMkZYUmpaV2JHaFlWak5TYUZkV1dtdFNNV1IxVldzNVYxWlVWbEZYVjNSclZURmFjMVpZYkdwU2F6VlpXV3RhYzAweFVuTlZhMDVYVFZac05sWlhOV0ZYYkZwWFkwVjRZVkpXY0ZoWmVrcEhVakZrZEdKR1RtbGhNRmt5Vm0xNGIyUXhTWGhhU0ZKWFlrZG9XRmxVU2xOaFJsWjBUbFZPV0ZKc1NsZFdWM1JoVkd4S2MyTklhRlppVkVFeFdWWlZlRll5VGtaaFJtaG9UVlp3Tmxac1kzaFRNVXB5VGxab1UySkhVbTlVVmxwMlpXeGtjbHBFVW1oTlZtdzBWMnRvVTFVeVNsbFZiR2hWVmxaS1dGVXdXbHBsVjFKSVVteGFUbFpzV1RGV1ZFb3dZekZXZEZKdVRtcFNiV2hoVm1wT1UyVnNVbkpYYkdScVZtdHdNRnBGV2s5VWJGbDRVMjFHVjAxdVVsZFViRnBhWlVaa1dXSkhhRk5OYldoWlZsY3hORmxYUmtkalJWWlVZWHBzY1ZSWGRIZFRSbVJ5VjIwNWFGWnNjRmhaTUZwelZqSktWVkpZWkdGU1JWcG9XWHBHWVdNeVJraGxSazVPVFZWd1dGWXhaRFJXTWxGNVZtNU9WMWRIZUU5VmExcGhWMFpTVmxWclpGaFNiWFF6V1ZWV01GWXdNVmRpZWtwV1lsaG9kbFp0TVVkamJVNUhVV3hhYVZkSFozcFdWRUpoVXpKTmVGVnVVbWxTYXpWd1dWUkNjMDVzV25STlZGSm9UV3hHTkZaV2FITldSbVJJWVVkb1ZtSlVSbFJaVlZwWFpFVXhXRTlYY0U1V2JIQTBWbXRrTkZReVJuTlRiazVVWWtkb1dWbFVSbmRWUmxweVYydDBhMUl4U2taV1IzaHJWRzFHY2xKWWFGaFdiSEJvVlhwS1QyUkdUbkpXYkZacFVqRktVRmRXWkRSWlZsWlhWMjVTVGxOSGFGVlVWbHAzVjBaVmVVNVZPVmRpVlhCSlZsZHpOVll5U2xWV2EwNWhWak5vYUZZd1ZYaFdWbFowWTBVMVUxSnNiekpXYlhCS1RWWlJlR0pHWkZSaVJscFlXV3RhUzFZeGJISlhibVJPWWtaS1dGWXlNVWRoTVVwVlVtdHdXbFpYVVhkV1IzaGhZekZrVlZGc1pFNWliRW95Vmxod1IxVXlUWGhhU0U1b1VteHdjRmxVUm5kWFJscEhWbTEwYVUxVmNFaFdNV2hyVjBkS2NrNVlSbHBoTWxKVVZGWmFhMk5zY0VoUFZscE9ZVE5DU0ZkWGNFOWhNVmw0VTI1T2FsSnRhRlpXYkZwM1lVWldjVkp0ZEd0V2F6VjVWREZhYjFaR1NsWmpSMFpYVFZad1ZGVnFSbUZrUmxweVdrWm9hVkpzY0ZaWFZsSlBWVEZhUjFWc1pHRlNhelZZV1d0YVlWZFdjRlphUkVKWFZqQndTRmxyVWxkWFIwWnlUbFJPVjJGcldtRmFWM2hIWTIxV1IxcEdUbE5YUlVwV1ZteGtkMUl5UlhsVmJHUldZbXhLYjFWdGN6RmlNWEJZWlVkR1RtSkdiRFJYYTFKRFlWVXhWbFpxVWxkTmJtaHlWMVphUzJSSFJrbFViRnBwWW10S05sWnRjRWRWTVZsNFkwVmtWV0pHU2xSWmJHaHZUbFprVjFac1drOVdNRnBJVlRJMVMyRlhWbkpqUjBaYVZrVmFNMXBYZUZwbFZURldWMjE0VTAxRVZrZFdhMlEwV1ZaU2MxTnVWbEppVjJoWldXdGFkMVl4Y0ZaWGJVWlhUVlZ3TVZaSGVHdGhSMVp6VjJ4c1YyRnJTbGhWTW5ONFl6RmtkVlJzV21oTk1VcFFWbGR3UTJNd05VZFhXR2hvVTBVMVdGVnFRbGRPVm14V1dYcFdWMkY2UmtsWlZWWlRWMFphYzJOSGFGcE5ibWhvV2tWYVMyTXhXbk5VYld4VFZucHJlbFpxU2pSV01rVjRVMWhzVTFkSGFGVldNR1JUVjFac1ZWTnRPVmhXYlhoV1ZUSjRUMkV5U2tkalJXeGhWbGRTU0ZsVVJtRmpiR1J4VVd4V1RsWnVRbmxYVmxaV1pVWmtWMUp1VG1sU2JWSlBWbTAxUTJWV1duTlpNMmhYVFZWc05GWlhOVTloVmtsNVlVWlNXbUpIVW5aYVJFWnJWakZXY2xwSGRFNVdNVXBKVmpKMFlXRXlSa2RVYTJoV1ltdGFWbFp0TVZOV1JsVjNWMnh3YkZaVVZsZGFSVnAzVmpKRmVsRnJiRmRXUlc4d1ZtcEdhMlJHU2xsaFIzQlVVMFZLVjFkWGRHRmtNREI0Vm01U2JGSXpVbkpWYWtaTFUxWnNWbFpVUmxaTlZYQllXVEJhZDFZeVNsbFJhM1JWVm0xU1QxcFZXbXRqTVhCSFlVZHNhR1ZzV21GV01XUTBZVEpKZUZwRlpGWmlSbkJvVlcxek1WWnNWblJOVkU1T1lrWmFNRlJXVWtOaFIwWTJVbXh3VmxZelVuWldha3BMVjFkR1NWTnNjRmRpU0VKUlZsY3hORlF5VWxkYVNFNWhVako0V1ZWcVNtOVhiRnB4VW0xR1dsWnRVakJXYlhScllXeEtWMk5IT1ZaaVZFWlVXV3BHVTFkRk5WaFBWbWhwVWpGS1dsZHNWbXBPVjBaV1RWWmthbEpYYUZoV2FrNXZZVVpzVmxkcmRGZGhlbFpZVm0xNGEyRldXa1pYYkZaWFlXdEthRmRXWkZOU2F6RlhWMjFHVTJKV1NsQldWM1JYV1ZVMVYxZHVSbFJoYkVwd1ZGWmtVMU5XVm5OaFJ6bFlVakJ3V1ZsVldtOVhiRnBHWTBaU1ZrMUdjRlJhUlZWNFZtMVNSMVJyTldoTk1FcEtWbXBLTUdFeVRYbFNiR2hUVjBkU2NWVnNaRFJYUmxKWVRsWk9WMUpzV25oVmJURkhZVEZLYzJOSWNGZE5iazE0Vm1wS1MxWXhUblJQVm1SWFpXdFpNbFpHV21GVmJWWklVMnRrVjJKR1dtOVVWVkpYVmxaYVIxZHRSbXROYkZwSVZteG9jMkZzU25KT1ZtaGFWMGhDU0ZwV1dscGxWMVpJVDFaa1RsSkZXWGhXYkdNeFV6RlpkMDFWYUZaaE0yaG9WV3hhZDFkR2JEWlRhMlJUVFZkU01GbHJXbTlWTURGMFZWUktWMkZyV2xSVmVrRXhVakZhV1dGR2FHbGhlbFphVjFkMFlWbFdXa2RpU0U1b1VsVTFWbFJXV25kbFJsWjBaRWhrYVZKcmNIcFpNR2gzVjBkRmVXRkVUbGRTUlZwb1drVmFWMk50UmtkWGF6VnBZbGRvV2xadE1YZFRNVTE0Vkd0a1YySnJOVzlWYlRWRFkwWldjVk50T1ZOV2JIQlpXa1ZrUjJFd01WWmpSbWhXWWxob2VsbFZXa3RqYXpWV1QxWmthR0V4Y0UxV1J6RTBZVEZaZUZkdVRsaGhlbXhZV1d0a00yVnNXa2RXYlRscFRWWndTVlV5ZEhOVmJVcElaVVpvV2xZelRYaGFSM2hhWkRGa2RWcEdUbGRoTTBGM1ZsY3dlR1F4VW5OWGJsWlNZV3h3V0ZSWE5WTmpiR3h4VW14YWJGWnNjREZXVnpFMFZUSktjbE5zY0ZkaVdFSlFXV3BHYTFJeFpIVlNiRXBYVWxad1dWWkdXbXRWTWxaellrWmFZVkpHU2xkVVZscDNWbXhhZEdWSVpGaFNiSEF3V1ZWU1QxWnRSbkpYYkVKWFlXdGFjbGw2U2tkVFIxSkhWR3hPYUUwd1NtRldha1poWWpKUmVGTllhRlZoTWxKdlZGUktVMWRXYkhKV1ZFWmFWbXh3TUZwRmFHdFhSbHB6WTBac1lWSldTbFJXYWtwSFRteEtjbUpHWkZkTk1Vb3lWbTB3ZUZJeVRuTmFTRVpWWWtad2IxbFVSbmRXVm1SVlUyNXdUbFp0VWtsVk1uUnJXVlpKZVdGRk9WZGlWRVYzVkZSR1lXUkZNVWxhUjNST1lrWndTRlpIZUZkaE1WbDRXa1ZvYUZKc1dsaFVWV1JUWkd4WmVGZHNjR3ROV0VKSlZERmFhMVJzV25Sa00zQlhUVzVTY1ZSc1dscGxSazUxVlcxNFUxSlZjR2hXUmxKUFVURk9SMkpHYUd4U1dGSnhWRlpWTVdWc1dYbGxSMFpWWWxWd01GbFZXa2RYUmxwMFZWUkNWbVZyY0U5YVZWcDNVMVphZEdOR1RtbFdhM0JSVmpGamVFNUdTWGROU0doWVlteEtUMVl3YUVOak1WWjBUVlpPVkZac2NEQmFSV1F3WVVaYWNtTkljRmROYm1oMlZqSXhSbVZHWkhGVWJHUnBVbTVDYjFkVVJtRlNNbEpJVld0a1ZtRjZWbGhXYWs1cVpERmFjVk5xUW1sTlZXdzBWbXhvYzFaSFJYbGxSazVhVjBoQ2VsWnFSbk5qTVZaeldrWk9VMkpJUWxsV2FrbDRVakpHZEZOcmFHdFNSbkJoVm14YWQxWkdXa2hsUjBaWVVqRkpNbFZYZUd0aFJURnlUVlJTVjFkSVFreFZha3BPWlVaU2RWWnNaR2xTV0VKM1ZtMTBhMDVHV1hoWGJsSk9Wa1pLY2xSVlVrTk9SbGw1WkVkMFdGSXdjRXBWVnpWUFZtMUtWVkpzVW1GV00yaGhXbFpWZUZaV1ZuTlhhelZvVFZkME5WWnRNSGhOUjFGNFYxaHNWR0pHV2xSV01HUlRWMVphZEdWSVpGcFdia0pZVmpKek5XRnRTa2xSYTJ4YVRVWndVRmxXV2xwbFYwWklUMVprVGxZeFJqTldNVnByVlcxV1IxWnVTbUZTTTBKVVdXeGFTMWRzWkZobFJ6bFdUVmRTU0ZaWGVHdFpWa3BHVTJ4Q1dtRXlVVEJXYWtaYVpWZFdSazlXWkZkTlNFSkpWMVJDVTFFeGJGZFVhMnhTWVRGS1dGbFhkRWRPUm5CSFYyeGthMUl3V2toWk1HUTBZVVV4V1ZGVVNsZGlWRVl6VldwR1VtVkdjRWRhUjNCVFZqRktkbFpYY0V0T1JscEhZa1pXVldFd05YQlVWbHB6VGtaa2NsVnJUbWhTVkVaWVZtMXdWMVl4V2paV2JFSlhUVWRTUjFwV1dsZGpNa3BIWTBkc1UwMXRhRlpXTVZKSFdWZE5lVlJ1VG1wU1YxSldXV3hvYjJOR1ZuRlNhM1JQVm14c05WcEZZelZoUlRGWFkwWnNWazF1VW5KWlYzaExZekpPUjJGR2NHbFNNbWhWVjJ4a05GbFhUbGRUYmxKVFlrVTFjRlpzV2xwTmJHUlhWbTFHYUUxV2JEUlZNbmh6VlcxRmVXVkdiRmROUjJoRVZUQmFZVkpXVG5OVWJHUk9WakZKZUZaclpEUlZNa1pYVjFod2FGTkdjRmxaYTJSU1RVWmtWMXBGY0d4U2JWSmFXVlZrUjFVeFNuSmpTR1JYVW0xUmQxbDZRVEZTTVdSellVZDBVMDB4U25aV1YzaFRVVEExVjJKR1dsaGlhelZaV1d4V2QxTldiRlpYYkU1WFRVUkdXRmt3V205WGJWWnlWMnhvV2sxdWFETlZha3BIVTBkS1IxUnRiRk5pV0ZFd1ZtMXdSMVV4VVhsVldHaFlWMGRvV1ZsdGRIZFVNVnB6VjIxR1YxSnRlSGxYYTFwUFYyeGFjMU5zWkZkTmJsRjNWakJhUzJNeVNrVlViR1JPWW0xbmVsZFhkR3RUTVVsNFdraFdhbEp1UWxoV2JUVkRaVlphZEdORlpGUk5WbXcxVmtkMGEyRldTblJoUm14V1RVWmFURlV4V210V01WWnlXa2RvVGxZeFNrbFdhMk14VXpGc1YxTnVVbWhUUlVwWVdWZHpNV1JzY0VWU2JVWllVakZhU1ZReFdrdFViRmw0VTJwYVYyRnJhM2hXVkVaVFl6RmtjbGRzVW1sU01taG9WbXBDYjFFeFRrZFhXR2hZWWxWYVZWVnNVbGRXTVZGNFdrYzVWMDFyV1RKV2JYUnpWakZhUm1FemFGZFNSVnBvV2tWYVMyUldUbk5WYld4WFRXMW9XbFp0TVRSWlYxRjVWbTVPYUUweWVITlZha0poWTJ4YWRFNVZUbFJTYlhoWFYydG9UMVpyTVVWU2JHUmFZbTVDU0ZacVNrZGpiVWw2V2tad2FHRXpRa2hYYkZaaFlUSlNWMVJ1U2s5V2JWSndWbTEwZDA1R1duTmFSRkpvVFVSV1NGZHJXbXRoVms1SFUyeENWMkpHVlhoV2ExcFhaRWRXU1ZSck5VNVdNVW8xVm0weGQxRXhXbkpOVlZaVFlrZDRXRlpxVGtOVFJscHhVVmhvYTFZd1drcFZNbmgzVmpGWmVGTnJhRmhpUmxweVZrUkdTbVZHWkhWVWJVWlRUVzFvZGxaR1ZtOVJNbEp6VjI1R1UySlZXbTlVVmxwTFRVWmFkR1JIZEZwV2F6VklWako0YTFkdFNraFZibHBYWVRGd2VsWXhaRTlTTVhCSVpVZHNVMDFWY0dGV01uUlhZVEZKZVZKWVpFNVhSVFZWV1cwMVExZEdVbGRhUnpscllrZFNXRll5ZERCVk1rcEdUbFJDVm1KWWFISlpWV1JHWlVkT1JrMVdhR2xTYmtKdlZteFNSMWR0VmtkYVNGWldZbGhTVkZSWE1XOWtNVnBZWlVjNVVrMVhVbnBXTWpWUFdWWktSMU51UmxWV2JWSlVWRlZhVm1WWFVraGtSbVJUVFVoQmVGWldaRFJpTVdSMFVsaG9hbEpGTlZoVVZWcDNaV3hTZEdWRmRHcE5XRUpKV1RCVk1WZEdTbFpqUlhCWFRWWndXRmRXWkVabFZrcHpXa1pTYVZJemFGUlhWM1J2VVRGa1IySkdhR3RUUm5CeVZGWmFkMVpzVm5Sa1IwWnBVbXR3TUZaWGVIZFhSMFY0Vmxob1YwMUdjRXhXYkZwaFl6Sk9SMkZHWkd4aE1Ga3dWbXhhVTFJeVJYaFRXR2hYWW1zMWIxVnFUa05XUm14elYydDBiRlp0VWxsYVJXUkhZV3N4UlZGcVVsaGhNbWhNVm1wS1MxWnNaSFZSYkZwcFYwWkplbFpHVm1GWlZtUklWR3RhWVZKdFVtOWFWM1JhWlVaa1YxWnNUbFZOVjFJd1ZXeG9jMVp0UlhsVmJXaFhZV3MxZGxVd1duTk9iRXAwVW0xd1RtRXhjRXBYVmxaV1RWWlplVk51U2xSaGEzQllXV3hTUm1ReFdsVlNhelZzVW14d1dsbFZXbTlYUmtsNVlVWmFXRlo2UlRCWFZscGhZekpLU1ZOc2FHaE5NVXA0VmxjeE5HUXlWa2RYYTJoT1VrWmFXVlZ0ZUhkbGJHdDNWMjVPV2xac2NGbFdWM1J2VjJ4YVJsSnFVbFppUm5CTVdrWmtUMUl4Y0VaT1YyaHBVbTVDVjFadE1UQmhNRFZIVkZob1ZHSnJOV2hWTUZwaFZsWnNjbGR0UmxoU2JYaDVXVlZXVDFReVNrZGpSV3hoVmxkU1NGWXllR0ZqYXpWV1drWldhVkp1UW05V2JGWmhXVmRTU0ZKclpGWmlSbHBZVm0wMVEyRkdXa2RYYlVab1RWWnNORll5TlU5WFIwWTJZa1pvV21FeVVYcFVWbHBoVmxaT2NWVnNaRTVXYkZreFZsUktNR0V4V2toVGJGcFlZa1p3V0ZsdE5VTlhSbkJJWlVad2EwMVhVakZYYTFwUFlWWktkVkZzWkZkV2VrVXdXVlJLUjFZeFRuVlRiWEJUVW01Q1dsWnRNVFJaVjA1ellrUmFVMkpHY0hOV2JYTXhUVlpWZVdWR1RtaFNWRUkwVlRKNGMxZEdXbk5UYTNoWFZqTk9ORlZxUm10a1ZrcHpWRzFzVTFkRlNqWldiVEI0VFVkUmVWWnNaR2xTYkhCWldXdFZNV0l4V25Sa1NFNVBVbXhXTlZwVmFHdFhSa3B6WWtSYVYxWjZWa3hXYkdSR1pVZE9TVk5zWkdoaE0wSk5WbGR3UzFJeFRraFVhMmhzVWpKb1QxWXdWa3BOVmxweFVtMTBUbEp0ZUZsV1JtaHJWREZhZEZWc1pGcGhNbEpVVmpGYWMyTXlSa2RVYld4T1ZqTm9ObFp0TURGaE1WbDNUVlprVkdKdVFsaFpiRkpDVFZaWmQxcEZkRk5OYXpWSVdXdGFhMVl3TUhoVGFrcFhZbGhDVEZWcVNrOWtSbEp5VjIxNFUySklRblpYVmxKUFVURlNWMWRzYUd4U01GcFhWRmR6ZUU1R2EzZFdiVGxvVm10d01GbFZXbE5YYkZwR1RsVlNWVll6YUdoYVJXUlhVMGRTU0dSRk5WZFdSVlYzVm0xNFlXSXlTWGhhUldSaFVsZG9jMVZ0ZUhkWlZscHlWbTFHVGsxWGVGZFdNbmhyWVd4YWNrNVlhRmRXTTJoeVZsUktTMWRYUmtoU2JHaFhVbFZ3YjFkV1VrdFRNVTVIVkc1S2FGSnNjSEJWYWs1dllqRmFXR1ZIUm10TmF6VjZXV3RhVjFWc1pFaGhSbEpYWWxoU00xcFhlSE5XYkdSMFpFWldhVlpZUVhkWFZsWmhZekZaZVZOclpGUmhNMmhYV2xkMFlWVkdWbkZTYlVaclZteHdlbFV5TVhOVk1rcEpVV3h3VjAxWFVUQlhWbHBMWkVaV1dXRkdhR2xoTVhCVlYxZDRWMWxXWkVkVmJHaHNVbGhTVlZadGVIZFhWbkJHV1hwV1YySkZjSHBaTUZKRFZqRlplbUZJV2xkaVJuQm9WakJrUjFKc1ZuTldiV3hUWW10S2RsWnRNVFJaVmxGNVZHeGtWMkpyTlZoWldIQlhWMFpTVjFadVRrNU5WbkI2VmxkME1GUnNTWGRpUkZaV1lsaFNjbFpyWkV0VFJsWnpWbXh3YVZKc2NHOVdiVEUwV1ZkTmVGcElWbUZTVkZaUFZtMDFRMDVXV25GVFdHaFRUV3RhZVZSV1dtOVdiVXAwWlVkb1ZtSkhVbE5hUkVaaFZsWk9jbGR0ZUdsU1ZuQTBWbTB4TkdFeFZYZE5TR3hvVW5wc1dWWnRlRXRVUmxaeFVtMTBVMDFWTlhwWmEyUkhWVEF3ZDFOc1ZsZGlXRUpRV1dwR2ExWXhaSEphUm1ocFZsWndlVlpHV210Vk1VNUhWMWhzVDFack5XOVpXSEJEVGxac1ZsZHRPVmRXYkd3MlZsZHdUMVpyTVVkalIwWmhWbTFTVUZSdGVFdGpNWEJHVGxkb1RrMUZjRTFXYlhoaFlUQTFSMkpHWkdGU1YxSlpWakJvUTFZeGJITmFSemxZVm14d01GcFZhR3RYYkZwMVVXeGtWMDFxUlhkWlZFWmhZMjFPU1dOR1pHbFdSVm95Vm10a05GTXhTWGhhU0U1aFVtMVNjRlZxUVRCbGJHUnpWbXhhVGxacmJEUlpNRlpyV1ZaSmVXVkdVbFppVkZaRVZtcEdhMWRIVmtkVWJYQk9ZVEozTUZkWGRHRmpNa1p6VTJ4b1ZtSkhlRmhaYkdodlRURlplRmRzVG1wTlYzY3lWbTE0YTFSc1NrWlhhbFpZVmtWS2FGcEVSbXRqTVdSeldrZHdWRkp1UWxsWFZtUXdXVmRHUjFadVVrNVdWR3hVVkZkMFlWTkdhM2RXVkVab1ZqQndXVmxWVWxkV01ERllZVVJPVm1WcldrOWFWVnBQVjFkR1NHTkdUbGROVlhCWVZqRmtOR0V3TlVkYVJXUnBVbXhhVkZscmFFTmpNV3h5VjI1a2JGSnNWalZaTUZaUFZqSkdObEpzWkZwaE1VcFlWbTB4UzFOSFJrbFhiR1JvVFd4S1RWZFVTWGhVTVVsNFVtNU9ZVkl5ZUZoVmJGcDNWbXhhZEdORlRscFdNREUxVmtjMVQxZEhTbk5YYldoV1lXczFSRlpyV25OamJIQkZWRzE0YVZKdVFYZFdSbHBUVVRGU2MxTllaR3BTVjNoWFZGYzFVMk5zYkZobFJYUlRZa1UxTUZsVldtRmhWa2w0VTJ4V1YxWkZTbWhXTWpGWFYwWmFjbUZHVG1sU01VcFpWMVpTVDFFd05WZGFSbVJYWWxWYWNGUlhkR0ZTTVZKWFYyNU9WbUpWY0RCYVZWcHZWMnhaZWxWcmVGcE5ibWhZVkcxNFMyUkhVa2RhUlRWWFltdEdORlp0ZEd0T1JrMTVVbXhrVkdKc1dsTlpiVEZUVjBaYWRXTkZXbXROV0VKR1ZXMXpOVll3TVZoVmJuQlhZbGhvVEZsV1dtRldNazVKWVVab1YwMHlhRzlXVjNCQ1RWWkplR05GYkZSaVYyaFVXV3hhUzFkV1duUmpSVTVyVFZVMVdGWXllRzlpUmtweVRsWnNXbUpHV2xoVWJGcGhVakZXY2xSc2NGZGlTRUkyVjFSQ2IxTXhXWGROVldoV1lrWktWMVJWWkZOVlJsWjBZM3BXVjAxWVFrbFphMXBQVkdzeGMxSlliRmRpVkVWM1YxWmFjMVl4WkZsaVJrNVlVakpvV2xacVFtdGlNa1pIVm01T1lWSjZiSEJVVmxwaFRVWlNWMWw2VmxoU2EzQXdXbFZvYzFZd01YRldia3BYVWpOT05GWXhXa2RqTWtwSVVteGtWMDF0YUU1V01XUXdXVlpOZVZWclpGZGliRnB4VlcweFUxWkdjRmhrUm5Cc1lrWndlVmRyVWxOWGJGbDNUbFJDVjFJelVsaFdNR1JMVTBkR1IyRkdjR2hOV0VGNlYxZHdSMWxYVG5OV2JrcGhVbXh3VDFsWWNFWk5SbHB5V1hwR1YwMVdiRFZWTW5SaFlXeE9SbE5zYUZwaE1YQXpWRlJHV21WR1pIUmtSbVJPVm14d05WZHJWbUZaVjBaSVZtNUtXR0V5ZUZsV2FrNVRaR3hXY1ZKc1dteFdhelY1V1d0YVMyRlhSalpXYkdoWVZtMVJkMVY2UVhkbFJscFpXa1pvYVZkR1NuaFhWM1J2VVRGSmVGcElTbGhpVlZwV1dXdGFkMDFXVmxkaFJ6bFhUVlp3TUZaR2FHOVhiRnBHVjIxR1lWWldjSEpaTW5ocll6RldkR0pHWkU1aVYyZ3lWbTE0YTAxR1dYbFZXR2hWWVRKU1dGbHRkR0ZXUm14elZtMUdhbUpHY0RCYVZXUkhZa1phYzFOdWNGZE5ha1YzV1ZaYVNtUXlUa2RqUm5CWFZtNUNObFp0Y0V0VE1VNUhWVzVHVldKVldsaFdiWGhYVGtaYVZWRnRSbHBXTURFMFdUQldiMVV5U2tkVGJGSlhUVVphVEZZeWVHRmtSVEZWVVd4d1YySllhRnBXVkVadllqSkdWMVJyV21wU2JXaGhXV3hvVG1WR1drVlNiRTVYVFZkU01WZHJWVEZWTWtwWlZWaHdWMDF1VWxoWlZFWmFaREF4V1ZOdGNGTldNbWhvVjFaU1IxTXlSa2RYYmtaVFlUTkNjMWxyVm1GbGJGcFlaVWQwVldKVmNEQlpWV00xVjBaa1NWRnJlRmRTUlZwUVZUQmFTMk5zY0VkaFIyeFhUVEpvWVZac1pIZFRNa2wzVGxaa1dGZEhlSEpWYWtKaFdWWmFjVkZzWkU5V2JIQklXVlZvVDFack1YSldhbFpYVm5wR2RsWnRNVXRYVmxKWllVWmtUbEp1UW1oWGExSkhXVmRPZEZWclpGaGhlbFpZV1cxMFNrMUdXbk5aTTJSc1VsUkdTVlZzYUd0VWJGcHpZMFU1VjJFeGNFeFdNRnBYWkVVeFdFOVhkR2xTTVVwWlZtcEtNRTFHWkVkVGJrNVlZbTVDWVZac1duZE5NV3hYVjIxMFUyRjZSbFpXVjNodlZqQXdkMU5yYkZkaVdFSk1Wa2N4VjFJeFpIVldiR1JwVW14d2QxWlhjRXRpTVZwWFdrWm9hMUp0VW5KVVZscHpUa1paZVdWSGRGcFdhM0JIVlRKek5WWnRSbkpUYWs1V1RVWndZVnBXVlRGV2F6bFlZVWRzVTFkRlJqTldNbmhYWVRGSmVGZHNaRmhpUjFKeFZXcENZV0ZHVm5KV2JVWm9VbXhhZWxZeWREQmhiVXBYVTJ0b1dHRXhjSEpaVlZWM1pERktjVlZzWkU1V2EzQkZWakZhYTFWdFZsZFRia3BZWVhwV1dWVnRkSGRrYkZwWVRWUlNXbFp0VWxoV01qVlRZa1pPU0ZWdE9WWmlXR2hoVkZkNFYyUkZNVlphUjJoT1ZsaENObFpVU1RGak1XUjBVbGhvYWxKWWFHRldiWGgzVkVac05sTnJPVk5OYTNCSVdWVmFhMVJyTVhSaFNGcFhZa2RvTTFWNlJscGxSbVJaWVVkR1ZGSllRblpXVjNoVFZqRmtSMVp1VW10VFIxSlpWbTB4VTFkV2NGWmFSV1JZWWtad2VsbHJVbE5XTVZsNllVaEtWMDFIVWt4Vk1GcFhZekpHUjJOSGJGTmlSemsyVm14U1MwNUdXWGhhUldoWFlUSm9VVlp0TVZOWFJteHlZVVZPV0ZadFVsWlZWM2hQVmxVeFYySkVUbFZXYldoWVdWVmFUMUp0VGtoU2JGWlhaV3hhTWxkV1ZtRmtNVXB6WTBWYVVGWnJOVzlhVjNoaFYxWlplV1JIZEdwTlYxSklWVEZvYzJGR1NYZFhiR2hhWWtaS1NGUlVSbGRPYkVaWllVWk9UbUV6UWtsV01uUnJVakZWZUZkWWFGUmlTRUpaVm0xNFMxTkdjRVZTYlVaWFRXdHdTbFpITVVkVk1sWjBaVVpzVjFKc2NISlVhMlJYWXpKS1IxZHNjR3hpUm5CMlZsY3hNR1F3TVZkV2JHaHNVMFUxWVZadGVIZFhSbXQzWVVWMFdHSkdiekpWYlhRMFZtc3hSMk5HYUdGU2JWSk1WV3BLUjFOSFJrWk9WbWhUVmxkM01WWnRNSGhPUmxWNFZGaG9WVmRIZUZaWmJYTXhWbXhzZEdSSVpHbE5WbG93VkZaak5WZEdTbk5YYm5CWFlsUldjbGxXVlhoV01rNUpZMFprVjAweFNubFdiWEJMVXpGWmVGcElUbWhTYlZKVVdsZDRZVmRXV25Sa1IzUlVUVlZzTkZaSE5WTlZSbHAxVVd4b1ZtSkdTbGhWYkZwaFkxWktkRkpzY0ZkaE1uY3dWakowYjFVeFZYbFRhMlJVWVhwc1dGbHNhRk5OTVZWNFYyMTBXRkl4U2toV1IzaDNWakpLUjFkVVJsZFdNMmgyV1dwS1IyTXhVbkpYYlhCVFlraENXVmRYZEdGa01WSkhWbGhrV0dKR2NITldha1poVTJ4YVNFMVlaR2hXYTJ3MFZUSndWMVl4U2taWGJrcGFZV3RhWVZwV1drdFhWMHBJWkVkNGFFMVlRbUZXYlRCNFRrWnNXRkpyWkZkaWExcFVXV3RvUTJNeFduUmtTR1JPVm14V05WcFZXazloUmxwellrUldXbFpXY0ROV2FrcExWbFpHY1ZWc1pGZFNWbkJSVmxkd1IxbFhVbGRUYms1VllsZDRXVlZ0ZEhkWlZscDBUVWhrVGxaclZqUldSM1JyV1ZaT1JtTkhhRlpOUmxWNFdXcEdWMk5XU25SU2JYaHBVbTEzTVZkVVFsWk9WbGwzVFZWV1UySkhlRmhXYlRGdlkyeFpkMWR0Um1wTmF6VktXVEJhYTJGSFJYaGpSbFpZVmtWdk1GcEVSa3BsVmtweVlVZG9VMVpHV25kV2JYQkxZbXN4VjFkdVVteFNNMUpRVlcxNFYwNVdXa2RoUnpsb1ZtdHdNRlpYZUhOWGJVcFpWVzFvVjFaRlducGFSVlY0VmpGU2MyRkdUbWxTV0VKYVZtMXdTMDFGTVVoVGEyaFVZVEpTY1ZWdE1UUmhSbFp6VjJ4YVRsWnNjSGhWVm1odlZURmFjbU5FUmxwaE1YQXpWa2Q0UzJSV1JuUlBWbVJwVmtWVmQxWnFTWGhXTWsxNFUyNVdWV0pHY0hCVmFrWkxaR3hrVjFWclpHdE5Wa3BZVjJ0b1MxWXlTbFpYYkdoVlZqTk5lRlJWV21Ga1IxSklUMVphVG1FelFraFdSM2hoWWpGa2RGTnNiRlpoTTJoWVZGYzFiMWxXY0ZkYVJrNVVVbXR3ZWxrd1dtdFViRnBYWVROa1YySkdTa2haYWtwT1pVWmtjMkZHVGxoU00yaDJWbFJDVjFNeFdYaGlTRTVXWVRKU1dGVnRlSGRsVmxsNVRWVmthR0Y2UmxsV1YzQkhWbXN4Y1ZKWVpGZFNNMmhvV2taYVIyTldWbk5hUm1Sc1lUQnJkMVpyV2xkWlZsVjVWRmhvVldKSGVHaFZiVEZUWWpGc2NsWnVaRmhXYkhBd1ZGVm9iMkZWTVhOWGJuQlhUV3BXVUZkV1drdFhWbFp6Vm14YWFHRXdjRzlXVkVKaFlUSk9jMXBJVm1GU2JWSlBWbXhvUTFsV1dsZGFTR1JVVFZac05WVXllRmRWTVZwR1UyMUdZVll6VWpOV1JFWjNWbXh3Ums5V1RtbFNia0kyVm1wSmVHTXhXWGROU0d4b1VtdGFXRmxzVWtOTk1WSlhWMnRhYTAxRVZscFdSM2h2WVZkS1JtTkdRbGRXUlVweVdXcEdZVkl4Vm5OaFIzUlRZbFpLVVZaWE1UUmpNRFZYVlc1T1YxWkdXbGhVVlZKSFpWWlplVTVZWkZkaGVrWXhXVlZvWVZZd01YRlNhM2hXVFVkU1NGVnRjelZXTVZweldrZHNWRkpWY0RKV2JURjNVVEpGZUZWdVVsZGliRXBVV1ZSS2IyTldWbk5WYkdSWVVteEtXRlp0TldGVWJVcEhZa1JTVjAxdWFISldNbmhhWlVaS2NWVnNaRmRsYkZwUlZtMTBhMU15VFhoYVNFNVZZa2hDV0ZSVVNtNWxiRnB4VVcxR2FrMXJNVFJXYlRWTFZsZEdObUpHVWxwaE1YQXpWR3RhWVZaV1RuVmpSVGxYVFVad05WWkdXbUZqTVZaMFVsaHdVbUpIYUdGWmEyUnZaR3hhVmxkdVRsZE5WMUo1VkRGYVQyRldTbFZXV0doWFRXNVNhRmxVUmxwbFZscDFVMnhrYUdGNlZscFhWbEpIVXpGT1IxcEdaRmhpU0VKelZXcEJNVkl4WkhKYVJ6bFdUVlp3U0ZZeWVITldNVm8yVWxoa1lWSkZjRmhXYWtaclkyeHdSMkZIYkZOTlZYQTFWbXRhWVdFeFZYaFVhMlJZVjBkNGNsVnVjSE5XYkZKWFYyNWtUbEpzY0ZsYVZXTTFWakF4Y2xkdWJGWk5ia0pRVm1wQmVHUlhSa2hoUm1ST1VqRktXVlpVUWxaT1ZsbDRZMFZrWVZJeWVGVlZiRlozWVVaYWNWSnRSbGROVm13MFZsWm9iMkZXU25SVmJGWmFWa1ZhTTFZeFduTmpNWEJJVDFkb1UySkdjRFpXYWtvMFlURlJlRk51VGxoaWJrSllWRmMxVW1ReGJGVlNhM0JyVFVSV1YxZHJXbGRoVmtwMVVXNXNXRlpzY0doV1JFWkxZekZTZFZOdGNGTmlWa3AzVm1wQ1lWTXlTWGhYV0doWVlsVmFjVlJXWkZOVFJscFlaVWhPYUZacmNIbFViR00xVmxaWmVtRkZlRmRpV0doeVZtcEdWMk5zY0Voa1JUVlhUVlZ3V2xZeFpEQmlNVTE0V2tWb1ZHSkdjRmxaYTJRMFZqRnNjMVZyV2s1U2JrSllWako0ZDJKR1dYaFhhMnhXWWxSR2VsWlVTa1psYkVaeFYyeGthR0V5ZERSWFdIQkhWMjFSZDAxV2JGZGlWMmhVVmpCa2IyRkdaRmRWYTJSclRWWktTRmxyVW1GV1IwWTJZa1pXVjJGclNtaFZNRnBhWlZkV1NHUkdWbWhsYTFsM1YxWldVMVl4V1hsVGJHeG9VbXhLVjFsWGRHRmxiRnB4VW1zNVdGWXdXa2xWYlhoVFZUSkZlbEZzV2xkTlYxRjNXVlJLU21WR2NFWmFSbHBwVW14d1ZWZFdVazlWTWsxNFYyNVNiRk5IVWxsV2JURXdUVEZhZEUxVVFsaFNhMnd6V1RCYWIxWnRTbGxSYkVKWFlrWndhRmw2U2s5VFZrNXpXa1UxVTAxVmNFNVdiWEJEWVRGWmVGTllhRmRpYXpWWldXeGtORmRXVm5Sa1NFNVBZa1p3TUZrd1ZtdFhiRnAwWlVab1ZrMVhhSFpYVmxwUFVqRk9jMVZzY0doTldFSk5WbXRTUjFsWFVraFZhMnhoVW14S1dGbHJhRU5PUmxwVlVteE9VMDFXY0hsVVZscHJWa2RLZFZGc2FGVldlbFoyV2xkNFlWZEZNVlprUjNCb1pXeGFXVll5ZEdGa01WbDNUVWhvVkdFeWFGbFphMXBoWVVaYWRFMVdaRmhTYkhCNVdWVmFUMkZXWkVkVGJGWlhVbXh3YUZwRVJrOWpNWEJKVTJ4a2FWZEdTbmRXUmxwaFl6QXdlRlZzWkZkaWF6VlhXV3hXVjA1V2NGWlhiazVYVFd0V05GWXlkRFJYYXpGMVlVaHdXazFXY0V4WmVrcFBVMGRXUjFSdGFHeGlSbGt3Vm0weE1HRXdOVWRXV0d4VFlURndUMVl3V2t0aU1WWjBUVmM1V0ZadGVIbFhhMXBMWVRBeFdWRnJXbFppV0dob1dXdGFTbVF3TlZaaFJtUk9ZV3RhU1Zac1VrZGhNVWw0Vkc1T1dHSkhVbkJXYTFaWFRURmtjbFZyZEZkTmF6RTBWMnRvVDJGR1NYcGhSbEpWVmtWYVRGWXdXbUZTTVdSMFVtMTBUbFl4U2paV2JURTBZakZSZUZkWVpGaGlSMmhXVm1wT1UxZEdVbkpYYmtwclRWZFNNRlF4V205aFZscFhZMFJXVjJGcmJ6QlpWRVp6VmpGa2MxcEhjRk5pUlhCb1YyeGtNRmxWTUhoV2JrWlRZbTFTVlZWcVFuZFRWbXhXV2tSU2FGWnJjREJVTVZKWFZqSktWVkpVUWxwV1JVVjRWV3BHWVZkWFNrZFdiR2hUVFcxb1lWWXhaREJoTVZWNVZHdGtWMWRIVWxoWmJURlRWMVpXZEUxVVVrNVNiWFEyV1RCV2ExWXhXbFZTYkdoV1RXNW9kbFl3WkVabFJrNXpWV3h3YUUxWVFtOVhhMVpyVmpGSmVHTkZaR2hTTW1oUFZteG9RMUpzV25STldHUlNZbFphU0ZZeU5WTldWMFY1WlVoR1ZtSlVWa1JXUkVaWFpFVTFWbFJyT1dsU2JrSTBWbFpqZUUxR1ZYZE5XRXBQVjBkNFZsbHJXbmRsYkZweVdrVjBWRkpzV25sVU1WcGhZVlphUjFkclZsaFdNMEpJVjFaYWExSnJNVlppUjJoVFlrWndVRlp0ZUc5UmJWRjRWMjVTVGxaRlNtOVVWM1JoWld4VmVXVkdaRmROYTNCSVZUSXhSMWR0U2toaFJsSlhVbFp3VjFwV1pGZFRSa3AwWkVaT1RsSkdXa2xXYlhSclRrZFJlRmRZWkU1V2JIQlpWbXRXUzFkR1duSldia3BzVW14d1ZsVnRNVWRYUmtweVkwWndXbUV4Y0doWlZscExZekpPU0dGR1pHaGhNSEF5VmxaU1IyRXhTWGhhU0ZaVVlrZG9jRlpzV25kbFZscDBZMFZLVGxack5WaFdWbWh2VmpGYVIxZHNaRlZXTTFJelZUSjRWMVl5Umtoa1JtaFRZa2hDU0ZaVVNqUmlNVnBYVjJ4a2FsSnJOV2hXYkZwM1ZVWlplRmR1WkZSU01IQklWa2Q0VDJGRk1IZFRiVVpYWVd0YWNsUlZaRVpsVms1WllrWldhV0Y2VmxwWFZsSkxZakpOZUZadVJsSmlWVnB4V1d0YVlXVkdWbGhOVldSWFVtdHdlbGxyVWxkWlZscFlZVWhLV2xaV2NHaGFSVnBYWTIxS1IyTkdaRmRpUm10M1ZtMHhkMU14VFhoVFdHaGhVMFpLYjFWdE1WTmlNV3hWVkd0T1ZsWnNjREJaTUZaclZtc3hjMU5zYUZkV2VsWlFWbXBLUzFkSFZrZFdiRnBwVW14dmVsWnFTalJYYlZaSFkwVldVbUpYZUU5V2JGcGFUVVprV0dSSFJtaE5WM2hZVlRJMVQxZEhTa1pPVjBaYVlURndhRmxWV25OalZrcHpWR3hvVTAxVmNFcFdWekI0VGtkR1YxTnVVbXRsYTFwWVZXcE9iMkZHV2tWVGEyUlhUVlUxTVZVeWN6VldNVmw2WVVkb1YySllhR2hhUkVwUFl6RmtkVlJzYUdsV1ZuQjRWa1prZWsxV1NYaGpSbHBZWWxWYVZsbHJWbmROVmxaWVkwZEdWMDFyY0ZaVmJGSkRXVlpLUmxkcmVHRlNWbkJZV1RKNGQxSXhaSFJpUms1WFVteHdVbFp0TUhka01ERlhVbGhvVldKck5WbFdNR1J2VmpGc1ZWRlVSbHBXYkhCNFZWZDRhMVF4U25OaVJGSmFWbGRvVUZacVJrcGtNazVHWVVad1RsSnNWWGhXYlRGNlpVWk9SMVp1VmxoaVIxSlBWVzAxUTA1c1duRlJiWFJXVFZVMVdGWlhOVXRWUmxweVRsaENWbUpVVmtOVVZWcGhZekZyZWxwSGVGTldSVnBKVm1wS01HRXhXa2hUYmtwUFZteGFZVmxzVWtka2JGbDNWMnhPV0ZKVVZsbFVNVnB2VlRKS1dXRkdiRmRoYTI5M1drUktTMUl4WkZsYVJtaG9UVzFvV1ZkWGVHOWlNazV6WWtaa1dHSllVbFJaYTFVeFpWWmFXR1ZIT1doV2EzQjZXVEJhYjFkSFJYaFRhM2hYWVd0YVMxcFZaRTlTYkhCSVlrWk9UbUp0YUZaV2ExcFRVVEZOZUZkc1pGaGliRXB6Vlcxek1WZEdVbGhsUjBaVVVteHNOVnBGWkRCWFJrbDNZMFZvV2sxR1ZURldha3BMVjFkR1NXTkdWbWhOV0VKdlZtcENhMVl4VGtoVmEyUmhVbFJXYjFSVVFrcE5WbHB5V2tSU1dsWXdiRFJXTVdoelZUSktjbU5HVmxwaE1sSjJWbTE0YzJNeVJraFBWbWhUWWtkM2VsWXlkR0ZoTVZWM1RWWmtWR0p1UW1GV2JHUlRaV3hhY1ZKdGRGTmlSVFV3V1ZWYWExUnNXblZSYkd4WFlsaENRMVJXV2twbFIwNUdZa1pTYUdWc1dscFdWekUwWkRKU2MxZHNhRTVUUjJod1ZGWmFkMlZzYkhKaFJUbG9VbXR2TWxscldtRldiVXBWVWxoa1ZXSkdjSGxhVnpGUFVteHdSMXBGTldoTlYzUTFWbTB3ZUU1SFNYaGFSV2hUVjBkb1dGWXdaRzlYUm14WVpFaGtWVkp0ZERWYVZWVTFZVEZLY21OSWNGaGhNbEoyV1ZWVmVGZFdSbk5YYkdScFVtNUNWVlpYY0V0VWJWWkhZMFZhWVZKc1duQlZhazV2Wkd4YVdFMUlhR2xOYXpWSVdXdG9TMVl5U25SVmJHaFhZbFJHVkZZeFdsTldNVlp5Vkcxb1RsSkZXbHBXYkdRMFlqRmtkRkpZYkdoU2EwcFlXVmQwZDFSR1duUmxSM1JxVFd0YVNGa3daRzlVYkdSR1VtcGFWMDF1YUZoWFZscHpWakZTY2xkck5WZFdiSEJaVjFkMGEySXhXa2RpUmxaVllUQndjMVZ0ZUhkWFJtUnlWV3RPYUdGNlJsbGFWVnB2VmpBeGRXRklXbHBXVm5CTVdUSjRUMlJHU25OYVIyaE9WbTVDZGxadGRGZFpWbXhZVkZob1lWTkZjSEpWYWs1RFZERnNWVkp1WkZSV2JWSllWbTB4TUdGVk1WZFRha0pXVFc1U2FGWXdXbXRUVmtaellVWndhVkl5YURKV2JYUmhWakExYzFOdVNrOVdNMmhZV1d0V2RtVkdXbkphUkZKWFRXdGFXVlV5ZEdGaGJFcHpWMnhzVjJGck5WUlpNbmhoVmxaT2NtTkhlRk5pUm5BMlYxWldhMlF4VW5KTldGSm9VbXRhV0ZadWNFWk5SbkJGVW0xMFUwMVhVbnBaVldRd1ZURktWbU5HYUZkU2JGcFVWV3BLVjFZeFZuVlViV2hVVWxSV1dWWnRNVFJrTWxaellUTmtZVko2YkZoVVZWSkhVMVphV0dSSE9WZFdNSEJXVlcxME5GWnRSbkpqUldoV1lXdGFjbHBGWkV0U01WSnlUbGRzVjAxdGFFbFdiVEYzVWpKRmVWVllhRlJYUjJod1ZXMHhVMkZHVm5OWGJtUlZUVlp3ZWxkclVsTmhWVEZYVjJwQ1lWWlhVa2haVjNoTFl6Sk9SVkZ0UmxkV01taDVWbTEwWVZsWFRYbFVhMnhxVW0xb2IxUldWbmRXVmxweFUycFNXbFl3TVRWVk1uUlhWakpLUjJOSVFsZGhNWEJvVmxaYVlXUkhVa2hrUmxKT1ZsZDNNRlpyWXpGVU1XeFhVMjVXVW1KclNsZFpWM1IzWkd4YWMxZHRkRmROVm5Bd1ZXMTRZVlJzV25WUmFscFhUVzVTZGxaRVJtdFRSazV6WWtkb1UySlhhRmRXYlRFMFpEQXdlRlpxV2xOaVZWcHhXV3RvUTFKc1dsaE5WemxWWWxWV05Ga3dWbmRXTWtwVlVWaG9WbVZyV25KVmFrWjNVbTFHU0dGR1RtbFdNbWh2Vm0weE1GWXhiRlpOU0docVVsZG9jMVV3WkZOV1JscDBaRWhrYkdKSGRETlhhMUpEVmxkS1JtTkZaRmROYm1oMlZtcEJlR1JXVm5SaFJuQm9ZVE5DU1ZacVFtRlRNV1JZVW10b2FsSnJOWEJXYlhSM1YyeFplRnBFVWxaTlZYQjVWRlpXYTJGc1NsZFhiRlphWVRKU1ZGWXdXbE5YUjA0MlVteFNVMkpXU2pWV2FrbDNUbGRHUjFOWWFGaGhhMHBvVm14a2IyVnNXbkZUYTNSWFZtdHdXbGRyV205V01rcFhVMnhzV0ZkSVFraFhWbHByVjBaT2NtRkhlRk5oZWxaUVZrWmFWMlF4WkVkWFdHaGhVa1pLV0ZSWGVFZE9SbFY0WVVjNWFGSlVRalZXVjNoclYyMUZlVlZzVWxkTlJuQlVWbTE0VjJOc2NFZGhSbVJwVTBWS1dsWnRlR3ROUmxGNFYxaGtUbGRGY0ZsWmJURTBWMFpTV0dOR1pFNU5WbkI0VlRKME1GZEdXbk5UYkhCYVZsWndjbGxWWkVabFIwbDZZMFprVjAwd1NrbFdNVnByVlRGT1IxUnVTbUZTYkZwd1ZtcE9iMlJzV2tkV2JUbFNUVVJHZWxZeU5WTmhiRXBaVld4Q1ZtRnJTbGhVVkVaVFZqRmFkR1JIYUZkaE0wRjNWMVpXWVZsV1pITlhhMXBxVW14S1dGUlZXbmRsYkhCR1drWk9WRkpyY0hwV01uTXhWakF3ZVZwRVRsZGhNWEJvVjFaYVVtVkdjRVphUm1ocFlYcFdlRlpYZEZkVE1rWkhWMjVPWVZKNmJIRlphMXAzVTFad1ZsWnFRbWhoZWtaWFZHeFNSMWRyTVVkalJFNVhZV3RhWVZwVldrdGpWbEp6WVVaa2FWSnVRblpXYkdoM1V6RlJlVlZyWkZaaWEzQndWV3BPUTFaR2JIUmtSWFJyWWtad1NGWXllR3RoTURGWVZXeG9WMDFYYUhaV01HUkxWbXhrYzFac1ZsZGlWa3BWVmxSQ1lWbFdaRWhXYTJ4VllsZG9WRmxVVGtKa01WcHpXWHBHVWsxV2JETlVWbFp2Vm0xS2MyTkdhRlppV0dneldUSjRZV014WkhKUFYzUlhUVVJXU0ZaSGVHRmhNa1pYVkd0YVZGWkZjRmhaYkZKRFRURlNWMWRzU214V2EzQXhWa2Q0VTJGWFNrWmpSbWhZVm5wR05sUldXbk5XTVdSMVUyeGthVlpXY0ZCV1JscGhaREZPUjFkWWJHeFRSMUp3VlcxNGMwNUdXWGxrU0U1YVZtdHdXRlpzVWtkV01WcEdZMFY0VjAxWFVraFZha3BQVWpGd1NHSkdUazVXVmxsNlZtcEdZVlV4U1hsU1dHaFZZVEpTVmxsdGVHRldiR3h5VjJ0MGFsSnRlRlpXUjNSUFYwWktkRlZzYkdGV1YwMHhXVlpWZUZZeFRuSmhSbVJPWVd4YVRWWnFRbXRUTVZweldraFdVMkpJUW05VVZtaENaV3hrYzFwRVVtaE5helY2VmpKNFYxWXlTa2RqUlRsYVZrVTFSRlV5ZUd0amJVWkpXa1pLVGxadGR6RldWRW93WWpGYWMxcEZhRlppVjJoWFdWUkdZVTB4V2taWGJHUnFWbXR3ZVZReFpEQldNa3BHWWpOa1dGWXpVbWhXUkVaV1pWWk9jbUpHU21sU00yaFpWa1phYTFWdFVYaGlSbFpVWVROQ2MxWnRlSGROVmxwSVpVYzVhRll3Y0VkWk1GcERWakpLV1dGSVdsZFdSVnBvVm1wR1lXUldTbk5UYld4WFZtNUNWMVpzWTNoT1IwMTNUbFprYWxKc2NHOVZhazVUWWpGV2RHVklaR3hXYlhoNVZsZDRhMWRIU2tkalJtaFdUVzVSTUZacVNrZGpiVTVHV2tkR1YxWXhTbEZXVkVKclVqRkplR05GYUdoU01taFBWRlZXZDFZeFduUk5XR1JTVFZkNFdGWnNhSE5XVjBweVRsaEdWbUpIVW5aV2ExcHpZMnhhVlZKc1ZrNVdhM0JZVm0wd01XRXhXbk5YYms1cVVrVktWbFp0TVc5amJGcHpWbGhvYW1KVmNFWldSM2hYWVZaSmVXRkdSbGRoYTBwb1dWUkdUMU5HV25KaVJsSnBVbTVDZGxkV1VrTmtNa2w0V2tab2FsSlhVbGRVVm1SVFUxWmFXR1JJVGxwV2EzQjZWVEo0YjFkdFJYaGpSMFpWVm14d2NsbDZSbUZrUjFKSFZHczFWMDFWY0VwV2JGSkhZakpGZVZKdVRsUmlSM2hUV1d0a1UxZEdiRmhqZWtacllraENTVnBWWkVkaE1VcFZVbXhrV0dFeVVqTlpWV1JYWXpGa2RGSnNaR2hoTWpoM1ZqRmFZVlV5VFhoVWJsWlhZa1Z3YjFscmFFTlhWbVJZWlVaT1UyRjZSa2haYTFwWFZrZEdObFp1VGxkaVdHaE1XbFphYzFac2NFVlJiRnBPVm01Q1NWWnFTalJXTVZsNFYycGFVMVpGU21oVmExWjNVMFpXY1ZKdGRGaFdNRnBKVlcxNFQxVXhXbGxSYlRsWFlsUkdNMVZVU2s1a01EVlhXa1prYVdKRmNIcFdWM0JQVlRGa1IxWnVVazVXYXpWVlZtMDFRMVl4WkZsalJtUlhUV3R3VjFrd1ZuTlhiRnBZWVVkb1YyRnJSalJXYWtwUFUwWktkRkpzVGxOWFJVcEtWbXhqZUU1R1ZYbFVXR2hXWW1zMVZsbHNaRFJYVmxaeFVWUkNUbFpzY0RCYVZXUjNZa1pLVlZKcmJGZFdiV2g2Vm10a1JtVldWbk5pUm5CcFYwVXhORlpxUm1Gak1sSkdUVlpXVm1KSVFsaFphMmhEVG14YWNWTlVSbWhOYTFwSVZUSTFVMkpHU25SVmJHaGFZVEpTZGxreWVITmpiR1J6WTBkMFRsWXhTalZYVmxaaFpESkdSazFXYkZKaWJYaFlXV3hvUTFOR1ZqWlNiVVpyVW14S2VWbFZXa05XTWtwWFUyeHdWMVpGU2xoVmVrWlRWakZrZFZOc1dtaE5iRXBhVjFkNFlWbFdUbGRYYTJoclVqQmFZVlp0ZEhOT1ZteFdWMnhPVjAxclZqUlpNR1J2VmpBeFYyTkhhRmROUmxZMFZteGFSMlJIVWtaT1ZtUnBVMFZLWVZadE1YZFRNRFZJVTFoc1UySnJOVlZaYTJSdlZqRnNjbGR0UmxkaVJuQXdXbFZvYTJKSFNrZFRibXhYVFdwV1VGbFhNVXRXYkdSeVdrZEdVMVp1UW5sV2EyTjRVbTFXYzFKdVNtaFNiVkpVVkZSS2IySXhaRmRWYTJSb1RXeEtTRlpITlV0WlZrcDBZVWM1V2xkSVFsaFpha1poWkVVeFZWVnRkRTVXYlhjd1YxUkNZV0V4V1hoYVJXaG9VbTE0VjFscldrdGxiRmwzVjI1T1YySklRa3BXUjNoaFZHMUZlbEZxVmxkV1JWcFVWWHBHV21WV1RuTmlSa3BvVFRKb1YxWnRlR3RWTVUxNFkwWmFZVkpZVWxSVVZtaERVMFphV0dWSE9WZFNhM0JYV1RCU1MxWXlTa2RUYTFKYVlXdGFSMXBXV2t0amJIQkhXa2RzYUdWc1dtRldNV1F3WVRGVmVGWnJaRmRpYkVwelZUQmtVMk14Vm5SbFIwWk9VbXhLZWxkclVrTldNREZXWTBoc1dtRXhTbFJXYlhONFpGWldkVmRzWkdoaE1YQk5Wa2N4TkZNeVVsaFVhMlJxVW0xU1dGbHJXbkprTVZwelZXdGtXbFpyYkRWV1YzUmhWVVphZEZWdGFGWmhhMjh3VmpCYVYyTXhaSE5qUjNocFVtMTNNRlpxU1hoTlIwcElVMnhrV0dFeWFGaFVWbVJ2Wkd4YWNscEZkRlJTTVZwS1ZWZDRZV0ZXWkVaTlZGSllWak5DU0ZaVVJtdFRSbHB5VjIxMFUySlhhRmxYVjNoaFV6RmtWMWRZYkd0U2F6VlhWRmQwVjAweFVsZFhiVGxYWWxWV05WbFZaRWRYYkZwR1kwaGFWMkV4Y0doVmJGcExaRVpLYzFwSGFHeGlSbkJhVmpGa01GbFhSWGxTYkdSWVlURndXRll3WkZOWFZteHlWMjVrYUZKdGVGWlZNbk0xWVdzeFdGVnVjRmRpV0doUVdWWmFXbVZ0UmtkV2JHaFhZa1Z3VVZaV1kzaFZiVlpIWTBWc1ZXSkhVbkJWYkZKWFZrWmFSMWR0Um10TlYxSklWakZvYzFReFdsVmlSemxhWVRGYU0xcFdXbFpsVjFaSVQxWm9hVkp1UWtoV2FrcDNWREZaZUZOc1pHcFNSVFZYV1d4b2IyRkdXbk5YYlVacVRWaENTRmRyWkhOV1JrcFdZVE5zVjJGcldtaFdha3BHWlZaT1dXRkdXbWxoZWxadlZsZDRZV1F4V2xkaVJsWlZZVEExV1ZWdE1UUmxiRnBZWkVkMFZXRjZSbGhXTWpWdlZtMUtXVlJZYUZwaE1YQk1XVEp6TVZaV1NuTmFSazVPVFcxb1ZsWXhXbUZaVmsxNVZGaHNWV0V5VWxoWmEyUnZWMFpTVlZKcmRHbE5WMUo1VmxkMGExWnRTbGRYYTJoWVlUSm9XRlp0TVV0WFYwWkhWbXhhYUdFeGNFMVdha1poV1ZkU1JrMVdWbFppV0ZKUFZtcEdTMU5XV1hsa1IwWlhUVlp3V1ZVeWVGZGhWa3AwWVVab1dtRXhjRXhWTUZwaFkxWktkVk50ZEU1V2JIQTFWbXRrTkdFeVJraFdia3BZVjBkb1dGbHJaRTlPUm14eFVtMTBhazFYVWpGV1J6RjNWVEZrUjFOdE9WZGlXRUpRV1dwR2ExSXlTa1ZYYkU1cFVqRktlRlpHV21Ga01sWnpXa2hLV0dKWVVtOVZiRkpEVFRGVmVVMVZaRmROYTFwNVdXcE9hMVl4V2taWGEzUmhWbXh3VEZZeFpFZFNNa1pIWVVaT1RtSlhhREpXYlhoVFVURmFjazFXYUZOaE1sSllXVzE0UzJOV2NGaGtSMFpYWWtaS1dGZHJVbE5XTWtwSFkwVnNZVkpXVlRGV2JGVjRZMjFPUm1GR2NFNVNNbWcyVm1wQ2ExSnRWa2RVYms1V1lrZFNUMWx0TVc5aU1XUlpZMFYwVlUxVmJEVlZNblJyVjBkS1dHVkdVbFZXZWtaMlZHeGFZV1JIVWtkVWJFNU9ZVEZaTUZaVVNURlRNVkY0VjI1U1ZtSlViRmRaYkZKWFVrWnJkMWRzWkd0U01VcEtWMnRhYjFZeVNrbFJiSEJZWVRGYWNsVnFSbXRUUms1eldrWm9hVkl6YUZsWFYzaHZWVEpTYzFkc1ZsUmhNMUpWVldwQ1lWTkdXbGhsUm1SWFRWWndlVmt3V25OV01WcEdVMjFvVjAxcVJsaFdNRnBYWTIxR1NHUkdUazVpYldoUlZqRmFVMUl5VVhoYVJtUllZbXRhVlZsWGVFdGpWbEpYVjIxR1RsSnNWalZhUldNMVZqSktWbU5GYkZwV1YxSklWako0WVZKdFRrZFZiR1JYVm01Q1ZWWnRlR0ZUTWsxNFZXNU9ZVkpVVmxoVVZsWnpUVEZaZVdSR1pGcFdiRVkwVmxjMVQxZEhTa2RYYkdoYVZqTm9NMVl3V25OWFIxSkpXa1U1YVZKcmNEWldha28wWkRKS1IxTnVWbEpoTWxKaFZteGtVMlJzV2xWVGEzUllWakJhU0ZscldtdFdNbFp5Vmxoa1YwMVdjSEpXUkVwT1pVWndTVlJzWkdsU1ZGWjJWMnhrTkZsWFZuTlhiR2hxVWxWd1QxWnRjekZUUm1SeVlVVjBXRkl3Y0ZwV1YzaHZWbFphYzFkcVRsZE5SbkI1V2tSR2EyUkdTbk5hUlRWWFlsUm9OVlpzV21GaU1rbDRWMjVPV0dFeGNGbFphMVpMVjBac1dHUkhSbWhTYmtKSVZqSjRhMkV4U1hoWGEyaFhVbnBGTUZsV1dtdFRSMFpIWTBaa2FWZEdTbTlYVmxKQ1pVWk9SMVpzYkdsU2JWSndWV3BHUzFkV1duRlJiWFJQVWpBMVdGWnROVWRWYlVwV1YyeHNWbUpZYUV4V2FrWmhWMGRTU0dSR2FGTmhNMEkyVm0weGQxWXhiRmRUYkdSVVlURktXRmxYZEdGaFJtdzJVMnM1VTFaclducFhhMXByVkdzeFJWRnFVbGRoYTFwb1YxWmFUbVZHVG5WVWJGSnBZVEZ3V0ZkWGRHdFZNazVIVjI1S1YySlZXbFZXYlhoM1YxWnJkMVp0ZEZkaGVrWjZWVEowYzFadFNsbFZiV2hYVWtWYVlWcFdaRmRTTWtaSFZteGtiR0V4Y0RWV2EyTjRUa1pzV0ZWcldrNVdiRnBYV1d0YWQxUXhXbk5YYkhCT1VtMVNXVnBGWkVkaFJURnlWMnhvVmsxcVZsUlpWVnBMWXpGT2RGSnNaR2hOVm05NlZtMTBZVmxYVGxkVGJsWlZZbGhDY0ZVd1ZrdFRWbHB5V1ROb2FrMVdTbnBXTWpWUFlXeEtSMU5zYUZwV1JYQlRWRlZhWVZKV1RuSmFSM0JPVmpGSmVGWnJaRFJpTWtaSVVsaGthbEo2YkZoWmJHaHZZVVprVjFaWVpHeFNiVko1V1ZWVk1WWXhaRWRUYkZaWFVteHdjbFpVU2xkU01WcHpZVWQ0VkZJeFNsZFhWM1JYWkRBeFYxWnNhR3hTVjFKWlZXMTRkMlZzV1hsbFIzUmFWbXh3V0Zrd1pFZFpWbHB6WTBaU1drMXVhRE5WTUdSTFVqRlNjazVXVG1saE1IQm9WbTB3ZDJReVZrWk9WV2hXVjBkb2FGVnRNVk5YVm14MFpVVjBWVTFXY0hsV01uUXdWMFphZEdWSWNGZE5ha1pJV1d0a1MxSXhaSEZSYkZacFVtNUNlVmRXVm10VE1VcDBWR3RXVW1KSFVsaFVWRUYzWlVaYWRHTkZkRlJOVm5CWVZqSTFTMVp0U2toVmJGSmFZVEpvUkZscVJtRldWa1p6VjIxNFUySklRbGxXYlRBeFZESkdjMU51VWxaaGVteFlXV3RrYjFKR1ZqWlNiVVpyVWpGS1NWcEZWVEZWTURGSFYxUkdWMVo2UVhoV1JFWmhVakZ3Um1GSGVGUlNWRlpZVjFkNFUxSXlVbk5YYmxKc1VqQmFjVmxyV25kTlZtUnlXa1JDYUZacmNIcFpNRkpoVmpKR2NtSkVVbFpoYTNCSVdYcEdhMlJXVG5KUFZtUlRWbTVDWVZZeFdsTlNNbEY0VjJ0a1dHRXlhSE5WYWtKaFkxWnNjbHBHVGxkaVJsb3dXbFZrTUdGR1duSmlSRkpXWWxoQ1VGWXdXbUZqTVU1eVlVWndWMUpXY0ZGV1YzQkhWVEpTVjFkdVRsWmlWM2hVVkZjeGIwMHhXbk5hUkZKV1RWWnNOVlZ0ZEd0WlZrcDBZVWhLVm1Gck5WUlpNRnBUVmpGa2RWcEdVbE5pUjNjd1YxWldhazVXWkVkVFdHUnFVbGQ0V0ZadWNGZFRSbHB6VjJ4d2JHSkdXakJaVlZwaFlVZEZlR05HYUZoaVJuQlhXbFZhWVZZeFduVlViR2hvWld4YWRsWkdVa05UTVU1elYyNVNhbEpYVWxkVVZsWlhUa1paZUdGSVRsZFNNSEJJVmpKNFQxZHNXWHBoUlhoYVZsWndXRmt5ZUdGa1JrcHpXa1pPYVZkSFRqVldiR04zWlVVeFIxcEZaRmhpYkZwVFdWUktORmxXVWxaWGJtUldVbXh3ZUZWV2FHdGlSbGwzVjJ0b1dtRXhjSEpaVlZWNFYxWkdkV0ZHWkZOaVNFSjVWbFJKZUZZeFdYaFhibFpYWWtaYWNGVnFTbTlrTVdSWFZXdGthMDFXY0hwWGExcHJWbTFHTm1KR1pGVldNMDE0V2xkNFdtVlZOVmRVYldoT1ZsZDNlbFpxU25wT1ZscDBVMnhzYUZKWGFGWlpWRVozV1Zad1YxWllhRmRXYTFvd1dWVmFUMkZGTVhWYVJGcFhZbFJDTkZwRVJscGxSbVJ6VjJzMVYySldTbFpYVjNSWFV6RmtSMkpHYUd0U01GcFdWVzB4TTAxc1ZYbGplbFpYVW10c00xWXlkRzlYYXpGSVZWUkNXbFpXVmpOYVJFWlBZekZLYzFwRk5XbGlWMmhhVmpGYVUxSXhWblJXYTJSVllteGFWbGxzVm1GV1ZsWjBaRWhrVjFadFVsbGFSVnBoVkd4YWMxSnFVbGRXTTJoeVZtcEtTMlJHVm5OYVJtUnBWMGRuZWxkc1pEUlpWbVJJVld0YVVGWnRhSEJWYlRWRFRsWmFSMWRzVGxaTlZtdzBWVEp3WVZZeVNrWlRiR2hWVmxkU1ZGWkZXbkpsVjFaSVpFZHdUbFp1UWpaWFZFSnJZekZaZUZOc1pHcFNiSEJZV1d4U1JtUXhaRmRYYkZwc1VtNUNSMWxWV21GaFJURjBZVVpXV0ZZelVuSlpha1pyVWpKS1NWTnNhR2xUUlVwUVZtMHdlRlV5Vm5OWGJsSk9Wa1ZLVjFSVlVrZFhSbXQzVjIxMFYxWnNjSHBaTUdSdlZqRktSbGR0YUZkTlIxSllWV3BLUjFJeGNFaGlSMnhvVFVoQ1MxWnRlRk5STVd4WFlrWm9WV0pIVWxaWmJYUjNZMnhXZEUxV1RsaFNiWGhXVmtkMFQxUXhXbk5qUlZwV1lsUkdTRlpxUVhoV01rcEZWbXhhVG1Kc1NqWldiR1EwWVRGT1YxSnVUbWhTYlZKdldWaHdWMUpXV2xWUmJVWm9UVlpzTkZrd1ZtdFdWMHBJVldzNVYySllhREphVlZwaFkyeHdSVlZzWkU1aE1YQlpWbFJLTkZZeFdYbFRhMXBVWWtkb1dGbHROVU5STVhCV1YyeGtWMVpyY0hwV1IzaFBWR3haZUZOWWFGZGlSMUkyVkZaYVlWSXhUbGxoUmxKcFltdEtXVlp0TlhkU2JWRjRZa1JhVWxaRldsUlVWbVJUVjJ4c1ZscEhPVmRTYTNCV1ZtMTRjMVl4U25SVldHUmhVa1Z3V0ZacVNrWmxiSEJIWVVkc2FHVnNXbUZXTVdRMFZqSlJlRmR1VGxoaWJFcHlWVzF6TVZkR1VsWlZhMlJZVW0xME0xZHJWbXRYYkZweVkwVmtXazFHV25aV2JURkxWMWRHUjFWc2NHeGhNWEJ2VjFod1IxVXlVa2hUYTJSb1VtczFUMVZyV2tkT1JscDBUVWhvVDFKc1ZqUldSbWhyVkRGYVdHRkdVbGROUjFFd1ZtdGFjMlJIVmtaa1JtUlhZbGhvTlZZeWRHRlVNVmw0VjI1U2JGSnNjRmRVVjNCQ1RWWlpkMWRyZEdwTmF6VktXVlZhYTFVeVZuSlNXR2hYWWxob2FGVjZTbE5UUmxweVdrZEdVMkpYYUhaV1JscGhZekF3ZUZkdVVtcFNWWEJ6VlcxNGQyVldVbk5YYkdSV1lsVndTRmt3YUVOV01ERklWVzVhWVZac2NHaGFSV1JQVW0xU1IxcEZOV2hsYTFWM1ZtcEtNRmxYVFhsU2JrNVVZbXhLVjFsdGRFdFdNV3h6WVVaT1RrMVdjRWhXTWpGSFYwWlpkMDVWWkdGU1ZuQllXVlphWVdNeVRrWmlSbVJwVmtWR05GWnRjRWRaVm1SSFZHNUthRkl5YUZWVmJGWjNWMFprV0dWSE9XbE5SRUkwV1RCV2IySkdTWGRYYkZKVlZteHdNMVJWV2xKbFJtUnlaRVpXYVZaV1dURlhhMmgzVVRGWmVWSnVTbWxOTWxKaFZtdFdZV1ZzV25GU2JFNXFZbFZ3U0ZVeU1XOWlSMHBaWVVad1YwMVhVWGRYVmxwT1pVWlNjbHBHWkZoU01VcGFWMWQwYjFFeVRYaFhiazVXWWtkU1dWVnRlSGRUVmxKWFdYcFdhRkpzY0hsWk1GcDNWbXhaZW1GSVdsZGhhMXBMV2xjeFIxTldTbk5XYld4VFltdEtkbFp0TVhkU01rVjVWV3hrVjJKck5WbFpiR1EwVmtac1ZWUnJUbGhXYkd3MFZqSXhNRlJzU25SbFJteFhZbGhvY2xsWGVFdFdNV1J6Vld4d2FFMXNTbFZYVkVaaFl6Sk9kRkpyV2xWaVJrcFVXV3hhUzA1V1duRlRibkJQVmpCYVNGWXlOVXRVTVZwWVZXeGtWVll6UWtoVk1GcGhZMVpPY21SR2FGZGlSbTkzVjFaV1lXUXlSa2hTV0hCU1lUTm9XVmxyV21GaFJuQkZVbXM1VjAxV2NERldSM2hYWVZaSmVXRkdWbGRTYkVwTVdXcEdhMVl4WkZsaFJtaHBVbFJXVjFaR1pEQmpNRFZIV2toS1YySllVbGhaYkZaM1UwWnJkMWR1VGxoaVZYQldWVzE0VTFkdFJuSlhiR2hoVWxaVmVGWnRlRk5qTVZaelZHMXNWMkV5T0hoV2JUQjRUa1pWZUZkWWFGaFhSMmhWV1cxMGQyTkdWbkpXVkVaWVVteEtXVlJzV2s5aE1rcEhZa1JXWVZaWFVraFdha0Y0WTJzMVZtRkdXbGROTW1oNVYxWldhMUp0VmtoVWExcE9WbTFTY0ZZd1ZrdFRWbVJYVld0a1dsWnNiRFJWTWpWWFZsZEtWbGRzVWxWV2VrWjJXa2Q0WVZJeFpIUlBWa3BPVWtaYVNWWnFSbTlqTWtWNFUyNUtUMVpzV2xaV2JYaDNaV3hTY2xkc1dteFNNRnBKVkRGYWExWXdNVWxSYTNCWVlrWmFkbFZVUm1Ga1JrNXpZa2RvVTFKVVZtaFhWbVF3V1ZaYVIxZFlaR0ZTYlZKVVdXeGFTMU5XY0ZaWGF6bG9WbXMxUjFVeU1VZFdNa1Y0WTBkb1YxWkZXbGRhVlZwclkyeGtjazVXWkdsV2EzQmFWakZhYTA1R1RYaGFSV1JXWWtkU2FGVnVjSE5qVm14eVYyNWtiRkpzVmpWYVJWSkRZVVV4Vm1OSWNGZE5hbFl6Vm1wS1MxZFhSa2RoUm1Sb1lUTkNUVlpVUm1GU01sSkdUMVprWVZJeWVGaFZiRnBYVFRGYWRFMUlaR3hTYkd3MFYydFdhMVp0U25KWGJHeGFZVEpTVkZrd1dtRmpWazUwVDFab1YySklRa2xXYlRCM1RsWldjazFXV2s5V1YyaFlWRmMxVTJOc1dYZGFSWFJUWVhwV1dGWXllRmRXTWtwSlVXcGFWMUl6VW1oV2JURlhWMFpTY21GR1RtbFNia0pRVjFaU1IyUXdOVmRYYTJoc1VqQmFjVlJXV25OT1ZsVjVaVWhPYUZKcmNEQlpWVnBoVjJ4YVJsZHFUbGRoYTFvelZtMTRhMlJIVWtoalJUVllVbFZ3U2xacVNqQlpWMFY1VW10YVRsTkhVbFZXYTFaM1YwWnNjMkZGVGxWU2JFcDVWMnRXWVdKR1duSk9XR3hhVmxad1ZGbFZWWGhqTVU1MVlVWmtWMlZyUmpSV1ZsSkhZVEZKZVZOclpHaFNNMUpVVkZWYWQyUnNXbGhOU0doV1RWZFNTRll4YUhOVU1WcFZZa1pvVlZZelVtRlVWM2hoWkVkV1NWcEdaRTVXVjNjeVYxWldZVlV4WkhOWGJsSldZVE5vVjFsWGRIZFZSbFp4VW01a1UwMXJXa2hYYTFVeFZHeGFXRTlVVmxkaVdHaG9WbFJHVG1WR1ZuVlZiR1JvVFcxb1ZsZFdVa3RWTVdSSFlraEtXR0pWV25CVVZscExWakZhV0dWSGRGZGlSbkF3VmxkNGMxbFdTbGhWV0dSWFlsaE9ORmw2Um10a1YwNUhZVWRvVG1KWGFFNVdiVEIzWlVaS2RGVllaRTlXYlZKWldXdGFZVmRHYkhKWGJtUlBZa1p3U1ZwRlpFZFdNa3BYVjJ4c1YxWXpVblpXVlZwaFpFWldjazlXWkdsV1JVVjNWMnhhWVZsWFVrWk5WbFpXWWxkNFQxWnRNVE5sYkZwSFYyeGthVTFXY0RCVmJHaDNZVVpLZEdGR1dsZGlXR2d6VkZSR1dtUXhaSFZVYXpscFVsUldOVll5ZEdGVk1WVjVVbGh3VW1Gc2NGaFVWelZUVmpGU1YxZHNUbXRTYXpWNldWVmtiMVV3TVVkalJteFlWak5vZGxaVVNrZFNNV1J6Vm14T2FFMHdTbnBXVnpCNFZUQXhWMWRzYUd4U00xSnZWV3hTUjJWc1ZYbGxTR1JZVW14dk1sVnNhR3RaVmtwR1YyeG9WMkZyV25KYVJscExZekZhZEdKR1pGTk5NbWN3Vm0xNGFtVkZOVWRpUmxwT1ZtMVNiMVJVU2xOaU1WWnpZVVpPYWxKc1duaFZWelZyVmtaYWMyTkdiR0ZXVjFKSVZtcEtTMUl5U2tWWGJIQlhWbTVDUlZadGNFdFNNazV6VTI1R1ZtSklRazlaYlRGdlpWWmtWVk5xVW10TlZXdzBWakkxVDFsV1NYbGxSbWhWVm5wR2RsWnFSbUZrUlRGSldrZDBUbUpHY0VsV1ZFa3hWVEZaZVZOdVRsUmlSa3BoVm10V2QyUnNiSEZTYkdSclVsUkdXRlpITVhkVk1rcFpXak5rV0dFeFdsaFVWVnByVWpGa2RWUnRjRk5TVlhCdlZsZDRhMVV4VGtkaVJtaHFUVEpvV1ZWdGVHRmxWbXh5VjIxMGFGWnRVa2hWTW5CaFZqSktXV0ZJU2xabGExcHlWbXBHWVdSV1VuTlhiV3hUWWtoQ1dsWnRNWGRUTWtsNFUyeGtXR0pHV2xOWmJGWmhXVlphZEdWSVpGaFNiSEJKV2xWb1QyRkdTbkpqU0d4VllrWlZNVlpxU2t0WFZsWnhVMjFHVTFKV2NHOVdiWGhoVkRKT1YxSnVVbXBTVkZaWVdXdGpOVTB4V25OVmEzUk9VakJXTlZWdE5VOVdSMHB6VTI1T1ZtSlVSblpYVmxwelkyeGtjbVJHVWxOaWEwcEtWMnhXWVZReFdYaFhia3BxVWtWYVdGVnFUbTlqYkZweFUydGFiR0pGV2xwWGExcHZZVVV4VjJOSE9WaFdiRXBJVmxSS1RtVkdjRWxVYkdScFVqRktkbGRYZEZka01XUlhXa1prWVZKRlNuSlpXSEJIVTBac2NsZHNaRlpOYTNCS1ZWYzFUMVp0U2xsVVdHaFZWbXh3YUZVd1ZYaFhWbkJIVjJzMWFFMHdTVEZXYkZKTFRrZE5lRmRZYkZSaVIzaFRXV3RXUzFsV2JGaGtTR1JXVW0xM01sVnRNVEJoYlVwV1YydGtWV0pHY0hKWlZscGhZMjFPUjFkc1pHaE5XRUp2VjFkd1IxSnRWa2RWYmtwaFVtMW9jRmxyVm5kbGJGcFlUVmh3VGxZd2JEUldiVFZQVm0xRmQwNVdRbFppV0doWVZHeGFVMk15UmtaUFZtUk9Va1ZhV1ZkWE5YZFRNVnB6VjFod1VtSkdTbGhaVjNSaFlVWldkRTFWT1ZOTmExcElWakl4YjJGRk1WbFJibHBYVFc1U2FGZFdXbHBsVmxKMVUyczVWMkpXU25aV1Z6RjZUVlprUjFadVVteFRSbkJ6Vm0xNGQwMUdVbFpoUjNScFVtdHdWbFp0ZEhOV01WcDBZVWhhVjAxSFVreFpNbk14VmpKS1IyTkhhRTVpUlc5NVZqRlNSMWxXV1hsVVdHaFhZbXhhVmxsclpHOVhSbXh5VjI1YWEwMVhVbnBXYlRBMVlVVXhjbU5GYkZaTmJsSjJXVlJHUzFKck5WaFNiR1JwVW01Q2IxZFVTalJaVjA1WFUyNU9hbEl6VWs5WldIQlhVMFprV0dSSFJtaE5WbXd6VkZWb2MyRkdTbk5YYkdoYVlrZG9SRlpGV2xkT2JFcDBVbXhrVGxaVVZYaFdWRWw0VGtaVmVWTnJiRkppYlZKWVdWZDBTMk5zYkhGVGJHUlhUVmhDU0ZadGVGTmhWMHB5VTJ4R1YySlVSVEJaZWtFeFVqSkZlbHBHWkdsV1ZuQlhWa1phWVdReFduTlhibEpQVmxVMVdGUlhkR0ZsVm10M1lVVjBWMVl3Y0ZwWlZXUnZXVlpLVjFacVVsWk5WbkF6VlRCa1YxSXhVbkpPVm1SWFlsaFJlbFp0TVRSVk1VbDVVMWhzVkZkSGVGUlphMlJUVmxac2RHTjZSbXBXYkZvd1drVldNRmRHU25OVGJHUlhUVzVvYUZscldrdGtSMUpGVkd4a1RtSnRhSGxYVmxKSFV6RmFWMU51VG1oU2JWSlVXbGQwWVU1c1duSmFSRkphVmpBeE5WWkhkRmRYUjBwSVZXNUNWbUZyV2tkYVJFWnJWakZXY21SR1RrNWhla1V3Vm10ak1WWXhXbGhUYTJSVVltdEtWMWxYZEhka2JGbDVaVWQwVjAxV1dubGFSVnBoWVZaYWNsZFVRbGRoYTI5M1ZtcEdZVk5HU2xsalJscHBVbXR3VjFadE1UUmtNREI0WTBaYVdHSlZXbkpWYWtaaFUwWmtjbGR0ZEZWaVZWWTJWVmQwYjFkR1drWlRiV2hYWVd0YVlWcFdXa3RrVms1MFlrZDRhRTFJUWxwV2ExcHJaREZKZUZaWWFHcFNiSEJaV1cweFUxWldXblJsU0dST1VtMTRlVll5Y3pWaFJsbDNWbXBPV2sxR1NreFdha3BHWlVkT1NWSnRSbGRXTVVwTVYyeGFZVmxYVFhoalJXUm9Vako0Y0ZWc2FFTk9WbHB6V2toa1VrMVhlRmhaYTFwclYwZEtjMU5yT1ZkaVdFMTRWbXhhVjJSRk1WVlZiWGhUWWtoQ1NsWkhlR3ROUm1SSVUydGthbE5IZUdGVVZWcExVa1paZVdWSFJsZE5helZLVmpKNGEyRldXa1pYYXpGWFZrVktjbFZxUmt0ak1WcDFWRzFHVTJGNlZuZFdWRUpYVXpBMVYxZHVVazVXUmtwaFZtMTBjMDVXV2xoa1IzUlhVakJ3ZVZSc1dtRlhiR1JKVVd4b1YwMUdjRlJXYWtaaFpGWndSMVZ0YkZOaVdHTjNWbTE0YTAxR1VYaFhXR1JPVjBWd2NGVnJXbUZXTVd4eVdrYzVhMkpHY0hsV01qRXdWa1pKZUZkcmNGZFNNMmhvV1ZaYVlWSnNaSEZUYkdSb1lUQndiMWRZY0V0VWJWWkhWMjVXVkdKR1NtOWFWM2hoVmxaa1dFMVVRbFJOVjFKSVZqSTFSMVpHWkVoaFJsSlZWbXh3ZWxScldscGxWVFZXWkVkb2FWSlVWa3RXVm1RMFl6RmtjMWRyV21wU2JFcG9WbXBPYjJGR1ZYZGFSbVJVVW10d01GcEZXazlVYkZwWVpFUldWMkpIVGpSVWEyUkdaVlpLYzFwR2FHaE5XRUpWVjFaa05GTXhaRWRpUmxaVFlUTlNWbFZ0ZUdGbFJsVjVZM3BHYVZKcmNIcFZNbkJIVmpKS1dXRkhhRnBXYkhCeVZUQmtSMUl4V25OaFJtUk9UVlZ3ZGxZeWRGTlNNa1Y0VjFob2FsSlhVbWhWYWtKaFZrWldjMVp1Wkd4V2JIQklWakl4UjJFd01WWk9WV2hYVFZkb2VsbHJXa3RPYlVwSlVXeGFhVmRHU2paV1JsSkhWMjFXV0ZacmFGQldiVkpQV1ZST1ExbFdXbk5aTTJocFRWZDRXRll5TlU5aGJFcEdUbFprV21KSGFIWlVWRVpXWlVaa2MxUnRjRTVYUlVwSVZrZDRhMkl4VW5KTlZWcHFVbnBzV0Zsc1VrWk5SbVJYVjJ4YWJGSnJOVnBaVlZwdlYwWkplV0ZHV2xoV2VrWTJWRlprVDFZeFduVlNiRkpwVmtkNGFGWnRNVFJrTWxaWFYyNVNUMVl6VWxoVmJYUjNaV3hyZDJGSE9WZGlWWEJXVld4b2ExZHNXWHBVYWxKWFlXdHdVRlV4WkU5U01YQkhWRzE0YUUxWE9IbFdha1poV1Zac1YySkdhRlZpYkVwV1dWUktVMkl4Vm5STlZrNVZUVlp3ZUZWdGRHdFVhekZYWWtSU1YwMXFSa2hXYkdSTFZqRmtjbUZHWkZkbGJGcE5WakZhWVZOdFZsaFdhMlJXWWtoQ2NGVnFSa3ROYkdSelZtMUdXbFpyYkRSV2JUVkxZVEZKZVdWRk9WcFhTRUpZVmpGYVlXTXhjRVZWYldoT1ZqTm9XVlpVU1RGVE1WRjRXa1ZhVDFadFVtRlphMlJ2Wkd4U1ZWSnNUbGRpUjFJeFYydGFhMkZXU1hoVFdHUllZVEZhY2xscVJscGxWa3BaWWtkMFRrMHdTbGxYVjNoVFVqQXdlRmRzVmxOaVdGSnhWRlprVTJWV1dYbGplbFpZVW10d1dsVlhlSE5XTVVwelYyNUtWMVpGV2t0YVZXUlBVakZrZEZKc1RsZFNNMmhYVm14a2QxRXhiRmRVYTJSb1RUSlNhRlZ1Y0hOaU1WWnpWV3RrV0dKR1dsbGFWVll3VmpBeGNtTkZiRmRTTTBKVVYxWmFXbVZzVW5GVmJHUm9ZVEZ3ZVZkcldtRldNazE0Vlc1U2FGSlVWbkJXYWtwdlZqRmFjVkp0ZEU1U2JIQjVWRlphYTFsV1NuUlZiR2hhWWxoTmVGWXdXbk5rUlRGWFZHeG9VMkpGY0ZsV2Fra3hZVEpLU0ZOcmFGWmliWGhZVm1wT2IxVkdiRlpYYlVaWFZtdHdlbGRyV210aFZtUkdVMnhzVjJKWVFreFZla1poVmpGa2RWUnNTbWxTTW1oWlYxZDBiMUV4VmxkWGJHaE9VMGRvVmxSV1ZuTk9WbFowWkVkMGFHSkZiRFZhVlZwVFYyeGFSazVWVGxWV00yaG9Xa1ZrVDFKc1VuTmpSbVJwVW14cmQxWnFTakJXTWtsNFYxaHNVMWRIZUc5VmJYaExXVlpzVlZOc1RtdGlSbXd6VmpJMVQyRnRTa2hWYm5CYVRVWlZlRlpxU2t0VFZrWnlZMFpvYVZKc2NHOVhWbEpIV1ZaYWNrMVdaR0ZTTTBKVVZXeFdkMWRHV2tkWmVrWnBUV3RhU0ZscldtOWlSa3BaVld4c1ZtSllhR2hhVjNoYVpWZFdTVnBIYUZOV1JWbzJWbFJLTkZZeFpFaFNXR3hXVmtWS1dWWnRNVk5WUmxweFVteE9hMVpyTlRCVmJYaFBWR3N4Um1ORVRsZGlSMUV3VmxSR1lXUkdWbGxoUjBaVFlsWktXVmRYZUZkWlYwNXpWV3hrV0dFelVuTlphMXB6VGxaU2MxZHRkRmRpVlhCSlZsZDBkMVpzV1hwaFNGcFhZV3R3VEZwR1drZGpiSEJIVm14a1YySnJTblpXYlRFMFdWWk5lVlZyWkZSaWF6Vm9WV3hTVjFkR1duSlhiR1JQVW14d01GcFZaSGRpUmtsM1lrUlNWMkpIYUhKV1IzaHJVakZrZEU5V1dtbFdSVlYzVm1wQ1lXTXlUWGxTYTJSVllsZG9WRmxyYUVOT1JscFhWMjA1YUUxcmNFaFZNalZUVm0xR2NsZHNhRmRoYXpWUFdsVmFZV05zWkhKalIzaFRZWHBWZUZkVVFtRmhNVmwzVFVoa1ZHRXhXbGxXTUdoRFVURlNWMWRzY0d4U2JWSXhWbTE0VjJGV1dYbGhSbFpZWWtkT05GUnJXbXRXTVdSellVVTFWRkl5YUZoV1JscFdUVlprUjJKSVNsaGlWVnBaVldwQ2QyVldVbk5YYms1WVlsVldORmt3VWs5V2JVWnlWMjVzWVZKRlduSlpla1pUWXpKR1IxUnRiRlJTVld0NVZtcEdVMUV5U1hsVldHaFlWMGQ0VlZsVVNsTmpWbFowWkVWMFdsWnVRbGxhUldSSFZqRktkR1I2U2xaTmJsSnlWbFJCZUZZeFRuRlJiSEJvVFd4S01sWnJaRFJVTVVwelZHNUthMUp0VW5CV2ExWktUVVprY2xWclpGVk5helY1VkZaYWEyRkdTbkpPVm14V1lXdHdkbGxxUm1GWFIxWklaRVphVGxadVFsbFhWM1J2VXpGa1NGTnNXbGhpUjNoWFdXeFNSazFHY0ZkWGJIQnNWbFJXV1ZwRldtdFViRXBHVjJ4c1dGWkZTblpaYWtaYVpVWk9XV05IYUZOWFIyaFpWbGR3VDJJeFVrZGlSRnBVWVhwc1ZGUldaRk5sYkZsNVkzcEdhRll3Y0VkV01XaDNWakF4VjJOR1VsWmhhMXBQV2xaYVUxZFhSa2hTYkZKVFZtNUNWbFl4WkRCaE1rbDVVMWhvVm1KSFVtOVZiRlV4WXpGYWRHVklaR3hXYlZKV1ZrY3dOVll4U2xWU2JteFZWbXhLVkZacVJrdE9iRnB6WVVad1YySklRazFYYTFaclVqRkplVk5yWkZoaGVsWlVXV3RvUTFSc1duTmFSRUphVmpCV05WWkdhRzlYUjBwelUyNUtWbUpZYUdoWk1GcGhaRWRXU1ZwR2FGZGlTRUpYVmxSR1UxSXhXa1pOVm1oV1lUSjRWMVJYTlZOamJHeFlaVVU1VTJKRk5YcFhhMXAzWVZaSmVXRkdWbGRTYkVwSVZqSXhWMWRHV25KaFJrNXBVakpvVlZaR1dtRmtNVTVYVjI1S1lWSkdTbTlVVmxwTFpXeFplVTVWZEdoaVJYQlpXbFZhYjFkc1dYcFZha3BWVmxad2FGa3hXa3RqTVhCSVpFWk9hR1ZzV1RKV2JUQjNaVWROZUZaWWJGUmhNbmhUV1d0a1UxZEdiSE5oUlU1V1VteHdWbFZXYUd0aVJrbDNUbFZvV2xaWFVUQldWRUYzWlVaT2RXRkdhRmROTVVwNVZteFNTMVl5VFhoalJXeFVZa2RvY0ZZd1drdFhSbHBIVm14T1UwMVZOVWhaVkU1clZtMUtWbGRzYUZWV2JIQXpWV3BHYzJOc1ZuSlBWbVJYVFVoQ1NWZFVRbXRpTVd4WFUyeGthbEpZYUdoVmJYaDNWVVpzTmxKc1RtdFNNRnBKV1d0YVQxZEdTbFpqUm5CWFlsaENTRmxVUVRGVFJrNVpZa1pTV0ZJemFGVlhWbEpMVlRGa1IxZFlaR0ZTYXpWdlZXMTRZV1ZzV2xoT1ZUbFhZa1Z3TUZwVmFITldNREZ4Vm01S1dtRXlVa3hWTUdSWFVqRndSMkZIYUU1aVYyaFNWbTB3ZUdWdFZraFVibEpWWVRKU1dWbHJhRU5YUmxwMFpFaGtXRlpzY0RCWk1GWXdWa1V4Vms1VmFGZFdlbFpJVm14a1MxSXhaSE5oUm5Cb1RXMW9SVlp0ZEdGaE1rMTRWMjVTVTJKWGFFOVpXSEJHVFVaWmVXUkhPVlJOVmtZMFZqSTFVMkZHU25OVGJVWlhZVEZWZUZWcldsTmtSMVpJVW0xd1RsZEZTa2RXYkdRMFpERlplVkpxV2xOV1JVcFlWRmMxVTJGR2JGVlNiWFJVVW1zMU1WVXlNWGRWTWtwWVlVZG9WMkpZVWxkVVZscGhVakpLUlZkc1RtbGhlbFo0VjFkNFYxbFdTWGhYYTJoc1VsUnNWbGxyV25kTlZsWllZMGRHVjAxcmNFbFdWbWhyVjJ4YVJsZHVTbFpoYTFwUVdrWmFUMlJIU2tkVWJFNW9UVEJLWVZadGRHRmhhekZYVmxoc1YySnJOVmxXTUdRMFZERmFjMWR1WkdwTlZscDRWVlpTUjFaSFNrZFdhbFpoVmxkUmQxWnRjM2hTVmtaeFZteHdWMVl3TUhoV2FrSnJVbTFXUjFwSVRtRlNiRnB3VlcwMVExVldXbkZSYlVaVlRXczFlbGt3Vm05Vk1rcEdUbFpvVm1KWWFETldNbmhhWlVacmVtRkZOVk5oZWtVeFZteGpNVlF4WkVkYVJXaG9VakpvVjFSVlpGTldSbHB5VjJ4T1YwMVhVakJWYlhNeFZUSktTVkZZWkZoaE1WcHhWR3hhWVdOck1WZGhSbHBvVFRCS1dGWnROWGRTTWxKelYyNVNUbFpYVW5GWmJGWjJUV3hXV0dWSGRHaFdhM0F4VlZkNGMxZEdaRWxSYTJoWVZtMVNWRlpxU2s5U2JIQklVbXhPYUdWc1dqTldiVEI0VFVkUmVGcElUbGhpYTFwVVdXdFZNVlpzVWxoa1NFNVBVbXh3V0ZsVll6VldNVWwzWTBoc1ZXSkdjRmhXTWpGTFZsWmFjbFZzWkU1U2JrSTJWMWh3UzFJeFRrWlBWbVJvVW1zMWNGVXdWa3RaVmxweVYyMUdWMDFYZUZsVk1uUnZWa2RGZVZWc2JGcFdNMUpNVm0xNFUxWXhaSFZhUlRWT1ZqTm9XRlp0ZUc5aU1WbDNUVlprYWxOSGFGaFdhazV2WTJ4c1ZscEZXbXhTTURWSlZERmFiMVl4U2xoa2VrSlhZbGhDVEZaVVJrcGxSbHAxVm14U2FWSXlhSGRXYlhoaFpERmFWMWRyWkZwTk1taHdWRlprVTFkR1pISlhiWFJYWWxWV05sWlhjelZXVmxsNllVZG9ZVll6YUhKWk1uaHJZekZ3UjFkdGJGZFhSVXBaVm0xd1NrMVdTWGhYYkdSWVltczFjVlV3YUVOV2JHeHlWMjVrVjAxWVFsaFhhMXByVlRBeFdWRnJhRmhoTVZWNFdWVlZlRmRXUmxWU2JHUm9UV3hGZDFkV1VrZFRiVlpIV2tac2FWSnNTbTlVVjNoTFpVWmFXR1JHV2s1V2JYaFlWbGQ0YjFReFdqWmlSbXhXWWxSV1JGVnFSbXRqYkZwVlVtMXNVMDFJUWxoV2Frb3dZakZaZUZOWWNHaFRSWEJoVm14a1UxZEdiRFpTYlhSWFZtczFlbGRyWkhOWFJrbDVZVVJXVjJFeVVYZFpWRVpMWkVaYWNscEhSbE5pV0doM1ZsY3hORk15VGtkV2JsSnNVMGRTY2xsclpGTmxiR1J5Vld0T2FFMUVSbGxXVjNSdlZqRlplbUZJU2xkTlIxSk1Xa1ZhVjJSRk9WZFhiV3hZVWpKa05sWXllRmRaVmxsNFYxaG9WMkpyY0doVmJYaDNWREZXY2xadFJsaFNiSEJKV2xWak5XRnJNVmhWYTJ4V1lrZG9kbGxYZUV0amJFNTBVbXhrYVZaRldsVldhMVpoVmpKU1JrMVdXbEJXYXpWUFZteGFkMDVzV1hsa1IzUnFUVmRTU0ZVeWVHRmhiRXBWVm14b1ZWWnRVbFJVVkVaWFkxWk9jbGR0ZUZOaGVsWmhWMWQwWVZZeVJrWk5XRTVVWW14d1dGWnFUa05WUm14eFVtMUdVMDFXV25wV01uaHZZVmRLVjFOdWNGaFdNMUpvV2tSQmVGSXhWbk5hUmxwcFVsUldkbFpHVmxOU01sWnpWMWhzYkZKNmJGbFZha0pYVGtacmQxZHRPVmROYTNCSlZsZDBORll5U2toVmEzaFdZV3R3U0ZWcVJtRmpNWEJIV2tkb1RrMUZjRXhXYlhCTFRrZEZkMDVWWkZoaWJFcFlXV3RrYjFZeGJGVlRiVGxXVm14d01GUldZelZoVlRGWlVXeHNZVkpYVWtoV2ExcGhaRVpXYzFkc1dsZGxhMFY0VjFaU1FtVkdXWGxUYTFaWFlrWndUMWx0ZUV0TmJGcDBUVWhvVTJKV1dqQlZiWFJ2VlRKS1IxZHNhR0ZXTTJob1ZGZDRZV014V25SU2JYUk9WbGQzTUZZeWRHOVRNa1Y0VTFod1ZtSkdTbUZXYTFVeFVrWlNkR1ZHY0d4V01VcEpXa1ZrZDFSc1duUmtla1pYVmpOb2RsbDZSbGRTTVdSeVdrWlNhVkl5YUdoV2JYQlBWVEF4YzFWc1dsaGlWVnB4Vm0xMGQwMVdXa2hsUnpsV1RXdHdSMWt3WkVkV01ERjFWV3hrVldKR2NISlZha1pQWXpGYWMxcEhiRk5OVlhCaFZtMHdNV1F4U1hkT1dFNVdZa2RTYUZWc1pGTldSbEpYVjI1a1RsWnNXakJhVlZwcllVWmFjMk5GYkdGV1ZuQXpWbXBHWVU1c1NsVlJiSEJzWVRCWmVsZHNWbUZoTVdSWVUydG9hMUpyTlZSV2JHaERWMnhhY2xkdGRFNVNNVVkwVmtkNGExZEhTa2hoU0U1V1ltNUNlbFl4V25OamJHUjFXa1pvVjJKWWFGaFhWbFpYVFVaa1NGTnJaR3BTYldoWVdXeG9RMVpHV25GUldHaFRUV3MxU0ZsVlduZGlSMFY2VVd0c1YxWXpRa2haVkVwUFkyczFWMkZIYkZOTmJXaFFWbFJDVjFOdFZsZFhibEpPVTBkU2MxVnFSa2RPUmxWNFlVYzVhRlpyY0RCV1YzaFhWakF4U0ZWdVdscFdWbkJYV2tSR1lWWldTblJqUms1cFVtMDVNMVl5ZUZkaU1rVjVVbTVPVkdKck5WbFpiVEZ2VmpGc2MyRkdTbXROVm5Bd1dsVldNR0V4U25OWGFrWmFUVVp3Y2xsV1dtRlNiR1J5WWtab1YySkdjRmhYYkZaaFYyMVdWMVZ1U21GU01taFVXV3hhUzFaV1pITmFSRkphVm14S1dGZHJXbXRXYlVWNVZXeFdXbUpHY0doYVYzaGhaRVUxVms5V1pHbFdXRUpLVm14amQwNVdXbGRYYms1cVVrVTFZVmxYZEdGWlZuQldWMjEwYTFKcmNIcFpNRnByVkd4S1IxZHNjRmRpV0ZKeVZHdGtUbVZXU25KYVJsSnBZVE5DVVZadGVGTmpNV1JIWWtoT1ZtSkhVbFJWYlhoWFRrWlplVTFWWkZkTlZuQjVWR3hhWVZadFNsbGhSbWhYVW5wR1IxcFZaRTlTVm1SeldrWmtVMVo2YTNwV01WcFRVekZKZVZSWWFGVmliRnBYV1d4a2IxWkdiSEpoUlU1WVZtMVNXVlJWVWtkVmF6RllWV3RvV2sxR1duWlphMXBLWkRGa2MxVnNaR2xYUmtsNlYyeGtORmxXVGtoV2EyaHJVbXhhY0ZWcVJrdFRSbHBWVTJwQ2FVMVhVa2xWYkdodlYwZEtXR0ZHYUZkaE1WcG9WbXBHZDFZeFpISlBWM0JwVmxoQ1NWWlVTWGhpTWtaWFUyNVdVbUpWV2xoWmJGSkhUVEZhUlZKc1dteFdhM0I1VjJ0YWEyRkhTa2xSYkZwWVZteEtURlpVUm10V01WcDFWVzF3YkdFeGNIcFdiVEI0VGtkV1YxZFliR3RTUlVwdlZXMTRjMDB4YTNkWGJrNVlZa1p3V0Zrd1VrOVdNa1p5WTBWNFYySkdjR2haTVZwVFl6RmtkR0pHYUZOV1JrWXpWbTE0YTJReFNYaGlSbWhWWWtkU2FGVXdWVEZXVm14eVdrWk9WMUpzY0RCVWJGWlBWREZLYzJOSWJGZE5ha1pJVmpKNFlXTnJNVlZXYkdScFZrWmFVVlpxUW1GaE1VNUlWbXRzVldKR2NHOVpWRUozWWpGYWNWSnRSbGROYkVwSlZsZDBjMVpYUmpaaVJsSmFZVEZ3WVZSV1dtRlNNVnB6Vkd4a1RsWnRkM3BXUmxwaFdWZEdjMVJyYkZKaVZWcFdWbXhrVTFaR2NFaGxSMFpyVWxSR1dGZHJaSGRoVmtwWlVXcFNWMkpIVVRCWFZtUkhVMFpLV1dGSGNGUlNNMmhhVjFaU1IyUXlSa2RYYmtaVVlYcHNjVmxZY0hOWFJtUnlXa1ZrVmsxRVJqQlpWV2gzVjBaWmVsVnRhR0ZTUlhCVVdYcEdhMlJXVm5KT1ZsSlRUVlZ3TlZacldtdE9SbXhYVkd0a1dHSnJOVzlWYm5CelYwWldkRTFXVGxSV2JYaFhWakl4TUZkSFNsWmpSbkJYVW0xb2RsWXlNVWRqYkdSellVWndUbFp1UWxWWFdIQkhWVEpOZVZKclpHRlNNbmhaVldwS2IySXhXbkZTYkU1U1RWWnNORlpXYUc5V2JHUklaVVpXV2xaRmNGUldNVnB6WTJ4d1NFOVdjRmRpU0VJMlZqSjBZVk15UlhkTlZtUnBVa1UxV0ZSWE5WSmtNV3hZWXpOb2FtRjZWbGRYYTFwdllVVXhXVkZZY0ZkaE1sRXdWWHBLVG1WV1NsbGpSMFpUWWxaS2RsZFdVazlSYXpGeldraE9WMkpWV2xWWmJGcGhVMFprY21GRk9WZE5hM0JIVkd4b1ExWnRTbFZXYTFKWFZsWndhRnBGVlhoU1ZrcHpVMnMxYVZKdVFscFdha293V1ZaWmVGZHJaR0ZTVjJodlZXMTRkMVpzV25SbFJscHNVbXhXTkZZeU1VZGhNVWw0VTJ0c1lWSldjRE5XYWtwR1pXeEdXVnBHWkdsU01VVjNWMWR3UjJNeFdYaGFTRVpZWWtVMWNGbHJXbmRXTVZwMFRWUlNhMDFyV2toWk1GWmhXVlpLVldKR1VscGhNbWhFVlRGYWMxWnNXbFZTYldoWFlUTkNXVmRXVWs5aE1WbDVVMnhzYUZJeWFHRlpWM1IzVXpGd1ZsZHVaRk5pU0VKSlZXMTRUMVl3TVhSaFJGcFhZa2RPTTFwVlpFcGxSMHBIV2tkc1UySkdjRlpYVjNSV1RWWmtSMVp1VWs1V1JrcHpWVzE0WVUxR2NGWldWRlpYVFVSR1dGa3dhSE5XVjBwSVlVaGFWMkZyV21GYVZ6RkhVMVprYzFwR1pGTlhSVXBPVm0xd1IyRXhTWGhVYTJSVVltczFiMVZ0TVZOV1JscHpZVVZPYTJKR2JEUldNbmhQVlRBeGNsWnFWbGRTYldoMlYxWmFUMUl4WkhOWGJIQnBVakZGZDFadGRHRldNazE0Vm01T1lWSnRhRmhaYkZwTFYyeGtjMVp0Y0U5V2JIQXdWVEo0YTFVeVJuTlRiR2hWVm5wV1ZGcEhlSE5YUjAxNldrZDRWMDFHY0VsWFYzUmhXVmRHU0ZKWWFHcFNlbXhZVm10V1MyRkdiRFpTYlVacVRWaENTbFpYZUVOV01rcFlZVVpXV0ZadGFETldha1pQVWpGa2MxWnNVbWhoTUhCNFZrWmFhMVV4VGtkWFdHeFBWbFJzYjFsclZURlNNV3QzVjIxMFdsWnNiRFpXVnpGdlZtMVdjbGRxVGxkaGExcHlXWHBHVTJSSFRraGlSbEpUVmxoQ1RGWnFSbUZXTVd4WFZWaHNVMkpIVWxaWlZFWjNWbFpzY2xadFJsaFNiRXBZVjJ0Vk5WUXhTblZSYkd4YVpXczFkbFpVU2tkT2JFcHpXa1pvYUUxWVFqSlhWbHByVWpBMWMxZHVUbXBTYldoWVZGUktiMWRXV1hoWGJVWm9UVlpzTlZVeWRITldWMHBJWVVoQ1YySkdjRE5XYlhoaFYwVXhWVlZ0ZEU1V1ZGWlpWbXhqTVZReFpFaFNhbHBwVW0xb1lWbFVSbUZOTVhCWVpVaE9hbUpHV25sVU1WcHJWR3hLUmxkWWFGaFdiRnBvVmxSR1dtVldTblZUYlhCVFZqSm9hRlpHWXpGaU1rNXpZVE5zVGxadFVsUlVWbVJUWlZaU2MxZHJPV2hXTUZZeldUQlNTMVl5U2xsaFJsSldWa1ZhYUZwRldtRmpiSEJIWVVkc1UwMVZjRnBXTVdONFRrWk5lVlJzWkZkaWF6VlhXV3RrVTFkV1ZuUmxSWFJZVW14d01GUnNaREJYUmtsM1kwVm9XazFIYUROV01GcGhVbXMxV1ZOc1pGTk5NbWh2VjFod1MxTXhTbGRXYms1cVVqSm9UMVl3Vmt0T1ZscDBUVlJDV2xZd1ZqUldSM1J2VmpKRmVXVkdXbHBoTVhBeldUQmFXbVF4Y0VoUFZsWlhZa2hCZDFaR1dsTlZNV1J6VjFob1ZHSkhlRmhWYWs1VFkyeGtWMWRyY0d4aVJsb3hWVmQ0WVZSc1NuTmpSVEZYWVd0S2FGZFdaRTlXTVZKMVVteGFhVmRHU2xCWFZsSlBVVEZPVjFkc1ZsUldSVnBYVkZaYWQwMUdWblJPVlhSWFVqQndTRmt3V21GV01rcFpZVVJPVlZaRlducFdiWGhyWkVaS2MxVnNUbGRTVm5CWlZtcEtNRlpyTlZoU2JHUlVZbXhhVTFsWGVHRlhWbHB5Vm10MGFGSnRlRlpWYlhoM1lrWktjazVZY0ZoaE1sSXpWbFJHUzFkV1JuTmpSbVJvWVRCd01sWldVa2RVTVVsNFdraE9hRkpVVmxoWmJGcExWbFphUjFkdFJscFdWRVpZVm14b2MxUnNXbGhWYkdSVlZsWktSRlJVUmxabFYxWkhXa1pvVTAxSVFrcFdhMlIzVlRGYVdGSlliRlpoTW1oWFdWZDBZVTB4Vm5GVGEyUlVVakZhU0ZaSE1UUmhWbVJJWVVac1YyRnJXbkpVYTFwelZqSktSMXBHVm1oTmJFcGFWMWQwYTJJeVRYaFdibFpxVTBVMWNWVnRlR0ZOUm10NlkwVmtWazFFUmxoVk1qVjNWMnhhVjFkWVpGZGhhM0JNVm0xNGEyUlhTa2RYYld4VFRXMW5lVlp0TUhkbFJrMTRXa1pvVTJFeVVtOVZiVEZUVkRGV2RHVkdjRTVTYkhCNFZWZDRZVlF4V25OaVJGSmFUVVphYUZaRVJscGxWMFpHVDFaV1YxWnNiM3BYVjNCSFdWZE9WMU51VWxOaVIxSlBXVlJHV2sxR1dsVlNiVGxwVFZkU1NGZHJWbTlpUmtwelUyeG9WVlpYVWxOVVZWcGhaRWRXU1ZSc2FGTk5WbkJJVjJ0V1lXRXlSbGRUV0hCb1VtMVNXRlp1Y0VKbFJteFZVbTFHYW1GNlJsaFphMXBMWVZaSmVXRkdiRmRTYlUxNFZsY3hVbVZIU2tkV2JFNXBWbFp3ZUZaR1dsWk5WVEZYWVROa1dHSllVbGRVVjNoaFpWWlplV05IUmxoU2JIQjZXVEJvUzFadFNsVlNiRTVoVm14d1ZGa3lNVWRTTVZKMFlrWk9UbFpZUWxKV2JUQjRaREZKZUZOWVpFNVRSMmhvVlcweFUxWXhiRlZVYkU1WFZtMTRlbFl5TVVkWFJrcHpZa1JXVldKR2NISldha1phWkRKT1JtSkdaRmRsYTBWNFZtcEplRkp0VmxoU2ExcFdZa2RTYjFSV2FFTmlNV1JWVW0xR1UwMXNTa2xXVjNSdllWWktWVlp0T1dGV00yaG9Wako0WVdSSFZraGtSVGxUVFVkM01WWlhNREZWTVZsNVUyNUthbEp0ZUdGWlZFWjNZVVphY1ZKdVRtcE5WbHA1VmpKek1WVXlTbkpUYkd4WFlXdHZNRnBFU2t0U01XUlpZVVpvYUUxc1NsZFdSbHByVlRKU2MxZHNWbFJoTTFKVlZXcEdSMDVzYTNkWGJUbFhUVlZ3VjFrd1VrdFhSbVJKVVd0b1dGWnRVbEJaTW5ONFZqSktSMVJ0YkZOTlZYQXpWbTB4ZDFNeVNYaGFSbVJoVW0xU2FGVnJWa3RqYkZKWFYydDBWRkpzYkRWVWJGVTFWMFpKZDJOR1pGZE5hbFpJVm1wS1MxZFhSa1psUjBaWFRUSm9OVmRyVWtka01VcFhWbTVTYUZKck5WaFZiRnAzVTJ4WmVGZHNUbFZOYTFZMFZqRm9jMVpIU2tkWGJGSmFWak5OZUZacVJuTlhSMUpJVW14a1RsZEZTbGxXYWtvMFZERmtSMWRZWkdwU1YyaFlWVzV3UjJSc1draE5WWFJZVWpCYVJsWlhlR3RoVmtsM1RrUkNWMUl6VW1oV1J6RlhVakZ3U1ZOdFJsTk5ibWhXVmxjeE1HUXlWbGRYYkdoc1VucHNWMVJXV21GVFJteHlZVVYwV0ZJd2NIbFViRnBEVm0xS1dXRkljRlZpUm5BelZtMTRZVlpXV25OYVJUVlhZbXRLV0Zac1kzZE5WMDE0V2toU1UxZEhhRlZaYTFwTFYwWnNjMkZGT1U5U2JrSklWMnRXYTFaR1duSk9XSEJZWVRKU2RsbFZWWGhYVmtaeFZteGthVkpyY0VWWFZsSkhWMjFXUjFSdVZsUmlSVXBZV1d4YVMxZHNaRmRoU0dSWFRWWndTRlpYZUd0V01rcHpZMGhPVjJKWWFIcFVhMXByWTIxR1NHUkdXazVTUlZwWlYxZDBVMVl4V1hoWFdIQldZbXh3V0ZsWGRIZFNNWEJYV2taa1UwMVhVbnBaTUZwdlZrWktWbUo2U2xkTlZrcEVWMVphV21WV1VuTmFSbHBwWWtWd1VsWnRNSGhpTVZwSFlraE9XR0V6VWxsV2JYaDNUVVpTVjFWc1RsaGlSbkI2Vlcxd1UxWXdNWEZXYkVKYVZteHdURlZxUms5ak1YQkhWbXhrVGsxRmNGcFdiWGhYV1ZkTmVGZFlhR0ZUUlhCeVZXMXpNVlF4YkZsalJtUlVWbXhzTlZwRlpFZGhSVEZ5VjJ0c1ZtSllRbWhXYWtwR1pVWmtjMkZHY0ZkU1ZuQnZWMVpXWVZkdFZsWk5WbVJoVW0xb1ZGbHJhRU5PVm1SWFZtMUdWVTFyV2xoWGExWmhWa2RLUmxOc2FGcGlSMmhFVlRCYVYwNXNTblZVYkdST1YwVktTVlp0TVRSVE1rWlhXa1ZrVkdKR1dsaFZiWGgzWVVac05sRlVSbE5OVjFKYVdXdFZOVll5U2xkVGJHaFlWak5vV0ZwRVJtRmpNa3BKVTJ4b2FXRjZWbHBYVjNSaFpERkplRmRZYkdwU1ZHeFpXVmh3UjAxV2JGWmFSemxYWWxWd1NGa3dWalJYYXpGMVZGUkdWMkZyV2xSWk1uTXhWakZ3UjFwR1RtbFNiWFF6Vm0wd2QyVkZNVWhTYmxKWFlUSm9WVll3Wkc5WFJsbDNXa1JTVjFKdGVGbGFWV2hyVjBaS2RHVkliRnBXVmxwUVZqQmFTMk15VGtsaFJtUlRaV3RGZUZacVFtRlRNazE1Vkd0c2FGSnNjRmhaYTFaM1UxWmFkR05GU214U2JWSklWbTAxUjFVeVNraFZiR2hoVmpOU1dGUlVSbUZqTVZaeVpFWlNUbFp0ZHpCV2EyTXhWREpHUjFOdVVsWmlSa3BoV1ZSS2IxSkdiSEZTYlVaWVVqQTFSMVV5Y3pGV01rVjVaSHBDVjJGcmEzaFdha1poVjBaT2MyRkhhRk5pUm5CWVYxZDBZVk14WkVkWFdHaFlZbFZhV1ZWc1VrZFRiR3hXVjIxR1ZXSkdjRlpXYlhoelYwWmFSbE50YUZoV2JIQnlWVEJhVDJOc1pISlBWbVJwVjBkb2IxWXhaREJaVm14WFdrVmtWbUpyTlZsWmJGWmhWMVpXYzFWc1pGaFdiRm93V2xWak5XRkdTWGhYYm14WFRWZG9kbFl3V21Gak1XUjBZVVprVjFKV2NHaFhiRnBoVkRKT2MyTkZhR3BTYXpWWlZXcEtiMlJzV25OWk0yaFBVakZHTTFSVmFHOVdNV1JJVlcxb1ZtSkdTbnBXYkZwWFkxWkdkVnBHVWxOaVNFSktWa1phYWs1V1dsaFNhbHBUWVRKU1lWUlZaRTVOVmxweFUydDBXRlpyV25sWlZWcHJWakZLVjJORmFGaGlSbkJvVmtSR2ExZEdTbkphUm1ocFVqSm9WVlpHWTNoaU1XUlhWMjVTYWxKVk5XOVVWM1J6VGtaa2NsZHRkR2hXYXpWSVZUSTFUMVp0U2toaFJsSmFUVlp3VkZacVJtdGtSa3B5VGxaT2FWSllRVEpXYlRCNFpXczFWMXBGYUZSaE1sSnhWVEJvUTFsV2JGVlNhM1JXVW14c05WcFZaRWRXTURGWVZXNXdWbFl6YUhKV1IzaExaRlpHY2sxV2FHaE5WbkJ2Vm0xd1MxUnRWbGRUYmtwaFVqSm9WRlJYTVc5VlJscDBUVWhvVGsxc1ducFdNalZUVkd4YVJsTnRSbGRpV0UxNFZGVmFZV1JIVWtoa1JtUlhUVWhDTlZkVVFtRmpNV1IwVWxoc1ZtSkdTbUZVVlZwM1dWWndSVkp1WkZSU1ZGWlpXbFZrYzFVeVNuSlNhazVYVFZaS1JGWnFTa1psUm5CR1lVWlNhVkl4U2xwWFYzUnJUa1paZUdKSVRtaFNhelZ5V1d0YWQxWXhXWGxOVldSb1RWVndlbFl5Y0VOV1ZURlhZMFpvVjJGcmNFeFdNR1JIVW14YWMyRkhiRk5pYTBwMlZtcEdZVmxYUlhoYVJXUldZbXR3V1Zsc1ZtRldSbXgwWkVWMFdGWnNjRWhXYlhoUFZUSkdObEpyYUZoaE1YQllWbGN4UzFOR1ZuVlNiRlpYWWtoQ1dWWkhlR0ZXYlZaWVZXdG9VMkpYYUhCVmJGSlhVMFphVlZOcVVtaE5WMUl3VlRKMGIyRkdUa2RqUmxwWFlURmFhRmxWV25OT2JFcDBaRWQwVTJFelFqWlhWbFpoVkRGU2MxZHVWbEpoTTFKWVdWUkdTMU5HWkZkWGF6VnNVbXhhTVZaWGVGTmhSVEZ6VTI1b1YxWjZRalJVYTFwclVqSktSMkZIZEZSU2JrSjVWa1phYTA1R1duTldibEpPVmtWS1dGVnRkSGRsVmxKellVaGtXR0pWVmpSWk1HUnZWMnhhYzJORmVGcE5ha1pRVldwR2QxSXhjRWhpUm1SVFZsZDBNMVp0TVRSVk1VbDRZa1prVkZkSGFGbFphMlEwWWpGV2RFMVhPV3BTYkhCNlZqSTFhMkpHV25OalJteGFUVVphY2xaclZYaFdhelZYWVVaa1YySlhhREpXTVZwaFV6QTFkRk5yWkZoaVNFSnZWRlpvUW1Wc1duRlRhbEpYVFZkU1NWWnRkRzloTVVwMFZXczVWMkpVUVRCYVZscGhWMFV4V1ZwR2NGZGlTRUphVmxSS01HRXlSbk5UV0d4b1VtMW9ZVlpxVGxOaFJtdDVaVWhPVDJKRmNERlhhMXBQVkd4YWMySXpaRmhXTTFKb1ZrUkdVMk14WkhOaVJrcHBVak5vV1ZkWGVGTlJNREI0WTBaYVYxWkZXbFZWYlhoaFYyeHNWbHBJVGxaTmEzQllWVEkxYjFZeFdqWlNWRUpoVWtWd1NGVnFSbUZrVmxKMFVteE9hR1ZzV2xwV2JUQjRUa2RSZDAxVlpHaE5NMEp4Vld4a1UyTkdWblJsU0dSc1lrWmFNRmt3V2s5V01ERkZVbTVvVm1KSGFISldha3BMVTBaV2NtVkdXbWxXUlZwUlZsZDRZVkl5VFhoWGJrcFBWbTFTYjFSVVFrdFZNVnAwVFVob2EwMVZNVFJXUm1odlZrWmtTR0ZHV2xwaVdGSXpXV3BHVjJSRk5WWlViV3hPVmpOb1YxWnJaREJVTVZwelUyNVNWbUp1UWxoWmJGSkhVMFphY1ZGWWFHcE5WVFY2V1ZWYWExWXlWbk5YYkZaWFlrWktURlY2Umt0amF6VlhXa2RvVTJKR2NGbFhiR1F3V1ZVeGMxZHVSbE5pVlZwWldXeGFZVk5HYkZWVWJtUm9VbXR3VmxadGVGTlhiR1JKVVd0a1ZWWldjR2haTVZwUFZsWktjMVpyTlZkTlZYQkxWbXhTU2sxV1RYaGFSV2hVWVRKU2NWVnFRbUZYUm14VlVtMUdVMDFZUWxkV01uaDNZa1pLZEZWdWNGaGhNbEYzVmxSR1lWSnNaSE5hUm1Sb1RXeEpNbFpHV210U01WbDRWRzVXVldKWGVFOVVWM2hMVjFaYVdHTkZPV2xOVm13MFZsYzFUMWxXU2xoVmJGSmFWMGhDU0ZZd1dscGxWVEZaV2taYVRtRXpRa3RXVm1RMFl6RmtSMWRZY0doVFJuQmhXVmQwZDFaR2JEWlNiWFJyVm10d2VsWkhNVzlVYXpGV1kwWktWMDFYVVhkV2FrcFNaVVprZFZSc1pHbFNNbWg2VmxSQ2ExVXhaRWRWYkdSWVltMVNjMWxyV25OT1JteFdZVWQwV0ZKcmJETlpNRlp2VjJzeFNGVnVXbGRoYTNCSVdUSjRhMlJIUmtkYVIyaG9UVmhDVWxZeWRHRlpWbFY1Vld0a1ZHSnJOVlpaYkdSdll6RnNjbGR1WkZaaVJuQXdXa1ZrUjJGSFNsZFhhMnhXVFZkb2NsWkVSbUZrUmxaellrWndhVmRHU1hwWFZsWmhWakpPYzFkdVNtdFNNbmhQVm0xMGQxZFdXblJOUkVaVlRWWkdORlV5TlU5aFZrcEhVMjFHVjJKSFVrOVVWbHBhWlZkV1NGSnRjR2xXVkZaSFZsWmplRkl4V1hoWFdHUk9VMGRvV0Zsc1VrTk9SbFkyVW0xR1YwMVZOVEZXYlhodllWWk9SbE51V2xoV2JFcElXa1JCTVdNeGNFZFdiRkpZVWpKb1ZWWkdXbGRrTWxaelYyeG9UMVpyTlc5VmJYUjNaVlpTYzJGRlRsZGhla1pJVmpKMGIxWldXa1pYYldoYVRXNW9jbGw2Um5kVFIwcEdUbGRvVG1KdFRqUldiWGhxWlVVMVIySkdaRlppYXpWWldXMTRTMVl4YkhKWGEzUmFWbXh3ZUZaSE1EVldWa3AwVld4b1YwMXVhRkJXYWtwTFUwWldjVkZzV21sV1JWWXpWMVphWVZNeVVsZFNia3BxVW0xb2NGVnRlSGRsVmxwWVkwVmthRTFWYkRSV1J6VlhWbGRLU0dGSVFscGlXRkpNV1ZWYWExWXhWbkphUjNST1lURndTVmRYZEdGaE1XUklVbGh3Vm1KcldtRlphMXBXWlVaVmQxZHVUbXBpUjFJd1drVmtiMVV3TVVkWFZFSllWa1ZLY1ZSc1dtdFRSa3BaWVVaU2FFMXRhRmhYYkdRd1pERlJlR05HWkZoaVJUVnhXV3RrVTJWc2JGWmFTRTVYVFZad01WVlhlR0ZXTURGWVZWUkNXbFpGY0V0YVZWcHJZekZ3U0ZKc1RtbFdhM0JaVmpGYVUxUXhWWGhWV0doV1lrWndWMWxVU2xOWFZsWjBaVWhPVDFac1NucFdiRkpYVjBaS2NtSkVUbHBOUm5Cb1ZqSXhSbVZYUmtaVmJHUnBVbTVDYjFkclZtRldNazE0Vm01T1dHRjZWbFJaYlhSTFlqRlplV1ZIUmxkaGVrWllWakZvYjFadFNuSk9WMmhXWWxSR1ZGa3dXbUZrUjFKSldrWlNUbFp0ZHpCV2FrbzBZVEZrYzFkWVpHbFNSa3BZVkZkd1YxWkdXbFZTYlhSVVVqQmFTRmxyV25kV01VcFpVV3hXV0Zac1dtaFhWbVJPWlVad1NWWnRSbE5pVjJoVlYxY3hNRk14VGtkWGJsSnNVbnBzY0ZSV1duTk9WbFY1WlVkMFYxSXdWalZaVlZwdlZqSkdjazVZV2xwTmJtaDZWbTE0WVZkWFJrZGhSazVYVWpOb1dGWnRkR3RPUjBWNFZXNVNWR0pyTlZWWmEyUTBWMFpzYzFWclpFOWlTRUpYVmpJeE1GVXdNVlpPVkVaWFVucEdTRlpVUVhoU01rNUhWbXhrYVZkRlNrMVhWM0JMVlRKTmVGcElUbWhTTTFKVVZGVmFkMVpzV2tkWGJYUldUVlUxU0ZscmFFdFhSMHBJVld4a1ZWWXpVak5VVlZwaFYwVTFWbHBHYUdsV1Zsa3hWMVpXVjFVeFduUlRiR3hvVW0xU2FGWnRNVk5WUmxKMFpVZEdhMUl3V2tkVWJGcHJWMFpLVm1FemJGZGhhMXBVVlZSS1NtVldVbGxoUjBaVFZqSm9WVlpxUW10T1JsbDRZa2hTYkZOSFVsbFZiWGhoWlVaYVNHTjZWbFZOVlhBeFZWZDBiMWRIUlhoWGJrcFhWa1ZHTkZadGVHdGtWMDVIWVVkb1RtSkZiekpXYlhCRFdWWk9kRlpzYUZOaE1sSlpXV3RrVTFReFduRlRiVFZzWWtad1dsa3dWbXRXYlVwWFYydG9WMUl6YUhwWlZWcExaRWRHU1ZGc2NHaE5XRUY2Vm0xNFlXRXhaRWhWYTJSaFVqTlNUMVpxUmt0VFZscDBUVVJHVlUxV2JEVlZNalZUVm0xS1NGVnNaRnBpUjJoMlZGUkdVMVpzWkhOVWJHUk9WbXh3TmxaclpEUmhNVkp6VTJ0YVdHRXlVbGhaYkZKR1pERnNjVkpzY0d0TlJFWmFWbTB4YjFaR1NuVlJiR3hYVmpOQ1VGbHFTa2RTTVdSWldrWm9hVkl4U25oV1JtUXdaREZPUjFkWWJFNVhSVFZaVlcxMGQyVldiSFZqUlhSWFRXdFdOVlpXYUd0WFJscHpZMGhLWVZKV2NHaFpla3BIVWpGd1NHRkZOV2xXTW1jeFZtMTRhbVF5VmtoVFdHeFZZVEpTV1ZsdGN6RlhWbXh5WVVWT1ZVMVdXakJhVldoclZqSktSMVpxVmxwTlJscFFWbXhWZUZadFRrbGpSbkJvVFZWd1dWWnRNSGhUTVZwWFYyNUtiRkp1UWxoVVZFcHZWRlphY1ZKdGRGTk5WV3cwV1RCV2ExWXlTa2hWYkdoVlZteGFNMVp0ZUdGak1WWnlWR3h3VjJKSGR6RldhMlEwWVRGYVNGTnVTbXBTTW1oWFdWZHpNVkpHV2tWU2JrNVlWakExU0ZkcldsTmhWa2w0VTJ4c1YySlVSVEJYVmxwVFl6RmtXVnBHYUdsU01taFlWa1pqTVdJeVZuTlhiR2hPVmxoU1ZGbFljRmRYUm14V1YyNWtWMDFFUWpSVk1XaHpWMGRGZUZOcmFGcFdSVnBoV2xWYWQxTldXbk5XYld4VFRWVndVVlp0TUhkTlZrVjRZa1prWVZKdFVsaFpiR2hUVmtaU1YxZHNaRTlXYkZZMVdsVmtNRll4U1hkalJscGFZVEZ3ZGxacVNrWmxSbVJ5WlVad1YxWnVRbGxXUnpFMFZESk9jazlXWkdGU1ZGWllXVzEwUjA1R1duUmxSM0JzVWpGR05WVXlkRzlWTVdSSVlVaEdWbUpVUmxSV01GcFhaRWRXU1ZwSGNHbFNhM0ExVmpKMFlXRXlSbkpOVm14U1lUTkNWMVJYTlc5Tk1XeHlXa1ZhYkZJd05VcFhhMXByVmpBd2QxTnJWbGhoTVVwSVZrUkdTbVZXVG5KaVJsSnBVbTVDZDFaWGVGTldNV1J6VjJ4b2FsSlZOVmhVVlZKWFUwWmFjMkZJVG1oTlZYQjVWR3hhYjFaV1dYcFZhazVXVFZad2FGWXdaRk5UUlRsWFdrWmtUbE5GU21oV01WcFhZVEpKZUZwSVVsZGlhM0JaV1Zkek1WWXhiRmhrUjBab1VtMTNNbFZ0Tld0Vk1ERlpVV3RrVldKSFVucFdha0Y0WTJzMVJWSnNaR2xXUlVsNlYydFNTMVl4U25KTlZscGhVako0VkZsc1pHOVdWbHB4VVcxMGFVMVdjSHBaYTJoTFdWWktjazVXYUZaaVZFVXdWRlZhY21WdFRrWmFSbWhUWVROQmQxZHNWbTlqTVdSelYyeGtXR0pGU21GV2FrNXZWRVpzTmxOcmRGTldiRXA2VjJ0Vk1XRlhTa1ppUkZwWFRWZFJkMWxVUms1bFJrNVpZa1pXYUUxdWFIZFdWekI0WWpKSmVGVnNaRmRpYlZKWVZtMTRkMDFHVWxkaFNHUnBVbXR3ZWxsclVsZFdhekYxVld4b1YySlVSa3hWTUZwWFpGWkdjMXBIYUU1WFJVcDJWbTF3UjFsV2JGaFZhMmhYWVRKb2NsVnRlRXRVTVZweFVtdDBXRlpzY0ZsVVZWSkhWbFV4Y2xkcmFGWk5hbFpZVmxjeFMyTnNUbk5hUm5CWFRURkplbGRyWkRSVk1XUklWbXRvVTJKWVFsaFpWRVoyWkRGYVdFMVVVbWxOYTFwWVZqSTFUMkZzU2xsUmJHaFhZbTVDUjFwRVJuTk9iRXAxVkd4a1RsWlVWWGhXYTJONFpERlZlRmRyYUd4U01taFlXV3hvVTFkR1pGZFhiazVYVFZaYWVsWXllRzloVmxwWFkwaG9WMkpVUmpaVVZscGhZekZhZFZWdGVGTk5SbkJYVjFkNFYxWXdOWE5XYkdoclUwVTFXRlJXV25kU01XeFZWRzA1VjAxV2NFZFpNRlkwVm0xR2NsZHNRbUZTYkhCVVdrVmtUMUl4VW5SaVJtUk9ZbGRvTWxadGNFZFpWbFY0VkZob1YxZEhhRmxaVkVwVFkxWldjMXBIT1dwTlZsWXpWbXhTUjFkR1NuUmxTR3hZWVRGd1VGWkhlRXRrVmtaeVdrWmtUbUZyVmpOV2JYaHJVekZKZVZSclZsTmlSbkJZV2xkMFlWTldXblJqUlVwc1VqRktXRlp0TlZkV1IwcEhWMjA1VlZadGFFUldNRnByWXpGa2RGSnNWazVoZWtVd1YxUkNWMkV4V25SVGEyaG9VbXhLVmxadWNFZGtiRmw1WlVkR2FtSkhVakJaTUZVeFZqSktSMWRVUmxkV2VrVjNXVlJLUjJNeFRuTmFSbWhwVW14d2FGWnRkRmRrTVZwSFYyNUtXR0pyTlZsV2FrRXhVakZrY2xkdE9XaFdhM0F4VlZkMGQxZEhTa2RYYldoWFVrVndTRlZxUm10a1ZrNTBZMFpTVTAweWFHOVdhMXBYV1ZkUmQwMUlhRmhYUjFKWldXeFdZV05XVWxkV1ZFWnNWbTVDVjFZeU1UQldhekZXWTBaa1YySllRbFJXYWtaYVpXeEdjbUZHY0ZkU1dFSlJWMnRXWVZNeVRuTmFTRXBRVm0xU2NGWnRkSGROTVZwMFRVaG9UbEl4UmpOVWJGWnJWMGRLY21OR2JGcGlSbHBvVjFaYVlXUkhUWHBoUlRWT1ZtdHdXVlpxU1hoTlJtUkhVMWhrYWxKWGVHRldiRnBXVFZaYWNWRllhRlJTYkZwNlZsZDRhMkZIUlhoalJsWlhZbGhDU0ZsVVNsTldNazVHV2taV2FHVnNXbGxYVjNodllXMVdSMWRZYkd4U2JWSllWRlphUjA1R1pISldiWFJYVWpCd2VWUnNhRWRXYlVWNFYydDRXRlpzY0doWmVrWnJZMjFTUjFkc1RtbFRSVWt3Vm14U1MwMUZNVWRYV0doWVltdHdjVlV3YUVOWlZscHpWMjVrYW1KSGVGZFhhMVpoWWtaSmQySkVXbHBOUm5CeVZtcEJkMlF4VG5KTlZtUlhUVEJLU1ZaclVrZFVNVWw0V2toV1ZHSlZXbFJaYTFwM1pERmFjVkZ0ZEdsTmJFWTBWakkxUjFWdFNsbFZia0pWVm14d00xcFhlRnBsVlRWWFZHMW9UbFpYZDNwV2FrbDNUbFphVjFkc1pGUmlSMmhYVkZWYWQyRkdWbkZUYTJSVVVqRktTRlp0TVhOVk1rcHlVMjFHVjJKWWFISlVhMlJLWlVaa1dWcEZOVmRXTW1oWVZtMTBWMU14WkVkWGJrNVlZbTFTYjFWdE5VTlNNV1J5VmxSV1ZVMXJjRWRaTUdoM1YyeGFWMk5HUWxwV2JIQk1WakZhUjJSR1NuTmFSVFZwWWtWd1dsWXhaSGRUTVVwMFZteGtWV0pyY0c5VmJYaExZakZTV0dWRmRHdE5WbkJaV2tWa1IxZHNXbk5qU0hCYVlUSm9URll3WkV0VFZrWjFVMnhXVjJKSVFYcFhiRlpoVm0xV1dGVnJhR3RTYkZwUFdWUk9RMU5HWkZWUmJUbHFUVmRTZWxZeWVHdGhiRTVHWTBkR1YySllhRE5aTW5oWFpFZFdSazlYY0U1V2JrSTJWakowYTJNeFpFZFRXR3hvVTBad1dGbHNhRU5UTVhCV1YyeHdiRlpzV25sWGExcFRZVmRGZWxGdVpGZFdNMEpRVlZSR1lWSXhWbk5YYkdocFlsWktXVlp0TVRSa01ERkhWV3hrVm1KRk5WbFZha0phVFd4V2RHUkhPVmROUkVaNFZtMTRVMWRzV1hwaFJYaFhUVVp3V0ZwR1drOWpNVnB6V2tkc1UySkdhM2RXYlhoVFVqRnNWMkpHWkdGU1YyaFhXVlJLYjJOc1ZuUk5WazVZVW14S1YxbFZWazlYUjBwSVZXNXdWMkpVUmpOV1JFWmhZekpPUjJGR1pFNWliV2d5VjFaV1lWTXhXWGhVYmxKVFlraENXRlJVUmt0aU1XUlhWbTFHYTAxVmNIcFdNbmh6WVVaS2RGVnNhRnBXUlZveVdrUkdhMVl4V25Sa1IyeE9ZVE5DU2xaWGVHOWlNa1p6VTI1V1VtSkhhR0ZaVkVwVFZURlNWbGR1VG1wV2F6VjVWR3hrTkZVeVNrbFJiVVpZVmpOU2FGWlVTa2RYUmtweFYyeGthVkp1UWxwV2JYQlBWVEpPYzJKSVJsTmlhelZZVkZkMGQxTkdXblJsUlRsb1ZqQndXRlV5TldGV01WbzJVV3BTVlZaV1ZqTmFWVnByVjFkS1NHVkdUazVTYmtJeVZtdGFWMVV4U1hoYVNFNVhZa2RvY2xWdWNITlhSbEpYVm01T1QySkhlRmRXVjNNMVZqQXhjbGR1YkZwTlJsa3dWbXBCZUZkR1ZuSmhSbHBwVW01Q2VWZFljRWRrTVU1SVUydGtWV0Y2VmxoV2JURXpUV3hhZEdORlpGcFdiRlkwVlRGb2IxbFdUa2RUYkdoYVZrVndWRlp0ZUhOa1IxWklVbXhrVGxZemFEWlhWbFpxVGxaWmVGZHVUbGhpYldoWVZXNXdRazFXV1hkYVJYUlVVbXhhZWxsVldtdFdNREI0VTI1c1dGWnNTa05hVldSUFkyczFWMkpIY0ZOaVZrcFFWMWN3ZUdJeFpGZFhiazVXWVROU1ZGbHNXbUZsYkZwMFRsVTVhRkpyY0RCV1Z6VkRWakF4U0ZWdVZtRldNMmh5V1hwR2QxSldWblJqUjJ4WFlURnJkMVpxU2pCaU1WVjRWbGhzVkdKSGFHOVZiVEZ2V1Zac1ZWTnRPVk5TYkZZelZqSXhSMkZzV25KalJFSlZUVmRSZDFaSGVHRmtSMUkyVW14a1YwMHlhREpYV0hCSFdWZFNSMU51VmxWaVdFSlVWRmN4YjFkV1pGaGtSM1JXVFZad1NGWXlOVXRYUjBwSVZXNUdWMkpZVWpOVVZWcFhaRVV4VlZGc1pFNWhNMEpMVmxaYWIyRXhXWGhYYWxwVFZrVktXRlZyVm5kVFJscHhVbTEwYTFack5UQlpNRnBQWVVVeFdWRnNjRmROVjFGM1dWUkdVbVF3TVVsaFJscHBVakZLV2xkV1VrZGtNazE0Vm01U2JGTkhVbk5aYTJSVFpWWlplVTFFVm1oU2EzQldWVzAxZDFack1YVmhTRnBYVFVad2FGbDZSazlqTVVaeldrWmtVMVp1UW5aV2JHUjNVakZaZVZSWWFHcFNWMmhVV1d0Vk1XSXhjRmhsUjBaWFRWWndlbGRVVG05VU1VbDRVbXBTVjFJemFISldiVEZMWTJzMVYySkdjR2xTTW1oVlZtcENZVlV4WkVoVmEyeGhVbTFTVDFacVRsSmxiRnAwVFVob1RsSnNiRFJXTVdocllXeEtXR1ZIUmxkaVJuQm9WbXRhWVdOV1JsbGhSM0JYWVROQ05WWXlkR3RTTVZsNFYyNVdVbUp0ZUZsV2ExWmhZVVphVlZOck5XeFdiRXA1V1ZWa2IxVXdNWFJoUmtKWFlXdEtXRlY2UVhoak1XUjFVbXhPYVZKVVZsVldSbHByVGtaa1IxWllhR2hUUlRWWVZtMHhVMU5XYkZaYVJ6bFhZWHBHU0Zrd1ZqUlhiVlp5VjJ4b1lWSlhVbEJVYlhoTFl6RmFjazVXWkdsVFJVVjRWbTB4ZDFOdFZrZFRXR2hZWVRKb1ZWbFVTbE5qVmxaeVZtdDBhRkpzY0hwWGExcFBWa1pLZEdWR2FGZGlSMmgyV1ZjeFIwNXNTbk5YYkdScFYwZG9iMVpyWTNoVE1rMTRWRzVXYVZKdFVuQldNRnBMWlZaYVdFMUlhRmROVlRWSVZsYzFTMWxXU25SVmJrSldUVVphVEZwRVJtRlhSMDVHV2taU1RsSkZXalpXYWtreFZUSkdjMU5zYUZaaWExcFdWbXBPVG1WR2NGaGxTRXByVFZad01GUXhXbUZWTWtwSVpIcEtWMkpIVFhoVlZFWmhaRVpPYzJKSGFGTlNWRlpYVjFkNGIySXlSa2RoTTJoWVlYcHNjVlp0ZUdGbGJHdDNWMjEwVldKRk5VZFZNblIzVmpKS1dWRnJlRlZoTVhCaFdsVmFhMWRYU2tkVmJXaE9ZbGRvTWxac1kzZGxSMGw0VjFob2FWSnRhSEZhVjNSaFkyeHNjbUZGVGxSV2JrSlhXVlZWTlZZd01VVlNiR3hYVm5wV2VsWXljM2hUUmxaVlVXeGtWMUpZUWtsV1J6RTBXVmRPVjFkdVRtaFNiVkp3VlcwMVEyUnNXWGhYYkU1VFRWZFNNRlp0ZEd0V1YwcHlUbGhDVm1KWVVqTldNVnBXWkRGYWNtUkdhRmRpVmtwWlZteGtNR0V4V2taTlZscFBWbGRvWVZsVVJuZFhSbHB5V2tWa1QySkdjREZXUjNoaFlWWmFSMWRyVmxkV1JXOHdWMVprVTFOR1duSmhSazVwVmpKb1dWZFdVazlSTURWeldrWldVbUpWV25KVVZscHpUa1paZUdGSVpGWmlWVlkyV1ZWa1IxZHNXWHBWYWs1V1RVWndXRmt4V2t0a1ZuQkhWR3MxYUUxWVFrdFdNbmhYV1ZaUmVWSnJhRmRpYXpWWldXdGFkMWRHYkZWU2JtUm9VbTFTV0ZZeU5VOVdNREZYVTI1c1dHRXhjSFpaVmxwS1pWZEdSMUpzWkdsWFIyaFZWMWh3UjJFeFdYaFhibFpUWWtWd2NGVXdWa3RWUm1SWVpFZDBUMUl4V2xoV01XaHpWR3hLUjFkc2FGVldWa3BJV2xaYWNtUXhaSFJTYkdScFZsaENZVmRXVm1GVk1XUkhWMjVPYWxJeWFHRmFWM1IzVlVaVmVGcEZkRlJTYTNCNlZrZDRUMVl5U2xWaGVrcFhZbGhvVkZWVVJtRmphelZYV2tab1dGSXlhRnBYVnpFMFV6Sk9SMVp1VW1wbGExcFpWbTE0WVdWc1duUmxTR1JWWWtWd2Vsa3dVa05aVmxwWVZXdG9XbFpXVmpSVmJGcExZMjFHUjFwRk5WZE5iV2Q1Vm0xd1ExbFhSWGhVYTJoWFlUSlNXRmxyYUVOWFJsWnpZVVZPVjFadFVsWlZiVEZIVmpBeGNrNVdhRmRTZWxaVVZsVmFZV1JIUmtkVmJIQnBVakpvTWxacVNqUmhNazV6VjI1U2ExSnJOVTlXYlRWRFYxWmFWVk5VUmxkTlZsb3dWV3hvYzFadFNraGhSbHBYWW01Q1dGcEhlR0ZXYkdSelkwZDBUbFl4U2paWFZFSnJUVVpTYzFkWWFGUmhiRnBaVm0xNFlXRkdiRlZTYkZwc1ZteHdNVlV5ZUc5aFIwcEpVV3hzV0ZZelVtaFZla1pUVWpGYWNWZHNVbWhsYlhoNFZrWmFZVk13TVZkWGEyaHNVbnBzYjFadGRITk9SbFY1WlVWT1YwMXJjRlpWVm1odlZteGFSbGR0YUZkaGExcHlXWHBHZDFJeFpIUmhSVFZPVmxoQ1dsWnFSbXRPUm14WFlrWmtWV0V5VW05VVZFcFRWMFpzYzJGR1RscFdiSEF3V2tWb2ExUnNTblJsUm1SYVZsWmFVRlpxU2t0V2JVNUhZMFp3VjFacmNGRldiWEJMVWpKT2MxcElWbFJpUjFKUFZXcEdTMWRXV2xoalJXUldUV3hLU1ZaSGRHRlVNVnAwVlc1Q1ZtSlVSWGRVVkVaaFpFVXhWVlZ0YUU1U1JscEtWbGQ0YjJJeGJGZFRiR2hvVW14YVlWbFVSbmROTVZsNFYyNU9hbUpJUWtaV1YzaHJWR3haZW1GRVdsaFdiRnB4Vkd4YVUyTnJNVmRhUmxKcFVqRktXVlpHWkhkV01rNXpWMnhXVkdFelVsVldiWFJoWlZaWmVXVkhSbGROUkVJMVdWVm9jMWRHV25OWGJrcFhZV3R3VUZsNlJuZFRWbEowWVVaT2FWWXlhRnBXYkdRMFZqSlJlVk5ZYUZoWFIyaFpXV3hXWVdJeFVsaGpNMmhQVW0xME0xWnRNVWRoUmxweVkwaHNXazFIVFRGV2JGcGhVbTFPU1Zkc1pFNWliV2h2VjJ0V1ZtVkdXbGRXYmxKclVsUldXRmxVVGtOVGJGcDBZMFZ3VGxacmJEUldiR2h6VmtkS1NHVkdaRnBpV0ZKb1YxWmFjMk5zWkhWYVIyaFRZa1paZWxacVNYaE5SMFowVTJ0b1ZtRnJTbWhWYkZwM1YwWnNWbHBHWkdwaVIxSmFWMnRhYjFZeVNrZGpSRXBYVFZad2FGWXlNVmRXTVZKMVZHeGthVkpVVm5aWFZtaDNWakZrUjFwR1pHRlNSVXB5VkZaV2MwNUdhM2RYYlhSWVVqQndTVlpYTlVkV1ZscDBZVVZTVmsxR2NHaFZNRlY0VjFaU2RHRkdUazVXYmtFeVZtMXdTMDVIVVhoWFdHUk9WbTFvVjFZd1pGTlhSbXh6WVVVNVQxSnNjSGhWYlRWclZUSktTVkZyYkZwaE1YQlVWbFJHYTFKc1RuRlRiR1JwVWpGRmQxWnRjRXRWYlZaSFZteHNhRkl5ZUZWVmJHaERWMnhrV0UxSWFGWk5hekUwV1d0b1MxZEhTbkpPVmtKWFlsaG9URll3V21GWFIxSkdUMVprVGxadVFsZFdWekUwWVRGa2NrMVZhR2hUU0VKWVZGZHdSMUl4Y0ZaWGF6bHFUVlphZWxkclpHOWhSVEZIWVROa1YwMVdTa2hYVmxwelYwWlNXV0ZHWkdsaGVsWnZWbGN3ZUZVeFdrZFhibEpQVmxVMVVGWnRlSGRsYkZwWVpFZDBXR0pHY0hsWmExSlhWakZLZEdGSVdsaFdiSEJRVlcxek1WZFdTbk5YYldob1RUQkplVlp0ZEZOU01XeFlWV3RhVGxaV1dsaFpXSEJ6WTBaV2RFNVZTbXROVjFKV1ZWZDRhMVpWTVZoVmJuQlhUV3BXVkZscldrdGtSMVpIWVVaYWFWWkZXakpYYTJRMFlURlplRnBJU2xCV2F6VlBWbXBHU21ReFpGZFdiVVphVmpCYVdGZHJWbUZVYkZwSFUyeG9XbUpIYUZSWlZWcHpUbXhPY2s5WGRGTmhNMEkxVm1wS05GWXlSbGRUV0doVVlrVktXRmxzVWtKbFJsWlZVVlJHVjAxWFVscFpWV1J2VmtaSmVGTnNWbGRTYkhCb1drUkdXbVZHVm5OYVJtaHBWMFpLV0ZaR1pEQlpWMVp6Vmxoc2JGSXpVbGhXYlhoelRteFdXR1ZIT1ZkTlZuQllXVEJrUjFsV1NrWlhhazVXWWxSR1ZGVXdaRk5TTVhCSVlVVTFXRkpWVmpWV2JURjNVekF4UjJKR2FGWlhSM2hVV1d0a1UxWldXWGRhUkZKcFRWWmFlVlp0Tld0WFJscHpZMFJDWVZaWFVraFpWVnBMWkVaV2MyRkdaRTVoYTFwSlZtMXdRbVZHV1hoVWJrWlRZa1p3VDFsdE1XOU5iR1JYVjIxR2FFMVZOVWxWYlhScllWWktkRlZzVWxwaE1YQXpXV3BHYTJOc1ZuSmFSbFpPVmxkM01GWXlkRzlUTWtaSFUxaHdhRkpzU2xaV2JGcDNUVEZzVmxkdFJtdFNNRFZIVmtkNGQxWXlTbGRUYTJ4WFlsaG9kbGw2UmxKbFJtUnpWbTFzVTJWdGVHaFhWbEpIV1ZVeGMxVnNhR3hUUlRWeFdXdGtVMDFHVVhoWGJYUlZZbFZXTmxWWE1VZFhSbHB6VjJ4b1ZXRXhjR2haTW5ONFZteHdTR05HVGs1aVYyaHZWbXRhWVZsWFVYaFZhMlJwVWtad1ZWbFljSE5XVmxaeFVtMUdWRkpzY0VsVVZtaFBWakF4Y2xacVZsVk5SMmg2Vm1wS1MxWldSbkZVYlVaWFZteFdORlpYY0V0VE1VbDVVbXRrVldKWGVGUlVWbFozWkd4YWMxcEVVbHBXTVVZMFZqSjRhMkZXVGtaalJtaGFWa1UxVkZZeFdsZGtSVEZWVlcxNGFWSnVRbHBYYTFaclVqRmFXRk5yV21wU1JWcFhWbXBPVTJGR1duUk5WWFJYVm10d1dsZHJXbXRXTVVwV1YxUkNWMkZyU21oV2FrcFRWMFpTY2xwSGNGTmlWa3BaVjFkMFlWZHJNVWRYYmxKT1YwZFNWRlJXVlhoT1JsbDVUbFpPVjFZd1ZqVldWM2h6VjIxRmVWVnNVbGRoTVhCNldUSXhSMUpzVW5SaVJUVlhZbGhqZDFadGNFdE9SbXhZVTJ0a1ZHSnJjSEJWYTFwTFYxWnNWVk50T1ZoU2JIQXdWRlpXTUZkR1dYZFhhMmhYWWxob2FGbFdXa3RqYlU1SFlrWm9hRTFzUlhkV01WcGhZVEZLY2sxV1pGZGlSWEJ3VmpCYVMxVkdXblJOU0doT1RVUkdTRll5TlU5WGJWWnlWMnhhVlZadFVsUlZNVnBXWlZkV1NWUnNaR2xXV0VKS1YxWldZVmxXV1hsU2JrcFBWbXhLVmxaclZtRlpWbkJYV2taa1ZGWnNTbnBYYTJSelZrWktWbU5GZEZkaE1VcElWMVprUm1WV1NuSmhSbVJwWVROQ1dsZFdVa3RPUm1SWFYyNUtWMkV6VW5GWmEyUTBaVVpXZEdWSVpHbFNiSEI1Vkd4b2QxZHRSWGxWYmxwWFZrVkdORnBGWkVkVFIwWkhXa1pPYVZORlNuWldNblJUVWpKRmVGTlliRlJoTVZwWldXdFZNV05HVm5OVmJHUnNWbXh3V1Zrd1ZrOWhNREZXVGxWb1YwMXVVblpaYTFwTFRtMUtSMXBHVmxkaVNFRjZWbXBHWVdReFNuTldiazVWWWtkU1QxbFVUa05XTVZwWVpVWk9VazFXYkRSV01uUmhWMGRHTm1KSGFGWmhNVnBIV2xWYVlXUkhWa2xhUms1T1ZtNUNObGRXVm1GVU1WSjBVMnhvYUZJeWFGaFpiRkpIVFRGV1ZWTnJXbXhXYXpWYVdWVmtSMVV5U2xkVGJtUlhWa1ZLV0ZwRVJtdFdNa3BKVkd4a2FWWldjRnBXVnpFMFdWVXhSMVZzWkZaaVJUVlpWVzE0ZDAxV1ZsaGxSM1JZWWtad1dWWldhR3RXTURGSFkwVjRXazFxUmxCVk1XUlBVakpPUms1V1RtaE5NRXBIVm0xd1IxbFdiRmRpUm1SaFVsZG9WRmxVU2pSV1ZteHlXa1pPVlUxV1dqQlViRlpQVmxaYWRGVnNjRnBOUmxweVdWVlZlR014VG5OaVJscHBWMFpLZVZacVFtdFRNV1JJVm10a2FWSnNjSEJXTUZwS1pXeGFTR1ZIUmxoaVZscElWMnRvVTJFeFNYcGhTRUpYWWxob00xVXhXbUZqVms1VlVteGFUbFp1UWxwV1YzaHZZekpLUjFOcVdtbFNiVkpoV1d0YVMxTkdXbkpYYlVaVFZtdHdNVlpIZUc5Vk1ERldZMFZzVjAxdVVsZFVWbHBUWXpGa2RWWnNTbWhpU0VKWlYxZDBhMVZ0VVhoaVJsWlRZbGhTY1ZSV1pGTk5WbHBZWlVkR2FGWnJiRFZaVlZwdlYwWlplbUZHVWxkaGExcFlWV3BHYTJSV1ZuSk9WbVJZVW10d1YxWnNZM2hPUm14V1RWWmtWMkpIYUhOVmFrNVRWbXhzY2xadVRrOVNiRlkxV1RCV01GWXdNWEpYYm14V1RXcEdkbFl5ZUdGU2JVNUhVV3h3YkdFeGNHOVhhMXBoVkRKU1NGVnJaRlZpVjNoWVdWUk9RMVZzV25GU2JVWnBUV3hHTkZVeU5VdFViRnBZVld4c1dtSllVbWhXYkZwaFkyeGFkRkpzWkdsU2EzQmFWMnRXYTFJeFdrZFRiazVYWVd4S1lWWnNaRzlWUm14WFYydDBhbUpWTlVwWk1GcGhWRzFLZEdGSWJGZGhhMncwVlhwR1QxTkdTbkphUmxwcFVteHdXVlpYZUdGa01rbDRXa2hLVjJKWVVsaFVWbFV4VTFaYVdHUkhkR2hTYTNCNVZHeFZOVll5U2toaFJWSldUVzVvYUZreFdrOWpWa1p6WTBaa1RsWldhM2RXYlhCSFlqSk5lRmRyYUZOWFIzaHZWVEJXZDJGR1duRlViRTVWVW14c00xWXlOVTloYXpGWFYyNXNWazFxUlRCV1ZFcExVMVpHYzFwR1pGZFNWemt6VmpGYWExTXhTWGhVYmxaVllrWktjRmxzYUc5aFJscDBaVWRHYTAxcldraFphMXByVjBkRmVsVnVTbGRpV0ZKb1dsZDRjMk5zWkhSUFZtUk9Va1ZKTVZkV1ZsTlRNVmw1VTJ0a1ZHRXdOV2hWYTFaM1YwWldjVkp1WkZSV2JIQjZWa2N4YzFVeFdrZFhhazVYWWtaS1JGWnFSazVsVmxwMVZHeG9hV0pGY0hoV1YzaHJWVEZhVjFWc1pGZGlhelZRVlcxNGQxZEdiRlpaZWxaWVVtdHNNMWt3V25kV01WbzJVVlJHVjJGcmNFeFdNVnBYWTFaU2MxWnNaR2xUUlVwYVZtMXdRMkV4VVhoVWEyUlVZbXMxYjFWdGN6RmpSbFYzVm10MFZGWnNjSHBXVjNSM1lrWkpkMkpFVWxoaE1taFFWakJrUm1WSFRrZGlSbkJwVjBaSmVsZFdWbUZXTWsxNFdraFdZVkl5YUZSWmJYUkxVMVphY1ZOdWNFOVdNRnA1VkZab1MxZEhSWGxsUjBaYVZrVndWRnBYZUhOV2JGcFpZVVpTVjJFeGIzZFdWekUwWVRKR1NGSllhR3BUUjNoWVZXcE9VMk5zVlhsTlZtUlhUVlpLZWxsclpHOVZNa3BKVVc1YVYxSnRVVEJWZWtwVFl6RmtjbHBHV21oTk1VcFJWbGR3UW1WRk5VZFhibEpQVmxSc1dGbHNWbmRsVmxKellVVmtWMDFyY0ZwWlZWWTBWakF4UjJOSFJtRldiVkpVVld4YVIyTXhXblJpUms1WVVsVlpNRlp0ZUdGaE1EVklVbGhvV0ZkSFVrOVdNRlpoVlRGYWNsWnRSbGhTYlhoNldWVlZOVlF4U25OWGJuQlhUVzVSZDFsWGVHRmpiR1IxWTBad1RsSnVRbmxXYlhCTFV6Rk9WMUp1VmxoaVIxSndWbXRXV21Wc1dsbGpSV1JWWWxaYVNGa3dWbXRoUmtweVRsYzVWVlo2Um5aYVIzaGhWMFV4U1dGSGJFNVdNVXBKVjFkMGIxTXlSa2RUYkZwUFZucHNWMWxzVWtkV1JuQllaVWRHYTFKVVJsZFhhMXByVmpGYVJsZHNjRmRpUjFFd1dYcEdZV1JHVG5OaVJscHBZVE5DV2xadE1UUmtNVTE0WTBaa1lWSlhVbFJaV0hCelYwWmtjbFpVUmxaTmEzQktWVmR6TVZZeVJYbFVhbEpWWVRGd2VsWXdXbE5YVjBaSVkwWk9WMkpJUWxsV01XUTBZVEpKZUZWWWFGaGliRXB6VlcwMVExUXhWblJsU0dSc1VteFdOVmt3Vms5aFJrcFZVbTVzVjAxdWFIWldiWE40WTFaYWMxRnNaRTVTTVVwTlZsY3hlazFXWkVkVGJrNXFVako0VkZsVVRrTlRiRnAwVFZSQ1dsWnRlRmxXUjNoclZrZEtjazVXV2xwaE1sSlVWa1JHWVdOV1NuSmpSM2hUWWtkM01WZHJWbXROUmxGNFUxaGtXR0pIYUZkVVYzQlhWMFphV0UxVlpHcE5helZJV1d0YWEyRldaRWhoUnpsWVZrVmFhRlpVU2s1bFIwNUdWMjFHVTJKV1NsQldiWGhUVmpGc1YxZFliR3RTTTFKeVZGWmFWMDVHV1hoaFNFNW9VbXR3TUZwVldtOVdiVXBWVW1zNVlWWldjSHBaTVZwUFl6RlNkR05GTlZkTlZXdzBWbXhqZUU1R1ZYbFNhMXBPVTBkb1ZWbHJhRU5YUm14elZXdGFUbEp0VWxoV2JHaHZWakF4VjJOR2NGcGhNbEV3VmxSQmQyVkdUbk5pUm1SVFlsWkZkMVl4V210V01WbDRXa1pzYVZJelFrOVVWekZ2VjFaYVIxZHRSbXROVld3MFZteG9jMVJzV2paaVJtaFZWak5TYUZwV1duSmtNVnBWVm14d1YySklRbGxYVkVKdlV6RnNWMU51VG1wU2JXaGhXbGQwWVZaR2NFWmFSWFJUVFZaS2VWUnNXbXRYUmtwV1kwYzVWMkpVUmpOVmFrcEdaREF4Vm1GR1VsaFNNbWhWVm1wQ2EySXhXWGhpU0ZKcVpXdGFXVlp0TVRSTlJuQldWbXBDYUdGNlJsaFdNalZ2VmpGSmVtRkdRbGRpV0doTVdYcEdhMk5XUm5OV2JHUnBVbGhDVmxadGNFTlpWazE1VkZoc1ZHRXhXbGhaYTFwaFkwWldkR1ZHV214U2JIQjRWVEp3VTFkc1dYZE9XR3hWWWtad2FGZFdXa3RrVmtaeVQxWmFhVlpHV2tWV1JtUTBXVmRPVjFSc2JHaFNhelZ3Vm0xNGQxTnNXbkphUkVKcFRXdGFTRlV5TlZOV2JVcFZZa1phVjJKVVJuWlZhMXB6WTFaS2RHUkhjR2xTYmtGM1YydFdZV0V4VW5OWGJGWlhZa2Q0V1ZaclZrdFhSbXhWVW0xR2ExSnJOWGxaVlZwaFlWZEZkMk5HYUZkU2JGcG9WMVphVTFJeFpGbGlSM2hUVFVad2VGWnRNWHBOVjFaSFZteG9iRkl3V2xaWmExcDNaV3haZUZWclRsZE5hM0JhV1ZWb1lWZHNXa1pYYkZKYVpXdGFjbHBHV2xkak1XUjBZa2RvVGxkRlNscFdiWFJoVmpKRmVWTllhRlJoTWxKWlZqQmtVMWRXYkhOV2JVWnFWbXh3TUZwVlZqQlViRXB6VW1wU1YwMXFRVEZXYlhONFkyMU9SMkZHV2s1aWJXZzJWbTF3UzFJeVRuUlRXSEJoVW14YVdGWnFSa3RUVm1SeVZtMUdWVTFyTlhwWGEyaExWVVphZEdGR1VsVldSWEIyVmpCYVlXTnNaSFJTYkhCWFRWVlpNVlpYTVRCaE1rWlhVMjVTVm1KSGVHRldhMVV4VmtacmVXVkhSbXRTTVVwSlZXMTRiMkZXU1hwVldIQlhZV3RzTkZSVldscGtNREZXVm14S2FHSkZjRmhXUm1SM1VXc3hWMWR1UmxKWFIyaFlWRmR6TVZOV2JGWlhibVJYVFZWd1dGa3dXa2RXTVZsNlVXdG9XbFpGY0ZSV2FrWlRaRlpXZEdGR1RtaGxiRm95Vm10YVYySXhSWGhhU0U1WVYwZG9ZVlJVU205VU1WWjBZek5vVDFKdFVubFdNakV3VjJ4YWNtTkVRbGRXTTJoeVZqSjRhMU5XUm5WalJtUlhVbFp3VlZadGNFZFpWbHBYVTI1T1ZtSkZOWEJXYlhSMlRWWlplRmRzWkZkaGVsWllWakZvYTFSc1pFWmpTRVpXWWtkUk1GWXdXbUZrVjA1R1UyczFWMkpJUWpaV2FrbDRVakpHY2sxWVNrOVdWbkJZVldwT2IyTnNXa2hsUjBaclZtdGFlbGxyV205WFJrNUdVMnN4VjFZelFraFdSRVpQVWpGYWRWTnRhRk5OYldoVlZrWmpNV0l4V2xkWGJrWlNZa2RTVlZsWWNFZFhSbGw1VGxWMFdsWnJjRWhWTWpGSFZqSkdjbE51Y0ZWaE1YQnlXVEl4UjFJeFVuTmFSazVPVW14cmVGWXhXbGRoYXpWWFYyNVNWR0pIZUZkWlZFNXZWMFpzYzJGSE9XeGlSbkI2VmpKME1HRXhXblZSYTJSVllrWlZlRlpxU2t0WFZuQkZWMnhrYUdFeU9UTldNVnByVW0xV1IxZHNiR0ZTVkZaWVdXeG9iMVpHWkZkVmEzUnBUVmRTV0ZscldsZFZNa3BIWTBoT1ZtSllhRE5hVlZwV1pWZFNSVkZ0YUdsV1dFSklWa2Q0WVZsV1duUlRiR3hvVTBWd1lWWnNaRk5TTVhCWFZsUldWMVpzU25wWGExVXhWakpLY2xOdVdsZGlXRkp4V2xWYVdtVkdaRmxoUmxacFlrWndWMWRYZUZkWlZscEhZa2hLVjJKdFVuSlVWbVJUVjFad1JsZHRkR2hOUkVaWVZqSTFkMVl3TVhWaFJtaFhWbnBHVEZZeFdsZGtWa1p6Vm14a2FWWnJjRlpXYlhCRFdWZE5lVlJ1VWxOaE1YQnlWVzB4YjFaR1VsWmhSVTVZVW14d2VGVXhhR3RVTVZwelkwUkNWazF1YUZoV2FrcEdaVVpPYzFwR2NHbFNNbWd5Vm1wQ1lXUXhTbk5qUldSaFVteEtWRlJXVm5kVGJHUlhWbTEwYVUxcmNFbFZiR2h2WVd4SmQxZHNhRnBpUjJoMldURmFVMVl4Y0VkVGJYaFRZbFpLWVZZeWRGWk5WbVJIVTI1T2FsTkdjRmhXYTFaTFlVWndSVkp1VGxkTlYxSXhWa2Q0YjJGV1NYaFRiRVpYVm5wRk1GcEVTbGRTTVZwWllrZHdiR0pHY0ZoV1JsWlRVakZrYzFac2FHdFNlbXhaVldwQ1YwNUdhM2RoUlhSWFRWVnNObFpIY0ZOWlZrcFlWV3RvVmsxV2NISlpla1ozVTBkR1NHRkZOVmhTVlc5NVZtMHhkMUl4YkZkaVJtUlhZbXhLV0ZsVVNsTldiR3h5V2tSU2FVMVdXakJVVm1NMVlXeEtkR1ZHY0ZwTlJuQnlXVlJLUzFJeVRrZGlSbkJPVW14VmVGZFdXbFpsUmxsNVZHdGFhRkp0VWs5WlYzaGhVMVphYzFWcmRGTmlWbHA2Vm0wMVQyRldTblJWYmtKWFlURmFhRlpzV21GalZrcDBVbTEwVGxadVFqWldNblJ2VlRKRmVGTnVVbWhTYkVwV1ZteGFkMlZXY0ZkWGJVWllVbFJHUmxWdE1UQlViRmw0VTJ0d1YxWXphSFpaZWtwSFVqRk9jMkpIYUZOaVYyaFhWbTE0YTFVeFdrZFdia1pUWW0xU1dWVnFSbUZUUm1SeVdraGtWV0pWVmpSWk1GWnpWakpLVlZKVVFscFdSWEJJVm1wR1UyTnNaSE5VYldocFUwVktXbFl4WkRSaU1VVjRVMnRrWVZKdFVtaFZiRkp6WTJ4V2RHVkhSbGhpUjNoWFZqSXdOV0ZHV1hkalJXUmFUVVp3V0ZZd1dscGxiRloxVTJ4d2FHRXhjRzlXVjNCSFZqSk5lRnBJVG1oU01uaFZWV3hXZDFWV1duUk5TR2hQVWpGR05WWnROVTlYUm1SSVpVVTVWbUV4Y0doWmFrWlhZekZXY2xwR2FGTmlXRkY2VjFaV2IxUXhXWGhYYms1cVVrVktZVlpzV25ka2JGcHhVMnQwVTAxck5VcFZNbmhoVkd4S2RWRnNiRmhoTVZweVZXcEdTbVZIVGtaaFIyeFRZWHBXZDFkV1VrTlhhekZ6VjI1R1UySkZOVlZVVlZKWFUwWmtjbUZHVGxkTmExWTFWbGN4YjFack1VZGpSMmhhVmxad1dGcEZaRTlPYkVwelZtczFWMkpyUmpOV01uUlhZakZzV0ZKWVpFNVdiV2hYV1d0a2IxZEdiSE5oUnpsb1VteHdTVnBWWkVkaGF6RnlUbFZrV2xaV2NHaFdSekZMWkVkR1NFOVdhRmRpVmtWM1ZsaHdSMU15VWtkVmJrcGhVakpvVkZsdGRFdGtNVnBZWTBWMGFVMVdjRmhYYTFwclZqSktWbGR0UmxkaGEwVjRWakJhVm1WVk5WWlBWMmhwVWxkM01sZFdWbUZpTVdSMFVsaG9XR0ZyTlZsV2JYaDNZMnhaZDFwR1RsUlNhM0F3V1ZWVk1XRkZNVmxSYlVaWFlrZE9ORnBFUm5OV01XUlpZa1pTYUUxdGFIcFdWekI0VGtaa1IySkdhR3BsYTFwWVZXMHhORll4V1hsTlZFSlhUVVJHV1ZaWE5YZFdNREZ4VWxSQ1YxWkZSalJWTVZwSFkyMUtSMXBIYkZkU1ZsWXpWbTE0VTFNeFNYaFhXR2hWWW1zMVdGbHJaRk5qUmxaeFUyMDVXRlpzY0ZsVVZsSlRZVEF4Y2s1WWNGZFdlbFpNVjFaYVMyUkdWbk5oUmxaWFlsWktWVlpHV21GWlZtUkdUVlpXVm1KSFVsUlpWRW96VFVaYVZWTnFVbWhOVjFKSVZqRm9kMVp0U2xoaFIyaFdZVEZhU0ZScldtRmpWa3AwVW0xd1RtRXhjRXBYYkZaaFZERlNjazFXV21wU2JrSllXVlJHZDJOc1VsWmFSa3BzVW01Q1NsWkhlRzloVmtsNFUyNWFWMVl6UWxCV1ZFWnJVakZXYzJGSGRGUlNNVXBaVjFkMFlWbFZNVWRqUlZwV1lrVTFXRlJYZEhkV01WbDVUbGhPV0dGNlJraFpNRlpUVmpKS1ZWSnJhRnBOYm1oeVdURmFVMk14WkhSaFIyaE9WbnByTWxadGVHcGxSMVp5VFZaa1lWSlhhRlZaVkVwdllqRldjVlJ0T1dwU2JGcDZWakkxVDFReVNrZGpSRUpWVmxkb2NsbFVRWGhqTVdSeVdrWldhVkpzY0hsWFZscGhVekpTUjFadVRsaGlSMUpQVldwR1MwMXNXbkZTYlVaWVlsWkdORmt3Vm05VlJscDBZVVpvV21KSGFIVmFSRVpyWTJ4YWRHUkdUazVXYlhkNlZrWmFZV0l5U2tkVWEyaHNVbTFvVmxacVRrTlhSbXQ1WlVad2EwMVhVbmxhUldSM1ZHeGFWVlpxV2xkaGEyOHdWMVphVTJSR1NuVlRiRTVZVWpKb1dWZFhlRzlWTWtaSFdrWmtZVkpVVm5OV2JYaExaVlphZEdWRmRHaFdhM0I2V1RCYWMxZEdXWHBWYkdoaFVrVmFhRlpxUm10a1ZsWnlUbFpvVkZKVmNEWldiR04zWlVaVmVGUnJaRmhpYkVwUVZteFNjMkl4Vm5Sa1NHUk9VbXh3V1ZwVll6VlhiRnB6WWtSYVdsWlhVblpXYWtaaFl6Sk9TR0ZIUmxOV01VcFZWbFJDYTFVeFNYaFdia3BQVm0xU1dGVnRlSGRUTVZwMFRVaGthMDFFUmxoV1ZtaHpWVEpGZVZWc1ZscGlXR2hNVm1wR2MyUkhVa1prUm1oVFlsaG9WMVpYTURGaE1rWkhVMjVPV0dKdVFsaFVWM0JIVTBaWmQxZHJjR3hTYlZKNVdXdGFZV0ZXWkVoYU0zQlhZbGhDUTFwVldtRmtSbEp5VjIxd1UySldTbmRXVjNCSFVqQXdlRnBHYUdwU1YxSllXV3hhWVZkR1draE9WWFJhVm10d01GbFZZelZaVmxvMlVsUkNWMDFHY0hKV2FrWlhZMnh3U0dSRk5XaE5XRUpLVm0weE5HSXlTWGhhUldoVVlrWndXVmx0ZEhkV01XeHlWMnQwVkZKc2NEQmFWVnByVjBaS1ZWSnNiRlZOVm5CWVdWWmFTMlJXUm5GWGJHUm9ZVEZ3VlZaWGNFZFhiVlpIV2toS1dHSlhlRTlVVjNoTFlVWmFkR1JHWkd0TlZUVklXV3RTWVZVeVJqWmlTRXBYWWxob1RGcFhlR0ZYUlRGWlZHeGtUbFp1UVhoV1ZtUTBaREZaZDAxV1pHcFNiRXBYV1ZkMFlXVnNXWGRYYTNScVlraENTRmxWWkc5VWJHUkdVMjFHVjAxWFVUQldha1p6VmpGa2MxcEdaR2xoTVhCVlYxZDRWMWxXV2xkV2JsSk9WbXMxYzFadE1WTmxWbXhXV2tSQ1YwMVdiRE5aTUZadlYyc3hSMU5yYUZkaVdHaG9Xa1ZrUjFOV1RuTmFSMmhvVFZoQ2RsWnJZM2hPUmsxNFYyeGtVMkpyTlZsWmJHaHZZakZTVjJGRlRsZGlSbXcwV1ZWb2ExVXdNWEpXYWxaWFZqTm9jbFp0TVV0ak1VNTFVbXhhYVZkRk1UUlhWRUpoVjIxUmVHTkZhRkJXYldod1ZXMHhNMDFHV25GVFdHaE9VbXhLZWxVeGFHOVdSMFp5VTJ4b1YySlVSblphUjNoclZqRmtjbVJIZEZOaVJtOTNWMVpXWVZsWFJsZFRXR2hVWWtaYVdWWnJWbUZoUm13MlVtMTBXRkpzU25sV01qRkhWVEpLV0dGR1ZsaFdNMmhvVlhwQk1WWXhaSFZTYkZKWVVqSm9VRlpYY0VOWlZrNUhWbGhvYUZJelVsbFZiWGgzVWpGcmQxZHRPVmhpVlhCSldWVm9ZVmxXU1hwaFIwWmhVa1ZhY2xsNlNrOVRSMVpJWWtaa1YySnJTazFXYlRGM1V6QTFTRkpZYUZoWFIyaFZXV3RrVTJOV1ZuUmxSMFpZVW14d2VGWkhkRTlXUmtwMFpVWmFWazF1VFhoWmExcGhZMjFPU1dKR1pFNWlhekI0Vm0xd1MxTXhXWGhVYmxaaFVtMVNjRlpyVmxkTk1XUnlWV3RrYWsxV2JEUlhhMmhYVm0xR05sWnNiRlpoYTFwTVZtdGFZVkl4WkhSa1JUbFRZbFpLU1ZadGVHOWlNa1pIVTJwYWFWSnRlRmRaVjNSTFYwWlNjMWR1VGxkaVZWcEhWREZhYTJGV1dsZGpSRlpYVmtWc05GbHFSbHBrTURGV1drZHdVMkpGY0ZsV1JsWnJWVEZhUjFaWWFGaGliVkpVVkZaYVlXVnNXa2hOV0U1WVVtdHdlVll4VWt0V01rcFZVV3BPWVZKRlJqUldha1pYVjFkR1IyRkdhRk5OVlhCUlZtMHdkMlZHVlhsVWJHUlhZbXMxYUZWdGN6RlpWbHAwVFZSU1dGWnRkRFpaTUZacllVZEtWbU5GYUZwTlIyZ3pWakJrUm1WR1pIUmhSbkJvVFZoQ1RGZHJVa0pOVmxwelkwVm9VMkpIVWxoVVZsWjNVMnhhZEdWR1RsTk5WM2haVmxkNGExVXlTbkpPV0VKV1lsUkdkbFl3V2xkak1XdzJWVzEwVGxZeFNsbFdiR1F3VFVaYVdGTnNaRmhoTW1oWVZGZHdWMWRHV25STlZYUllVakZhU0ZaWGVIZFhSazVHVTJ4c1YyRnJiekJYVmxwclUwWmFjbHBIUmxOTk1VcFFWbTF3VDJJeFpGZFhia1pVVmtWYVYxUldXa3RsYkZwSVpFYzVhRkpyY0hsVk1uaHJWMjFLU0dGSVdsZE5SbkJVV1RKNGEyTXhaSFJsUms1T1VtNUNTMVl5ZEZkWlZsbDRWVzVPV0ZkSGFGVlpWRXB2VjBaV2NWUnRPV2hTYlhjeVZXMHhNR0V4U25KalJuQmFZVEZ3YUZsV1drdGpiVTVIWWtaa1UySklRbTlYYTFKTFZqSk5lVkpZY0dsU00yaFZWV3BHUzFaV1drZFhiVVpVVFd4YWVsZHJhRXRYUjBZMllrYzVWMkpZVWpOV01uaFhWMGRXU1ZwR1pFNWhNMEpYVmxaa2QxUXhiRmRYYkdScVVsaFNhRlp0ZUhkVlJtdDVUVlZrVTAxV1dqQlpWVlV4WVZaS1dWRlVRbGRpV0doeVZHdGtSbVF3TlZaaFJrNW9UV3hLV2xkWE1YcE5WbVJYWWtoU1RsWnJOVmhVVmxwaFRVWlNWMVZzVGxoU2EzQjZXV3RTVjFsV1NsZFRhMUphVmxkU1RGWnRNVTlTTVhCSFZtMXNVMkpJUVhsV2JYQkRZVEZLZEZacmFGVmhNVnBXV1d0a1UxWkdVbFZUYlRsVlZtMVNlVll5TVVkVk1ERnlUVlJTVmsxcVZsQlhWbHBLWlZkV1IySkdXbWxTYkc5NlZtdGtORmxYVFhsU2EyeGhVbXMxVDFac1VsWmtNVnAwVFZSQ2FFMXJXbnBWTW5odllrWktkRlZ0UmxwaE1sSlVXa2Q0WVdOc1pIVlViWEJwVmxad1NGWnJZM2hOUmxKelYyNVdVbUpJUWxoVmJYaGhWa1pXY1ZKc1pHcGhla1pZVjJ0a2QxVXlTbGhoUm14WFVtMU5lRmxxU2xOak1XUnlZVWQ0VTAxR2NGVldSbHBXVFZVeFIxWnVVbXhTTTFKdlZXcENWMDB4V25SalJrNVlVakJ3U1ZaV1VrTlhhekZ4VW14T1lWWldjSEphUmxwWFpFZFNSMVJ0YkZkaE0wSlhWbTEwWVZZeVNYaFNXR2hoVTBVMWFGVXdWVEZYUm14elZtMUdWMDFXU2xoV01qVlBWREZhYzFacVZtRldWbkJ5Vm1wQmVHTnNXbkZWYkZwT1ltMW9NbFp0ZUdGWlYwMTVWR3RXVldKSVFsaFdiVFZDWld4YVdFMVVVbXROVld3MFZsYzFUMVp0U2taT1Z6bFZWa1ZLU0ZSVVJscGxSbkJGVVd4a2FHVnJXbGxXYWtadll6RlZlRnBGYUdoU2VteFdWbXRXZDFaR1dYZFhiazVxVFZaYWVWWkhjekZVYkZweVkwWnNWMkZyYnpCVmVrcExVakZPZFZac1NtaE5iRXBvVm0xNFlXUXhXa2RpUmxwWFYwZG9jVlJXVlRGTlZteFdWMjEwVjAxc1dubFZNVkpEVmpGSmVsVnRhRnBsYTFwaFdsVmFkMU5XV25OVmJXeFRUVlZ3TTFadE1UUlpWMUY1Vlc1T1dHSkhhRTlWTUdSdlZqRlNWMXBHVGxSU2JHdzBXVlZvVDJGV1NuSmpSbHBhWVRGd2RsWnNXbHBsYkZaeFZHeGFUbFp1UW05V2FrSnJWREZLYzFWdVRtRlNNbmhZVmpCV1MyRkdXWGhYYkdSb1RXdHNORll4YUc5V1JtUkpVVzA1Vm1GclNtaFpWVnBoWTFaU2RFOVhlRmRpYTBwYVZrWmFWMDFHVlhkTlZteFNZVEpvV1ZsVVNsSk5SbXhXVmxob1YwMXJjRVpXTW5ocllVZEZlR05IT1ZkaVJrcElWVEl4VjFJeVRrWmlSbHBwVWpGS2QxWlhjRWRUTVZsNFdrWm9UbFpGU25KVVZtUlRWMFpzY21GRk9XaFNhM0JYVkd4YWIxWXlTbGxoUjJoaFZsWndhRlV3VlhoU1ZscHpZVVpPYUUwd1NUSldNVkpEVmpKSmVGcEZaR0ZTVjNoVFdWUktiMWxXV25SbFJtUlBVbXh3ZUZWdGN6VmhiVXBXVjJ0b1drMUhVblpXUnpGTFYwZEdSazVXWkdoaE1YQnZWakZhWVZSdFZrZGpSV1JoVW0xU2NGbHJXbmRXVm1SWVpFZEdXbFp0VWtoWmEyaExWMGRLU0ZWc1FsWmlWRVpVV2xkNFdtVlZNVlphUjJocFZsaENXVlpYTVhkVk1XUklVbGhzYUZKc1NtRldhMVpoVkVad1JsZHNaR3BoZW14WVdUQmFhMVV4V2tkWGExcFhZa2RvTTFWcVJuTldNV1JaWVVkd1UxWnNjRmhYVjNodlVURlJlRmR1VWs1V1JUVlBWbTE0ZDFac1ZYbGpSVTVvVWxSR1dGa3dWbk5XYlVwSVlVaHdXbFpXY0V4YVJXUkhVMFpLYzFwSGFHaGxiRnBXVm10YVUxSXhiRmRYYms1aFUwWmFhRlZ0Y3pGalJsWnhVbXR3YTAxV2NGbFVWV2h2WVRBeGNsZHNhRlpOVjJoMlZtdGtSMk15VGtkaVJtUnBWMGRvYjFkVVNqUmpNRFZ6VTI1T1dHSllhRlJaYkZwTFRsWlplV1JIUm1sTmExcEpWV3hvZDFWdFNraGxSbXhYWWxob1RGVXdXbmRTVmtwMFpFWk9UbUV6UWt0V1Z6RTBWREpHUmsxV2JGSmlia0pZVm01d1EwNUdXbFZUYkdSWFRWaENTbFV5ZUc5aFZscElaVWhhVjJKWVFrUmFSRVpLWlVkRmVscEhhRlJTTVVwWlZrWmFZV1JyTVhOWGJsSnFVbFJzV1Zsc1dtRmxWbGw1VFZjNVdHSldXbmxXTW5odlYyMVdjbU5GYUZaTlIxSllWV3BHVTJOck5WZFViV3hvVFVkME5WWnRNWGRTTWtWM1RWVmthVkp0YUZkV01HUlRWREZhYzFwR1RtcFdiRm93V2xWb2ExZEdXblJsU0hCYVZsWndVRll3V2t0a1IxWkpZMFprYVZaR1dubFdiWEJDWlVaWmVWUnJWbEppU0VKUFZXMDFRMlZXV25SalJVcHNVbXhzTlZVeWRGZFhSMHBKVVd4b1YySlVWa1JXYkZwaFpFZE9SbVJHVGs1aGVsVjNWbXRrTUZsWFNrZFRibEpXWW10S1YxbHNVbGRTUmxwSFYyMUdhMUl4V2tsVmJYaFBWRzFHTmxKVVFsaFdSVXBZV1dwS1IxWXhUblZWYldoVFlrVndWMVp0TlhkU01rNVhZMFphV0dKVlduRldiWE14WlVaYVdFMVhPV2hXYkhCNldUQldjMVl5U2tkalNGcGFZV3RhYUZZd1drdFhWMHBJWVVaT2FWWnJjRzlXYlRFd1ZqSlJlRmRyWkZoWFIyaFpXVzF6TVdOV2JISlhibVJYWWtaYU1GcFZZelZXYXpGeVkwVm9XazFHU21oV2FrcEhZMjFGZW1GR2NGZFNWbkJ2Vmxkd1IyRXlVbGRWYmxKcVVtczFWRlpzYUVOaU1WcHlWMnhrV2xadFVqQldWbWh2VjBkRmVXRklUbFppUjJoVVdURmFVMVl4V25WYVIzaFRZa2hDV2xkc1ZtdE5SbHBZVTJ4YVdHSnVRbGhVVnpWUFRrWmFjVk5yV214V2JGcFdWVmQ0YjFZeVNsZFRiRlpYVmpOQ1NGZFdaRk5XTVZaMVZHMUdVMDF1YUZaV1YzaFhaREF4YzFkdVNsaGlWVnBoVm1wR1IwNUdXbGhsUjNSWVVqQndlbFV5TlVkV2JVcElWV3hTV0Zac2NHaFpNVnBIVmxaS2RHVkhiRk5pV0dONFZtdGtORll3TVVoU2EyaFVZVEZ3Y1ZWdGVIZFhSbXh6WVVjNVYxSnNiRFZVVmxaaFlrWkpkMDVWV2xkU00yaFlXVlZWZUZkV1JuUlBWbVJvWVRCd1dGZHNWbUZaVmxsNFYyNVdWV0pIVW05YVYzaGhaR3hhUjFkdGNFOVdWRUkwVmpJMVQxWnRSWHBWYXpsV1lsUkZNRll3V21GV01rWklUMVp3VjJFelFscFhiRlpoVkRGa2RGSlliRlppUmtwWVdXeG9iMkZHY0VkYVJUbFRUVmhDU1ZwRlpITlZNREI0VWxob1YwMXVhRmhaYWtaU1pVWmtXV0pHVW1oTmJtaFVWMVpTUzJJeFpGZGlSbFpVWWtVMVQxUldaRFJYUmxsNVpFaGthVkpyY0hsVWJHaDNWMGRGZUdOSVNsZGhhMXBNVmpCVk5WTldjRWRoUm1ScFVsaENUbFpzWkhkU01XUjBWbXRrVm1Kc1dsaFphMlJUWTBaV2MyRkZUbXROVm5Bd1drVmtNRlF4U25SVmJHaFlZVEZ3ZGxscldrdE9iVXBIVkd4V1YySkdWalJXVkVKaFdWZE5lVkpyYkZWaVJscHdWVzAxUW1ReFduTmFSRkpXVFZad1dGWXlOVTlXTVdSSVlVWmFWMkpZYUROWlZWcDNVbXh3UjFwR1RrNVhSVXBLVjFaV1lXRXlSbGRVYTFwVVlraENXRlJXV2t0U1JtUlhWMnh3YkZKdVFrZFhhMXB2VjBaT1JsTnNhRmhXTTFKeVdXcEtSMUl4V25WVGJHUnBZbFpLV2xaWE1IaE5NREZ6Vm01U1RsWkZTbTlaV0hCSFpWWlplV1JJVGxoaGVrWklXVEJhUTFZd01VZGpSWGhhVFdwR1VGVnNXbE5qTVhCSVlVVTFXRkpWY0RKV2JYQkhXVlpzVjFwSVVsWlhSMUpRVm0xNGQyRkdWblJOVnpsWVZteGFlRlpITURWV2JGcHpZMFJDWVZaV2NGQlpWM040VjBaV2NtRkdaRmROTW1neVYxWlNSMVF4VGtkV2JrNW9VbXhhV0ZscmFFTk9iRnBJWlVkR2EwMVdjSHBYYTJoTFZVWmFkRlZyT1ZaaE1WcG9WR3hhYTFaV1JuUlNiWFJPVmpGS05sWnFTalJoTVdSSFYydGFWR0pIYUdGWmExcExVMFpWZDFkdVNteFdNVnBKV2tWa01GVXdNVWRqUlhCWFZucEZNRlpFUmxwa01ERlhWMjF3VTJKSVFsbFhWM1JoVXpGS1IySkdWbE5pUm5CelZXMXpNVmRzYkZaYVJXUlhVbXR3ZVZrd2FHdFdNVm8yVVdwU1YxWkZXbkpXYWtaaFpGWlNjMXBIYkdsV2EzQlhWakZrTUZsWFVYZE5WV1JXWWtkU2IxVnFUbE5YUmxaelZXdGtVMkpHY0RCYVJXaFBWakpLVm1ORmJGcFdWMmhvVm1wQmVGTkdWbkpsUmxwT1VtNUNXVmRZY0V0VE1VbDVWR3RvYUZKVVZuQlZiR00xVGxaYWNWSnRkR3ROVld3MFZqRm9jMVp0UlhsaFJtUmFWa1ZhTTFreWVGZGtSVEZZVDFaa1UySllhRFpYVmxacVRsWlJlVk5yYUZaaVIyaFlXV3hTUjAweFdrVlNiSEJyVFZkU2VWbFZXbUZVYlVaelYyeEdXRlp0VVRCVmVrWkxZekZTZFZWdGFGTmlWa3AzVmxkd1IxTXhXa2RhU0VwV1lUSlNjVlJXWkZOU01WSlhWMjFHYUUxVmNIbFViRlUxVmpKS1IxTnNaR0ZXVm5CeVZteGFSMlJHU25SaFJUVlhZVEk1TTFac1kzZE5WazE0V2tWb1UySnJOWEZWYlRGdldWWnNWVkp1WkZWU2JGWXpWakl4TUZZd01WaFZibXhhVFVkUk1GWlVTa2RPYkZwWllVWmtWMlZyVlhkV2JYQkxVakZaZUZSc2JHaFNiRXB3V1d4YVMxZFdXblJPV0dSU1lsWmFTRlp0ZUZkV1IwcElWV3hvVlZadFVsUmFWbHB6Vm14d1JWRnNXazVTUlZwSlYxUkNZVmxXWkVkWFdIQm9VakpvV1ZadGVIZFZSbFp4VW01a1ZGWnJOVEJaVlZwUFlWWmFjbU5HY0ZkaVZFWXpWVlJLVW1WR1VuSmFSbVJZVWpOb1VWWnRlRlpOVm1SWFlraEtXR0p0VWxSVVZscExaV3hhZEdWRk9WaGlSbkI2V1RCYWIxZHJNVWhWYmxwWFlXdEdORlV3V2xkak1rWkhWMjFvYUUxWVFsWldNV2gzVWpGVmVWUnVTazlXYlZKb1ZXcEtOR0l4VWxaaFJVNVZVbXh3TUZSVmFHOWhNREZXVGxoc1ZWWnNjSEpXYkZwclUwZEdSMkpHWkU1U01VVjNWbTE0WVdNeVRuTmFTRlpoVW0xb1dGbHNhRzlPVmxweFUycENUbEpzYkROVVZscHZZa1pPU1ZGdFJsZGlSMUpQVkZaYVlWTkhUWHBoUm1ST1lUTkNSMVpyWkRSaE1WSjBVMjVTWVUwelFsbFdhazVUWVVaWmVVMVdaRk5OV0VKS1ZUSXhjMVV3TVVkalJsWlhZbFJCZUZWVVNsZFdNV1IxVTJ4d1RrMXRhRlZYVjNoaFdWZFdjMVp1VWs5V1ZHeHZWVzEwZDAxR1dsaGxSazVZWWxWV05WbFZWbE5XTWtwSFkwZG9XbVZyV2xoWk1uaDNVakpPUjFwRk5WZFhSVXBMVm0weE1HRnJNVmRWV0d4VFlrZFNWVll3WkRSaU1WWjBaVVYwVjJKR2NERlpNRlpyWVRKS1IySkVVbGROYWtaSVdWUkdTbVZHVG5KaFJtaG9UV3hHTTFaclpEUlpWbVJJVldwYVVtSkhhRmhWYkZaM1lqRlplRmR0Um1oTlZUVklWVEkxUjFkSFNsaGxSbFpXWWtkb1JGWXhXbXRYUjFaSVQxWmFUbEpGU1RCWFZFSmhZakpLUjFOdVZsSmlhelZZV1d0YVMxTkdXWGxsUjBaVVVqRmFTVlZ0ZUZkaFZscFhWMVJLVjFadFVYZFpla1pyVWpGa1dXTkdXbWxTYTNCYVZtMHhOR1F4YkZkalJtUllZVE5TV1ZacVFtRlRWbXQzVjJzNWFGWnJjRnBWVjNoelZqQXhWMk5JU2xWV1ZuQjZWbXBLUzFJeGNFaGpSazVwVTBWS1lWWXhaRFJpTVZWNFdrWmtXR0pyV2xOWmJGWmhWbFpXZEUxVVVsZE5WMUo1V1ZWVk5XRkdTbkpqUmxwV1ZqTkNVRlp0YzNoalZscDBZVVprYUdFelFrMVdWRUpoVlRKT1YxWnVUbGRpUjFKWVZGWldkMVpXV1hsbFIwWmFWbXhXTlZaSE5VOWhiRXBZVlcxb1ZtRnJiekJaYWtaM1YwZFdTRkpyTldsU2JrSTJWakowVTFVeFdYbFNhbHBUWWtkb1dWbFVSbUZqYkd4WFYyczVVMkpWTlVsWlZWcGhZVlprUmsxVVVsaFhTRUpJV1hwS1QyTXhjRWxXYlVaVFZrWmFWVmRYTVRCVE1XUkhWMWhzYTFKdFVtOVVWbHB6VGtaWmVHRkhkR2hpUlhCWldWVmtSMVpXV2xoVmJscFZWa1ZhYUZreFdrZFhWMFpJWTBaa2FWTkZTVEJXYlhSclRrZEZlVkpyYUZOWFIxSlpWbXRXUzFkV2JGVlNibVJxWWtaYWVGVnRjelZXUmtweVkwaHNXR0V5VWtoV1ZFWmhVakZrYzFac1pGTmlTRUpaVjJ0U1IxUXlUWGhhU0ZaVVlraENUMVJYZUV0bGJGcFlUVmh3YkZKVVZraFdiR2h2WVVaS05tSkhSbGRpV0UxNFZXcEdVMk14WkhWVWJHaHBWbGhDU2xac1dsTlJNVmw1VWxob2FsTklRbWhWYkdSVFZrWldkRTFXVGxSU01VcEpXV3RhVDJGWFJYZGhNMnhYWWxSRk1GbFVRWGhTTVZaWllVZEdWRkpVVmxwWFZ6RjZUVmRPUjFadVNsaGhNMUpaVm0weE5GWnNWblJOVldSb1RXdHdTRmt3YUc5V2F6RjFWVzFvV21FeGNFdGFSRUV4Vm0xS1IyTkdaRmRpYTBwMlZqRmFZVmxXYkZkVGJrNWhVMFUxV0ZsclpHOVhSbFp6Vm01a2FVMVdiRFJXTWpFd1ZsZEtWMWRyYUZwTlJscDZWbXhrUzFkV1JuTlZiR1JvVFZoQ2IxZHJVa2RaVm1SR1RWVldVMkpGY0U5VmExcGhWMVphY1ZKdE9XcE5hMVkwVlRJMVMxUXhXblJWYkZwWFlsaG9NMXBYZUZOV1ZrcHpWR3hrVGxZeFNYZFhhMVpoWVRGVmQwMVZiRkpYUjJoWVZtMHhVazFHYkZWU2JVWlhUVmRTZUZZeWVHdGhWMHBKVVcxb1YxSnRUWGhaYWtwWFl6RmtXVnBIUmxOaVZrcFZWMWQ0WVZNeFRrZGFTRXBYVmtWYVdGUldXbmRUUmxsNFZXdDBWMDFFUmxoWk1GcHZWMFphZEZWclpHRldiSEJNV1hwS1IxSXhWblJpUjJoT1RVVndXRlpxUm10TlIwVjNUbFZrWVZKdFVuQlZNRlozWVVaV2RHUklaRlZOVmxvd1dsVm9hMVl5U2tkV2FsWmFUVE5DV0ZsVlpFZE9iRXB6WTBaYVYwMHhTWHBXYlRGNlpVZE9WMU51U21oU2JWSllWV3hXV21Wc1pISlZhMlJWVFdzeE5GVnROVTlaVmtsNVpVWnNWbUZyY0hWYVZscGhZekZrYzFSc1NtaGxhMXBhVm10YWIySXhiRmRVYTJSWVlrWktZVmxVUm5kVVJteHhVbTVPYW1KR2NERlhhMXByVkd4YWRWRnJiRmROYmxKVVZWUkdhMk14WkhWVGJXeFRVbXR3V1ZadGNFOWlNazV6VjFoa1lWSllVbGhaYTJSVFRVWlJlRmR1WkdoU1ZFWllXV3BPZDFZeVNsVlNWRUphWld0d1VGbDZSbmRUVmxaelVXeGthVlpyY0ZGV01WcFRVakpSZDA1V1pGaGhNbWh6Vlc1d2MxbFdXblJOVms1c1lrWnNOVnBWWkRCaFIwcEdUbFZrV2sxR2NIWldNbmhhWld4V2RHRkdjRTVpYldnMVYyeGFhMVl4VGtoVmEyaHJVbXMxVDFadE5VTlRiRnAwWkVkd2JGSXdNVFJXTW5SclZrZEtSMk5IT1ZWV1JXOHdWakJhYzJNeVJrWlViRlpUWWtWd1dGWnFTVEZVTVdSSFUyNUthbEp1UW1GWlZFWjNWVVpzVmxaWWFHdFNNRnBJV1d0YWIxWXlWbkpYVkVwWFVteHdhRmxVUmxwbFZrNXlZa1phYUdWc1dsbFhiR040VGtaa2MxZHNhRTVXUmtwaFZteFNSMU5HYTNkWGJVWm9VbXRzTmxaWGVITldiVXBaVldwT1ZWWldjR2hXTUdSWFUwVTVWMXBGTlZOU1ZtdzBWakZhVjFVeFVYaGFTRkpUVjBkb2NWVnNhRzlaVm5CWVpFaGtWbEpzV25wV01uUXdZV3N4V1ZGcmFGaGhNbEV3V1ZWVmVGWXlTa1ZYYkdScFZrVlZkMVpzVWtkVGJWWlhVMnhzYUZKc1NsbFZha3B2VmpGa1dFMVljRTVXTURWSVZtMDFVMVJzV25KT1ZteFdZbFJXUkZZeFduZFNiR1IwVW0xb1RsSkZXbGxYVkVKVFVURmtjazFWWkZoaE0yaFlWV3BPYjFsV2NFVlJXR2hYVm14d2VsWXljekZoVjBwR1kwUldWMkpZUWtSWlZFWk9aVVpTY2xwR1pHbGhlbFozVmxjeE5HUXlTWGhpUmxaVllUQTFUMWxyV25kbFJsWjBUVlZrYUZKVVJsbFdWM1J6VmpGWmVsVnVXbGRXUlhCTVZqRmFWMk5yT1ZkalIyaE9WMFZHTmxaclkzaE9SbXhZVkd4a1ZHSnNTbEZXYWs1RFZERnNWVkpzY0U1U2JIQldWVEkxYTFkc1dYZFhiR2hXVFdwV1ZGbFZXa3BrTVdSMFVteHdWMUpXYjNwWFZsWmhWMjFSZUZwSVRsVmlXRUp3VldwR1MwNXNaRlZSYlhSUFVteFdOVlV5ZEd0aGJFcEhWMnhvV2xaRmNGTlVWVnB6VmxaT2NscEdaRTVXTVVvMlYxZDBZVk15UmxkWGJHUnFVbTVDV0Zsc1VrWk5SbVJYVjIxMFUwMVdXakZWTW5odllWWmtSMU51YUZoV2JXZ3pWV3BHYTJNeFpIVlZhelZYWlcxNFdGWkdaREJXTURCNFlUTmtZVko2YkZsVmFrSjNVMVphVjJGSGRGaFNiSEI2V1RCYWIxWnRSbkpqUlhoV1lrWndjbGw2UmxOa1IwcElZa1prYUUwd1NsaFdiVEV3V1Zac1dGTllhRk5YUjJoV1dWUktVMWRXYkZWVGJUbHFUVlphZUZaSGVFOVhSa3B6VTJ4c1lWWlhVa2hXUjNoTFpFWldjVkpzY0U1U2JIQjVWbTF3UW1WSFRuUlVhMlJZWWtad1dGUlVRa3RWVmxsNFYyMUdXbFpzYkRSV01uaHpZVVpLYzJOSE9WcFdSVFZFVmtaYVlWZEhUa1phUjNST1ZsZDNNVlpYTVRCaE1rWkhVMjVLVDFaVWJHRlphMlJUWkd4WmQxZHRSbXRTVkVaYVYydGFTMVJ0UlhoWFZFWlhWa1ZhZGxscVJtdFRSa3BaWWtaYWFXRXdjRmhXUmxaaFpERlNSMkV6YUZoaWJWSlpWV3BHUzFOV1ZuUmxSemxXVFd0d1NsVldhR3RXTVVwelkwWlNWMVpGY0V4VmFrWnJaRlpTZEdKR1RsTmlTRUoyVm14a05GbFdUWGhUYTJScFVteHdhRlZzWkZOVlJteHlWbTVrYkdKSGVGZFdNakV3VmxkS1ZsZHVjRmROVjJnelZtcEtTMWRXUm5KVWJVWlhWakZLVlZadGNFZFpWMDE1VTJ0b1UySkZOWEJXYlhSM1RURmFkR05GVGxkaGVrWkhWRlpXYTFkSFNuTlRia1pXWWtkb1ZGWnRlRk5XTVZwVlVteG9WMkpJUWtwWGExWnJUVVprYzFkdVNtbFNSbHBvVm14YWQyUnNXblJOVlhSVFRXczFSbFpIZUdGVWJVcDBZVWM1V0dFeFduSldha1pLWlVaV2RWUnNWbWhsYkZwWlZrWlNTMkl4YkZkWGJsSnJVakJhY0ZSWGRITk9SbGw1WlVjNVYxSXdjSGxaTUdoSFZtMUdjbU5JV2xkaGExcDZXWHBHVjJOc2NFZGFSazVwVjBaR05sWnRjRXRPUjFGNVVsaGtUbFp0YUZkWmJURTBZVVpXYzFwR1NrNVNiSEI0VlRKME1GWkdXbkpYYm1oWFRXNW9jbFpIZUdGamJVNUhVbXhvVjAwd1NrbFdNVnBoVXpKT2NrMVdaR0ZTYldod1ZqQldTMVpzV2xWUmJHUlVUVmRTZWxkcldtdFdiVVY2Vlc1Q1ZWWnNjR2hWTUZwclkyeGtkR1JHYUZOTlJsa3lWbXhqTVZJeFdsZFhibEpXWWtaS2FGWnFUbTlsYkZwMFpVZDBhMUl4U2tsWlZWcFBWR3hLYzJFemJGZGlSbkJ5V2tSR1RtVkdaRmxpUmxKb1RXeEtlRlpYY0V0aU1XUlhWMjVTVGxack5WaFZiWGhoVFVac05sUnRPVmROUkVaWVdUQm9kMVl3TVhGU2JuQlhZVEZ3VEZadE1VOVNNazVIV2tVMVYwMVZXWHBXTVdSM1VqRktkRlZZWkU5V2JYaFdXV3RrYjFkV1ZuRlViVGxzVm14d1dWUnNhR3RoYXpGWFkwWm9WMVl6YUhKV01HUkxaRVpXYzJKR1pHbFhSMmhaVmtkNFlXUXhTbk5qUlZaU1lsZG9WRlJWYUVOVFJscElaVVprYUUxV2NIbFVWbWhYWVVaT1JtTkdhRlZXTTBKSVZXcEdkMVpzY0VaUFZrNXBWbXh3U1ZZeWRHRmhNVlY0VjI1U1VGWkdjRmhaYTJSU1RVWmtWMWRyTld4V2JGcDVWMnRhVTJGWFJqWldiVGxYVmpOb1ZGWnFSbXRXTVZwMVZHeGthV0pXU2xaV1Z6RTBaREF4UjJOR1dtRlNSVXBXVkZaV2QyVnNWblJqUms1WFRWWnZNbFp0ZUVOV01ERklWV3Q0V21WclduSlpla1pUWXpKT1IxcEZOVTVpVjFFeVZtMHhkMUV4YkZkaVJtaFZZbXMxV1ZsdGVHRldWbXh6WVVjNVYxSnRlSGxXTWpWTFlrWmFjMk5HV2xaTmJrSkVXVlZWZUdOc1pIVmlSbFpYWWtoQ2IxWnJVa2RoTVU1WFVtNU9hRkp1UW5CVmFrcHZUV3hhYzFadFJtcE5WbXcwVjJ0b1MyRXhTWHBSYmtKWFlrWktXRlV4V210WFIxSklVbTFzVGxadGQzcFdSbFp2WWpGYVNGTnNWbWxTYlhoaFZtdFdZVlJHVmxWU2JtUlRWbXMxZWxkcldrOVViRmw0VTFob1YySlVSVEJXVkVwSFZqRk9XV0pIYUZSU01VcFpWMWQ0YjJJeVJrZGpSVlpUWWxoU1dGUldaRk5sVm1SeVYyMDVhRlp0VWtoVk1uaHZWakZLZEZWVVFsaFdiVkpZV1hwR2QxTldUblJoUms1WVVtdHdZVlpzWkhkUk1sRjRWR3hrV0dKSGFFOVZhMXBoVjBaU1dHUklaRmhpUjNoWFZsZHpOVll3TVhKalJuQmFWbFp3ZGxZeU1WZGpiR1J6WVVad1RtSnRhRlZYV0hCSFpERktjazVXWkdGU01uaFlWV3BLYW1WR1duUk5WRkpvVFVSV1NGWnNhRzlWTVdSSVlVZG9WbUpIVWxSV01WcHpaRWRPTmxKdGNGZGlSbTkzVmtaYVlWUXlSa2RUYms1cVVrVkthRlpzWkc5amJGcHpWMnQwYWsxcmNFWldWM2hyVkcxR2MxZHViRmRpV0ZKb1ZUSXhVbVF3TlZkWGJXaFRZbFpLVlZkc1pEQlpWVEZ6V2tab2ExSXpVbFZVVmxaelRsWmFTR1JHWkZkU01IQkpWbGMxUTFZeVJYaFhhM1JoVmpOb2Nsa3llRmRqYlZKSFdrVTFWMVpHV2twV2JYUnJUa2ROZVZKc1pGUmlhelZ4VlRCV1MxbFdXWGRoUlU1WVVteHNORll5TVRCWFJrbDRVMnRzVm1KWWFETldha3BMVTFaR2NtSkdhRmROTVVveVZsaHdSMk14V1hoVWJsWlVZWHBzV0Zsc2FHOVhSbVJZWlVjNWFVMVdTa2hXTVdoclYwZEtTVkZ1VGxkaVJrcFlWakZhZDFKc2NFbFViRnBPWVROQ1MxWldXbTloTVZsNVUydG9WVmRIYUdGYVYzUmhXVlp3UlZGWWFGaFdiSEI2Vm0xNGExVXhXblZSYkhCWFRWZFJNRmxxUmxKa01EVldXa1pvYVdFeGNGWlhWbWgzWXpGYVIySklUbGRpYlZKVlZXMHhNRTB4WkhKVmJFNW9VbXRzTkZZeU5YZFdNREZYVTJ0NFYyRnJjRXhXTVZwSFkyeFdjMk5HWkZOV2JrSk9WakowVjFsV2JGaFViazVxVWxkb1ZGbHJXa3RXUmxweVYyMUdUbUpHY0hwWFZFNXZWREZKZUZKcVZsZFNiV2gyV1ZaYVMyTXhaSE5WYkhCcFZrVmFWVlpxUm1GWlYxSkdUVlprVldKSGFIQlZhazVTWld4YWRFMUlhRTVTTUZwSVZUSjRWMVV5U25SbFJscFhZbGhvVEZacldscGxWMDE2WVVaT1RsWXhTWGhXVkVvMFlqRlplVk5yYkZKaGVrWlpXVlJHWVdOc1ZuRlNhM0JzVW14d01WWkhlR3RoVmtsNFUyNXdXRlpzU2toYVJ6RlhWakZrZFZWdGNGTldNVXBvVm0wd2VFNUdaRmRYYkdoclVucHNXRlpxUWxkT1JtdDNWMjFHV0dKVmNFbFdWelZoVmpGS1JsZHNhRnBOYm1ob1dUSXhUMU5IVmtoaVJrNXBZVEJ3UzFadE1YZFRNRFZJVWxoc1UyRXhjRTlXYlRGdlZqRnNWVk5xVWxkTlYzaDVWMnRqTldKSFNraGxSbVJYVFc1Tk1WWlVTa2RPYkZwellVWm9hRTFZUVhwWFZsWldaVWROZUZSdVRsZGlSMUp3VmpCYVMySXhXbkZUV0doV1lsWmFTRmt3Vm5OV01rcEhWMjVDVjAxR1dreGFSRVpoVjBVeFJWSnNTbWxXYkhCSlZtcEdiMk15UlhoVFdIQldZa1ZLVjFsc2FHOWxiRkp6VjJ4YWJGWXhXa3BXUjNocllWWkplRk5yZEZkV2JWRXdXV3BHYTJSR1RuSmhSMmhVVW01Q2IxWlhjRTlpTWxaellUTm9XR0V6VW5KVmJYUjNUVVpyZDFwSE9XbFNNRlkwV1RCYWQxWXlSbkppTTJSYVZrVndVMXBWV21GWFYwcEhWVzFzVTAxdGFESldiR1IzVXpKSmVGcEZaRmRpYkVwelZXcENZV0l4Vm5STlZrNVlVbXhzTlZSV1ZtdFdhekZGVW14c1YxWXpRa2hXYlRGTFYxZEdSMUZzY0ZkaVNFSnZWbTF3UzFReFRsaFNhMlJoVW1zMWNGWnRkSEpsVmxweVYyMUdXbFpzUmpSVk1XaHpWa2RGZVZWc2JGcGhNbEoyV1RCYWMyTXhaSEprUm1ST1ZqRktXbGRzVm1GaE1XUnpWMWhvV0dKSGFGaFVWbVJ2Wld4c2NsZHJkRmRoZWxaWVdXdGFZV0ZIUlhkaU0zQlhWa1ZLYUZZeU1WZFdhekZYWVVaQ1YySldTbEJYVmxKSFpEQTFWMXBHVmxKaVJuQlFWbTB4TkZkR1dYbGxSM1JvWWtWd1IxUnNXbXRXVmxwelkwUk9WMkV4Y0hwVWJYaExaRVpLZEdSR1RrNVRSVXBLVm1wS01GWnJNVmhTYkdSWVYwZDRiMVZ0Y3pGWFJteHpWV3RhVGxKc2NGWlZiWFJoWWtaS2RGVnNjRnBXVm5CWVZqQmFTbVZYUmtkalJtaFhaV3RaTWxaR1dtRmhNVmw1VTJ0c1ZtSllhRlJXTUZwTFZqRmFSMWR0Um10TmJGcFlWakkxVTJFeFNrWlRiVGxhWVRGYU0xcFhlRlpsVjFaSVQxWmtUbEpGV1hoWFZsWnZVekZaZUZOcldsaGhNMmhoV2xkMFlXTnNjRWRhUlRsVFRXczFTRmRyV210VWJFcEdVMVJDVjJKVVFqUmFSRVpIWkVaYWNtRkdWbWxpUlhCWFYxWlNSMlF5VGtkV2JsSk9WbXMxV1ZWdGVFdFdiRlY1VFVSV1ZXSlZjRWhaTUdodlZtc3hkVkZzVWxwV1ZsWTBWbTF6TVZZeVJrZFhiV3hYVW14d1dsWXhXbXRPUmsxNVZXdGtWMkpzU2xGV2JUVkRWMFpXYzFkdVdteGlSbkF3V2xWa1IxZHNXWGhUYTJSVlZteGFlbGxWV2t0amF6VldUMVprYVZKcmNGbFdWRUpoV1ZaS1YxTnVVbE5pVjJoUFZtMDFRMWRzV2xoTldHUmFWbXhzTlZVeWRHOWhSa2wzVjIxR1YyRXhXak5XUkVaVFZqRmtjMVJzWkZkaE0wSTJWMVJDYTA1R1dYZE5WbHBxVWxkNFdGUlhOVk5oUm14VlVteE9hazFWTlhsV01uaHZZVVV4ZFdGR2JGaFdiVkYzV1RJeFYxSXhaSE5XYkU1cFZsWndWbFpYTVRCa01XUnpZa2hLV0dKVldtOVdha0pYVGtacmQxZHRPVmhTYkd3MldWVmFVMVp0U2xsVWFsSldZV3R3VEZWcVJtdGpNa1pJWWtaT1RsWllRVEJXYlhSaFdWZEplRkpZYUZWaVIxSlhWakJrYjFkR1duSldiVVpYWWtkNGVWWXlOV3RVYkZwelYyeHNXazFHY0ZCV2FrRjRWakpLTmxOc1dsZE5NRXBWVm0wd2VGSXlUbk5hU0U1aFVqQmFXRmxyYUVOVlZtUlZVMnBTYUUxck5YbFVNVnByWVVaS2NrNVZPVlZXZWtaMldrZDRZV1JGTVVsaFJUbFRZbGhvV2xac1dtOWpNVlY1VWxoc1ZtSkhlR0ZaYkdoVFlVWmFWVkpzY0d0TldFSklWa2N4ZDFSc1duVlJhbEpYVm0xT05GVnFSbFprTURGWFlVZDRWRkl6YUZsV1JtUjNVbTFSZUZkdVVtcE5NbWhVVm0xMFlXVkdXblJsU0dSWFRWWnNOVmxWVW1GV01rcFpVV3Q0Vm1WclduSldha1pMWkZaT2RHRkdUbWxUUlVvMlZqRmFVMVF4UlhoV2EyUmhVMFUxV0Zsc1ZtRlhSbEpZWlVWMFdGSnNiRFZVYkZVMVZqQXhjbU5HYkdGV1ZuQlVWako0WVZKck5WWlZiRlpYVWxad2IxZFljRWRrTVU1WFkwVmtWV0Y2VmxoV2ExWldaREZhY1ZOcVFscFdNRlkwVjJ0V2IxWkhTbkpPVmxaYVYwaENlbFpxUm5OV1ZrcDBVbTFvVTJKSVFsZFdWekUwVkRGWmQwMVdhRlppYlhoWldWUkdWazFXV2xWVGEzUlVVakZKTWxWdGVHdFZNREI1WVVac1YxSnNXbWhXTWpGU1pEQXhWMkpHVW1sWFJVcFZWbTF3VDJJeFpGZFhibEpQVjBkU1ZGUldWVEZUUmxsNVRsVmtWMUl3VmpaV1YzaHpWakpHY2xOdGFGWmhhMXA2Vm0xNGEyTXhjRWhoUms1WFVsWndhRlpzV210T1IwMTRXa1ZvVTFkSGFGbFphMlJUVm14YWRHVklaR2hTYlhRMVdUTndWMVl3TVZsUmEyaGFWbGRTZGxsclpFdFNNazVGVTJ4a2FFMVlRbFZXVmxKSFZHMVdSMVZ1VmxWaVIyaFpWV3BLYjFkR1pGZFZhMHBPVmpCc05GbHJXbk5oYkVwMFZXeHNWbUpZYUhwVWJGcDNWbXh3UlZGc2FGTmhNbmQ2Vm0weGQxVXhaSEpOVldScVVteEtXRmxYZEVkT1JsVjNWMnhrYTFadFVucFhhMVV4VlRKS2NsTnVXbGROVmtwTVZHdGFjMWRHVm5KYVJsSnBZa1Z3ZGxaWE1YcE5WMDVIVjFoa1lWSlViRkJXYlhoM1pXeGtWVlJ0ZEdsU2EzQjVXV3RTVjFadFNraGhTRnBYWVRKU1RGa3lNVTlUVmtwelYyczFVMDF0YUVaV2JURjNVakZWZUZwRldrOVdiSEJRVm1wT2IxWkdiSEpoUlU1UFVteHdWbFV5Y0VOVWJFcHpZMFZvVjAxcVZreFdNR1JIWTJ4T2RGSnNaR2xTYmtGNlYxUktORmxXVGtoV2EyUnFVak5vVkZsVVRrTk9SbHB5V2tSU2FFMXJXbGhWTWpWTFlXeEtXR1ZHYUZwaVJrcEVWR3RhWVdOV1NuSmpSM2hUWW10S1MxWnRNVFJoTWtaWFUyNVdVbUp0VWxoV2JuQkdaREZ3UlZOc1RtcE5WMUo1VjJ0YWIyRldXa2hsUmxKWFVteHdjbFpVU2xkak1YQkpVMnhvYVZaSGVIWldSbHBYWXpBMWMxZHNhR3hTTTFKWVZtMTRkMlZzYTNkaFNHUlhWakJXTkZrd2FIZFhhekZ4VW10b1ZtSllUVEZXTUdSSFVqRlNkR0ZGTlU1U1YzUTBWbTB4TUdFd05VZGlSbWhVVjBkb1dWbHRlRXRXVm14eVdrUlNhVTFXV25sV2JGSkhWMFpLZEdWR2JHRlNWMUpJV1ZWYVMyUkhValpUYkZwT1lteEtlVlp0ZEdGVE1WcFlVMnRrYUZKdFVrOVpiWE40VGtaa1YxWnNXbXROYkVZMFZrYzFTMkV4U25SVmJrSlhUVWRTZGxwVldtRlNNV1IwWkVaV2FWWnNjRWxXTW5SaFl6SkdSMU51VGxSaVIzaFhWRlZhWVZSR2NFaGxSMFpZVWpBMVIxcEZaSE5VYkZsNFUydHNXRll6VW1oWmFrcEdaVVpPV1ZwR2FHbFNia0pZVjFkNGIySXlWbk5WYmtwWVlraENjMVpxUmt0VFZuQkdXa2M1YUZacmNERlZWM0JYVmpGSmVtRklXbUZTUlZweVZUQmFTMWRYUmtoalJsSlRWMFZLYjFadE1IaE9SMUY0Vld0a1dGZEhhRmxaVkVwVFkxWnNjbHBHVG14aVIxSjVWMnRqTlZaWFNsWmpSV1JYVFZkb00xWnFTa2RqYkdSMFlVWm9WMkpJUWxSWGJGcGhWakpPYzJORlpHaFNNbmh2VkZSQ1MwMXNXbk5aTTJoUFVtMTRXVlV4YUc5V2JVcElWVzA1Vm1KR1ZYaFdNVnB6WTJ4d1IxUnNhRmRpYTBwSVZqSjBWMkV4V1hoVGJGWlRZbTE0VmxscldtRmtiRnB4VTJ0MFYxWnNjSHBWVjNoM1ZqRmFkVkZyTVZkaVZFWTJWRlphV21WV1RuSmFSMFpUVFc1b1dsWlhjRXRoTURWelYyNUtXR0pIVW1GV2FrWkhUa1pWZVU1Vk9XaGlSWEJZVmpKNFQxZHRTa2hWYmxwWFRVWndhRmt5ZUdGa1JrcHpWR3MxVjJKclJqTldhMXBYVlRGSmVWSllaRTVXYlZKd1ZXdFZNVlpzV25STlZ6bFlVbTE0VjFZeWN6VlZNa3BXVGxWb1dsWldjRmhXYWtaYVpVWk9jMVpzWkdoTlZuQnZWbTB3ZUZWdFZrZGpSV3hWWWxWYVZGUlVRa3RWUmxwMFRWUlNhMDFFVm5wV01qVlRWR3hhUjFOdE9WVldNMUpvVmpCYVZtVlZOVmRhUmxwcFZsaENObGRVUW1GaU1WcFhWMnBhVjJKc2NHRlVWelZ2VmtacmVXVkhkR3RXYkVwNlYydFZNVmRHU2xaalJXeFhUVlp3V0ZkV1pFWmxWa3B5VjJzMVdGSlVWbFpYVjNSclZURmtWMWR1UmxWaVZHeHhXV3RhUzJWV1dYbE5WV1JXVFVSR2VWa3dWbTlXTWtwWllVWm9XbFpXVmpSVmJGcGhZekpPUjFwR1pHeGhNR3QzVm0xNFUxSXhiRmhVV0doWVltczFiMVZzVWxkWFJscHhVbXQwV0Zac2NEQmFWVnBQVlRBeFdGVnJhRnBoTW1oTVZtMHhTMU5HVm5OaFJuQllVMFZLU1ZaR1dtRlpWbVJHVGxaYWExSnRVazlWYTFaaFUyeGFjMXBFUWs5U2JHd3pWRlpXYjFadFJYbGhSbVJhVmpOU2FGUlVSbGRqVms1eVQxWlNVMDFHY0VoV1IzaGhZakZWZUZkc1pHaE5NbmhZV1d4U1EwMHhjRlpXV0doVFRXdHdTRmRyV205WFJrbDZZVVpvV0Zac1NreFpha1pyVWpKS1IxWnNVbWxXUjNoWlZsY3dlRTVIVm5OaVJscFhZWHBzYjFsclZuZGxiRnAwWTBVNVYwMXJjRnBXVm1oclZqSkZlR05IYUZwbGEzQlFWV3BHYTJNeFpISk9WbVJPWWxka05WWnFSbUZoTWxaMFZtdGtXRmRIYUZsWmJYUmhWakZzY2xwR1RsVk5WM2haV2xWa1IxWnNXblJWYkdoWFlsaG9hRmxVUVhoak1XUnpZa1phYVZkR1NubFhWbFpoVXpKTmVGcElUbWhTTUZwWVZGUktiMkl4V2tkYVJGSmFWakExV0ZWdE5WTlZNa3BKVVd4b1ZWWldTbGhXTVZwaFZsWk9WVkpzVms1V2JrSktWbFJLTkdNeVJrZFRiazVVWWxWYVlWWnJWbUZOTVZKVlVteE9hMUl4V2toWk1HUTBWakF4Vm1ORmNGZFdla1V3VjFaYVUyUkdTbGxoUjNCVFlsaG9XVlp0ZEZkamJWWkhWMjVHVTJKSFVuSlZiWE14WlZac2NsZHJkR2hXYTJ3MldWVmFjMWRHV1hwaFNGcGFZV3RhVkZWcVJtRmpNVnB6Vkcxc1UxWkdXbHBXYTFwaFlURlZlVlp1VG1oTk1sSm9WV3RhUzFZeFVsaGtTR1JZVW14V05GbFZZelZXTURGeVkwVnNWMUl6UWxSV2JHUkdaVWRPUjFwSFJsTlNWVmt3Vm0weE5HUXhUa2hVYTJSV1lrVTFUMWxzWkc5WlZscHhVbTEwVDFKc1ZqUlZiR2hyVkRGYVdGVnNaRnBoTVhCb1ZsUkdXbVF4Y0VoUFYzQlhZa1Z3V1ZacVNURmhNVkp6VjI1T2FsSnRlRlpXYlhoTFVrWmFkR016YUZOV2ExcDRWbGQ0WVZSdFNuUmhSRnBYWWxoQ1NGVjZTbE5TTVZwellrZEdVMDFHY0ZWV1YzaGhaREZTUjFwSVRsZGlXRkpVV1d4YVlXVnNhM2RXYlRsb1VtdHdlbFV5ZUZOV01rVjRZMGRvVjAxdWFHaFpNbmhyWXpGd1IxZHJOVmRXTTJRMlZtdGFZVmxYUlhsU2JHUlVZbXMxY1ZWdE1UUlpWbXhWVW14YWJGSnNiRE5XTW5oUFZqQXhXRlZxUmxoaE1YQlFWa2Q0WVdSSFVqWlNiR2hwVW14d1dWWnJVa2RYYlZaWFZHNU9XR0pZUWxSWmJYUkxWMVphV0dORk9WSk5WbkJJVmpJMVUyRnJNSGxoUm14V1lsaG9hRnBYZUZkWFIxWklVbTFvVTAxR1dUQlhWM0JQWkRGWmVGZFljRkpoTW1oWVdWZDBkMVF4Y0ZaWGJVWnJWbXhLZWxadE1YTlZNREZXWTBkR1YySkhVVEJXYWtwU1pVWlNjMXBHYUdsaVJYQlFWbFJDYTJJeFZrZFdia1pTWWtkU1VGWnRlSGRYUm14V1dYcFdWMDFWY0RCV1YzUnpWMnhhVjJOR2FGZGhhMFkwVlRCYVYxWldSbk5hUjJ4WVVqSm9iMVl5ZEZOU01sRjRWR3RhVUZadFVtaFZiVEZUWTBaWmQxcEhkRTVOVm13MFZsZHpOV0V3TVZaaVJGSllZVEZhY2xZd1pFdGpNVTUxVkd4YVRsSXhSWGRXYWtaaFl6RmFWMU51Vm1GU2JIQlVXV3RrTTJWc1duRlRXR2hUVFd0YWVWUldXbTlXYlVaeVYyMUdWVlpXY0ROWk1uaGhZMVpHV1ZwSGVGZE5SbkJMVjFkMFlXRXlSa2hTV0dScVVucHNXRll3YUVOVVJscElUVlprVjAxV1dqRlZNbmh2WVZaWmVXRkdWbGhXTTJob1ZYcEtVbVZHWkhWU2JFcHBWMFpLZDFaR1pEUlpWbVJIVjFoc1QxWlhVbGhWYWtKaFpXeFZlVTFWWkZkTmExcDVWV3hvYjFsV1dYcGhSMFpoVm14VmVGWnRlSGRTTVhCSVlrWmtXRkpWY0V4V2JURTBZVEpXY2s1V1pHRlRSa3BWV1d0a05HSXhWbk5oUnpsWFlrZDRlbGxWWXpWaGJVcEhZMGhvVm1KVVJYZFpWRVpMWTIxT1NXTkdaRmROTURFMFZtMXdSMWR0Vm5OaE0zQmhVbTFTY0ZZd1drdGxSbHBIVjIxR1ZtSldXa2hYYTJoUFlVWktjMU50T1ZWV2VsWjJWbXRhYTFkSFZrZFViWEJPVm01Q05sWnFTVEZWTWtwSFZHdG9WbUY2YkZaV2JURlNUVVp3Vmxkc1pHdFNWRVpYVjJ0a2IxUnNXbGhrTTNCWFVqTm9XRmxVUm10VFJrcFpZVWR3VkZKWVFsbFdWelYzVWpGU1IxWnVVazVXVkd4VVdXeFZNVk5HWkhKYVJ6bFZZbFZ3UjFsclVtRldNa1p5VjIxb1dGWnNjR2hhUlZwaFl6RndSMVp0YkdoTk1FcDJWbXhqZDJWSFNYbFVhMlJYWW10YVZWbHNVbk5pTVZaMFpVaGtUbEp1UWtkV01qRkhWbGRLUjJOSWJGcE5SbHAyVm1wQmVHTldXbkpoUm1SWFVsaENUVlpxUm1GV01rMTVVMnRrV0dKWGFHOVVWbWhEVkd4YWMxVnJUbHBXTUZZMVZrYzFUMWxXVGtaT1YyaFdZbGhvYUZrd1dsZGtSVFZXVTIxNFUySklRbGxXTW5SdllURmtjMWR1VG1sU1JscFhXV3hTVjFSR2JGWldXR1JzVmpCYVNGbFZXbUZoUlRGWFkwYzVXRlpGYnpCV2JURlNaVVp3U1ZOdGRGTk5NRXBaVjFkNFlWTnRVWGhhUm1oclVqQmFWbFJXV2t0bGJGVjVUbFprVm1KVmNIcFpNRnB2VjIxS1IxTnJhRlZXUlZwb1ZXeGFTMk14WkhSbFJtUm9UVEJKTVZacVNqQlpWMFY0V2tWa1ZGZEhhRlZaYTJoRFYxWmFjVlJ0T1ZoU2JWSllWMnRWTldGck1WZGpSRVpXWWxob1VGbFdXbUZXTWs1SFZteGtVMkpJUWpKV1ZsSkhVMjFXUjJORmJGUmlWMmhVVkZSR1MyUnNXbGhOVkZKclRXeGFXRmxVVG10WFIwcFdWMnhvVlZZelVqTldNbmhYVjBVeFdFOVdaRTVoTVhBMVYxUkNWMDVHV1hsVGEyUnFVbGhvV0ZsclduZFRSbXcyVTJ0a1UwMVlRa2xaYTFwVFZURmFXVkZzYUZkaVdFSklWbFJHVG1WV1duVlZiR1JvVFd4S2IxWlhNSGhWTVdSSFlraFNiRkpZVW5CVVZscGhUVVpyZW1ORlpHaFdWRVphVlZkNGMxbFdXbGhWYTJoWFRVZFNURlZxU2t0U1ZsWnpZVWRvVGxaWVFrWldiWEJMVGtaa2RGWnJaRlJpYTFwWVdXdGFkMk5HV1hkWGEzUnNWbXh3ZUZWWE1UQldSVEZ5VGxod1dHRXlhRkJXYlRGTFUxWkdjMkZHV21sU2EzQlpWbGQ0WVdFeFpGaFVhMXBoVW0xU1QxbHJWbmRUYkZweVdraGtXbFpzVmpWVk1uaHpZVVpLZEdGSFJscFdSWEJUV2xkNFUxWXhaSFJTYkU1T1ZqRktObFpyWkRSWlZsSnpWMjVXVW1Gc1dsaFZiWGgzWVVac1ZWTnJaR3BOVlRWNVZqSjRiMkZXU1hoVGJHeFlWbTFTTmxSV1pGTmpNazVIWVVkNFUySnJTbmxXUmxwclZUQXhSMVp1VWs1WFIxSldXV3RhZDFac1duUmpSbVJYVFd0d1NWWkhjRk5XYlVaeVYyeGtZVlpXY0ZCWmVrWjNVMGRPUjFSdGJGZE5iV2hvVm1wR2EwMUdiRmRpUm1oVFlUSlNjRlZ0ZUdGV1ZteHlWbFJHV0ZKc1NsaFdNakZIVkd4YWMyTkZiRlZXYkZweVZtMXplR050VGtkaVJuQlhWbTVDV1ZadGNFZFRNbEpIVlc1R1ZtSklRbTlaVkVKWFRrWmtXV05GWkdoTlYxSlpWVzEwYjFVeVNrWk9WbEpYWWtkb1JGbHFSbUZrUlRGSldrZDRVMVpHV2tsV01uUlhZVEZzVjFScldtcFNiV2hoV1d0a2IxWkdXWGhYYkdScVZtdGFNVmRyWkRSaFZrcHpWMVJHVjFJemFGaFVWVnBhWlZaT2MxZHNhR2xpV0doWFYxZDBZV1F4V2tkWGJrWlVZVEpTY1ZsclpGTk5WbXQzVjI1a2FWSXdWalJaTUdNMVYwZEZlR05IYUdGU1JWcExXbFZhVjJSV1RuSlBWbVJwVm10d01sWnJXbE5STVVwMFZteGtXR0pzU2s5V01HUlRWbFpTVmxWc1pGUldiRnA2V1ZWak5WZHNXbkpPVldSVllrWndlbFl5TVV0WFZsSlpZVVp3VGxadVFsbFhhMVpXWlVaa1JrOVdaR2hTYXpWd1ZqQmtiazFXV25GVGFrSm9ZWHBXV1ZWc2FITldSMFY1Vlc1R1ZrMUhVblpXYWtaell6SkdTRTlWTlU1V00yZzFWakowVjAxR1dYbFRhMmhXWW0xNFlWbFVSbmROTVZweFVtMUdhMVpyV2pGWmExcHZWakpLU1ZGdE9WaFdiRXBJVmtSR1QxSXhUblZUYld4VFRXNW9WVmRYZUd0aU1XUlhWMnhvYkZJelFsQlZha1pIVGtaa2NtRkZkRmRpVlZZMVZsZDRWMWR0U2tkalIyaFdUVVp3Y2xreU1VZFNNWEJIV2taa1RsTkZTa3BXYlhCS1RWWkZlRmR1VWxOaWEzQlpXVlJPYjJGR1ZuSldiVVpvVW14d2VsWXlkR3RoYXpGWlVXdG9WMVl6VFhoV2FrWmhVbXhhV1ZwR1pHbFhSVXBNVmtaYVlWWnRWbGRVYmtwaFVteEtXVlZxUmt0WGJHUllaVVpPYWsxV2NIcFdNalZQVjBkRmVsVnNiRlppV0doWVZGUkdXbVZYVmtoU2JXeFRZVEozZWxacVNqQmpNVnBXVFZaa2FsTkdjRmhXYTFaSFRrWlZlRmRyWkdwV2JWSjZWMnRhYTFVeFdqWmhSRTVYWWxob1ZGVnFSbXRrUmxaWldrVTFWMkpJUW5aV1YzQkxZakZhUjFkdVVtdFRSMUpaVm0weFUxZFdjRlpaZWxab1ZsUkdlbFl5TlhkWGJGcEdUbGh3V21FeGNFdGFWM2hYWkZaT2MxZHRiRmhTYTJ3MlZqSjRhMDVIVFhoWGJrNWhVMFZ3VVZacVNtOVhSbXhaWTBaa1ZGSnNjRlpWYlhoUFZrVXhWMkpFVmxaTmJtaDZWbGN4Um1Wc1ZuTlhiR1JwVmtWYVZWWlhjRWRrTVZweldraFNVMkpIYUZoVVZWcDNVMVphYzFremFHcE5hMXBKVm0wMVQxZEhSbk5UYkdoYVlUSlNVRlJVUm5kV2JGcFZVbXhTVTJFelFqVldNblJoWWpKR1dGSnFXbGRpU0VKWlZtcE9VMkZHY0VWU2JFcHNVbTFTTVZaWE1UUldSa2w0VTJ4V1dGWXpVbWhYVmxWNFVqSk9SbGRzV21oTlJGWjJWbGR3UTJReFdYaGhNMlJYWW1zMVdGUldXbk5PYkZaWVpFYzVWMDFFUmpGV1IzQlRWbTFHY21OR1FsWk5SMUpJVldwS1QxSXhjRWhpUmxKVFZsYzRlRlp0TVRSVk1VVjVVbGhvVkZkSGFGWlpWRVozVlZaYWRFMVdUbWhTYkZwNFZUSndVMVl4U25SbFJscFhVak5TVUZac1pFdFNNazVKWTBab1YxSlVWbmxYVjNSaFV6Sk5lVk5yVmxkaVIxSllWRlJHUzJWV1duUmtSM1JVVFdzMU1GWkhkR3RoVmtwMVVXeHNWazFHV2t4VWJYaGhZMVpHZEZKdGNFNWhlbFYzVmxjeE1GbFdXbGhUYkd4V1lYcHNXRmxzVWxkU1JsbDVaVWRHVTAxWFVucFdSM2hMVkcxRmVGZFljRmRTYkhCWVZtcEdXbVZXVG5WV2JFcHBVakpvVjFadE5YZFdNbEp6WVROc2JGSXdXbkpWYkZKSFZqRlplVTFVVWxkTmEzQklXVEJTWVZkR1duTlhiV2hYWVd0YVlWcFdXazlqYlVwSFUyMW9hVk5GU2xwV2JHUjNWREZWZVZKclpGaFhSM2hQVm0weFUxZEdiRmxqUm1SWVVteHNOVnBWVms5V01ERnlZMFpzV2xaV2NGaFdha1pMWXpGa2RWZHNXbGRTVm5BMlZtMXdSMkV5VFhoalJXaFRZa1pLVlZWc1ZuZFZiRnAwVFVob1QxSXdNVE5VYkZwclZqRmtTR1ZJU2xaaGF6VlVXV3BHYzJOc1duVmFSazVPVm10d05sWnFTWGRPVmxsNFYyNU9hbEp0YUdGVVZWcExWVVpaZVdWSFJsZE5helZKVlcweFIxVXhTbGRqUnpsWFlXdGFjbFZxUmtwbFIwNUdXa2RHVTAxdGFGQldha0pYVW0xV1YxZHVVazVXUmtwdlZGZDRZV1ZXVWxkWGJYUllVbTFTU1ZwVldsZFhiRnBHWTBoYVYxWnNjR2haTW5oaFZsWktjMkZHVG1sWFIyY3lWbTE0YTAxR1VYaFZXR2hVWW1zMVZWbHRNVFJYVm14VlVteGFiRkp0ZUhsV01qRkhZVzFLVms1VmNGcGhNWEIyV1ZWVmVGZFdSbk5XYkdoWFlraENiMVpZY0V0Vk1WbDRVMjVXVldKRk5YQlZha1pMWkRGYWRHUkdaRlJoZWtaSVZqSTFUMVp0UlhsVmJUbFZWbXhhZWxSc1dsWmxWMUpKVkd4a1YwMUlRbHBYVmxaaFZURnNWMWRxV2xOV1JVcG9WV3BPYjJGR1dYZFdXR2hYVm14YWVsZHJWVEZWTVVwV1lUTmtWMkpZUWtoWmFrcE9aVlpPY2xwR1VsaFRSVXBZVjFkNFUyTXhiRmRpU0VwWVlsVmFUMVJXV2xkTk1WbDVUbFYwYUUxRVJubFdNblJ6VmxVeFYyTklTbGRTTTJob1drVmtVMDVzVG5OaFJtUnBVbTVDZGxac1dsTlNNa1Y1VkZob1lWTkdXbFpaYkdoRFZrWlpkMXBIT1ZoV2JIQklWakl4UjJFd01WWk9WV2hhVmtVMWRsWXdaRXRXYkdSMVVteFdWMkpYYUVWV1ZFSmhZVEpPYzFwSVNsQldiVkpQV1d0YWRtUXhXWGxqUlRsclRWWnNOVlV5ZUhOaFJrNUhZMGRvVm1FeFdtaFZla1ozVm14a2RWcEdVbGRpUm5BMlZqSjBhMkl4VW5SVGExcHFVMFp3V0ZscldrdFNSbHAwWXpOb1YwMVlRa2RYYTJSelZrWktXVkZzYkZkaVdGSllWMVprVDFJeFZuTmFSMFpUVW10d2VsWnRNSGhPUmxsNFYyNVNhbVZzV2xsVmJYUjNaV3hyZDJGSVpGaGhla1pJVlRKMFUxWXlTa2RqUjJoYVpXdGFVRmw2Umxkak1rNUhXa1pPVjFadGRETldiVEYzVVRGc1YxZFliRlZpYkVwVVdWUktVMkZHVm5GVGFsSllVbXhhTUZwVmFHdFdSMHBIWTBSQ1lWWldjRkJXYTFWNFZtMU9SVkZzWkdsV1JscFJWbTF3UzFNeVRYaGFTRTVXWWtoQ2IxUlhNVzlTVmxweFVtMUdWMkpXUmpSV01qVkxZVEZLVldKSVFsWmlWRlpFVkd0YVlWWXhhM3BoUms1T1ZqRktTbFpVU2pSaE1XUklVMnRvYkZKdGFHRlphMlJ2VmtacmVXVkhkRmROVjFKNVdrVmtNRlV3TVVkalJXeFhZa2RSTUZwRVJscGxSazV6Vm14a2FFMVdjRmxYVjNodlVURk9SMXBHWkdGU2F6VlVXVmh3UjFkR1duUmxSMFpvVm10d01WVlhlRU5XTWtwVlVXcFNWVlpGUmpSV2FrWnJZekZhYzFWdGFHbFNXRUkwVm10YWEwMUdiRmRVYTJSWFYwZDRVRlp0Y3pGaU1WWjBaRWhrVGxKdVFsZFdNakExVjBkS1ZtTkZiRnBXVjJob1ZteGFZVkpzWkhOaFJuQk9WbTVDVFZkcldtRmtNVWw0WTBWb2FWSnJOVTlXYkdRelpXeGFkR1ZIY0d0TmJGcEpWbFpvYjFadFNuTlRiRkpYVFVkb1JGWlVSbk5XVmxKeVZHeG9WMkpJUWpWV2JURXdUVWRHUjFOdVRtcFNiSEJYV1d4U1IxTkdXbFZSV0doWFlYcFdXbGt3V210VWJVWnlWMWh3VjJKR1NreFZiVEZYWXpGS2RWUnRiRk5pVjJoWlYxZDBWMlF4VGxkYVNFcFdZVEpTYjFSV1ZuTk9SbVJ5WVVVNVYwMXJjRWhWTWpBMVZsWmFSbE5yZUdGV2JIQm9WV3BHWVdNeFVuTlVhelZYVmtaWk1sWXhaREJaVm14WFdrVm9WR0pIZUZkWmJGSnpWMFpzV0dSRmRFNU5WbHA0VlcwMVMyRXdNWEpYYTNCWFVqTm9jbFpIZUdGa1IxSTJVMnhvVjJKR2NESldNVnBoVjIxV1IxcElTbGhpUjJod1ZteGFkMkl4V25SbFIwWnJUVmRTU0ZsclVtRlZNa3AwVld4U1ZWWXpVbWhWTVZwelkyeHdTVlJzWkU1aE1Wa3lWbFpqZUdJeFdYbFRiR3hvVTBWYWFGWnNXbFpsUmxaeFUydDBVMDFYVW5sVWJGcHJWakF4Vm1OR2JGZE5WMDQwV2xkemVGZEdUbGxoUm1ScFlURndWMWRYZEZaTlZtUlhWbTVTYkZKWVVsaFVWbHAzVjFad1JscEVRbGhTYTNCNVdUQlNRMWxXU2xkVGJFSlhZV3R3VEZac1drdFhWbkJIV2tkb2FFMHdTa3BXYTJONFRrWk5lVlJzWkZSaWF6Vm9WVzB4VTJNeGJISlhibVJyWWtad01GUldhR3RXUlRGV1RWUlNXR0V4Y0haV1ZFcEdaVmRHUjFWc2NHbFNiSEJ2Vm1wQ1lXUXhaRWhWYTJoVFlrWktXRmxyYUVOWGJHUlZVV3hrVGxKc1ZqTlVWbHBoWVZaS1IxTnNhRlZXTTBKWVZtdGFjMVl4WkhKa1IzQm9aV3hhV0ZaRVJtRmhNa1pYVTFoc2FGSldXbGhVVmxwM1lVWmtWMXBHVGxSU2JIQjVXVlZrZDFVd01IbGhSbFpYWWxoU2FGZFdXazlXTVdSMVZHeG9hVlpIZUhoV1JscGhaREZrUjFwSVNsZGlWR3h2VlcxMGQyVnNhM2RhUldSWVlsVndTVmxWVlRWWlZscFhZMGh3VjJKWWFISlpla1ozVTBkU1IxUnNaRk5XYmtKaFZtMHhNR0V3TlVoVFdHaFhWMGQ0VlZsclpEUmhSbEpWVTJ4T1dGWnRlRlpWYlRGSFYwWktkVkZyV2xaTmJsRjNWbFJCZUZkR1ZuRlNiR1JUWld0WmVsWnNVa2RUTVZwMFZHdG9VRlp0VWxoVVZFcHZZakZrY2xWcmRGVk5hekUwVjJ0b1YxVXlTa1pqUm14V1lXdHdkbHBWV210WFIxSklVbTEwVG1KR2NFbFdha28wWWpKS1IxTlljRlppUjJoV1ZtcE9VMDB4V1hoWGJrNVhZa1phZVZwRldtdFViVVY2VVd0c1YxWkZiM2RVYTFwaFpFWmFkVk50Y0ZOaE1IQm9Wa1pqTVZSdFZrZFhia1pUWW0xU1ZGUldaRk5OUm14eVYyeE9WazFXY0ZwVlZtaHpWakpLV1ZWdGFGaFdiVkpMV2xWYVMyUldWbk5hUjJ4b1pXeGFZVll4WTNoT1JrMTRWVmhvV0dKcmNGbFpWRTVUVjFaYWRFMVVVbXhpUm13MVdrVmtNRlpWTVZaalNIQmFZVEZLV0ZkV1dtRldNazVKVTJ4a2FWZEZOREJYVkVsNFZERktkRkpyWkdwU1ZGWlVXV3RhVjA1R1duUk5XR1JVVFZVeE5GWXllR3RYUjBweVkwWmtXbUV4Y0doWk1GcGFaREZ3U0U5WGJFNVdNVW8xVm0weE5GbFhTa2RUYmtwUFZtMTRWMWxzYUZOamJGcHpXa1ZrVDJKR2NIcFpWVnAzWVVVeGRHRkZVbGRTYkhCb1YxWmtUMk14Y0VsVmJFNXBVMFZLV1ZaR1ZtRlhhekZYVjJ4b1RsSkZXbFpVVmxwM1UxWlZlV1JIT1dsU2EzQjVWR3hrUjFkdFJYaGpSMmhhVmxad2NsWnFSbXRrUmtwMFkwZHNVMkpyUmpOV2JHTjRUa1paZUZaWWJGUmhNbmhUV1ZkNFlWZEdiRmhrU0U1UFVteGFlRlV5ZEd0aGF6RllWV3BHVmsxcVJqTldhMXBLWlcxR1NFOVdaRmROTW1oNVZteFNRbVF5VmtoVGEyUmhVbTFvYjFSVVFrdGxiRnBZVFZod1RsWXhXa2hXTVdoellrWkplbFZzV2xwaVJsb3pXbGQ0Vm1WVk1VVldiR1JPVWtWYVdWZFVRbTlUTVZwMFVtNUtXR0pWV21oV2JHUlRWVVpXZEdWSGRHdFNhM0I2VmtjeGMxVXhaRVpUV0hCWFlsUkNORlJWWkVaa01EVldXa2RHVTJKV1NtOVdWekI0VlRGWmVHSkdWbFJpUlRWeFdXdGFTMWRXY0VaYVJXUlhVbXR3ZWxrd1VrTlhhekZJVld0b1YySllUalJaTWpGUFVqRndSMXBGTldoaVJuQktWbTB4TkZsV2JGaFZhMmhUWVRGd1YxbHJXbmRVTVd4MFRWYzVXRkp0VW5wV01qRXdWakF4Vm1KRVVscE5SbHAyV1ZWYVMyUkdWblJQVmxaWFVsVndTVlpIZEdGWlYwMTRXa2hTYTFKVWJGUlVWVkpHVFVaWmVXUkdaR2hOVjFKSVYydFdjMVZ0U2toVmJVWmFZVEpTVkZwSGVGcGtNV1IxVkcxd1RsWnNjRFZXTW5SaFdWWlNjMXBGV2xSaVIyaFlXVmQwYzA1R1VsWmFSV1JyVW1zMWVsWXllRzloUlRGMVlVZG9WMUpzV21oYVJFWlhVakZrZFZKc1NsaFNNbWhaVjFkNFZrMVdUa2RYV0d4c1VqTlNiMVZzVWtkWGJGWllUVVJXVjAxRVJsaFpNR2hMVmpGYU5sSnNhRmRoYTFweVdrWmFZV014V25SaVJrNU9WbGhDYUZadGVHdGtNVkY1VTFob1YySkhVbGxaYlhoTFl6RldkV05JVGxkTlZrcFlWMnRhVDFaR1NuUmxTR3hhVmxaVk1WWnFRWGhqYlU1RlVXeGtWMDB5YURaV2JYQkxVekZhVjFkdVNsWmlSMUp2V1ZSR2QyVldXbkZTYlhSVlRWVnNORmt3Vm10WlZrcFZWbXhvV21KWVVrdFVWM2hhWlVaV2NsUnNjRmROUjNjd1ZtcEpNVk14VW5OYVJXUllZa2RTWVZsc2FHOU5NVmwzVjI1T2FtSklRa2hXUjNoWFZUSktTR1I2UWxkTmJsSllXVlJHWVZJeFRsbGFSbWhvVFcxb2FGWkdWbUZXYlZaSFlrWmtZVkpZVWxsVmFrSmhVbXhhZEdWSGRGVmlSbXcxVjJwT2QxWXhXWHBSYTNoWFZucEdXRlZxUmxOak1rcElZVVpPYVZORlNqTldNVnBUVkRGRmVGWnNaRmhpYkVwUFZUQmtiMVl4VWxkYVJrNVVVbTE0ZVZsVldrOWhSVEZXWTBab1drMUhhRkJXYWtwTFYxZEdSVlJzVmxkV2JrSlZWbTF3UjFZeVRuTlZibEpvVW1zMVdGVnNXbmRUUmxwMFRVaG9UbEl3YkRSV01XaHpWa2RGZVdGSE9WWk5SMmhFVmpCYWMxWldUbk5VYkU1T1YwVktXVlpxU2pSaE1rWnlUVlprYWxOSVFtRlVWV1JUWkd4YVNHVkhkRk5pUlhCNFZqSjRhMVJzV25KalJXeFhUVlp3YUZZeU1WZFdNVnAxVTIxb1UySkdjSFpYVjNSdlVURmFWMXBHYUd0U00xSndWRlphZDFOR2JISmhSVGxvVW10dk1sbHJXa05XTWtwWllVUk9ZVlpXY0ZkYVZXUkhVMFU1VjFkck5WTlNWbTh4Vm0xd1MwMUhTWGhYYmtwT1YwVmFXRmxyVmt0WlZscHhWRzA1VlZKdVFrZFhhMVpyVlRBeGNsZHJhRmRpV0doeVdXdGtTMUl5U1hwaVJtUnBWMGRvV1ZZeFdtRmpNVmw0V2toT1lWSnNXbkJaVkU1RFpWWmFXRTFVVWxSTlZuQklXV3RvUzFkSFNuTmpTRTVXWWxSR1ZGWXhXbmRTYkhCR1drZG9WMVpGV2pWV2Frb3dZVEZhVjFkdVRtcFRTRUpZVm01d1IxTkdVblJsUlhScVRXdHdTRmRyWkhOWFJrbDVXa1JhVjAxV2NGaFhWbHBhWkRBMVdWUnNVbWxoZWxaNFZsZHdUMkl4WkVkaVNFcFhZbTFTVUZadGVITk9WbkJHV2tSQ2FGWlVSbGhXYlhCWFZtc3hkV0ZJU2xkaE1sSk1XWHBLVDFJeVJrZFhiV3hZVWpKa05sWXlkR3RPUmxsNFYyeGtVMkpIZUc5VmFrNURWREZhY1ZKcmNHeFNiSEJXVlRKd1UxZHNXWGRYYTJSVlZtMW9VRlpyWkV0VFIxWkhZVVphYVZaRldsVldSekUwWkRGYWMxZHNWbE5pUlRWUFZqQldTMU14V2xWVFdHaHBUVlpXTkZZeWRHOWlSa3AxVVd4b1YyRnJOVVJWYTFwM1VsWktjazlXWkU1aE0wSkpWbXBLTkdReVNraFRhMlJxVW0xNFdGbHNVa1pOUm5CRlVtMTBVMDFXY0ZwWmEyUTBWVEpXZEdWR2JGZFNiRnBVVldwR2ExSXlSWHBhUjBaVFpXMTRXVlpHVmxOU01VNUhWMjVTYWxKck5WaFVWVkpIVjFaYVdHVkZUbGRpVlhCYVZrWm9iMVl5Um5KWGJGSmFaV3RhTTFWcVJsTmpNWEJJWWtkb1RsTkZTazlXYlRCM1pESlJlVlpyYUZaWFIyaFZWakJrTkZaV1dYZGFSRkpYVW14c00xZHJZelZoUmtwelYyNXdXR0V5VFRGV2FrWkxZekpLUlZSc2FHaE5WWEJWVm0xd1FtVkdaRWhXYTJ4cFVtMW9iMVJYYzNkbFJscHhVMnBTV2xZeFNrbFdiWFJyVjBkS1IyTklRbGRoTVZwb1ZURmFZV05zY0VsalIzaFRZbFpLV1ZaWE1ERlVNa1pIVTI1U1ZtRjZiR0ZXYWs1dllVWndWMWR0Um10U01EVkhXa1ZhVTFSc1dsaGtla1pYWVRKUmQxbFVTa2RqTVU1MVZteEthVkl5YUZsWFYzaFRWakZLUjJKSVJsTmlWVnB4V1d0b1ExSnNXbGhsU0dSWFRVUkdWMWt3V25OV01WbzJVVmhvVjFKRmNFaFdha1pQWkZaV2RHRkdUbWxXTW1oWlZqRmtNRmxXYkZaTlNHaFlWMGRvV1Zsc1ZtRmpWbEpYVjIxR2JGWnRVbmxXTWpBMVlVWmFjMk5JY0ZwTlJscDZWbXBCZUdSV1ZuVlhiR1JvWVRGd2IxWnFRbUZVTWsxNVUydGtWR0pYZUZSWlZFNURZakZaZUZwRVFtaE5WbFkxVmxjMVQxZEdaRWhoUm14YVlrWmFhRll4V2xkalZrWlZVbXhPVGxacldUQldha28wWVRKR1IxZHVUbXBUUjNoWVZGWmFTMUpHV1hkWGJVWlRZa1UxTUZsVldtOVdNa3BKVVc1c1YxWkZTbWhWZWtaclYwWlNjbHBHYUdsV00yaDJWa1phYjFFeFpFZFhibEpPVTBkU2MxVnRlRmRPUmxsNVpFZDBhR0pGY0RCWlZXaFBWbTFHY2xOdGFGZGlSbkJZV1hwR1YyTnNjRWRoUm1ScFVsWnJkMVp0Y0V0T1IwVjVVbXRrV0dKcmNIRlZhMVpoVmpGYWRXTkZaRlJTYkhCNFZXMHhSMkV4U25OWGJtaFhVak5vY2xsVlpFWmxSMDVJWVVab2FWSnVRbTlXYTFKTFZESlNSMU51U21GU2JXaHdWV3BHUzFaV1duUmxSemxTVFZkU2VsWXhhRzlYUjBwWlZXczVWbUZyV2toVWExcGhWakpHU0U5WGFHbFNXRUYzVm14a05HTXhaSFJUYTJSWVlsZG9ZVlJYTlc5aFJuQkdXa1prVTJKV1NrbGFWV1J6VlRBeFZtSjZSbGRoYTI5M1dXcEdVbVZHWkhWVGF6VlhWbXh3VlZkWGRHdFZNV3hYVld4YVdHSnRVazlVVmxwM1pVWldWMkZIT1ZkTlJFWjVWR3hXYjFZeFdYcGhSMmhhWVRKU1IxcFZaRTlTTWtaSFlVZHNVMkpJUW5aV2FrWmhXVmRGZUZwRlpGUmlhM0J2VldwS05GWkdiSEpXYm1SWFZteHdlRlZYZUd0V1JURllaVVpvVjAxWGFIWldNR1JMVW1zMVYxZHNWbGRpUm5CWlZrZDBZVmxXV1hsU2EyaFFWbTFvVkZSVmFFTk9iRnBWVTJwU1VrMVdiRFZWTW5SclZqRmtTR0ZHYUZWV1ZuQXpWbXRhWVdOV1NuUmtSM1JYWWtWd05WWkVSbUZoTWtaWFUyeHNVbFpGY0ZoWlYzUjJaREZhVlZKcldteFNiVkphVjJ0Vk1WZEdTbGxSYm1oWFZucENORlpVUm5OV01WWnpWMnhvYVZaV2NIbFhWM1JoWXpBMVYySkVXbFZpVkd4WFZGVlNSMlZXVW5OV2JtUlhZWHBHTVZsVmFFdFhiRnBZVld0a1lWSkZXbkpXYkZwSFl6SkdTR0ZGTlZoU1ZYQXlWbTB3ZUdReFRYaFZibEpYWWtkU1ZWbHRkSGRoUmxaeFVXMUdWMUpzU2xsVWJHTTFWakZhZEZWc2JGVldiRXBFVm10VmVGWXhUblZqUm1ST1lXeGFWVlpyWkRSaE1VNUhWbTVPVm1KR1dsaFVWRVpMVjFaYVNHVkhSbHBXYXpWSFZHeGFhMVpYU2tkalJUbGFWa1ZhWVZSV1dtRmpNWEJGVlcxd1RsWXhTWGRXVjNodll6RmFkRk5yWkZSaVIyaFhXVlJHWVdGR1duSlhiSEJyVFZad1dsbFZXbTlWTVZwSVpVWnNWMkpIVGpSWmVrWldaVlpPZFZOc1RtaGhlbFpaVjFaU1IyUXhaRWRpU0VaVVlURndjMVp0Y3pGbFZtUnlWMnhPYUZZd1ZqWlZWelZ2VmpGWmVsVnNhRlpsYTFweVZXcEtTMU5XVW5OWGJXeFRUVlZ3V1Zac1kzaE9SMUYzVFZWa1ZtSkhVbGhaVjNSTFlqRnNjMVpzY0U1aVJuQXdXbFZqTlZkR1NYZFdhbEphVFVaS1VGWnFRWGhTTWs1SFVXeGFhVmRIYUZGWFdIQkxVekZKZUdORmFHbFNiV2hVV1ZST1EwMXNXblJqUldSYVZqQldORlpzYUc5V1IwcHlZMFpDVjJKVVJsUldNVnB6WTJ4a2RGSnRjRk5pUm5BMlZteGtOR0V4WkVkWGJsSldZa2Q0YUZWc1pFNU5WbHBZWXpOb1UxWnNjREZaTUZwclZHMUdjMWRyYkZkaVdGSm9XVlJHVDFJeFduVlViRXBwVWpGS2RsZFdVa05rTWtsNFdraE9XR0pWV2xkVVZscHpUa1paZVU1Vk9WcFdhM0F3Vmxkek5WZHNXa1pYYlVaVlZteHdjbFpxUm1Ga1JrcDBZVVUxVjAxVmJETldiRkpMVFVkRmVGZHJhRlJoTW1odlZXMHhiMWRHYkhKWGJtUk9UVmQ0VjFZeU1VZGhhekZZVlc1c1ZVMVhVak5aVmxwaFkyMU9SbUpHWkdoTmJFa3lWa1phYTFJeFRrZFhibFpWWWtkb2IxUlVRa3RYVm1SWVpVYzVhVTFyTlhwV1Z6VkxXVlpLY21OSVRsZGlXRkl6V2xaYVdtVlhUalpTYkdST1lUTkNXVlpVU1RGaU1WbDRWMWh3YUZKc1NsZFpWM1JoWTJ4V2NWTnJkRk5OVm5CNlZsY3hjMVV4WkVaVGJFWlhZa2RPTkZSclpGSmxWbHB5V2taa1dGSXphSGhYYkdRd1dWZE9SMVp1VW10VFIxSlBWVzE0ZDFkV2EzZFdiWFJYVFVSR1dGbHJVbUZYYkZwWFkwVlNWMDF1YUdoWmVrcFBVbTFXUjFwRk5WZGlhMHBLVmpGb2QxSXhTWGxVV0docVVsZG9jRlZ0TVZOV1JscDBaVVp3YkdKR2NIaFZNbkJEVm1zeFZtSkVWbFppUjJoMlZqQmFhMU5IUmtoaFJscE9VbTVDYjFadGNFZGpNV1JZVkd0a1lWSnRhRmhaYTFwYVpXeGFkRTFVUWs1U2JIQjZWVEkxVDJGc1NrWlRiVVpWVmxad2FGWlZXbHBsVjFaSFkwZDRVMkpXU2paWFZsWmhZVEZaZDAxSWJHaFRSM2hZV1ZkMFMyTnNWalpTYlVacVRWaENTbFpITVhOVk1rcEpVVzVhV0Zac1NrUmFSekZYWXpGa2MxWnNUbWxXVm5Cb1ZtMHdlRlV4VGxkWGJsSnJVbnBzYjFSV1ZuZE5SbXhXWVVWT1YwMXJjRWxaVlZaVFZtc3hkV0ZJU2xkaGExcG9Xa1ZhUzJNeFpISk9WbVJwVjBkT05GWnRlR3RPUjBsNVUxaHNVMkpyTlZaWlZFbzBWVEZzY2xwSE9WcFdiWGhXVlcwMWExUnJNVmRqUldSWFRXcFdURmxyV21GV1ZrcHpZVVprVTAweWFGRldhMlEwWVRGS2MxUnVTbXBTYldoWVZGUkdTMkl4WkZkVmEyUm9UVlZzTkZaSE5VOVhSMHBaVVd4U1YyRXhXbWhXTVZwclZqRndSVkZzY0ZkaVNFSkpWbTB4TkZZeFZYbFRia3BQVm0xNFYxbHNhRk5OTVZsNVpVaE9WMkpIVWpCVU1WcHZWVEpGZVdSNlJsaFdiRnBvVjFaYWExSXhaRmxqUmxwcFZqSm9iMVpYZEZka01WWkhWMjVHVTJKVlduSldiWGhMVFVaV2RHVkZPVlpOYTFZMlZWY3hSMVl5U2toVWFsSlZZVEpTVTFwV1dtRmpiSEJIWVVkb1RtSlhhRFZXYkdRMFZUSk5lRnBGWkZoaWJFcHlWVEJrVTJNeGJISmFSRUpPVFZkNFYxZFljRmRXTURGeVkwWmtXazFHY0doV2JURkxWMVpXZFZkc1pFNWliV2hvVjJ4a05GVXlUbGRXYms1aFVqSm9iMVJXYUVOVmJGbDVaRWRHYUUxV1JqUlZNV2h2WVd4S1dHRklRbFppVkVaVVZtdGFZV1JGTlZaVWJGSk9WbTVCZDFaR1dsTlZNVnB5VFZaYVRsWkdTbGhWYlRGdlpXeGFjMXBGZEdwaGVsWllWako0ZDJGV1pFWk5WRkpZVmtWS2FGWnFTbE5TYXpGWFdrWldhVmRGU2xWWFYzUnJUVEpXYzFkWWJHdFNNMEpRVm1wQ1lWWXhVbGRYYlRsWFlsVndNRnBWV205V01rWnlUbFpTV2sxdWFHaFpla1poVjFkR1IxcEhiRmRYUlVwSVZtMTRhMDVIU1hsU2ExcE9WbTE0VTFsWGVIZFhWbHAwWlVoa2FGSnNXVEpWYlRGSFZqQXhXRlZxUmxkU2VrWjZWbFJLUzFOV1JuVmFSbVJYWld0V00xZHJVa2RoTVZsNFdraFdWV0pIYUhCV2JGcDNZVVphZEUxSWFGWk5WV3cwVmxkNGExZEhTa2hWYkdSYVlrWmFNMVV5ZUZkWFIxWklUMVprVjJKSVFqWlhWRUpUVkRGYVdGTnNiR2hTTW1ob1ZXeGFWMDVHVm5OWGEzUnFUVmRTZVZSc1pHOVVhekZHWTBWMFYySllhRlJWYWtwS1pWWktXV0ZIUmxOV01taFdWMVpTUzJJeFdYaGlTRXBZWW0xU1dWVnRNVFJYVm10NlkwVmtWMDFWY0hwVk1uaGhWbTFLV1dGSVNscFdNMmhvV1RJeFQxTlhUa2RhUlRWb1lURldNMVp0TVhkUmJWWkhVMnhrVjJKSGVIQlZiVEZUVjBad1dHUkdXbXROVjFKWVZsZDBNRlV3TVZkaVJGSllZVEpvVUZsV1drdGpiVTVKVVd4a2FWSnVRWHBXYWtaaFlURmtTRlZyYUd0U2JGcFBWV3RhWVZOV1pGaGtSemxUVFZaV05WVXllR0ZYUjBweVYyeGFWMkpVUmxSV2ExcDNWakZrYzJOSGVGZE5WbkJLVmtSR2EySXhXWGxTV0d4clpXdGFXVlp0ZUdGaFJtdzJVbTEwVTAxWFVqRldWM2hoVjBaSmVGTnNjRmRpVkVJMFZsUkdUMUl4V25WU2JGSm9UVmhDZWxkWGVGZGtNVTVYWVROa1lWSkdTbTlWYkZKSFYyeFdXRTFWWkZkTmEzQkpWbGR3VDFac1dYcFVhbEpYWVd0YVVGWXhaRWRTTVdSMFlrZG9iR0pHY0doV2FrWnJUa2RKZUZaWWFHRlNWMUpYV1d0a2IyTnNWWGRhUms1cVRWWndNRnBWV210VU1WcDFVV3hrV2xaWFVYZFdha0Y0VWxaS2RXSkdjRTVTYmtGNlZtcEtORmxXWkVoU2ExcG9VbTFvV0ZscmFFTmlNVnAwWTBWa1dsWXdOVmhXYlRWUFYwZEtXR0ZIT1ZWV2JXaEVWbTE0WVdSSFRrWmFSMmhPVmxkM01GWlVSbTlpTWtaelUyeG9hRk5GU2xkWlYzUjJUVVphY2xkc2NHdE5WbkI1V2tWYWQxWXlTa2xSYWxKWFZucENORlJWV2xOak1VNVpXa1prYUdGNlZsZFhWM1JoV1ZkU2MxZHVTbGhpV0ZKVlZXcENZVk5HYkZaWGJtUm9WbTFTUjFSV1VsTldNa1p5VTIxb1dGWnRVbEJaZWtaclpGWldjMVJ0YkZOTmJXaFdWakZrTUZZeVVYaGFSbVJZWW10YVZWWnJWbUZpTVZKWFYydDBiR0pHVmpWVWJGcHJWbTFLVm1ORmJGZFdNMmg2VmpKNFlWSnNaSFJoUm5CT1ltMW9iMWRVUm1GVE1rNTBWV3RvYWxJeWVGaFdhMXBoVkVaWmVGVnJUbHBXTUZZMFZsYzFVMVV5U25KT1ZteGFWak5vTTFZd1duTmpNa1pHVkd4V1UySkdhM2xXVnpCNFRVWlpkMDFXV21wU1JWcFlWV3BPYjJGR2JGZFhhM0JzVW1zMWVsbHJXbXRXTURCNVlVUktWMVpzU2toV1ZFWmFaVVp3U1ZSc1pHbFNWRlozVm0xNFlXUXhXbGRYYTJSaFUwaENUMVpxUm1GbGJHeFZWRzEwVjAxcmNGcFdWM2h6Vm0xR2NsTnRSbFZXTTJob1drVlZNVlpzVW5OaFIyeFhWMFZLUzFadGVHcE5WbXhYVjFob1ZGZElRbTlWYWtwdllVWldjMWRzWkU5U2JHdzBWakkxYTFVd01WZFRibXhWWWtad2NsWkhjM2hrUjBaSVVteGthVlpGV1hwV1dIQkNUVlpPUjFOc2JHaFNiV2h2VkZjeGIxWnNaRmhOVkVKclRWZFNXRmxyYUV0WlZrcEhVMjFHVjJKVVJUQldiWGhXWlZkV1JrOVdaRTVXV0VJMlYxZDBVMVF4V1hkTldFWlhZa1ZLWVZadWNFZFVSbHAwWlVkMGFtSklRa2hYYTFwUFZHc3hkRm96YkZkaVZFWXpWWHBHVG1WR1VuTmFSazVwWVhwV2VGWlhNSGhpTVdSSFZtNU9WMkp0VWxsV2JURlRWMFphV0dSSGRGZE5hM0JZVlcxd1QxWldXbk5qU0hCWFlUSlNTRlJ0ZUdGak1rWkhWMjFzV0ZKcmJEWldiWEJIV1Zac1dGVnJXazlXYlhob1ZXMHhVMVF4V25OVmJHUlVWbXh3ZUZVeFVrZFZNREZYWTBWc1ZtSkhhRE5XYlRGTFUwZFdSMkZHY0ZkTk1VcE5WMVpXWVZadFVYaGFTRkpUWWtkb1ZGUldXbmRUTVZsNVpFZEdhRTFXU25wV01uaHpWVzFLU0ZWc2FGcGlSa3BIV2tSR1lXTldTbk5qUjNoWFlYcFdObGRYZEdGWlYwWlhWMWhzYUZKdVFsaFpiRkpEVGtaYVZWSnRSbE5OVm5CYVYydGFiMkZXV2xkalNHaFlWak5TZGxWVVJrOVdNVnAxVlcxNFUxWkhlSFpXYlhCRFZqQXdlR0V6WkZoaWJWSllWRlZTUjFkR2EzZGhSMFphVm10d1IxWXlNVWRaVmxwWFkwUk9WbUZyV2pOVmFrcEhVMGRLU0dGSGVHbFNia0Y1Vm0weE5HRXdNVWRYV0doVlYwZG9jRlZ0TVZOWFZteDBaVVYwYWsxV1ZqTldiRkpIVm14S2MyTkVRbUZXVjFKSVdXdGtTMU5IVmtkYVJuQlhWbXhWZUZadGNFSmxSMDUwVkd0a1lWSnVRazlWYlhoM1pWWmFkR1ZIZEZSTlZUVklWbTAxUzJGR1NuUlZhemxhWWxSR2RsbHFSbUZYUlRGVlZXMW9UbUpGY0VwV1Z6RXdZVEpHYzFOdVVsWmlSMmhoV1d4b1UxUkdjRWhsUm5Cc1VteGFlVmRyV25kV01rWTJVbFJHVjJFeGNIWlpha1poVjBaT2RWUnNVbWxoTTBKWVYxZDBZVk14WkVkaVNFWlRZa1UxV0ZSWGRHRlNNVnBJWlVaT1YwMXJjRXBWVjNCWFZqSktTRlZZWkZwV1JWcHlXWHBHYTFkV2NFZGFSMmhwVW01Q1dWWXhaRFJpTWtsNVZHNU9XR0pyY0doVmJHaFRZMVpTVjFwR1RteGlSbkJKV2xWb2EyRkdTbFZTYm5CV1RXNUNURlpxU2tkamJFNTBZVVp3YkdFeGNIbFdWRUpoVmpKT2RGTnJaR2hTTW5oWlZXMTBkMVZXV25STlNHUk9WbXRXTkZVeGFHOVhSMHBJWVVVNVZrMUhVblpXYTFwVFYwZFNTRkp0ZUZkaVJYQlpWbXBKTVZReFduUlRiRnBYWVd4YVdGWnVjRWRUUmxweFUydDBWRkpzV25wV1J6RkhWVEZLVjJORVdsaFdSVzh3V2tSR1MyTXhjRWxWYlhSVFZrWmFkbGRzWkRSWlZrNXpWMWhvV0dKSFVtRldha0pYVGxaV2RHVkhkRnBXYTNCWVdUQmFWMWR0UlhoWGJXaFhUVlp3YUZreFdsTmpiRkp6Vld4T2FWTkZTa2hXYkdONFRVZFJlVk5yWkZSaWJGcFRXVlJPUTFkR2JITmhSemxvVW0xNFdGWXlNVEJXUmtsM1YydG9WMkpZYUhKWlZXUkdaREpPU0U5V1pGaFRSVXBOVm0xd1IxTnRWa2hVYTFwaFVqSm9WRlJVU205V1ZscEhWbTFHYTAxcldraFdNalZUVkd4a1NWRnJPVmRpV0UxNFZUQmFXbVZWTlZkVWJXeFRZVEk0ZVZkWGRHcE9WbVIwVTJ0a2FsSXlhR2hXYlhoM1dWWndWMXBHWkZSU01VcElWMnRhYTJGV1RrWlRWRXBYVFZaS1JGWlVSbEpsUm1SeldrWm9hV0Y2Vm5oV1Z6QjRZakZrUjFWc1dtRlNhelZZVlcxNFlXVkdWblJPVjNSV1RVUkdXbFZYZEd0V1YwcElWVzVhVjFJelRqUlZiVEZQVW0xU1IxcEhhR2hOV0VKV1ZteGFVMUl5VFhoWFdHaFlZa2Q0YjFWdE1XOVhWbFp4VTIwNVYySkhVbGhXVjNScllUQXhjazVXYUZkaVZGWlVXVmN4VjJOc1pIUlBWbHBwVjBkbmVsZHNaRFJYYlZaV1RsWm9hMUp0VW5CVmJHaENaREZrY2xac1RsZE5WM2hZVmpKNGIxWnNaRWhWYlVaWFlURmFhRlY2Um5kV2JHUjBaRWR3YVZaV2NFbFdNblJoVkRGU2NrMVlVbWhTUmxwWVZGWmFkMkZHYkZWU2EzUnJVbXhhV2xscldsZGhSVEZ6VTIwNVYxWjZRalJXVkVwS1pVZEtSMVpzVG1saVZrcDNWa1phWVdReVZuTlhiR2hyVWpOU1YxUlhkSGRYUmxsNVpVYzVWMDFyY0ZwWlZXaDNWMnhhVjJORmVHRlNWbkJZV1hwS1MxSXhaSFJoUjJoT1RVVnNOVlp0TVhkVE1EVklVbGhvWVZKV2NFOVdiVEUwWTFaV2MxVnNaRmhTYlhoNVYydFNUMVJzU25SVmJHeGhVbGROTVZac1ZYaFdNazVGVVd4YVRtRnNXazFXYTFKSFlURktjMXBJVGxoaVIxSndWbXRXWVZaR1drZFdiVVpyVFZac05GZHJhRk5oTVVsNlVXNUNWbUZyV2t4VWJGcGhVbFpLZEZKdGFFNVdhMjkzVmxkNGIyUXhWblJTV0d4c1VtMW9ZVlpxVGxOTmJGSldWMjVPVDJKRmNERldSM2hyVkd4YVZWWnFXbGhXYkZwb1YxWmFhMUl4VGxsaFJsSnBVak5vV2xadGNFOWlNVnBIVm01R1UySkZOVlJVVm1SVFRWWmFXR042UmxkTlZuQkpXbFZhVjFkR1dYcFZibHBXVmtWYVVGVnFTa1psYkhCSVVteFNVMVpHV2pKV2JURjNVVEZaZDAxSWFHaE5NbEpZV1cweFUxZEdVbGhrUjBac1ZteHNOVlJXWXpWWFJrcHpZMGh3V2sxSGFETldha3BIWTJ4a2RWTnNaRTVXTVVwSlZsUkNZVk15VFhoV2JrNVZZa2RTVkZscmFFTlpWbHAwWTBWa2FFMUVSa2xWYkdodlZqRmtTR0ZIYUZaaVIxSlVWbXBHYzJOc1pIUlNiR1JYWWxob05sWnNZekZVTWtaelUyNU9WR0pIYUZoVVYzQlhZMnhhU0dWRmRHcE5WVFY2V1ZWYWExWXdNSGxoUmtaWVZteGFhRlY2Um1GV01VNTFWbTFzVTJKR2NIZFdWM0JMWW0xV2MxZHVVbXBTVlhCelZXcEJNVmRHV1hsT1ZUbFdZbFZ3U1ZaWE1EVlhiRnBHVGxWU1YxSnNjR2hXTUZWNFYxZE9SazVXWkdsU00yTjRWbXhqZUUxSFJYbFNiazVVVjBkNGIxVnNVbk5aVm14eVdrWk9hMkpHV2pCYVZXUkhZV3N4VjFkdWJHRlNWbFV4VmxSS1MxZFhSa2RqUm1Sb1RWaENNbGRYY0Vkak1WbDRWVzVLWVZKc1NuQlpWRTVEVjBaa1dHUkhSbFJOYkZwNlZqSTFTMWRIU25KT1ZtaFhZbGhOZUZwVldtRlRSMDQyVW14YVRtRXpRa3RXVm1SM1ZURlplRmRyV2xoaVJrcFhXVmQwWVdGR1ZuUmpNMmhYVFZoQ1NGbFZaRzlVYlVwWVlVWndWMkV4Y0hGVVZtUktaVlpXZFZSdGJGUlNXRUphVjFaU1QxVXlUbGRWYkdocVpXdGFWVlp0ZUdGTlJuQldZVWQwVjAxRVJsZFpNRnB2VjJzeFNGUlVSbGRoYTFwTVdYcEdUMk50UmtkYVJUVm9ZVEZ3VlZZeWVGZFpWMUY0Vkd4a1YySnJOVlpaYkdRMFYxWldjMVp1WkZaV2JIQXdWRlpvYTFVd01WWk9WRUpYWWxoU2NsWXdXbXRUUjFaSlUyeGFhR0V3Y0c5V2JURTBWVEZaZUZwSVRtRlNWR3hZV1d0YVdrMVdaSEpXYlRsVlRWWndNRlV5ZUdGaGJFcFlaVWRvVjJKR2NETmFWM2hoWTFaT2NtUkdhRmROUm5CS1YxWldhMUl4VlhkTlNHeG9VbnBzV0ZacVRtOWhSbFkyVTJzMWJGSnNTakZXVnpFMFZUSkdObFp1V2xoaVIxRXdWbXBCTVZJeFpIVlViRnBvVFRGS1VWWlhjRU5qTURWWFZtNVNiRko2YkZoVmFrSjNaVlpyZDFkc1pGaGlWVlkxVmxjMVlWWXdNVmRqUjJoYVRWWndWRnBGVlRWWFIxSklZa1pPVGsxdFkzZFdiWGhUVXpBeFNGSllhRmRYUjFKUFZtMHhiMVl4YkhST1ZVNVlVbTE0ZWxsVll6VldNVXAwWlVaa1YySkhhSFpXTUZwaFkyeGtjVkpzY0U1U2JrSjVWbTF3UzFZeVRuTmFSbFpVWWtkU1ZGbHJhRU5sVmxwMFkwVmtXR0pXV2toV01qVlhWakpLUjFkdVFsWmhhM0IyV2tSR1lXUkhWa2hTYlhST1lrVndObFpxU1RGVk1WSnpWMnRhVkdKcmNGWldhazV2WVVad1dHVklUbGRXYkVvd1drVmFiMkZXV25OalJGcFhZV3R2TUZscVJtRldNV1IxVkcxd1UxSlVWbTlXYlhCUFlqRlplR05HWkdGU2F6VlZWV3hTYzFkR1pISldWRVpvVWxSR1dsVldVa2RXTWtwWlVXdDBZVlpYVWt0YVZWcHJWMWRLUjFSdGJHaE5NRXBoVmpGa01HRXlTWGxTYTJSWFlteEtjMVV3WkZOV01WWjBUbFZPVTAxWFVubFdNbk0xVm1zeFJWSnNhRlpOYmtKRVZqSjRZVll4V2xsaFJtUlRUVEpvVFZacVJtRlNNazE0Vlc1T1lWSXllRmhWYkZwWFRURmFkR1ZHVGxOTlZYQXdWbTE0YTFaSFNraGxTRUpXWWxob1RGWXhXbGRqVms1MFQxWmtUbFl4U2xwWGExWnJUVVphY2sxV2FGWmlSMmhoV1ZSS2IxWkdiRlZTYXpsVVVteGFNRlF4V21GaFZtUklZVWM1V0dKR2NHaFhWbVJUVTBaV2NsWnNTbWxTTVVwUVZtMHdNVkV3TlhOWGJGWlVZV3hLY0ZSV1duTk5NVkpYWVVaa2FGSnJOVWRaTUZwdlZtMUZlRmR0YUZwV1ZuQjZWRzE0UzJSSFVraGpSbVJvVFZoQk1sWnRNSGRsUjAxNFZsaHNWR0V5VWxoWlYzaExWMFpzYzFWclpFNU5WbHA0Vlcxek5XRXhTbk5YYkhCYVZsWndkbGxXWkVabFIwNUhZVVpvVjAweFNubFdiRkpIVlcxV1NGTnJiRlpoZWxaWVdsY3hOR1F4V2tkWGJVWnFUVVJXU0ZZeGFITlViRnBZVld4c1ZtRnJTak5XTUZwYVpWVTFXVnBHWkU1aE0wSlhWbTB4TUU1R1pIUlNXR2hxVWxob2FGVnRlSGRUUm10NVkzcFdWMDFyTlVsWmExcHJWVEZhZEU5VVZsZGlWRVl6VldwR2MxWXlTa2RoUmxacFVqRktWVmRYTVRSVE1rNXpWbTVTVGxack5WWlVWbHAzWld4c1ZsWnJPVlZOYTNCSlZsZDRZVlpzV1hwaFNFcGFWbFpXTkZreWVHdGpiVVpIVjJzMWFHSkdjRlpXYlRCM1pVWk5lVlJ1VGxWaWF6Vm9WVzAxUTJOR1ZuUmtTR1JZVm14d1dGWlhkR3RXYXpGWFlrUlNXR0V5YUZSV1ZFcExWMVpXYzFWc1ZsZGlTRUY2VmxSS05HRXlUbk5YYmxKclVsUnNWRlJWV25kWFZscHhVMVJHVlUxclducFZNbmh2WWtaS2RHRkhSbHBoTWxKMldrZDRkMU5IVmtsVWF6bHBVbGhCZDFaWE1UUlZNVlY1VWxod1VtSlZXbGxXYWs1VFlVWmtWMXBGWkZoU2EzQmFXVlZrZDFVeVNsaGhSbkJYWWxoQ1VGWlVTa2RTTWs1R1ZteE9hVkpVVmxWV1JscHJWVEZrYzFwSVNsaGlWR3h2Vm0xNGQxZEdhM2RoUnpsWFRXdHdWbFZzVWtOV2JWWnlVbXBTVm1GcldsaFdNV1JIVWpKR1NHSkdaRk5OTW1oYVZtMTBZV0V3TVVoVldHaGhVMFUxV1ZsclpGTldNV3hWVTJ4T1dGSnNTbGhXYlRWcllrZEtTR1JFVGxkTmFrVjNWbXBHWVdNeVRrVlJiR1JYVFRGRmQxWnRNSGhTTWs1eldraE9VbUpWV2xSWmEyaERWVlprY2xadGRGVk5WV3cwVm0wMVQxWnRTa1pPVm1oWFRVWmFURmxWV21Ga1JURlZVV3h3VjAxR2NEVldSbHBoWWpGYVIxcEZhR2hTYldoaFZtdFdkMVpHYTNkWGJHUnJVakZhU2xkcldtOVZNa3BJWkROd1YwMXVVbkZVYkZwYVpVWmtkVlJ0Y0ZOU1ZYQnZWbGQ0YTFVeFRrZGlTRXBoVWxoU1ZWVnRlR0ZOVm14eVYyMTBWV0pWV25sVmJHaHZWMFphYzFkdGFGaFdiVkpRV2tWYVUyTnNXbk5VYld4VFltdEtXbFpyV2xOUk1VMTRWV3hrV0dKcldsTlpiRlpoVjFac2MxZHRSbXhpUmxvd1ZHeFdNR0ZHU25KalJFSlhWbnBXUkZacVNrWmxSbVIwWVVaa1RsWnVRbTlXYWtKclZERktjMk5GYUdoU1ZGWndWV3hvUTFkc1duUmxSM0JPVm14V05GWnNhSE5XUjBWNFkwWkNWMDFHV2t4V01GcHpZekpHUjFSck5VNVdhM0JhVjJ4V2ExSXlSblJUYTJoV1lXdEthRlZzV2xaTlZscFZVMnRrVDJKRmNGWlZWM2hyWVVkRmVVOUlaRmhXYkVwSVdWUkdUMUl4VW5WVGJXaFRUVzFvVmxaWGVGTldNV1JIV2tab1RsSkZXbE5VVjNoaFpXeHNWVlJ0ZEZoU01IQkhWR3hhYjFaV1duTmpSRTVWVm14d2FGVXdaRTlPYkZwelYyczFhRTB3U2t4V2JGcGhZakpGZUZkWWFGUlhTRUp2VldwS2IxZEdWbkpXYm1SVVVteGFNRmw2VG05V01ERllWV3BDV2sxR2NGQlpWbVJHWkRKT1IyTkdaR2xXUlZsNlZtdFNTMU50VmxkVmJsWlZZa2RvV1ZWcVRtOVZSbHAwWlVkR2EwMXJNVFJXYlRWSFZXeGFSbGRzVWxwaE1YQXpWVEZhZDFac2NFVlJiV2hUWVRKM2VsWnRNWGRWTVdSeVRWVmthbEp0YUZoWlYzUjNWRVpaZUZkclpHcGlWbHBJVmpJeGIyRkZNVmxSYkVwWFlsUkdNMVY2UmxKbFJrNTFWRzF3VTFZeWFGVlhWM1JXVFZaUmVHSklVazVXZW14WVdXdGFjMDVHWkZWVWJUbFZZa1Z3ZVZSc2FITldWbHAwWVVaQ1YwMUhVa3haZWtaUFpGWktjMWR0YkZOTmJXaFdWbTEwVTFJeFdYbFViR1JUWW14YVZsbFljSE5XUm14eVdrUk9UbFpzY0VsYVZWcGhWREZhZEZWcmFGWk5hbFpVVm0weFJtVnNSbk5hUm1ScFltdEtSRlpHV21GWlYxSkdUVlphYTFKc1NsUlphMXAyWlVaYWNWTnFVbWhOYTFwWVYydFdiMkZHU2tkalJteFhZVEZhTWxSVlduZFNWa3B5WTBkNFUySkdiM2hXYTJONFlqRlZlVkpxV2xkaWJWSllWbTV3UTAweFVuTldXR1JzVW0xU01WVXllRzloVmxwWFkwWnNWMUp0VVhkV2FrRXhVakZrZFZSdGFGTk5NVXBYVjFkMFlXUXlWbk5oTTJSWVlUQTFXRlJWVWtkVFZteFdWbXhPVjAxRVJsaFpNR2gzVmpKS1IyTkZlR0ZTYkhBelZUQmtUMU5IU2tkVWJXeG9UVWQwTTFadE1UUlZNVTEzVFZWYVRsWlhhRlJaYlhoTFZsWnNWVkp1WkZaU2JHd3pWMnRTVTFkc1duTmpTSEJYVFdwV2NsbFhNVXRUUjFaSFlVWmtUbUZyVmpOV2JGSkNaVVphY2s1V2JHcFNia0p2VkZab1EyVldaRmRYYlVab1RWVndlbFpITlV0aFZrcDBWVzA1V2xaRmIzcFVWVnBoWkVkT1JscEdVbWxXYkhCSlZtMHdNVll4V2xoVGJHaHNVbXhLVmxadWNFZGtiRnB6VjIxMFYwMXJXa3BYYTFwclZHMUtSbGRVUWxkTmJsSm9XVlJLUjFJeFVuSmhSbHBwVWpKb1YxWnRNVFJrTURCNFYxaGtXR0pZVW5GWmEyUlRUVVpSZUZwSE9WVmlSbkJaV2tST2QxWXlSbkpoTTJoV1pXdGFhRlpxUm10WFYwNUhWbXhvVTAxdGFGcFdhMXBYV1ZkUmVWSnJaRmhYUjFKb1ZXMHhVMVpHVWxkaFJVNVVVbXhzTlZSV2FFOVdhekZ5WTBoc1ZrMXVVbnBXYWtwTFYxWkdjbVZHVm1oTmJFcFFWMnhXWVdFeVVsZFdiazVXWWxkNFZGUlVTbTlOYkZweldrUkNWMkY2UmxsVmJYUnJWMGRLY2xkc1dscGlSa3A2V1dwR1YyUkZOVlpVYkU1T1ZtNUNObGRXVm1wT1ZsbDNUVmhLYWxKWVFsZFdhazVUWkd4YWNWRllhR3BXYTNBeFZqSjRkMkZGTVhOVGEyaFlZa1phY2xaRVJrcGxWbEp5V2tkR1UwMXVhRmxXVjNoWFkyMVJlRmRZYkd0U2F6VlVWRmR6ZUU1R1dYaGhSemxvWWtWd1dWcFZXbXRYYlVWNFZsaG9WMDFXY0ZoWk1WcFBaRVU1VjFwSGJGTk5WWEJoVmpKMFYyRXhTWGhYYTFwT1ZtMW9WMWxVU205WFJsSllZMFprV0ZKdGVGbGFWVll3VjBaS2MxZHVjRmROYm1ob1dWWmFhMU5IUmtoUFZtUlRZa1p3YjFkclVrZFpWMDE1Vkd0YVYySkZjSEJXYWtwdlpHeGtjMXBFUWxwV2JYaFlWako0YTFsV1NrWlRia0pWVm14d2VsUlVSbE5XTWtaR1drWmFUbUV6UVhoV1ZtUTBZakZhVjFkc1pHcFNSVFZYV2xkMFlVMHhXbkZTYm1SVFlraENTRlpITVhOVk1ERldZbnBLVjJGcmIzZFpWRXBPWlVad1JscEdVbWxoTTBKNFZsUkNZV1F4WkVkaVJtaHJVakJhYjFWdE1WTlhSbGw1WlVVNWFFMVZjSHBaTUdoM1YwZEZlR05IYUZwV2JWSk1WV3BLVDFJeGNFZGhSbVJPVFcxb1dsWnFSbUZaVm14WFYxaG9XR0pzV2xaWmJHUnZWa1phYzFWc1pGaFdiSEJJVmpJeE1GWnJNVmhWYkdoYVRVWmFhRmRXV2t0WFJsWjBUMVpXVjFacmNFbFdha1poV1Zaa1NGVnJhRkJXYldod1ZteGFXazFXWkZkV2JHUlBVbXhzTTFSV1ZtOVdiVVY2WVVkb1ZtSkdjRE5XTUZwelRteEtkVnBHVGs1V01VbDNWMWQwWVdFeFZYaFhibFpTWWtkU1dGbHNVa2ROTVZZMlVWUkdWRkpzU2pGV1YzaGhWMFpKZVdGR2NGaFdla1V3VlhwS1QyTXhXblZWYlhoVVVqRktWMVpHV21GWlYxWlhWMjVTVGxaWFVsbFZiWGgzVFVaYVdHVkhSbGRpUm04eVZWWlNSMWRzV2taU2FsSlhZV3R3VUZVeFpFdFNNVnB6V2tkc1YwMXRhRXRXYlRCNFpERk5lRk51VWxkaWJFcFVXVlJLVTJJeFZuUk9WVTVZVW14YWVsbFZWazlXTVZwelkwaHNWMkpVUmtoV2FrRjRZMnMxVjJGR1drNWhiRnBOVm14V1lWZHRWbk5XYms1b1VtNUNiMVJXV25abGJGcElUVlJTYUUxV2NGaFZiVFZUWVRGSmVsRnJPVmRoYTFwTVZURmFZVlpXU25SUFYzQk9ZVEZ3U1ZaVVNqUldNVmw1VTJ0b2FGSXdXbUZXYTFaM1ZrWmFWVkp1WkZOV2EzQXdXa1ZhYTFSc1dYaFRXR2hYWVRKUk1GbFVSbE5qTVdSWllVWlNhVlpXY0ZwV2JURTBXVmRPYzFadVJsTmlWVnBVVkZaVk1XVnNXblJsUjNSb1ZteHdTVnBWV25OV01rcFZWbXBPVm1KWVRqUlZha1ozVWpGd1NGSnNUbGRTTTJoV1ZtdGFZV0V4VlhkTlZtUllZa2RvVDFacldrdFhSbFowWkVoT1QxSnNWalZhVlZaclYwWktjMkpFV2xkV2VrWjJWMVphUzFKc1pIVlRiR1JvWVRGd1dWZFljRWRrTVU1SVVtdGtWV0Y2Vms5V2JHaERXVlphZEdSSFJsZE5WbFkwVlRGb2MxWXlTa2hWYlRsVlZrVndWRll3V25Oak1WWjFWR3hvVTJKWWFHRlhWRUpYWVRGU2MxZHVVbXhTYlZKWldWUktUazFXV1hkYVJYUlRUV3R3UmxZeWVIZFdNVnB6WVROa1YyRnJjRFphVldSVFZqRldjMkpIYUZOaVZrcDJWMVpTVDFFeFRsZFhiR2hxVWxoU1ZsUldWVEZUVmxaMFpFZEdWVTFXY0RCWlZWcFRWakpLU0dGRlRtRldiSEJvV2tWa1QxSnNjRWRqUm1ScFVqTmpkMVl4WkRCWlYwVjVVbXhrVkdKc1NsZFphMlEwVjBaU1ZscEdUbXRpUjNoWFZqSjRZV0V3TVZkalJscFdZbGhvY2xsV1drcGxiVVpGVm14a2FWZEhhRlZXVjNCTFVqSk5lRlJ1VmxWaVIyaHdXV3hrYjFkR1pGaGxSemxXVFVSQ05GbHJhRXRYUjBWNlZXNUdWVll6VFhoVk1uaHpZMnhrZEU5WGFGTldSVnBZVjFSQ1lWWXhXWGxUYkd4V1lrZFNhRlpzWkZOVlJtdzJVbTVrVkZac1NqQlpWVnBQWVZaT1JsTnNSbGROVjA0eldsVmtTbVZXV25OYVIwWlRZbFpLYjFaWGRHRlRNVnBYVld4b2JGSllVbFZXYlhoaFRVWndSbHBFUW1oU2EzQjVXVEJTUjFac1dYcGhTRnBYWWxSR1RGVnFTazlTVms1MFVteGtUazF0YURWV01WSkxUa2RSZUZOc1pGZGlhelZ4VlcweFUySXhVbFZSYTNSWVlrWndlbFpYZEhkVWJGcHpVbXBTV21FeGNISldhMXByVTFaR2MxUnNjRmhUUlVvMlZtcENZV014WkVoVmEyaFRZa1phVkZsclZuWmtNV1J6Vm0xMFUwMXJXbnBXTWpWTFZERmtTR0ZHYUZkaWJrSklXbGQ0WVZORk1WWlhiWGhUVFVSV1NGZFdWbUZoTVZWNVUydHNVbUpIZUZoWmJHaERVMFpaZVUxV1pGZE5Wa294VlRJeGIxVXdNWFJoUmxaWVZqTm9jbGxxUm10U01YQkhZVWQ0VTJWdGVIZFdSbFpUVVRBMVIxZFliRTlXVjFKWFZGZDBkMUl4VW5OWGJUbFlZbFZXTkZrd1VrOVdNREYxWVVod1YySllhSEpaTW5NMVZqRmFkR0pHVG1sWFIwNHpWbTE0VTFNeVVYaFhXR2hZVjBkNFZGbHRkSGRqUm5CWVpFVjBXbFp0ZUZsYVJXaHJWa1pLYzFkcVFscGxhelYyVmpCYVlXTXhUblZqUm1SWFpXdGFObFpzVWtKa01sWllVbXRvVTJKSFVuQldhMVphWld4YWNsVnJaRmRpVmxwSVdUQldZVmxXU1hwUmJGSlhZbGhvTTFadGVHdFhSMUpJWkVaYVRsWXhTa2xXYkdRMFlURnNWMU51U2s5WFJUVmhXVlJLVWsxR1duRlNiWFJxWWxWYVNWcEZXbXRXTURGSFlUTnNWMVo2UmpOVlZFWnJZekZrYzFwSGNGUlNia0paVjFaa01GbFdVa2RpUkZwVVlYcHNWVlZxUW1GVFZsWjBaVVU1VmsxV2NERlZWM0JYVmpKS1NGVnFUbFpsYTFwTVdrVmFZV1JXVW5SalJrNVhUVlZ3ZGxac1pIZFRNRFZIVjJ0a1dHSnJjRmxaYkZaaFYxWnNjbGR1Wkd4V2JHdzFWRlpXYTFkSFNrZGlSRkpXWWxoQ1dGWnFTa3RXVmxwelVXeHdWMVpzV1hwWGJGcGhWakpOZVZOclpHcFNNbmhVVkZjeGIxWnNXblJqUlU1YVZtMTRXVlpIZUd0Vk1rcHlUbGRvVm1KR1NucFdNRnB6WTIxR1JsUnNhR2xTTVVwWFZtdGpNV0V4V1hkTlZtaFdZbTVDV0ZSWGNGZFZSbXhZWlVWMGExSXdXa2xWYlhoWFZqRmFkVkZ0YUZkU2JGcG9Wakl4VjFack1WZGFSMFpUVFRCS2QxWlhjRWRUYlZaSFYyeFdWR0ZzU25KVVYzUjNVMVpXYzJGSE9XaGlSWEI2VmpKNGMxZHNXa1pYYldoYVRXNW9XRmt4V2t0amJWSklZMGRvYkdKR2NGcFdha293V1Zac1dGSnNaRlJpUmxwWVdXdGtORmRHYkZoa1JYUllVbXhaTWxWdE1UQlZNREZZVldwR1YxWXpUWGhXTUZwS1pVWk9jMWRzWkZOaVJuQlZWbTF3UjFReFNYbFRhMnhVWWtkb2NGWnJaRFJYVmxwWVRVaG9WazFWTlZoWk1GcGhWMGRLU0ZWc2FGVldWa3BJVlRGYVlWZEZOVmhTYkdST1lURlpNRmRVUW10U01XeFhVMnRhV0dGck5WZFVWVnBXVFZaYWNWTnJaRk5OVmtvd1dXdGFiMVV3TVhSVWFsSlhZbFJHTTFWNlFYaFNNa3BIV2taYVdGSXlhRzlXVjNoclZURmFWMkpJVW14U1dGSnhWRlphWVUxR1VuTldhemxZWWtad2VsVXllR3RXTURGeFZtNUtXbFo2Umt4Vk1HUlhVakpLUjJOSGVHaGxiRmw1Vm0xd1ExbFdUblJXYTJSaFUwVndjVlZ0TlVOaU1WSlhZVVZPYkZadFVsaFdNakZIVjJ4YWNtTkljRmhoTW1oTVdWWmFTMlJIUmtkaFJuQm9UVlp2ZWxaWGRHRmhNazE0VjI1U1UySlhhRTlXYlRFelRVWmFWVk5VUmxkTlZuQlpWVEo0WVZkSFNrZFRiVVphWVRGd00xWkZXbmRTVmtwMFVtMXdWMkV4YjNkV1Z6RTBWREZTYzFOcldsUldSVXBZV1ZkMGNtVkdXbFZTYkU1cVRWWktlVmxWWkc5Vk1rcEhZMFprVjJKVVJUQlhWbVJYWXpGV2RWUnNhR2xXVm5CV1ZsZHdSMU14VGxkalJWcFlZbTFTV0ZSWGRGZE9iRlpYWVVkMFYwMXJjRWxXVjNCaFZsZEtSMk5JU21GU1ZuQlFXWHBLUzFJeFduTmhSazVPVmxoQ1dWWnRNSGhPUm14WVZWaHNVMkV5VW5GVmJGcDNZVVpXZEUxV1RsZFdiRm93V2tWb2EySkhTa2RqUm14YVRUTkNTRlpxUVhoamJVNUhZMFpvVjFKVVZqSldiWEJMVXpGa1YxWnVWbFJpUmxwWVZtcEdTMU5HWkhOV2JVWmFWakZLV0ZadE5VOVdiVXBZWVVVNVdtRXhXak5VYTFwaFl6RnJlbHBIZUZOTlIzY3dWbXBKTVZReFpFaFRia3BxVW0xb1lWbHNVa2RXUm10NVpVaE9hbUpIVWpGWGExcFRWVEpLU0dSNlJsZFNiSEJVVlZSR1dtUXdNVmRhUjNCVVVqTm9hRlpHVm1GVE1VcEhXa1prV0dFelVsaFVWM014VTBaV1dHVkhkRlpOUkVJMVdWVmpOVll5Um5KWGJXaFdZV3R3VUZacVJuZFRWbEowVW14T1RtSnRhRnBXYkdRMFZqRmtjazFWWkZoaWJFcHlWVzF6TVZaR1VsZFhiazVQVm14d1dWcEZaREJXTVVsM1kwaHNWMDF1YUhwV01qRkdaVlpXYzFWc2NFNVNia0paVjJ0V2ExVXhUbGRqUldSaFVsUldXRmx0ZEVkTk1WcHlWMjFHVmsxV1ZqUlhhMmhQVjBkS1IxZHNUbHBXTTJoTVZqQmFjMk14Vm5OYVJscFRZa2QzZWxZeWRGZE5SbGw1VTJ0b1ZtRnJXbGRaYkdodlYwWmFjVk5yZEZkTlZUVjZWbTE0YTFVeVNrZGpSemxYWWxoQ1RGWlVSa3RqYXpGWFdrZHNVMkpHY0hkV1Z6RTBaREpSZUZkdVVteFNNRnBaV1Zod1IxZEdaSEpoUlhSb1VtczFTVlpYZUU5V1ZscHpZMGh3VldFeGNHRmFWbVJUVTBaS2RHRkdaRmRTVld0NFZtMTRhMDVIVFhoWFdHeFVZa2Q0YjFWclZURlhSbEpXVjI1a1dGSnRkRFJXTW5Rd1lURkplRk5yYkZwTlIxSjZWbXRhUzFadFRrWmtSbVJPVm10d1JWWXhXbUZXYlZaSFYyeHNhRkl3V2xSV2JUVkRWbXhrV0dSSGRFOVNiVkpJVmxkNGExbFdTbkpqU0VwVlZtMVNWRll3V2xwbFZUVldUMVprVG1FeGEzbFdWekV3WkRGa2MxZHNaR3BUUm5CaFZtMTRkMVJHYkRaVGF6bFRUVlp3ZWxsVldtdFVhekYwWVVad1YyRnJXbWhaVkVaU1pVWmtXV0ZHWkdsaGVsWnZWbGR3UzJJeFdrZFhiazVXWWtkU1dGWnRNVk5YVm5CR1drVmthRTFFUmxsV1YzaHZWMnN4UjJOSGFGaFdiSEJNVmpCYVYyUkZPVmRYYld4WVVqSmtObFl5ZUdGWlYwNTBWVmhzVTJFeWVGWlphMlJ2WWpGd1dHUkhSbFJXYkhCNFZURlNSMWRzV25OaVJGWldZbFJXVEZsWGVFdFhSMFpJVW14V1YwMHdTa2xXYkZaaFZqSk5lRnBJVW10U00wSlBWbTAxUW1ReFpGaGtSMFpWVFd0YVdWVnNhR3RoYkVsM1YyeG9XbFl6VWpKYVJFWmhZMVpLZFZSc1pFNVdiSEJoVjFkMFlWWXlSbGhTYWxwWFlsUnNXRlpyVmt0V01WSlhXa1Z3YkZKc2NERlZiWGhUWVVkS1JtTkdiRmRXZWtVd1ZYcEdhMUl4WkhWVmF6bFhUVEZLV2xaWE1UQmtNbFp6WVROa2FGTkZOVmhVVlZKSFRWWnNWbUZGZEZoaVJuQllWbTF3VTFkck1YRlNhM2hXWWtad1dGbDZSbmRUUjBwSFlVWk9hRTB3UlhoV2JUQjRaREZGZVZKWWFGVlhSMmhXV1ZSS2IxWkdiRlZUYWxKWFlrZDRlVll5Tld0aFZURllaVVphVmxaNlZuSlpWbFY0VmpKT1NXRkdXbGRsYTFwSlYxWmtlbVZIVG5KT1ZteHFVbTVDVDFWdGVIZGxWbHAwWlVkMFZFMVhVbGxWYlhScllVWktkVkZ0T1ZWV2VrWjJWV3hhWVZaV1RuRlZiV2hPWVhwRk1GWnFTVEZWTWtWNFUyeFdWMkpHU21GWlZFcFNaV3hTVmxkdFJsZFdhelZXVlcxNFUxUnRSWGhqUm14WFZrVnZkMWxVU2tkak1VNTFWVzE0VTJKWGFHaFdiWFJYV1ZaWmVHTkdXbGhpYTNCelZtcEdZVk5XVm5STldHUlhUV3RXTmxWV2FHdFdNVm8yVVdwU1ZWWldjRmRhVmxwUFkyeHdTR05HVG1sV2EzQmFWbTB3ZDJWR1ZuSk5WV1JoVW0xU2FGVnNaRk5XVmxaMFpFaGtXR0pIZUZkWGEyaHJWbXN4YzFkcVFtRldWbkF6Vm1wS1IyTnNUblZYYkZwWFVsWndVVlpYY0VkaE1rNXpWMjVPVm1KWGVGUldhMXBoVjJ4YWNsZHRSbHBXYXpFelZGWmFhMWRIUlhsaFNFNVdZbTVDZWxscVJtRmtSMVpKVkdzNVYySllhRmhYVmxadllURmtSMU51VG1wVFNFSlhWRmMxVTJSc1pGZFhhM1JUWWtkU01GbFZXbmRpUjBWNFkwaHNXR0V4Y0doV2FrcFBZMnMxVjFwSFJsTmhlbFoyVmtaU1ExTXlVbk5YYmxKT1UwZG9jbFJXVm5OT1JsVjRZVWQwVlUxV2NGbFdWM2h2VmpBeFNGVlVRbHBOYm1oWVdURmFVMk14VW5OaFJtUnBVbTVCTUZac1dtcE5WMFY0VjJ0a1dHSnJOWEZWYlRFMFlVWmFjMXBHU210TlZtd3pWMnRXTUZVd01YSk9WV1JZWVRGd1dGbFdXa3RqTWs1SFZteGthVmRGU2tsV1dIQkhVekpOZUdORmJGWmlWMmhVVkZWYWQxWldXblJqUldSVVRWWndXRll5ZUc5aGJFcFlWVzVLVlZac1dqTmFWbHBUWXpGa2RGSnNWazVXYmtGM1YxWldZVlV4V1hsVGEyaG9VbFpLV0ZSWE5XOWhSbkJHVmxob1ZGWnVRa2xhUlZVeFlWWktkVkZyY0ZkaVJrcElXV3BLU21WR2NFWmhSbEpwWVROQ2VGWlhlRk5qTVdSSFZXeGFXR0pWV2s5VVZscHpUVEZaZVU1Vk9WaFNhMnd6Vkd0U1MxWnRTbGxoUkU1WFlXdHdURlZ0TVU5U01rWkhXa2RvYUUxdVVUQldNVnBUVWpGc1dGUllhRlZpYkZwV1dXeG9RMVpXVm5GVGJUbFlVbXh3U0ZkWWNFZFdiVXBYVW1wU1YwMXVhRmhXVjNoclUwZEdSMkZHVmxkTk1ERTBWbFJLTkdNeFduTmFTRkpyVW0xU1QxbHJXbmRPVmxweFUycENhazFXYkRWVk1uaHpWVzFGZDA1WGFGWmhNVm96VmpCYVdtUXhaSEprUjNCcFUwVktTbGRYZEdGVU1rWlhWMjVLYWxKRk5WaFpiR2hEVWtaYWNWSnJOV3hTYkVwNlYydGFiMWRHU1hsaFJuQllWak5vZGxaVVJtRmpNVlp6WVVkd1RrMXRhRkZXYlRFMFpERk9WMk5GV21GU1YxSlpXV3RhZDJWV2EzZGhTR1JYVFVSR2VGWnRkRk5XTWtaeVkwVm9XazF1VFhoV01WcHJZekZ3U0dKR1RtbGhNSEF5Vm1wR1UxSXhiRmRUV0d4VlYwZG9jVlZzWkZOV01XeFpZMFprV0ZKc2NIaFdSekYzWVRBeFYyTkVRbHBOUmxweVdWWlZlR05yTVZWV2JGcE9ZbXhLZVZadGRHdFRNazE0Vkc1T1lWSnVRbTlVVjNoTFRXeGFkRTFVVWxwV01VcEpWbTEwYTFsV1NsVmlSbEphWVRGYU0xUnNXbUZqVms1WllVWk9UbUV4V1RCV1ZFbzBWakZaZVZOcmFGWmlSbkJXVm0xNGQwMHhjRWhsUjBaWFZtdGFXbGxWV2xOV01rVjRZMFJXV0ZZelVtaFpha1phWlVaT2MxZHRjRk5sYlhoYVZtMXdUMUV4VGtkWFdHeE9WbTFTV0ZSV1ZURmxiR3h5V2tjNVZrMXJjRmxaVldoaFZqRktjMU5yZUZwaGExcHlWbXBHZDFJeGNFaFNiRTVUVmxoQ2IxWnRNWGRTTVd4WVZtNU9XRmRIZUZCV2JGSnpWMVpXY1ZGc1pFOVdiSEJaV2xWak5WWXdNWEpqUm5CWFZucEdkbGRXV21Gak1rNUhWV3h3YkdFeGNIbFhWRXA2VGxaa1NGSnJaR0ZTTW1oUFZGVldXazFHV25SbFIwWm9ZbFphU0ZVeGFHOVhSbVJJVldzNVYwMUdjR2haYWtaWFpFVXhXRTlXYUZOaVdHaGFWMnRXYjJFeFZYZE5WbXhTWWtkU1dGUlhjRVprTVZsM1YyeHdhMDFyTlVkWlZWcHJWakpXY2xkcVNsZGhNazQwVlhwR1MyUkdVbkphUjBaVFlsWktVRlp0Y0VkU01EQjRWMWhvV0dKWVVsZFpiRnBoVTBacmQxWnRSbHBXYTJ3MVdsVmFWMVp0U2tkVGJHaGhVak5vYUZZd1ZURlhWbkJJWTBVMVYySllZM2RXYlRCM1RWWlZlVk5yWkZWaE1taFhXV3RrTkZkR2JITlZhMXBzWWtaS1dWcFZaRWRXUmtwVlVteGFWbFo2Um5aV2FrcEdaV3hHY1Zkc2FGZE5NVXBWVm10U1IxZHRVWGROVm14WFlrWndjRmxVVGtOWFZtUlhXa1JDV2xadGVGaFpNRnB2Vkd4YVdGVnNWbGRpV0UxNFdsZDRhMk5zY0VoUFYyaFRWa1ZKZWxaVVNucE5WbGw1VTJ0a1ZHRXlhRmxXYlhoM1V6RndWMWRzVGxoV01IQklWbGN4YjFSdFNrWmpTRnBYWWtkT00xcFZXbFpsVmxKWllVZHNVMkpHY0ZWWFZ6RXdaREpOZUZkdVVteFRSVFZRVm0wMVExWXhXWGxOVkVKb1VtdHdWbFZ0ZUc5V2F6RjFVV3RTVjJGcmNFeFdNVnBYWkZaT2MxcEhiRk5OVlhCT1ZqRm9kMUl5UlhsVVdHeFRZVEpTY1ZWcVNtOVVNVnAwVFVSV1QySkdiRFJXVjNSUFYyeGFkRlZxUWxkV2JXaDJXVmQ0UzFkSFJrZFNiR1JwVmtWYVZWWnFRbUZqTWs1MFVtdGFWR0pZVWs5V2FrWkxUbXhhZEUxSWFHdE5Wa1kwVmpJMVQxZEhTblJsUmxwWFlsaG9NMWt5ZUhOWFIxWkdaRVpvVTAxR2NFbFhWbFpoVmpGWmQwMUlaRlJpUjNoWVdXeG9VMkZHYkRaVGF6bHFUVmhDU2xVeU1UQlZNREIzVTJ4Q1dGWnRhRE5XYWtaT1pVWmtjMVpzVW1oaVJYQlpWa1phWVdNd01IaFZiRnBvVTBVMWIxVnRkSFpOYkd4eVYyNU9XR0pWVmpWV1YzaFBWbFphVjJOSVNsZGhhMW96VldwR1UyTXhWbk5VYld4VVVsVnJlRlpxUm1GV01XeFhVbGhvV0ZkSFVrOVdNRnBMWWpGV2RFMVVVbGhXYkhBd1dsVldNRlpzU25OWGJGcFdZbGhOTVZacVFYaFhSbFoxWTBaa2FWZEhhRlZYVmxaclV6RktkRlJyWkdGU2JWSlVXV3RvUTJWV1duTlZhMHBzVW10c05GWXlOVmRXVjBwWVlVWlNZVlo2UlRCV01uaGhWMGRPUmxSdGRFNVdNVXBaVjFkMFlWbFdaRWhUYkZacFVtMTRZVmxVUm5kbGJGSjBaVWRHV0ZKVVJsbFVNVnByVkd4S1JsZHJiRmhXUlVwMldrUkdZVmRHVG5OaVIyaFRZVEJ3YUZaR1l6RmlNREI0Vm01R1UySkhVbkZVVm1oRFUxWnNjbGRyT1ZoU2EzQlhWbTF3VjFZeVNsVlJhbEpoVWtWYVVGcEZXbUZqYlVaSFZteG9VMDF0YUdGV2JYQkRZVEpKZUZwR1pHbFRSa3B6VldwQ1lWWXhVbGRhUkZKc1lrZFNlVmRZY0ZkWFJrcHlZMGh3VmsxdWFIWldha0Y0WTFaYWRWTnNaRTVTYmtKTlYxaHdTMVF4VGxoU2EyUllZbGQ0V1ZWcVNtOVViRmw0V2tSQ1dsWnJNVFZXVjNSclZqSktjbGRzVWxwaE1sSlVWbXRhVTFaV1RuUlBWVFZwVWpGS1dWWnFTWGhOUmxWM1RWVldWMkp1UWxoVVYzQlhWVVpzV0dWRmRHdFNNRnBJV1ZWYWQyRldTWGhUYWtaWVlrZFJNRmxVUm10WFJsSnlWMjEwVTJGNlZsQldiWGhyVFRBeFIxZFliR3RTZW14WVZGWmFWMDVXVlhsa1IzUllVakJ3ZVZVeWVHOVhiRnBHWTBaT1ZWWldjR2hhUldSWFUwWktjMkZHVGxkU1ZuQk1WakZhVjFack1WZFdXR2hZWVRGd1ZWWnJWa3RYUmxKWVRsWk9hMkpHV1RKVmJURXdWa1pLY2s1WWNGcGhNWEJvV1ZaYVNtVkdUbk5hUm1ScFYwVktVVlpzVWtKa01sWkhWMjVXVTJKRk5YQlZiRkpYWlVaYVIxcEVRbHBXYXpWNlYydG9TMWRIU2xsVmJUbFdZV3RhYUZwV1dscGxSMFpJVDFab1UySklRalpXYWtreFdWWmFkRlp1U2xoaVZWcG9WbTE0ZDFSR2NFZFhhemxxVFd0YVNWbHJXbXRVYlVwWVlVaGFWMkZyYnpCWlZFRjRVakpLUjJGR1ZtbGhlbFphVjFjeGVrMVdaRmRpUmxaVllrVTFjVlp0ZUV0WFJteFdWbXM1VjFKc2NEQmFWV2h6VmpBeGRWUlVSbHBXVm5CaFdrUkdZV05XVW5OalIyaE9WbGhDV2xadE1YZFRNVWw1Vkc1T1lWTkdXbGxaYkZaaFZrWldjMWR1WkZSV2JWSldWVEkxZDJKR1NuTmlSRkphVFVaYWNsWnRNVXRUUjBaSFZXeFdWMlZyV2pKV2JYQkhWMjFXUjJFemNHaFNWR3hVV1d4b2IxZFdXbkZUVkVaVlRXdGFXRlpIZEdGaGJFcDBZVVpvV2xaRldtaFpWVnB5WlVaa2MxcEhkRk5OVm5CS1ZsY3hlazFXVlhsVGExcHFVa1p3V0Zsc1VrZE9iRkp6VjJ4d2EwMUVSbGRXYlhoUFlWWkplV0ZIYUZkU2JGcG9WWHBHUzFJeGNFZGFSbWhvVFRGS1dWWkdaSHBOVms1WFlrWmFXR0pZVWxkVVZWSkRUbFpzVmxsNlZsaFNiVkpLVlZkMGIxZEdXblJWYkVKWFlXdGFhRnBHV2xOa1IwNUhWR3hrVTJKSVFsZFdha1pxWlVVeFIxUllaRTlXYlZKWlZqQmtiMWRXYkhKYVJrNWFWbXh3TUZsNlRtOVVhekZYVTI1d1dsWldjRkJXYWtaS1pERmFjVlpzWkZkTk1taHZWbXBKZUZKdFZraFVhMmhvVW0xU1QxVnROVU5PYkdSVlUxaG9VMDFWY0hwV1Z6VlRZVlpLVlZac2FGcGlXRkpMVkZWYVlXTXhaSFJqUjNoVFlUSjNNRll5ZEc5VU1XUkhXa1ZvYUZKc1dtRldhMVoyVFVaWmQxZHRSbXBXYkVwNlZrY3hNR0ZXU25WUmJHUlhWa1Z2ZDFSVldsWmtNREZYWVVaYWFHRXhjRmhXYlhCUFlqSk9jMkpHWkZoaE0wSnpWbXBDWVZJeFduUmxSM1JYVFZWd1Yxa3dZelZXTURGWFkwaEtWMUpGV21GYVZWcFhaRlpTYzFwSGJGTldSbG96Vm0weGQxTXlTWGhXYTJSWVlteEtjVlZzVW5OalJsSlhXa1pPV0ZKc2JEVlViRlpyVmpGSmQxZHVjRlpOYWtFeFZteGFZV1JHVm5OVmJGcE9WbTVDV1ZkWWNFdFNNVTVYWTBWb2FGSnJOVzlVVkVKSFRURlplRmRzWkZwV01HdzBWMnRvVDFkR1pFbFJiRnBYVFVkU2RsbFZXbGRqVmxKMFQxZDRhVkp1UVhkWGJGWnJUVWRGZUZOdVNtcFNSVXBvVld4YWQxVkdXa2hsUlhSVFlrWndXbGxyV210VWJGcDFVV3hzVjAxV2NHaFdiVEZYVWpGd1IySkhSbE5XUmxwWlZtMHhOR1F4WkZkYVJtUldZVE5TVUZWdE1WTlRSbXh5VjIwNWFFMVZOVWhaTUZVMVZtMUtWVkpVUWxkaVdHaFlXa1ZrVjFKck9WaGhSVFZYVjBWSk1WWnJaRFJWTVVsNFYxaG9XRmRJUW05VmJURnZXVlphYzFwR1RsUlNiRW93V2xWa1IyRnJNWEpqUldoYVZsWndjbFpIYzNoV2JVNUpWMnhrVG1Kc1NsVldXSEJIVlcxV1YxVnNiR2hTYlZKd1dXdGFkMVpzWkZoa1IzUnBUV3RzTkZaWGVGZFZiVVY2Vlc1T1dtRXhjRE5XTVZwVFZtMUdTRTlXWkdobGExcEhWbGN4TkdJeFdYZE5XRlpXWW14d1lWbFVSbmRVUm10NVkzcEdXRkpVYkZoWGEyUnZZVVV4U1ZGdE9WZGhNWEJ5Vkd0YWMxZEdWbkpoUm1Sb1RXMW9WVmRYZEd0aU1WcEhZa2hLYUZKVmNISlVWbVJUVjBaYWRHVkZPVmRXVkVaWVdUQlNRMVp0U2xWV2EzaFhUVWRTVEZZd1pFZFNNWEJIWTBaa1RrMVZjSFpXTVZKTFRrZFJlRk5ZYUdGVFJUVldXV3hvUTFReGJGVlNibVJVWWtkU1dWcEZaREJoYXpGWFlrUldWbUpIYUROV1Z6RkxVMFpXYzJGR2NHbFNNbWd5VjFSR1lXUXhXbk5YYkZaVFlrWktWRmxyV25kWlZtUlhWbTEwVTAxV1ZqUldNV2h2VmtkS1NWRnNiRmRoYXpWVVdUSjRjMk5XVG5KUFYzQk9WbTVCZUZaWE1UUldNa1pYVTJ4V1YySklRbGhXYm5CR1RVWmtWMXBHWkZOTlZuQjZXVlZWTlZZd01IaFRiR3hYVW14YVZGVnFSbXRTTVZwWllrZDRVMlZ0ZUZsV1JscGhZekExYzJKR1dsaGhNRFZZVkZkMFlXVldhM2RXYWxKWFRXdHdWbFZ0ZUVOV2JVWnlZMFpDVm1GcmNGQlZha1ozVWpGd1JrNVdaRmRsYlhONFZtMHdkMlF5VmtoVldHaFVWMGRvY0ZWdE1WTldWbXgwWlVWMFYySkhlRlpWYlRWcllVWktjMWR1YUZaV2VrWklWbXBHUzJNeFpIVmpSbkJYVm14d1VWWnRNVFJaVjAxNVZHdGtXR0pHY0ZoVVZFcHZZakZhY2xWclpGcFdNREUxVlRKMFYxWnRTa2hWYXpsYVZqTm9hRlpXV2xwbFJtUjBVbXhTVG1KRmNFbFdiVEF4VmpGV2RGTnJaR3BTVkd4WFdXeG9iMDB4VlhkWGJYUnFUVmRTTUZWdGVIZFdNREZGVm14c1YyRXlUWGhWYWtaaFpFWk9jMkZIYUZOV1IzaFlWMVpTUjJReVJrZFdXR2hZWWxWYWNWWnRkSGROUmxGNFdraE9WV0pHYkRSVk1uUnpWakF4ZFZWc2FGcGhhM0JJVldwR1QyUldWblJsUms1T1VtNUNiMVl4WkRCaE1rbDRWMnRrVm1KR1dsUlpiWE14VjBac2NscEdUbXhpUjFKNVYydFNRMVpyTVVWU2ExcFhWbTFvZWxacVJtRk9iRXBWVVd4d1YxSldjRmhYYkZwaFZESk9jMXBJVW1wU2F6VndWbXBLYjFsV1duUk5TR2hQVW0xNFdGZHJWbXRYUjBWNFYyeFNXbUpHV21oV2ExcFRWakZhVlZKck5WZGlTRUpLVmtaYWIyRXhXbkpOV0VwcVVsaENWMVpxVG05a2JGbDNWMnh3YkdKVldraFdWM2hoVmpBd2QwNUVRbGRpV0VKSVdWUktVMVl4Vm5WVWJVWlRZbGRvVlZaR1kzaGlNV1J6VjI1S1dHSlZXbTlVVmxwWFRURlNWMWR0ZEdoU1ZFSTFWbGQ0YzFkdFNraGhSbEpYWWxob2VsbDZSbUZrVm5CR1RsWk9hVmRIYUZsV2FrWnZaREZaZUZkWVpFNVhSWEJaV1cweE5GWXhVbGhqUm1SVlVteHdNRlJXVmpCV01WcHlZMGh3VjFKNlJraFdWRVpMVm14YWNWVnNaR2xYUlVwSlYydFNSMVF4VGtkVGJrcGhVbXhhY0ZacVRtOVdWbVJZVFZSQ1ZFMVhlRmhXTWpWSFZUSktXVlZyT1ZaaVZFVXdWakJhV21WSFJraGtSbFpwVWxSV1NsZFdWbUZqTVdSelYydGFhbEpzU2xoVVZWcDNaV3hzTmxKdFJtdFNhM0I2V1ZWYVQyRldTbGxSYkhCWFlXdHZkMWRXV2xKbFJtUnlXa1pvYVdGNlZuaFdWM1JYVXpKR1IxWnVUbUZTYXpWVlZXMTRjMDVXY0ZaYVJXUm9ZbFZ3VjFSc1ZtRldiRmw2WVVoS1YyRnJjRmhaZWtaclkyeGFjMXBIYkZkU1ZXdDNWbXhvZDFJeVJYaFhXR2hZWW14YVZGbHJXa3RqUmxwelYyNWtWMVpzY0ZsYVZXUkhZVEF4Y21KRVVsZE5hbFpJVmxjeFMxSXlUa2xVYkZwcFZrVmFWVlpxUm1GWlZrNUlWV3RvVUZZeWVGUlpWRTVEVGxaYVNHVkhPVkpOVm5Bd1ZUSjRjMkZHVGtobFIyaFdZVEZhYUZsVlduZFNiSEJHVDFaT2FWWnJjRWhXUkVaaFZERlNjMU51VG1oTk1taFlXV3RrVDAweFVsZFhiRXBzVW0xU2VWbFZXbE5oUlRGMFlVWm9XRll6VW1oWFZscHpWakpLUjFac1VtbFNWRlo1VjFkMFlXTXdNSGhYV0d4UFZsUnNiMWxZY0VkbFZsbDVaRWhPVjFaVVJsaFdiR2h2VmpGSmVtRkhhR0ZTVjFKVFdsY3hUMUl4Y0VoaFIyaE9ZbXhGZDFadGVHOWtNVTE0VkZob1ZGZEhhR2hWTUZVeFYwWnNjbFpVUm1wU2JGcDRWVzEwTUZZd01WaFZiR3hoVWxkUmQxWnRNVWRPYkVweVlVWmtUbUp0YUZsV2JYUnJVbTFXYzFadVRsZGlSMUp3VmpCYVMySXhaSE5XYlVaWVlsWmFXVlp0ZEc5aE1VbDVZVVpTVlZaV2NHRlVWbHBoVWxaR2RFOVhhRTVXYlhjeFZsZDRiMkl4V2toU1dIQm9VbTFTWVZacVRsTmhSbXQ1WlVaa2FsWnJjSHBXUnpFd1ZqSktSbUl6WkZkV2VrVXdWa1JLUjFZeFRuTmlSa3BvWVhwV1dWZFhkR3RVTURWSFZXeGFZVkpyY0hOVmJUVkRVMnhhU0dWSE9XaFdNSEJIV1RCYVIxWXlSbkpUYmtwWFZrVmFhRlZxU2t0VFZsSnpZVWRvVG1KRmNGSldiR04zWlVaVmVWWnNaRmhYUjNoUFZtdFdTMWRXVm5Sa1NFNU9UVlp3TUZrd1pFZFdNREZYWWtSYVdsWlhhR2hXYWtwTFVqSk9TR0ZHY0d4aE0wSlJWbFJDYTFJeFNYaGpSVnBQVmpKNGNGWnFTbXBsUmxweFUycENWazFWYkRWV1ZtaHZWbGRLU0ZWdVJsWmlSMUpVV1ZWYVYyUkhUalpTYld4T1YwVktXbGRzVm10U01WcEhWMjVPYWxOSVFsaFdhazVTWkRGYVJWSnJkR3BpVlhCR1ZsZDRhMVJzV1hsaFJFcFhZbGhTY2xWNlNrOWphelZYV2tkc1UySnJTblpXUmxwdlVURlNWMWRZYUZoaVZWcFhWRlprVTFJeFVuTlhiVVpXVW14d1ZsbHJXbE5YYlVwSVlVaEdZVlpzY0doV2JGcFBZMVpHYzJOR1pFNVRSVXBMVm14U1MwNUdiRmRWV0doWVlrZG9jMVZxUW1GV2JGcHpWMjVrVGsxV2NGZFdNakZIVmtaSmQwMVVXbHBXVm5CeVdWWmFZVlpXV25KaVJtaFhUVEZLYjFkV1VrdFNNVmw0Vkd4c2FGSnNTbGxWTUZaTFYxWmFkR05GT1ZKTlZUVklXV3RTWVZVeVNsWlhia1phVjBoQ1NGWXdXbXRqYkhCR1drWmFUbUV6UWxwWFZsWnZXVlpaZUZOdVVsWldSVXBYV2xkMFlXTnNWbkZTYm1SVFRWaENTVmxWV2xOVk1ERldZMFJTVjJFeGNHaFpWRVpXWlVaU2NscEdhRmhTTTJoUlZtMTRVMk14WkVkaVNFNVhZa2RTVDFSV1drdGxiRmw1WkVVNVdGSXdjRmRXYlhCVFYyc3hTRlZ1V2xkaGEwWTBWbXBLVDFOWFNraFNiRTVUVm0wNU5sWnNZM2hPUjFGNFUxaG9hbEpXY0ZCV2JURlRZMFpaZDFwR1NrNWlSbkF3VkZab2ExWkhSalpTYkd4WFVtMW9kbFl3WkV0ak1VNXpWbXh3VjFKWVFsVldiWGhoWXpGYVYxTnVTbXRTYldoWVdXdG9RbVF4WkhOV2JUbG9UVlp3V0ZVeU5VOVhSMFp5VTIxb1YySkhVbE5hUkVaelYwVXhWbVJHWkU1V01VbzFWMVpXWVdReFVuTlRiazVYWVd4S1dWWnRlSGRqYkZZMlVtMTBWRkpyY0hsWGExcFRZVlpKZUZOc1FsaFdla1V3VlhwR2ExWXhjRWRhUmxwb1RXeEtXRmRYZUdGWlZrNUhWMnRvVDFadFVsaFZha0phVFd4c2NsZHRPVmhpVlhCSVdUQldORll5Um5KWGJrcFhUVWRTVkZVd1pGTlNNV1J5VGxkb2JHRXhWak5XYWtaclRVZEplRlZZYUdsU2JWSlZWakJvUTFVeGJIUmpla1pYVFZkNGVsbFZZelZVYXpGWFUyeGtWMDF1YUZCV2FrRjRWakZrZFdOR1pGTk5NbWd5VjFaYVlWTXlVa2hWV0hCcVVtMW9XRlJVUmt0V1ZscDBZMFZrV0dKV1draFdSelZYVm0xS1dHRkdWbFppUjJoRVZqRmFZVmRIVWtkYVJuQlhUVVp3U1ZacVJtOWhNV1JJVTJ0b1ZtSnJXbFpXYWs1VFRURlZkMWR1U210TlYxSXdXa1ZhWVZSc1dYaFRhMmhYVmtWdk1GZFdXbHBsVms1elZteE9XRkl4U2xwV2JUQjRWVEZSZUdOR1pGaGlSVFZ5Vm0xNFMwMUdWblJsUms1V1RXdHdTbFZYTldGV01rcElWR3BPWVZaV2NGZGFWVnByWTJ4d1NHSkdVbE5XUmxveVZteGpNV1F5VFhoV2EyUllZbXhLYzFVd1pGTmpNVlowWlVaa1QxWnRkRE5XYlhNMVZqRlpkMk5GWkZwTlIyZ3pWakp6ZUZJeVRrbGpSbVJwVjBVME1GZHJXbUZXTWxKWFZHNU9ZVkpVVmxSVVZsWjNWR3haZVdSSFJscFdhMncxVmtab2MxVXlSWGxWYmtaV1lXdHZNRlpyV25OV1ZsSnlWR3hTYVZKdVFqWldiR1F3VkRGa2MxZHVVbXhTYldoWldWUkdZV1JzV25OWGJYUlVWbXRhTUZReFdtRmhWbHBHVjJ4V1YyRXhTa2hYVm1SUFZqRk9kVk50ZEZOV1IzaDNWbGR3UjFNeFpGZFhibEpPVTBkb1ZGUlhkR0ZTTVZKWFYyMTBWMUl3V25sVk1uaHJWMjFLUjFOc2FGZFNWbkJoV2tSR2EyUkhVa2RWYkdSb1RWaEJNbFl4WkRCWlYwVjVVbXhrV0dFeGNGbFphMXBoVjBaV2RXTkZXazVTYmtKR1ZXMHhSMkZyTVZsUmEzQlhWbnBGZDFaVVNrZE9iRnB6VVd4a2FWWkZSalJXVm1ONFZqRkplRnBJVmxSaVNFSlBWRmN4YjFaV1drZFhiVVpYVFVSV1dGWnNhSE5oTVU1R1RsWmtXbUpHV2pOVVZWcGhWMGRXU0U5V2FHbFNiWGN5Vm14a01FNUdaSE5YYkdScVVtMW9WbGxzYUc5VVJtdzJVbXhPYWsxWVFrZFViRnByVkd4YVdHUjZRbGRpVkVWM1dWUkJNVk5HVmxsaFJscHBZVE5DVUZacVFtRlRNa2w0Vm01U1RsWkdTbGxWYlhoaFRVWndWbUZIZEdoaVZYQklXVEJhWVZadFNsVlNXR1JYWVd0R05GWnFTazlTVmtweldrWmtiR0V4V1hwV2JYaFRVVzFXUjFOWWJGVmhNbEp3VlcweFUyTkdXWGRXYTNSVFZtMVNlVlpYZEd0V1ZURldZa1JXVm1KSGFETlhWbHBMWkVkR1NWRnNaR2hOYkVWM1ZtcEtOR0V4WkVoV2EyUmhVbTFTVDFWcldtRlRWbVJYVldzNWFFMVdjREJWYlhCaFlWWktkR0ZIUmxkTlIyaEVWVEJhV21ReFpIVlRiWFJPVjBWS1NsWkVSbUZoTVZKMFVsaHdVbUV5ZUZsV2ExWkxZVVpXVlZKdVRsZE5WVFV4VmxkNFlXRldTbFpqUm1oWVZqTm9kbFpIYzNoV01XUjFVbXhPYVZKVVZuaFhWbWgzVmpGa1IxcElTbGhpV0ZKdlZtMHhVMU5HVm5SalIwWlhUV3R3VmxWWGNGTldWMFY0WTBaa1lWWldjRlJhUmxwUFkyczFWMXBIYkZkaE0wSlpWbTB4ZDFFeVJYbFRXR2hoVW0xU2NGVnRlR0ZXVm14elZXNU9XRkpzY0RCVVZsSlRWakpLUjFkcVFsVmlSMUYzV1ZWa1MxSXlUa2xqUm1ST1lXeFplbFp0Y0VkWlZUVnpWMjVPVW1KSFVtOVpWRTVEVkZaYVdHTkZkRlZOVlhCWVZXMDFUMVl5U2toVmJrSlhZa1pLUkZScldtRmtSMVpIVkd4T1RsWlVSVEZXYTFwdllqRnNWMVJyWkZoaWExcFhXV3hTUjFaR1drVlNiazVZVWpGS1NWVnRlRk5XTWtwSlVXcGFWMkpIVVhkVVZWcGhVbXN4VjFkdGJGTlNiSEJaVmxkd1QxVXlWbk5pUm1oc1VsaFNjbFZ0ZUdGbFZsRjRWMjVrVjAxRVFqUlZNbmh2VjBkRmVGTnJhRmhXYlZKUFdsVmFZV1JXVG5Sa1JrNW9aV3hhTTFadE1IaE9SMUY0Vkc1T1dHSnJjR2hWYTFaTFYwWlNWMXBHVGxSV2JGWTFXa1ZqTlZZeVNsWmpSV3hhVmxkU2RsWnFTa2RqYXpWWFZXeGthR0V4YjNwV1YzaGhVekpOZVZScmFHeFNhelZ3Vm0xMGMwMHhXbk5aTTJoUFVtMTRXRlpYTlZOVk1rWnpZMFpTVjJFeFdreFdNRnB6WTJ4d1JrNVhlRk5pUm10NVZsY3dlRTFHV2tkVGJrcHFVMGRvV0ZSWGNFZGxiRnBWVTJ0MFdGSXdXa2xaVlZwcllVZEZkMk5FU2xkV2JFcElXVlJHU21WR2NFZGlSMmhUWWxkb2QxWnFRbUZUTVdSelYyeG9hbEpYVWxWVVZsVXhWMFphZEU1V1RtbFNhelZKVmxkNGIxWldXbGRUYTJoV1RVWndlVnBFUm1Ga1ZsSnpXa1UxYUUwd1NsaFdiR1EwVlRGRmVGZFliRk5pYTNCWldXdGtVMkZHV25SbFNHUldVbTEzTWxWdE1UQmhhekZ5VjJ0c1dtRXhjRkJaVlZWM1pERk9jMkpHWkdsV1JVbDZWMnhXVmsxV1RrZFdiR3hvVW14d2IxUlhlRXRsUmxwWVRWUlNhMDFYVWxoWmEyaFBWakpLVmxkc2JGZGlXR2hvV2xkNFlWZEhVa2hrUm1oVFlraENObFpYTVhkVk1XUklVbGhzVlZaRldsaFpWM1JIVGtacmVXVkhSbXBXYlZKNlZqSjRhMVJyTVhSYWVrcFhZbGhDUkZkV1duTldNVTUxVkd4V2FXSkZjSFpXVnpBeFVUSkplR0pHVmxOaWJWSnZWVzB4VTJWc1duUk5WV1JvVWxSR2VWUnNXbTlYUjBWNVlVWkNWMkpIVWt4Vk1GcFhZekZXYzFwSGJGTk5iV2hHVm0xd1IxbFdaSFJXYkdoWFlUSm9jbFZzVWxkV1JteHpZVWM1V0Zac2NIaFZNbkJEWVVVeFdGVnJiRlpOYWxaTVZqQmtTMUl4VG5SU2JHUk9VakpvUlZkc1pEUmpiVlpIV2toT1ZXSkhVazlXTUZaTFUxWmFjbGt6YUU5U01GcFlWVEZvZDJGR1NuUmhSbWhWVm5wV1ZGa3hXbE5qTVdSMFVteG9VMkY2VmpWV2FrbDRaREZWZUZkWWJHaFNiWGhZVlcweFRtVkdiSEZUYkdScVRWZFNNVlZ0ZUZOaFJUQjRVMnhzVjJKVVJYZFhWbVJYVWpGa2MyRkhlRk5pVmtwMlZsZDRVMUl4WkhOV2JHaE9WbnBzV1ZWcVFsZE9SbFY1WkVVNVdsWnNjRmhaTUZwRFZqQXhSMk5GZUZwTmFrWklWVEJrUzFJeFVuUmhSM2hwVW01Q1dGWnRjRWRoYlZaR1RWVmtWVmRIYUZsWmJYTXhWMVpaZDFwSE9XaFNiRnA1Vm0xME1GZEdTbk5UYkd4aFZsWmFjbFpFUm1Gak1rNUdZa1pXYVZKc1ZYaFdiWEJMVXpGYWRGUnJXbWxTYlZKWVZGUktiMDFzV25GVFdHaFVUVlp3V0ZVeU5VOVdiVXBKVVc1T1dsWkZXak5aYWtaclkyeGFkR1JHWkU1V1YzY3dWMVJDVjFsV1ZrZFhibEpXWW10S1lWWnJWa3ROTVZsNFYyMUdhMUpVUmtwWlZXUXdWR3hhVjFkVVJsZFdla1YzV1ZSR2ExTkdUblZUYlhCVVVsWndXRmRXVWtkWlZsSkhWMWhrV0dKVlduRldiWGhMWld4YVNFMVVVbWhXYTNBd1draHdSMWRIU2tkWGJrcFdZV3RhWVZwRVFYaFdNa1pIVjIxc2FXRXdjRnBXYlRGM1ZESkplVlJ1VG1sU2JIQm9WV3hhZDJNeFZuRlJWRVpVVm14R05GWXlNRFZYUmtweVRsVmtWazF1VGpSV2FrcEdaVVpPY21GR1drNWhhMXBaVm0xd1IxUXlVbGRVYmxKVFlrVTFjRlpxU205Tk1WcDBUVmhrVkUxcmJEVldWelZQVjBkRmVWVnNiRnBpUmtwNlZsUkdVMVl4WkhWYVIzaHBVbTEzTUZkV1ZtcE9WbGw1VTJ4YVYyRnNjRmRXYm5CWFZVWmFkRTFWZEZoV01GcEtXVEJhVjJGRk1WbFJiR2hZWWtad1YxUldXbUZqYXpsWFdrZHdVMkpXU25aWGJHUTBXVlpPVjFkdVNtRlNSa3BoVm0xNFIwNUdaSEpoUms1V1RWZFNTVnBWV210WGJVVjRZMFY0VjAxR2NGUldiWGhyWkZad1IyTkdaR2xoTUhCSVZteGpkMlZHU1hsU2JsSlVZa2RTVlZsVVNtOVhWbXhWVW01a2FtSkhlRmhXTW5NMVZUSktSbU5JYUZkU00yaHlXVlZWZUZkV1JuUlBWbVJwVW10d1NWWnRNSGhXTVVsNFkwVmthVkl5ZUZSWmExWjNaREZhV0dORlpGUk5WMUo2VjJ0YWExWnRSWHBWYkVKV1lsUkdWRlV3V25OamJVWkdUMVprYVZaWVFrcFdiR1EwWVRGYWRGTnNiR2hTUlRWb1ZteGFkMVl4Y0ZkYVJrNVRWbXRhZWxkcldrOWhSVEIzVTFSS1YySllRa3RVVm1SU1pVWndTVlJzYUdsU01VcDRWbGQwVmsxV1pFZGlSbWhyVWpCYVZsVnRlSE5PUmxsNVpFZDBhR0Y2UmxoWk1HaDNWMGRGZVZWdWNGZFdSWEJIV2xkNFIyTnRUa2RhUlRWWFRXMWtObFpzYUhkU01WWjBWbXhrVm1KSGVHOVZhazVEVmtaYWNWUnRPVmhXYlZKWldrVmtNR0ZWTVhKaVJGSmFUVVp3ZGxscldrcGtNV1J6WWtaa2FWWkZXbFZXYWtaaFZURlplRlp1U2xWaVIxSlVWbXRXWVZkc1duTmFSRUpwVFZac00xUldhRWRXTWtWNVlVWm9XbFpGV2pOWlZWcFhaRWRXU0dSSGRGTldSM2haVm0weE5HRXlSbGRVYTFwVFlXeHdXRmxVUm5kWFJtUlhWMjFHYTFKc2NIcFpWVnBoWVVVeGRHRkliRmRXTTBKTVdXcEtUMUl4V25WVWJXaFRWbGhDZVZaR1dtRmtNbFp6V2toS1ZtSkZOVzlXYkZKSFYwWnJkMWR0T1ZkTlJFWXhWVmN4YjFZeVJuSmpSWGhXWVd0YVVGbDZTa2RTTVZweldrWmthV0V3V1RKV2FrWmhWakZzV0ZSWVpFOVhSVFZWV1cxNFMyTnNWbkZVYTA1cVVteHdNRnBGYUd0V1JscHpZa1JXWVZKV2NHaFdSM2hoWXpKS1JWUnNWbGRpU0VKdlYxWmFhMVl5VG5OYVNFNW9VbXhhV0ZscmFFSmxiRnB4VVcxR2FFMVdiRFJYYTJoWFZsZEtTRlZyT1ZkaGExcE1WMVphV21WWFVrZFhhelZYWWtoQ1NWWlVSbTlrTWtaSFZHdGthbEp0YUZoWlYzTXhaR3hyZVdWR1RtcGlSMUl3V2tWYVQxUnRSWHBSYTNSWFlUSlJNRmRXWkVkU2F6RldWbXhrYVZKV2NGbFdiVFYzVW1zeFIxcEdaRmRYUjJoVVZGWmFZV1ZzWkhKWGJUbG9WbTFTU0ZVeU5XRlhSbHAwWVVST1ZtRnJXbkpWYWtaclYxZEtTR05HVGxkTlZYQmFWbXRhWVZZeVRYZE9XRTVwVW14d1dWbHJWVEZYVm14eVYyNWtiR0pIZEROV2JYQkRWMnhhYzJOR2FGcE5SbkJFVmpJeFYyTnRUa1psUmxwb1lURnZlbFpVUW10VE1VbDRZMFZrVldKSFVsaFpiR2hTWld4YWRFMUlhRTlTYlhoWVZteG9iMVpHWkVoaFJscFhUVWRTZGxZeFdscGtNWEJJVDFkb1UySkdXWHBXYWtsNFVqRlplVk5yYUd4VFIzaFpXVlJLVGsxV2JGaGxSWFJxVFdzMVNsbHJXbTloUlRGV1kwWldXRll6VW1oVmVrcE9aVlpTY2xkdGFGTmlWa3AzVm1wQ2EySXhWbGRYYmxKcVVsVndjMVZ0ZUhkbFZsSnpWMjFHYUZKcmNEQldWelZEVmpKRmVHTkhhRmRpUm5Cb1dUSjRWMk5zY0VkalJtUnBVMFZLWVZac1VrdE5SMFY0WWtaa1ZHSnJOVmxaYTJSdlZteGFjbFp0UmxSTldFSlpXbFZrUjFZeFduSlhha0pXWWxSR00xbFdXbUZqYkdSVlVXeGtUbUpzU2pKV2ExSkhXVlprUjFSdVNtaFNNbWhWVld4V2QxZEdaRmhsUms1WFRWVndTRlpzYUd0WFIwcFdWMjVHVjJKWVRYaGFWVnBYVjBkT05sWnNXazVoTTBKS1YydG9kMUV4V1hoWGExcFlZbXh3YUZWclZuZFRSbFp4VW1zNWExWnNXakJaVlZwUFZHeEtkVkZ1V2xkaVZFWXpWa1JHVm1WV1NuSmFSbWhZVWpGS1dsZFhNSGhWTVZwSFZXeGtZVkpyTlhOWmExcDNVMVpTVjJGSGRGZFdNSEJJV1RCYVlWWXlTbGxSYkdoWFlXdGFTMXBYTVVkVFIwWkhZMFprVTFkRlNrcFdiVEYzVWpGVmVWUnVUbUZUUlRWWFdXeGtORlpHVWxWVGJUbFlZa1pzTkZkclVsTldhekZXWTBSQ1YxWnRhSFpaVmxwTFl6RmtjMVJzWkU1U01Vb3lWbTEwWVdNeFpGaFVhMXBoVW0xU1QxWnFSa3RPVmxweFUxaG9UbEl3V2toV01XaHJWakpHYzJOR1pGZGhhelYyVld0YVlXTldUbkprUm1oWFRVWndTMVpVU2pSV01rWkdUVmhPVkdFemFGbFphMXBoWVVaa1YxcEdUbGROVmxveFZsZDRUMkZXU2xWV2JscFlZa2RSTUZkV1dtdGpNV1IxVTJ4b2FWWldjSFpXUmxaVFZqRk9WMWR1VWs5V1ZHeHZWbTEwZDJWc2EzZFhiazVZWWtkU1NsVlhOWGRXTURGSFkwZG9ZVkpYVWxSVk1WcDNVMGRXU0dKR1RrNU5WVmt5Vm0weGQxTnJNVmRWV0doaFUwVTFXVmx0Y3pGalZsWjBUVlJTV0ZKc2NIaFdSM2hQWVRKS1IyTklhRlpXYldoMlZsUkJlR05yTlZaYVIwWlhWbTVCZWxkWGRHdFNiVlpJVkd0a1UySkhhRmxWTUZaTFUxWmtWMVZyZEZWaVZscEpWa2QwWVZsV1NuTlhiVGxoVmpOb2FGWlZXbXRYUjFaSVpFZHNhR1ZyV2xsV2Fra3hWVEZTYzFScmFHaFRSWEJXVm0xNFYwNUdVbkpYYlVaVFRXdGFTVlF4V210Vk1rcFhVMnR3V0dKR1dtaFhWbHByWXpGa2NsZHNhR2hoZWxab1ZrWldZV1F4WkVkalJWcFhWMGRvV0ZSV1drdGxiR3hXVjJzNWFGWnRVa2xYYm5CTFZqSktXVkZyZUZWV1ZuQjZWakJhUzFkV2NFWk9WbVJwVm10d05GWnNZM2ROVmtWNFlrWmtWbUpHY0ZsWmJGWmhWbXhXZEdWSVpGUldia0pYVjJ0V2EyRkZNVlpqU0hCWFRXcFdlbFl5ZUdGV01rNUpVMnhrVTJWcldrbFhXSEJIWVRKT2NrMVdaR0ZTTW1odlZGVm9RMDVXV25OaFNHUlRUVlUxTUZadGRHdFdiVXB6VjJ4b1dtRXhXak5aTUZwWFpFVTFWbFJ0ZEU1V2JrSmFWMVJDVjAxSFJsWk5WbHBxVW0xb1dGUlhjRmRUUmxwVlUydDBWMkpIVWpCVmJYaHJZVWRGZUdORk1WZFdSVnBvVjFaa1UxTkdWbkpoUmtKWFlraENVRmRXVWs5Uk1XeFhWMjVPWVZOSVFsQldiWGh6VGxaVmVXVklUbWhTYTNCSFZHeGFhMVpXV25OalJFNWFWbFp3ZVZwVldtdGphemxZWTBaa2FFMVlRVEpXTVZKRFdWZEZlVkpzWkZSWFNFSmhWRlJLYjFkR2JISlhhM1JWVW14S1YxZHJWbmRpUmtwMFZXcEdWMVl6YUZSWlZWVjRZekZPYzFkc2FGZE5NVXB2VjJ0U1IyRXhTWGxUYTJ4VllsZG9WRnBYTVRSa2JGcFlUVWhvVDFKc2JEUldNV2h6VkRGWmVsVnNiRlppV0ZKNlZHdGFXbVZYVWtoUFZtaFRUVVpaTVZac1dtOWhNVmw0VjJ0YVUyRnNTbGhaVjNSM1ZVWldkRTFWT1ZOTldFSklWMnRrTkdGRk1WZFhXSEJYWVd0YWFGWlVSa3BsUm5CSlZXeGthVkl4U2xkWFZ6RXdaREpPUjFadVVtdFRSMUp3VkZaYVMxWnNWbGhrUkVKWVVteHdNRlpYZUhOWlZrcFlWVmhrVjJKVVJraFViWGhMWTIxR1IyTkhhRTVpVjJoS1ZtMTRVMU14VFhoWGJrNWhVMFUxYjFWdGVHRlhSbXh6VjJ0MFYxWnRVbnBYYTFKVFlVVXhjazVZY0ZoaE1taFVWbFZhV21WWFJrZGhSbkJvVFd4R05sWkdXbUZoTVZsNFYyNVNVMkpYZUU5V2JURXpUVlphVlZOcVVtcE5WbkF3VlRKMGIyRkdTblJsUm1oYVlrZG9kbFJVUm10V01XUjFXa1prYVZORlNraFdSRVpoVkRGU2RGSllhR3BTVjJoWVZXcE9iMkZHYkZWU2JYUlRUVlUxTVZVeU1YZFZNa3BKVVd4c1dGWXphRlJWVkVFeFVqRldkVk5zYUdsaGVsWmFWbGN4TkdRd01WZFhhMmhzVWpOU1dWVnRkSE5PYkd4V1YydE9WMDFyV25sVk1uaHJWbFphYzJOSFJtRldWbkJZV1hwR2QxSXlSa2hpUjJ4WFlUTkNVbFp0TUhkbFJUVkhZa1prWVZKdFVuRlZiWGgzWWpGV2MxVnVUbGhTYkVwWFZsZDBhMkpHV25Sa1JFNVhZbFJXVUZacVFYaFdiVXBGVjJ4YVYwMHlhRlZXYWtKaFdWZE5lVlJyYUZOaVZWcFlWRlJLYjFaV1pGVlNiVVpYVFdzeE5Ga3dWbTloUmtsNVlVVTVWMDFHV2t4WFZscGhZMVpLZEU5WGRFNVdWM2N4Vm14YWIySXhXa2RhUldob1VtMW9ZVmxzYUc5VVJtdDNWMnhrYTFJd05ESlZiVEYzVlRKS1dXRkdaRmRXYlUxNFdWUktSMUl4VG5WVWJYQlVVakpvV0ZkWGVGTlNNVTVIVjI1U2FrMHlhRmhaYTJSVFRWWnNjbGRzWkZkTmEzQktWVmMxYzFZeVJuSlRiV2hhVmtWYVVGVXdXa3RqYkhCSVlrWk9hV0V3Y0ROV2JYQkRZVEpKZUZWc1pHRlNiWGh4Vld4a1UxZEdVbGhqZWtaWVVteGFNRlJzV2s5V2F6RnlZMFZzVjFaNlZrUldiVEZMVjFaV2NWUnNaRTVXYmtKdlYxUkdZVlF5VGxkU2JrcFBWbXMxVDFVd1ZrdFRiRnB6Vld0d1RsWnNSalJYYTFadlZUSktjbU5HVmxwaVIxSjJWbXBHYzJOc2NFZFViWFJwVWpOUk1WZHNWbTlVTVZsNVUydGthbEp1UW1GV2JGcDNWVVphY1ZOcldteGlSVnA0VmpKNGExUnRTbk5UYlRsWVlURktTRlpVU2s1bFJsSnpZa2RzVTAxdGFGVldWekF4VVRGa1YxcEdhR3hTYXpWVVZGVlNWMlZzYTNkWGJVWmFWbXR3VmxscldtOVdWbHB6Vmxob1ZWWnNjRmhhUldSWFVqRndTR0ZHWkdobGJGcEpWbXhTUzA1SFRYaFhXR3hVWWtaYVZGWnJWa3RYUmxKWVRsVTVUMUpzV25oVmJURXdZV3N4VjJOSWNGWk5ha1o2VmpCYVMyTnRUa2RqUm1Sb1RWaENiMVp0Y0V0VmJWWkhZMFZhWVZJd1dsVlZiR2hEWkd4YVdHVkdUbXBOVjNoWVZqSTFVMkV4VGtoVmF6bFdZbGhvTTFZeFdsTmpNVnB5VDFaa1RtRXhhM2xXVnpFd1lqRlpkMDFZVmxaV1JVcFlXVmQwUjA1R2NFZGFSV1JVVWpCYVNGa3daRFJoUlRGWVQxUmFWMkpHU2toWFZtUlNaVVpPV1dGR1dtbGhNMEpSVm0wd2VGVXhaRWRWYkZaVVlYcHNVRlZ0ZUhkTlJsSlhWV3RPV0dKR2JETlphMUpYVm1zeFdHRklXbGROUjFKSFdsWmtSMUl4V25OalIyeFlVbXRzTmxadGNFZFpWMDE1Vkc1T2FsSlhhRkZXYlRWRFYwWnNjMkZIT1U5V2JHdzFXa1ZrZDFReFdYZFdhbFpXVFc1U2NsbFhlRTlUUjFaSFlVWldWMDB3U2tsV1ZFSmhZekZhVjFOdVNtcFNNMmhVV1Zod1YwNVdaRlZSYlVacFRXdGFSMVJXV25OVmJVcDBaVVpvV21FeGNFeFdSVnBYVG14S2NrOVdaRTVXV0VJMlYxZDBhMUl4VlhsVGJHaG9VMGRTV0ZadWNFWk5SbkJGVTJ4a1YwMVhVbnBaVldSM1ZURlplRk50YUZkaVZFVjNXa1JLVjFZeFZuTmFSbWhwVmxad1dWWkdaREJrTVU1WFYyeG9UMVpWTlZoWmJGWmhaVlpyZDJGSFJsZE5SRVpZV1RCb1MxWXdNVWhWYkdoV1RVWlZNVll3WkV0U2F6VllZa1pPV0ZKVlZqVldiWEJIWVRBeFIySkdhRk5YUjJob1ZXeGtiMVpHV1hkaFJVNVhUVmQ0ZVZZeWREQldNa3BIWTBSQ1lWWldjR2haYTFwTFpGWkdjMkpIUmxkV01VcEpWbTEwWVZOdFZrZGFTRXBxVW0xb2IxUlhlRXROYkZwelZXdGtXbFpyY0hwWGEyaFBZVlpLZEdGR2FGWmlSbG96V2xWYVlWTkhWa2hTYkdocFZteHdXVlpyWXpGVU1rWlhVMjVLYWxKNmJGWldibkJIWkd4WmVGZHRkRmROV0VKR1ZWY3hNRlJzV25WUmEyeFhZbGhvZGxsVVJtdFRSazV5WVVaYWFXRXhjR2hYVjNSaFdWVXdlRlpZYUZoaVIxSnlWV3BHWVZJeFVYaGFSemxYVFd0V05sVldhRzlXTVZwMFZWUkNZVkpGV21GYVJFRjRWakZ3U0dOR1RtbFNXRUphVm14a01GWXhiRmRUV0docVVteHdXVmx0TVZOV1JteHlZVVZPVkZKdGVGZFhhMk0xVmxkS1ZtTkdiRnBXVmtwb1ZtcEtTMU5HVW5GVWJVWlhWbTVDV0Zkc1ZtRmhNbEpYVlc1T1dHSlhlRlJVVmxaM1dWWlplRmt6Wkd4U2JGWTBWbFpvYjFZeVNuTlRiazVXWWxSR1ZGWlZXbUZrUlRWV1ZHeE9UbFl4U2pWV2JHUXdWREpHUjFOdVNtbFNSVFZoVkZWYVlXTnNXbk5hUlhSVFRWZFNNVmt3V205V01rcEpVVzA1VjJGclNtaFdha3BQWkVaS2NscEhhRk5pVmtwM1ZsUkNWMU15U1hoWFdHeHNVak5TVUZWdGVITk9WbHBZWkVjNVZrMXJWalZXVjNoelYyeGtTVkZzYUZkaE1YQjZXa1ZrVTFKdFVraGtSMnhUWWxoamVGWXlkRmRaVjBWNVVtdGFUbFp0VW5CVmExcExWakZTV0dOR1pGZFNiSEF3VkZaV1lXSkdXWGRYYTNCV1lsaG9hRmxWWkVabFZUbEpXa1prYVZkR1NtOVdNVnByVkRKTmVHTkZiRlZpV0VKVVZtdGFZV1F4V2xoTlJFWlNZbFpHTkZZeWRHdFdNa3BWWWtoQ1ZWWnNjRWhVYTFwV1pWVTFWMVJ0YkZOaE0wRjNWMVpXWVdJeFdYbFRibFpTWWtkb1dGVnNXbmRoUmxWM1drWmtWRkl4U2toV1IzTXhWakZhUjFacVRsZE5WbkJZVjFaYVdtVkdaRmxoUmxKcFVteHdXVmRXVWtkWlZtUkhZa1pvYTFKWVVtOVZiVEV6VFd4VmVXTjZWbWhoZWtaYVZWZDBkMVl5U2xWU2EyaFhWa1ZHTTFwRVJrOWtWbkJIV2taa2JHRXhXWHBXTW5SVFVqSkZlRk5ZYUdGVFJscFVXV3RhUzJJeGJGVlJibVJzVm14d1NGZHJVa05oTURGV1RsVm9WMkpIYUhwV1JFWmhWMVpXZEU5V2NHaE5WbTk2Vmxkd1IxZHRWbGhXYTJoUVZtMVNjRlpzV25kT1ZscElaVWM1V2xac2JEVlZiR2h2WVd4T1NWRnNhRnBXTTFKb1dUSjRjbVZWTVZkVWJGSlRUVVJXU2xkWGRHRmhNVmw0VTI1T2FsSlVSbGhaVjNSaFZrWldWVkp1VGxoU2EzQmFXVlZhYjFkR1NYaFRiRUpYVmtWS2NsUnJaRXBsUmxwMVZXczFWMUpyY0ZwV2JUQjRUa1phYzFadVVtdFNSVXBZVlcxMGQyVnNhM2RWYTA1WFZteHdlbGt3YUV0V01WcEdVbXBTVjAxV2NFaFpNakZQVWpGd1NHSkdhRk5OYldoaFZtcEdZVmxXYkZkVWJsSlhZVEpTVmxsdGVHRmhSbFowVFZaT2FsSnNiRE5YYTJNMVlWVXhXRlZ1YkZkV00xSnlWako0WVdNeVNrVlZiR2hvVFcxb1dWWnRNSGhTTURWelYyNU9hRkpzY0hCV01GcEtaV3hhZEUxVVVscFdhMncwVjJ0b1QxbFdTWHBSYXpsV1lURndhRlV4V21GalZrcDBUMWR3VGxacldUQldha2t4VXpGUmVGZHVUbXBTTUZwaFZtdFdZVTB4VWxWU2JHUnFWbXR3ZWxZeU1UUldNREZYWTBWd1dHRXhXbWhaYWtwSFZqRmtjMkpHU21oTmJtaFpWMVprTUdRd01IaFhhMVpUWWxWYWNsVnRkSGROVmxWNVpVYzVhRlpzY0ZoWk1HTTFWakpLVlZGcVVsZFdSVnB5VldwR1lWZFdjRWhTYkU1b1pXeGFWbFpyV21GaU1VVjRVMWhvVm1Kck5XaFZibkJ6Vm14c1dXTkZaRk5OVjNRelZtMXdVMVl3TVhKWGJteFhUV3BHZGxacVNrZGpiR1IxWTBaa2FHRXhjRTFXYWtaclVqRkplVkpyWkdoU2F6VlBXV3hrYjJGR1duUk5XR1JTVFd0c05GVnNhSE5XUm1SSVlVWm9XbUpZVW1oV2JGcHpZekZXZFZSc2FGZGlSbTkzVmtaYVUxVXlTa2hUYTJoc1VtMVNXVll3YUVOWFJteFdXa1YwVjJKVk5VZFphMlJIVlRGYWNtTkdiRmROVm5Cb1YxWmFXbVZXVW5KYVJrcHBVMFZLV1ZaR1VrSk5SVEZIVjI1R1VtSlZXbGhVVjNoTFYxWmFTR1JIZEdoaVJYQXdWbGQ0YjFkdFNsbFZhM2hYWWxob2FGcEZaRmRTTVZKelZHczFWMDB5YUZwV2JYQkhZakpOZUZkcmFGTlhSMmhaV1d0a05GbFdiRlZUYkU1WFVtMTBNMVl5TVVkaGJVcEhZMGh3V2sxSFVUQlpWbHBMWkZaR2MySkdaR2xTTVVZelYxWlNTMUl5VG5KTlZtUmhVako0VkZWdGRIZFhWbHBZWTBVNWFVMXNXbnBaYTFwaFYwZEZlbFZ1U2xaaGEwcG9WVEo0VjFkSFZrbGFSbWhUWVhwV1NGWlVTalJqTVZsNVUyeFdVMVpGU21GV2ExWmhZMnhXZEdNemFGZE5WbkI2VlRJeGMxZEdTbkpqUmtaWFRWWndkbHBFUmt0amF6RldXa1pvYVdKRmNGQldWM1JYV1ZaYWMxVnNaRmhpYlZKUFZXMTRZV1ZzYkZaaFJUbFhUV3R3VjFrd1ZuTlhiRnBYWTBoS1YwMXFSa3hWTUdSSFUxWmtjMVpzWkZOV2JUazJWbTF3UTJFeFdYaFRXR3hWWVRKb2MxVnRNVk5YUmxaMFpVaGtXbFpzYkRWYVJWcHJWMnhhZEdWR2FGZFdlbFpRVmpCa1MxTkhWa2RVYkhCWFRUSm5lbFpxUm1GWlYwNXpWMjVLYTFJeWFGUlpiR2h2VGtaYVdFMVVVbXROYTFZelZGWldWMVV5U2tsUmJHaGFZa1pLU0ZwSGVHRmpiR1J5WkVab1YyRXhjRFpYVjNSaFlqRlpkMDFJYUZSaWJYaFlXV3RhUzFOR1dsVlNhM0JzVW01Q1NsWnRlR0ZoVm1SR1UyeENWMUp0VGpSWmFrWnJWakZrZFZWck5WZFNhM0JvVm0xd1IxbFhWbk5YV0dob1UwVTFiMWxzV21GbFZsbDVUVVJXVjAxcldubFZNbkJQVmpBeFYyTkljRmRpVkVaSVZUQmFTMk14Y0VaT1YyaE9UVVZ3YjFacVJtRldNV3hYVmxob1dHSnNTbGhaYlhSM1YxWnNWVlJ0T1doU2JGcDZWakkxYTFkR1NuTmlSRkpZWVRGWmQxWlVRWGhXTWs1RlVXeHdWMVpzVmpSWFZscGhVekZrVjFKdVRtbFNiVkp2V1ZSR2QyVldXa2hrUjBaWVlsWmFTVlV5ZEd0WlZrbDNWMnhTVjJGcldreGFSRVpoVmxaR2MxZHJOVmROUm5CSlZtMHdNVll5Um5OVWExcFBWbXh3VmxadE1WSk5SbkJYVjJ4d2JGWlVWbGxhUlZwdlZUSkZlbEZxV2xoV1JVcG9XWHBHYzFZeFRuTmhSbHBZVWpGS1dWZFdaREJTTURWSFZtNU9XR0V6VW5GVVYzUmhVMFpyZDFwSE9WVmlSbkJhVlZkNFlWWXlTbFZTYWs1V1ZucEdXRlV3V2xOak1YQkhZVWRzYUUwd1NqWldiR04zWlVkSmVGcEZaR2xUUlhCdlZXeFZNVlpzV25STlZrNVlZa2QwTTFadE1UQmhSa3BWVW01d1ZrMXVVbkpXYkZWNFZqSk9TVk5zWkdoaE0wSk5WbFJDWVZZeVRYaFdiazVoVWxSV1ZGbHJhRU5VVmxsNVpVZEdXbFp0ZUZsV1JtaHZWakpLY21OR1dscGhNbWhFVmpCYWMyTXlSa2hQVm1oWFlraENWMVpVU25kVk1rWkdUVlprYWxKWGVGZFVWM0JYVkVaYVJWSnNjR3hXTUZwSVYydGFkMkZXU1hsaFJFcFhZVEZhYUZkV1drdFdNVTUxVld4T2FWZEdTbFZXUmxwaFpERk5lRmRZYkd0U2JIQlFWbXBDWVZkR1ZYbE9WbVJXWWxWYWVsVXllRzlXTWtWNFYycE9WVlpGV21oV2JGcExaRWRTU0dORk5WZE5WV3cwVm0xMGEwNUdWWGxTYkdoVVltdHdWVmxyYUVOWFZscDBaVVYwVkZKdFVsaFhhMXByWVdzeFdGVnVjRnBXVmxWNFZtcEdhMUl4VG5OWGJHUlhaV3RWZDFZeFdtdFdNazE1VTJ0a1dHSkhhSEJaYkZwTFpHeGFkRTFVUW1wTlJGWllXV3RhWVZadFJYcFZiR3hXWWxob00xcFhlRnBsVlRGWVQxWmtUbUV6UWxkV1Z6RTBWREZzVjFkc1pHcFNSVFZYVkZaYWQxWkdjRVpYYTNScVRWWktNRmxyV210VWJVcFlZVVpvVjJKVVJYZFhWbHB6VmpKS1IyRkdXbGhTTW1oWFYxWlNTMVV4WkZkWFdHUmhVa1pLY1ZscldtRk5SbkJXWVVkMFYySkZjSHBaTUZKRFdWWmFXR0ZHUWxkU00wNDBWbXBHVDJNeVJrZGFSVFZvWVRGWmVsWXhXbGRoTVUxNFUyNVNWV0V5VW5CVmJUVkRWMFphZEU1VlRrNWlSbkF3V1RCV01GVXlTbGRYYTJoWVlUSm9TRlpyWkV0U01XUnpZVVprYVZaR1drVldha1poV1ZaT1JrMVdWbFppUmtwUFdWaHdSazFXV25KYVJFSnBUV3R3U0ZVeU5VdFVNV1JHVTJ4b1dtSkhhRlJVVjNoVFYwZFdTRkp0Y0ZkaGVsWTBWbFpqZUdJeFVuUlRhMXBZVmtWS1dGbHNhRzlrYkd4eFVtMTBWRkpyTlRGV1IzaHZZVlpLVlZadGFGaFdiRXBNVmxkemVGSXhaRmxhUm1ocFZsWndlRmRYZEdGa01sWlhZMFZhWVZKRlNtOVdiWFIzWld4cmQxZHRkRmROVm04eVZXeG9hMVpXV2xkalJtUmhVa1ZHTkZZeFdrOWtSMDVIVkd4a1RtSlhhR0ZXYWtaclRrZEplVk5ZYUZkaE1sSndWVzE0ZDFkR1dYZGFSemxxVm14S1dGWnNVa2RVYkZwMFpVWmtWMDFxUlhkV2JYTjRZMjFPUm1OR1dsZE5NbWcyVm1wQ2ExSnRWa2RVYmtwc1VtMVNiMWxVVGtOVlJtUnpWMjFHVlUxck5UQlZNblJyVm0xS1dHVkdVbFZXZWtaMlZGUkdZV014Y0VWVmJGcE9WbTEzTVZac1l6RlVNV1JJVTJ0b2FGTkZOVmRaYkdoT1pVWmFjbGRzVGxkTlZuQXhWMnRrTkdGV1NuUmtla1pYVWpOb2FGWkVTa2RUUms1eldrWm9hV0pyU2xsV1JtTXhZakpTYzFkdVRsaGlWVnB4VkZkek1WTnNhM2RYYkdSb1ZtMVNTVmxWVW1GV01rcFZVbFJDWVZKRldsQlZiWE0xVmpGd1NHRkdUbWhsYkZvelZteFNRMVl4VG5KTldFNVlWMGRvVjFsVVFURlhSbEpZWkVaa1QxSnRlSGxXTWpFd1YwWkpkMk5GYkZkV2VsWklWbTB4UjJOdFRrbFhiR2hYWWtoQmVsWnFRbXRWTVU1SFUyNUtUMVpVVmxoWmExcHpUbXhhY1ZOcVFsZE5hMVkwVm14b2ExUnNXblJWYkZaYVZqTlNURmRXV25OV1ZrcDFXa2R3YVZJemFGaFdiWGh2WVRKRmQwMVdXazlYU0VKWldWUkdkMk5zYkZkWGJVWlRZa1p3ZUZaSGVHdFViRnAxVVcwNVYyRnJiRFJXYWtaYVpVWldkVlJ0YkZOTmJtaFZWMWQwVjJReFpITlhiR2hxVWxoU2NGUldXbmRsYkZsNVRsVmtWbUpWY0ZwV1Z6VkRWbFphZEZWc1VsWk5SbkI2V1RJeFIxSXhVblJpUms1b1RUQkthRlp0ZUdwTlZrbDRXa2hTVTFkSGFIRlZha3B2WVVaYWNWUnRPV3hpUm5Bd1dsVmtNR0Z0UmpaaVJtaFlZVEZWZUZaVVJrdFdNazVJVW14a1RtSnRhRmxYVjNCTFZHMVdSMXBHYkdGU1ZGWlpWV3hhZDFkV1pGaE5WRUpyVFZkU1NGWlhlR0ZYUjBwMFZXeGFWbUpVUlhwVVYzaFdaVmRPTmxac1drNVdia0kxVm1wSk1XUXhXWGxUYkZaVFltNUNXRlpyVmtkT1JuQkdXa1ZrVTFac2NIcFhhMlJ6VmpGS1YySkVXbGRpUjJnelZXcEdVMlJHV25KYVJsWnBVak5vZDFaWE1UUlpWMGw0Vld4b1QxWjZiSE5WYlhoM1YxWlNWbUZIT1ZkaGVrWllWVzF3VTFkdFJYbGhSbEphWVRGd1RGWXhXbGRqYXpsWFkwZG9UbGRGUmpaV2ExcFhXVlpWZUZkWWFGZGlhelZXV1d0a2IxWkdVbFpoUlU1WVZteHdlRlV5Tld0VmF6RlhZMFJDVmsxdWFIcFdiVEZMVjBkR1NGSnNaR2xTYmtGNlZtdFdZV013TlhOVGJsSnJVak5TV0ZsVVJuZE9iRnB4VTFob2FVMXJXa2RVVmxwelZXMUdObFpzYUZwaVIyaEVWVEJhYTFZeFpIVlViR1JPVjBWS1NGWnFTbnBOVmxsNVUydGthbEp0YUZsV2FrNVRZVVprVjFkc1NteFNNSEJJV1d0a2QxVXhXblZSYkVKWFZucEZNRnBFU2xkV01YQkhZa2R3VTFZeFNsbFdiWGhUVWpGa1YyTkdXbGhpVkd4WVdWaHdSMlZHV25SbFJrNVhUV3R3VmxWdGREUldhekZJVld0b1ZtRnJXak5WYWtwUFUwZEtSMVJyTldsV01sRXhWbTF3UzA1R2JGZGlSbWhXVjBkb1dWWXdaRzloUmxWM1YydDBWMUp0ZUhwWlZWcFBWakZLYzFOc2FGZE5hbFp5Vm10a1MxTkdWblZpUm1ScFYwZG9iMVpyVWtkWlYwMTRWMjVHVjJKR2NFOVpiWGhMWWpGYWNWRnRSbWhOVlRWWVZXMDFUMkZHU25OalJ6bGFWMGhDV0ZSWGVHRmpWa1owVW0xd1RsWnVRbGxXVkVreFZURlZlVk5yYUdoU2JFcGhWakJvUTFZeGNGWlhiVVpYVm1zMU1Wa3dWVFZXTWtwSVpIcEdWMVpGYjNkWFZtUkhZekZPV1dKSGFGTmlXR2haVjFkNGIySXhVa2RXV0dSWVltMVNWRlp0ZEdGWGJHUnlXa1JTVmsxcmNGaFZNV2h2VmpGYVJtSjZRbHBoYTNCSVZqQmFTMk5XWkhOYVIyeHBWMGRvV2xadE1YZFVNVVY0Vkd0a1YyRnNjRlJaVkU1RFl6RldjVkZVUmxOTlZtdzFXbFZqTldGR1duTmpSbWhhVFVad2NsWXdXbHBsYkZaMVUyeGtWMUpXY0V4WGJGWmhXVlprV0ZOcmFHeFNiRXBVVm10YVlWbFdXbk5aTTJoUFVqRkdOVlp0TlU5WFJtUklaVVpDVjJKSFVsUldNRnBoWTFaR2RWcEdVbE5pV0ZGNlZtcEpkMDVXWkVoU2FscFRZV3RhV0ZWcVRrTldSbHB4VTJ0a2FtSkhVbmhXUjNoaFlVZEZlbEZyYkZkV1JVcHlWWHBHU21WR1ZuVlRhemxYVFc1b1dWWkdZM2hpTWtsNFYyNVNUbGRIVWxSVVYzUlhUVEZTYzFadE9WZFNiVkpKV1ZWYWIxWXdNVWhWVkVKWFlsaG9lbHBGWkU5T2JFcHpZVVprYVZkSFpETldNVkpQWkRGSmVWSnJaRlJpYXpWWldXMDFRMWRHVWxoalJtUnFZa2Q0V1ZsNlRtOVhSa2w0VjJ0d1drMUdjSEpaVmxwaFVteGtjbUpHWkdsU2EzQkVWMnhXWVdFeFNYaFhibFpYWWxkNFZGbHNXa3RWUm1SWVRVaG9hVTFzV2xoV01qVlRZa1pKZWxWc1ZsVldiRnA2Vkd4YVlWTkhVa2xVYldocFVsaEJlRlpXWkhwT1ZscDBVMnhzYUZJd1dsWldiRnAzWVVad1JscEZPVk5pVmtwSVZsZHpNVll4V2tkWGEzQlhZbFJDTkZScldscGxSbHAxVld4U2FFMXRhSFpXVnpCNFlqRnNWMkpHVmxSaVZHeFVWVzB4TkdWR1ZuUk5WRUpYVFZad2VWUnNVa2RYYXpGSVZWUkNWMVpGY0V4Vk1HUlRUbXhLYzFwR1pGTldlbXQ2VmpGa2QxTXhTWGxVV0doVllteGFWVmxZY0hOWFZsWnpWbTVrV0ZKc2NFaFdiVEZIVjJ4YWMxTnJhRmROVjJoNldXdGFTMlJXUm5WVWJGcHBWa1phUlZaWE1UUldNV1JJVm10c1lWSnRVazlWYTFaaFYwWmFjVkpzVGxKTlZtdzFWV3hvYzFac1drWlRiVVpYWVRGYWFGa3llRlprTVdSeVQxZHdhVlpXY0VsV2FrbDRZekZaZDAxWVVtaFNiWGhZVkZaYWQxWkdWbkZUYkVwc1VteGFlVmRyWkhOV1JrcFhZMFpXV0ZZelVsZFVWbHByVWpGV2MxcEhSbE5oZWxaUVZtMHdlRlV5VmxkWFdHeHNVbFJzV0ZSVlVrZGxWbXQzVm01a1YySkdjREJaVldoTFZqQXhTRlZyWkdGV1ZuQnlXa1phUzJNeFduUmlSazVPVmxoQ1MxWnRlRk5STVd4WFZWaHNWV0pyTldoVk1GcExZMVpXZEdWRmRGZFNiRXBXVlRJd05XRlZNVmRqU0d4WFRXNW9jbFl5ZUZwbFJrcHhWbXhrVjJWc1dsRldha0pyVXpKT2MxcElUbGRpU0VKWVZXeFNWMVpXV25Sa1IwWldUVmRTU1ZaSGNHRlZNa3BHVGxoQ1ZtSlVWa1JWTW5ocll6RmFkR1JHVGs1V2JrSmFWbFJLTUZsWFJuTlRhMXBZWWtkU1dGbHROVU5STVZKWFYyMUdhbFpyY0RCVmJYTTFZVlpLV1ZGc1pGZFdiVkV3V1dwR1dtVldUbk5hUmxKcFVsVndXbGRYZEdGWlYwNXpWMnRXVTJFelVuRlVWM014VWpGa2NsZHRkR2hXYkd3MVdWVm9kMWRHV1hwVmJXaGhVa1ZhY2xsNlJtdGtWbFp5VGxaU1UwMVZjRkZXYlRCNFRVWnNXRlpzWkZaaVIxSnZWV3hTYzFkV1ZuRlJibVJzVm14S2VsZHJWbXRXTVZwelkwVmtXazFIYUdoV2FrWmhWakpPUjJGSFJsTldiRmt3Vm0xNFlWWXlUWGxTYTJSVllsZDRWRlJVU2s5Tk1WcHhVbTFHVjAxcldubFViRnByV1ZaT1JrNVdiRnBpV0ZJeldURmFWMlJGTVZoUFZuQlhZa1Z3V0ZacVNURmhNVlY0VTI1T2FsTkhhRmRVVnpWU1pERlpkMWR0Um1wTlZUVjZXVEJhZDFZeFduVlJibXhYWVRKUk1GVjZTbE5XTVVwMVVteG9hVkl5YUZsV1YzaHFUa2RSZUZwR1pGWmhNMUpYVkZaV2MwNUdXa2hPVm1SWFlsVndXVmxWV2xOWGJHUkpVV3hvWVZKRldtaFdNRlY0VWxaS2MxTnJOVmROVlhCS1ZtMXdTazFXVVhoYVNFcE9VMGQ0YjFWdGRFdFdNV3hZWkVWMFdGSnNTbmxXTWpFd1lXMUtSMk5FUW1GU1ZuQjJWbFJLUzFZeFRuSmpSbVJwVWpBeE5GWlhjRWRaVjFKSFZHNUtZVkl6UWxSVmJGSlhWMVphUjFadFJtdE5hMXBJV1ZST2IxZEhTa1pPV0VwV1lrWktlbFl3V21Ga1IxWkdUMWRvVjJKV1NrcFhWbFpoWkRGWmVWTnNiRkpoTTJoV1ZteGFWMDVHVm5GU2JYUllWbTVDUjFSc1dtOVZNV1JHVTJ4S1YySlVSVEJaVkVwS1pVZEtSMXBHYUdsaGVsWmFWMWN3ZUZVeVRsZGlTRXBZWW0xU2MxVnRlRmRPVm5CV1drUkNhRkl3Y0ZkWk1GWnZWMnN4U0dGSVdsZGhhMXBMV2xjeFIxTldUbk5qUm1ScFUwVktUbFl4VWtwbFJsRjRVMjVTVkdFeVVtaFZha28wVmtac1ZWUnJUbFJpUm5Bd1dUQldkMkpHU25OaVJGSldUVmRvZGxacVNrdGpNV1J6WVVad2FFMVlRbTlYVkVKaFZqSk9WMVJ1VWxCV00xSlBWbTAxUTFkc1pGVlJiR1JPVWpCYVYxUldhRTlXUjBwMVVXeG9WVlo2VmxSWk1uaGhZMVpPY21SR1RtaGxiRnBaVjFaV1lWWXhXWGxUYkdSVVlrWmFXRlpyVmt0aFJteFZVMnM1YWsxWVFrcFdWM2hEVmpBeGRHRkdRbGRpV0doeVZGUktWMk14WkhWU2JGSm9Za1Z3V1ZaR1dtRmtNV1JIVjFoc1QxWlViRmhVVm1SVFUxWnNWbGR0ZEZkV2JIQllXVEJTVDFkc1dsZGpSRTVXWWxob2FGWnNXa3RqTVhCSVlVZDRhVmRIYUdGV2JYQkxUVVphY2sxV1pGaFhSM2hWV1cxMGQxWldiRlZVYTA1WVVtMTRlbGxWVms5V1ZrcHpVMjVzVjAxdVVtaFphMXBMWkZaR2NtTkdaRmROTW1oVlYxWldWbVZIVFhoVWJsWm9VbTFTV0ZSVVNtOU5iR1JZWTBWa1dHSldXa2xWTW5ScllVWkplbFZzVWxWV1ZuQXpWakZhWVZJeFpIUlBWa3BPVmpGS1NWWXlkRzlUTVdSSVUyeHNWbUpIVWxaV2FrNVRUVEZaZDFkc1dteFdNVXBKVkRGYWIxVXdNVWRYVkVKWFlsaG9kbGxxUmxwbFZrcDFVMjF3VTFkSGFHaFdSbU14WWpGV1IySkVXbFJoZW14VVZGWm9RMUl4VW5OWGJYUm9VbFJDTTFVeWRHdFdNa3BWVVdwU1lWSkZXazlhVlZwVFpGWldjMXBIYUU1aVJYQjJWbXhqZDJWRk5VaFRXR2hYWW14S2MxVnNhRk5qVmxaMFpVZEdiRkpzV2pCYVJWSkRWMFpKZDJORmJGZFdNMmg2VjFaYVMxZEdWbGxhUm1ScFYwVTBNRmRVU2pSaE1rNTBVbXRrWVZKVVZtOVphMXAzVld4YWRHTkZUbWhOVlRFMVZsZDBhMVl5U25KT1ZtaGFZVEZ3TTFrd1dtRmpiRnB6V2tVNWFWSnVRa2xXTW5SVFZURlpkMDFZVGxSaE1uaFlWbXBPVTFkR1dsaE5WWFJZVWpCYVNWUXhaRWRXTURCNFUyMDVWMkZyYnpCWFZtUk9aVWRLUlZkc1RtbFhSVXBRVm0wd01WRXhaSE5YYkZaVVlXdEtiMVJYZEdGbGJGVjVUbFU1VjFJd2NFbFpWVnB2VjJ4YVJsZHRhRnBXVm5CNlZtMTRhMk14Y0VoalJtUm9UVEJHTTFZeWRGZGhNbEY0Vlc1T1dHSnNXbE5aVjNoM1YwWlNXRTVXVG1waVIzY3lWVzE0ZDJKR1NuSk9XSEJZWVRGd2NsbFZaRWRPYkZwellrWm9WMDB5YUZWV1YzQkNaREpXUjFkdVZsTmlSa3B2V2xkNFlXVnNXbGhOU0doV1RWZFNlbGxyV21GWFIwcEdUbGM1VjJKWVVucFViWGh6Vm0xR1NGSnNaRTVXYlRoNVZsWmtkMVV4WkhSU2JrcHFVbGhTYUZac1duZFhSbXcyVTJ0a1UyRjZiRmhYYTJRMFlWWmtTRnA2UmxkaVdGSm9WMVphYzFkR1ZsbGhSMFpUWWxaS2VGWlhlR0ZrTWtaSFZtNU9ZVkpyTlZsVmJYaGhaV3hhV0dSSGRGaFNiSEI2V1RCYWMxbFdTbGhVVkVaWFRVZFNURlp0ZUdGalZscHpZMFprVjJKSGRETldiVEYzVXpGSmVWUnVVbFZoTVhCelZXMHhVMk5HV1hkYVJ6bHNWbTFTV2xrd1ZqQlZNREZXWWtSU1YwMXFWbEJYVmxwS1pWZFdSMVpzV21sU2JHOTZWa1prTkZsWFVraFZhMmhUWWtkU1QxWnFUbTlYYkZwelYyMDVhVTFXY0VsVk1qVkxWREZrUmxOc1pGcFdSVm96VkZSR1dtUXhaSFZVYlhCcFUwVktTVlpyWkRSaU1WVjVVMnhzYUZKR1dsbFdiWGhoVjBaYVJWSnNTbXhTYlZJeFZsZDRZV0ZXU25WUmJHaFhZbFJXTTFWcVJrOVNNa3BIVjJ4a1dGSXlhRmxXUm1Rd1pERktjMWRyYUd4U2JWSllWRmQwZDFkV2JGWlhiazVYVFd0d1ZsVlhjRk5XYlZaeVYydDRXbVZyV2xSYVJscFRaRWRHUjFSdGJHaE5TRUY2Vm0xNGEyUXhUWGxUV0dST1YwVTFhRlZ0TVZOWFJteHpWbTFHYWxac1NsZFdWM2hyWWtkS1IxWnFWbFZpUm5CUVZtMXplR050VGtkalJscFhUVEpvTWxacVNYaFNiVlpIV2toR1ZXSkdXbkJXTUdSdlpWWmFkR1ZIUmxOTmJFcEpWbGQwWVZWR1duSk9WVGxXWWxSV1JGVXhXbUZqYkdSMFVteHdWMDFFUlRCV2JUQXhWVEZhU0ZKWWJGWmlSM2hoV1ZSS1UyUnNXblJsUjBaclZqQTFTRmRyV210Vk1rcEpVV3BXVjJGcmJ6QlpWRXBIWXpGa2RWTnRjRlJTTTJoWFYxZDBhMVZyTVVkWGJrWlVZVE5TVkZsc1ZuTk9iR3hXVjIxMGFGSlVSbnBWYkdoclZqSktXVkZyZUZaaGExcHlWV3BHVDJSV1NuTmhSMnhUVFZWd00xWnNZM2ROVmtWNFdraE9XR0pzU25GVmJGSnpZMFpTV0dWRmRHeGlSM2g1V1ZWV2ExWnJNWEpqUm5CWFZqTm9kbFpzV21Gak1rNUZWR3hXVjJKSVFsbFhhMVpyVmpGSmVGVnVVbWhTYlZKd1ZUQldTMU14V1hsbFJtUmFWbXhzTkZZeGFITldSMHBIVjJ4U1YyRXhXa3haVlZwWFkyeGFkVnBHYUZOaVdHTjVWbGN3ZUUxR1pFZFhXR1JxVWxkU1ZsbHJXbmRqYkZweFVWaG9WMkpWTlVoWk1GcHJZVVV4V1ZGc2JGZGlSa3BJVlRJeFYxSXhjRWRpUjJoVFRXNW9WbFpYZUc5Uk1XUkhXa1pvYTFKc2NFOVdiVEZUVTBaYVdHVkhkRmhTTUhCNldUQlZOVmR0UlhoalJFNVZWbFp3TTFWdGVGZGpNVkp6WVVaT1RsTkZTbGxXYlRCNFpERlZlRnBJU2s1V1YxSlpWbXRXUzFkR2JGaGtTR1JVVW0xME5WUldWVFZWTURGV1YyNXdWMDFxUm5aWlZWVjRWMVpHY2s1V1pFNVdNbWQ2Vmxkd1MxVnRWa2RWYmtwb1VteEtiMVJYZUV0V01XUllaVWQwVDFKc2NFaFpNRnB2Vkd4a1NWRnVUbGRpV0dnelZGVmFVMVp0UmtoUFZsWk9WbGhDTmxadE1YZFZNVnB5VFZab2FGTkdjR0ZXYlhoM1ZFWndSbHBGWkZOTlYxSjZWMnRWTVZVd01WWmlNMnhYWWxoQ1NGZFdaRTVsVmxKMVZHMXdVMVpzY0ZoWFYzaHJUa1pSZUZkdVVteFRSMUpRVlcxNGQyVldaRlZVYlhSVlRWWnNNMVl5TlhkV2F6RnhWbXhDVjAxSFVraFpNbmhQWkVkR1IxcEhiRk5OVlc5NVZqRlNTMDVHWkhSVldHaGhVMFpLVkZsc2FFTlVNV3haWTBaa1UwMVdjRmhYYTFKVFZqQXhWMkpFVmxaTmJsSm9XVmQ0UzFZeFpITmlSbVJwVjBkb2IxWnRjRWRrTVZweldraE9hbEl6YUZSWmJYUkxVekZhV0UxVVVsUk5hMXBZVlRJMVYxVnRTa1pUYkd4WFltNUNSMVJWV2xkT2JFWlpZVWR3VGxkRlNrbFhWbFpyVFVaVmQwMVZaR3BTYkhCWVZXMHhVMDVzY0ZaV1ZFWlRUVmhDU2xVeU1XOVZNa1kyVm01YVYxWjZSWGRhUkVGNFVqRmtjMkZGT1ZkV1ZGWlpWMWQ0VjFsWFZsZFhXR3hyVWtaS1dGUlhkRmRPUm10M1drYzVWMkpWV25sV01qRnZXVlpLVjJORmVGcGxhM0JRVldwR2QxTkhTa2RhUjJoT1RVVndUbFp0TUhka01sRjVWbXRhVGxaWGFGVldNR1J2VjBaWmQxcEVVbGRXYlhoV1ZUSXdOVll3TVZobFJFSmhVbFpaZDFacVFYaFhSMVpIWWtkR1UxWXhTa2xXYlhoaFV6Sk5lRlJ1Vm1wU2JWSlBXVzB4Ym1Wc1pGaGtSMFpZWWxaYVNGWkhOVXRoVmtwelkwaENWMDFIVW5aYVZscGhZMnh3UlZWc2NGZE5SRVV3VmpKMFlWWXhWblJUYTJoV1lsUnNZVlpyVm5aa01WSnlWMjFHYW1KR1dubGFSVnBQVkcxR05sSlVRbGRoTWsxNFZrUktSMUl4VGxsalIyaFRZa1Z3YUZkWGRHdFZNbEp6VjFob1dHSllVbGxWYWtaaFUwWmFTR1ZGT1ZWaVJuQjZWakZTUTFZeVNraFZWRUpZVm14d2NsVXdXazlqYlVaSFYyMXNhRTFZUWxwV01XUTBZakZWZDAxSWFGWmlSbkJaV1d0a1UyTnNWbk5WYTJSWVlrZFNlVll5ZUd0aFJscHlZMFJDWVZOSVFrUldha1poVW0xT1JWUnNhRmRpU0VKNVZsZHdSMkV4WkZoVWEyUllZbGQ0V0ZSWE1XOVhiRmw0VjIxMFRsSXhSalJXUjNSclYwZEtjbGRzVWxwWFNFSjZXVEZhVTFkSFVrbGFSbEpUWWtaWk1WWkdXbTlVTVZweVRWVldVbUZzV21GV2JGcDNUVEZhY1ZGWWFGaFNiRnBXVlZkNGQyRkhSWHBSYTNoWVlrWndhRlY2U2s5ak1rNUdZVWR3VTJGNlZsbFhWM1J2VVRGYWMxZFlhRmhpUlRWV1ZGWmFWMDVHV1hsa1IzUlhZbFZ3U1ZaWE1XOVdiVXBaVkZob1dtVnJXbnBaTW5oM1VqRlNkR1ZHWkdsV2EyOHhWbXBHYjJReFdYaFhXR1JPVm14d2NWVXdaRFJaVmxKV1YyNWthRkpzY0hoVk1uUXdWMFpaZDFkclpGcFdWbkJ5V1ZWa1JtVkhUa2hQVm1SVFpXdFZkMVpZY0VkaE1WbDVWR3RhWVZJeWFGUlpiRnBMWkRGYWRFMVVRbXROVjFKNlZqRm9iMkZHVGtoVmJGSlZWbTFSTUZZeFdtRlhSMVpJWkVaa1RtRXpRalpXVkVreFZERmFkRk5zYkZWWFIyaFlWV3RXWVZkR2NFWldWRVpYWWtaS2VsbFZXbXRoVms1R1UxUkdWMkpZUWt0YVZWVjRVakZXZFZSc1VtbGhlbFozVmxkMFZrMVdXbk5pU0VwWVlsVmFjVmxyV25kbFJsWjBUVlJDVjFKcmJEUldNblIzVmpGSmVtRkhhRnBXYkhCTFdsVmFUMk14V25OYVJUVlhZbXRLZGxacVJtRmhNVlY0Vkd0a1dHSnJjSEJWYlRGdllqRndXR1ZIUm10TlZuQlpWRlZTUjFWdFNsZFNhbEpZWVRKb1VGWnFTa3RXYkdSelYyeFdWMkpJUWpaV1IzaGhWbTFXV0ZWcmFHdFNNbWh3Vld4b1ExZHNXbk5hUkZKcFRWWndXRll5Y0dGV01rcHpZMGRvVm1Gck5YWlpWVnB5WlVaa2NrOVhjR2xUUlVwS1YxUkNhMk14VlhkTlZscHBVa1UxV0ZSV1duZFhSbVJYV2taS2JGWnJOWGxaVlZwUFYwWkplV0ZJWkZkU2JFcFFWVlJHYTFJeFpIVlRiR1JvVFRGS2VGZFhkR0ZrTVVwelZtNVNhMU5IVW5CVmJYUnpUVEZTYzFadGRGaGlSbkJaVmxjMVlWWXhXa1pYYldoV1lXdGFjbGw2Umtkak1YQkhXa1UxVG1KWFpEVldiWGhoVlRGSmVGVllhRmhYUjJob1ZUQmFZVll4YkhOaFJVNVhVbXhzTTFZeWREQldiRnB6WTBac1ZWWnNTbFJaVjNONFVsWmFjbUZHWkU1V01tZzJWbXRTUjFsV1pGZFdiazVZWWtoQ2IxUldhRUpsYkZwSFZtMUdXbFp0VWtsV2JYUnZWVVphZEdGSVFsZGlSMmhFVjFaYVlXTnNaSFJQVjJ4T1ZtMTNlbFpHV21GaE1rWnpWR3RzVW1KVldsWldibkJYWkd4cmVXVklaRk5OVjFJeFYydGFUMVJ0UlhoalJXeFhUVzVTY2xsNlJtdFNNVTVaWWtkb1UySllhRmxYVjNoVFVtMVJlR0pHVmxKV1JWcFVWRlphWVZkc2JGWlhiVGxZVW10c05sbFZXbUZYUmxwelUydDRWMVpGV25KV2FrcExVMVpXY2s5V1pGZFdSbHBoVm14amVFNUdUWGhhUm1Sb1RUSlNXRmxzYUZOWFJsWjBaRWhrYkdKSGRETlpWV2hQVmpBeFJWSnFSbGRXYldoeVZqSjRXbVZzVW5GVmJHUk9VbTVDV1ZkcldtdFVNVWw1Vkd0b2FGSlVWbkJWYkdoRFV6RmFkRTFJYUd0TlZXdzBXV3RhYjFaV1pFaGxSbHBhVmtWdk1Ga3dXbGRrUlRGWFZHMXdVMkpIZDNwV2JURXdUVVphVjFkdVRtcFNiWGhoVkZWYVlWUkdXa2hsUm5Cc1VtczFlVmxWV210Vk1sWnpWMnN4VjJGclNuSlZla1pyVmpGS2RWUnNXbWxUUlVwM1ZsY3dNVkV4VWxkWGJsSnNVakJhWVZadGRITk9SbHAwVGxWMGFFMVZiRFZhVlZVMVYyeGFSbUl6Y0ZWV1ZuQm9XVEZhVDFaV1NuTlhhelZvVFZoQk1sWnNVa3RPUjBsNFYyNVNWR0pHY0ZsWmEyUnZXVlpzY2xwSE9XdGlTRUpaV2xWYVQyRnJNVmhWYWtKV1lsaG9WRlpVUVhoV2JVNUdZMFprVjJWclZYZFhWbEpMVWpGWmVGcElUbWxTYTNCdlZGUkNTMWRXWkZoa1IzUldZWHBHU0ZscmFFZFZNa3BaVlc1S1ZtSllUWGhhVmxwelZteGtkRkp0YUZkTlNFSkxWbFprTkdFeFpFZFhXSEJvVTBad1lWbFhkSGRUUmxaeFVtMUdXRlp1UWtsVmJYaFBZVWRXYzFkc1pGZGlSMDQwVkZWa1VtVldXblZVYkdob1RXMW9lRmRzWkRCWlYwbDRWbTVHVTJKVlduTldiWGgzWld4c1ZscEVRbGROUkVaNVdUQldiMVpyTVhWVldHUlhZa1p3YUZsNlNrOVNNVkowVW14a1YySnJSalpXYkdOM1pVWkplRk5ZYUZkaWJFcHZWV3hTVjFkV1ZuTldibVJXVFZad01GUlZhR3RVYkZsNFVtcFdWMUp0YUhwV1ZFcEdaVlpXYzJKR2NHbFhSa3B2Vm0weE5HTXlUWGhXYmxaVllsZDRUMVp0ZUhaa01XUnpWbTA1YUUxV1ZqVlZNblJyVjBkR2NsTnNXbGRpV0dob1dUSjRXbVF4WkhKa1IzQnBWbFJXU1ZacVNqUlpWMFpYV2tWa1ZGZElRbGhaVjNSMlRVWmtWMWRzY0d4V2JFcDVXVlZrYjFVeVNsZFRiRlpYVW14S1RGbHFTa3BsUm1SMVZXMXdVMVl4U25aV1JscGhaREZrUjFadVVrOVdWR3hoVm0xMGMwNVdjRlpYYlRsWFlsVndTRmt3V205V1ZscEdWMjFHWVZaV2NISlpla1pUWXpGU2NrNVdaRTVXVjNkNlZtMHdkMlZGTlVoU1dHaFlZa2RvVlZsdGN6RlhWbXh5V2tjNVdsWnRlRlpWYlRGSFZHc3hXR1JFVGxkTmFsWlFWbXBHWVdOdFRrVlNiR2hvVFZoQ2VWWnJaRFJaVjFKWFVteHNZVkp0VWxSWmEyaERWbFphYzFWclpHaE5hekUwVjJ0YWMxbFdTblJoUnpsVlZucEdkbFl4V21GU01YQkpXa1prVGxaVVZrbFdha28wVmpGYVNGSlljRlppUmxwWFdXeG9iMkZHVWxkWGJGcHNWakZhU1ZWdE1XOVZNREZIVjFSQ1dGWkZTbGRhVlZwYVpVWmtXV05HU21oTmJXaHZWbGQwVjFsV1VrZGlSRnBUWW0xU1ZWWnRlR0ZsYkZwSVRWaE9WMDFFUmpCWlZWcDNWakF4V0ZWWVpGcGhhMXBIV2tSQk1WZFdVblJTYkU1cFVtNUNWVll4WkRSaU1WVjRWMnRrVm1KSFVtaFZiWE14VmxaV2RHVklUazlXYkVwNlZteFNWMWRHU25KaVJFNWFUVVphZWxZeWVHRlhSbFp5WVVab1YySklRbWhYYkdRMFZqSlNTRkpyWkdwU2JWSllXVzEwU2sxc1duSlpNMmhQVW1zeE5WWlhkRzlXYlVWNVlVaEtWbUpVUmxSWk1GcFhZekpHUmxOck5XbFNiWGN3Vm1wS05HRXlSa1pOV0VwcFVrWktXRlp1Y0ZkV1JscHlXa1YwVkZJd1drbFVNVnBoWVZaYVJsWllaRmRoYTBwb1ZsUkdXbVZIVGtaYVJsSm9aV3hhVlZkWGVHOWlNRFZIVjJ4b1RsWkdTbFpVVjNSaFRVWldkR05IUmxaTmEzQkpWbGQ0YzFkc1drWmpSbEpWVmtWYWFGWnNXa3RrUmtwMFkwVTFhR1ZzV2twV2JUQjRUa2RKZUZkWWJGUmhNWEJ4VlcxMFlWZEdiSEpYYTNSVlVteHdSbFZ0ZUhkaVJscHlUbGhzV21FeGNGUlpWbHBLWlVaT2MySkdaRmROTW1odlYydFNTMVl5VFhoalJXUm9Vak5TVkZSVlduZFhWbHBIVm14T1YwMVhVa2haYTFwWFZsZEtkRlZ0T1ZwaE1Wb3pWakZhWVZkSFZraFBWbVJPWVRGd05WWlVTbmRVTVZsNVVtNUtXR0p0ZUdoVmExWmhZMnh3UjFkc1RtcE5hMXBKV1d0YVQyRlhSWGRqUjBaWFlsUkdNMVV5TVZkVFJrNVpZVVpvV0ZJemFGVlhWekV3WkRKT1YxWnVUbUZTYXpWdlZXMTRkMlZzV1hsT1YzUm9ZbFZ3U1ZwSWNFdFdhekYxVlc1S1YxWkZSalJaTW5oclkyMUdSMkZIYUU1aVJXOHlWbTB4ZDFNeFNuUldiazVUWW10d2NWVnRNVk5pTVd4VlUxUlNhMDFXY0RCWk1GWnJZV3N4VjJKRVVsZFdNMmg2V1ZaYVMyTXlUa2xSYkZwb1lURndUVlpxUW1GaE1XUkdUVlpzYWxKVVZsaFphMmhEVG14a1dHUkhPVlZOVjNoWVZUSjBhMVpIU2toaFJtUmFZa1pLUjFSVldsTldiR1IxV2taT2FWSnVRalJXVm1RMFlUSkdTRlp1U2xoaVIzaFpWbXRXUzJSc2NFVlNiSEJzVW0xU1dsa3dXbUZoVmtwV1kwWnNXRlp0VVhkYVJFWlBVakZXZFZWdGVGTlhSa3A0Vmtaa01GbFdUa2RhU0VwaFUwVTFWMVJWVWtkTlJtUnhWRzVPVjAxcmNGcFZWM1JUVjJ4YVJsZHJPV0ZXYkhCVVdrWmFUMk5yT1ZkYVIyeFhZVE5CZVZadGVHcGtNREZYVWxoc1ZXRXlVbGhaYlhoTFl6RlZkMXBHVG1wU2JFcFlWakkxYTJKSFNrZGpSbXhoVWxkUmQxWnFTa2RPYkVwellVWndhRTFWY0ZWV2FrcDZaVVpKZUZwSVZsUmlSMUp3VldwR1MxUldXbkZTYlhSVFRWVnNORlp0TlU5aGJFbDVZVVU1VjAxR1draFViWGhoWkVkT1JtUkZPVk5OUmxreFZtdGpNVlF4WkVoVGJrNVVZa1ZhV0ZsWGRIZGtiRnBGVW01T1YxWnJjREZYYTFwVFlWWktkVkZzY0ZkU2JIQjJXVlJHYTJNeFpIVlViR1JvWWtad1dGWkdZekZWTWxKelYyNVNUbFpZVWxWVmFrSmhVMFpaZVdWSGRHaFdNSEI1VlRKNGMxZEhSWGxWVkVKYVRXcEdXRll3V21GamJVWkhWRzFzV0ZKcmNGWldiVEV3VmpGc1YxcEZaR0ZUUlhCWVdXeFdZV05HVWxkWGJrNVBWbXhXTlZwRlpEQmhSMHBHWTBWb1YwMXVhSHBXTWpGR1pVZE9TR0ZHY0ZkV2JrSTJWbTE0WVZNeVRYbFVhMmhzVW0xU2NGVXdWa2RPUmxwelZXdDBUMUl3YkRWVmJYaHJWa1prU1ZGdE9WWmlWRVV3VmpGYVlXUkZNVmRUYlhST1ZqRktXVll5ZEZaT1YwWnlUVlprYWxKRldsZFpiR2h2VlVac1ZsWllaR3hTYXpVeFdWVmFhMVV5U2tsUmJUbFhUVlp3VjFwVldscGxSbkJKVTIxb1UwMHlhRlZYYkdONFRrZFNjMWR1VWs1V1JVcHhWRlZTVjFOR1duTmhTRTVWVFZac05sWlhlRzlXVmxwelkwUktWVll6YUZoV2FrcEhVMFU1VjFwSGJGTmlhMHBKVm0xd1MwNUhTWGhYV0d4VFltdHdXVmx0ZEhkaFJsWjBaVWhrVmxKdGR6SlZNblJyVmtaSmQyTkZhRmhoTVhCeVdWWmtSbVF5VGtWVGJHUnBWa1ZKZWxkclVrdFdNVXB5VFZaYWFGSnNXbGxWYWtaTFZWWmFkRTFJYUZaTlYxSllXV3RhVjFaSFNsVmlTRVphWVRGd2FGUldXbkprTWtaR1QxWm9VMkV6UWpaV1ZFbzBZekZzVjFOc1pHcFRSWEJZVld0V1lWUkdjRVphUms1VFZteEtlbGRyVlRGaFYwcFlZVVJXVjJKWVFrUlpWRVpPWlVaa2RWUnNhR2xoTVhCWVYxZDBhMVV4VVhoaVNGSnJVbGhTVjFadGVIZE5SbXQzVm10MGFWSnJjSGxaYTFKWFZqRkplbFZ1V2xwV1ZuQk1Xa1phUjJSV1VuTmpSbVJUVm0wNU5sWXllR0ZaVjBWNVZHNU9ZVk5HU2xSWmJHaFRWREZhYzFwRVRrNVNiSEF3VkZWU1IxWnJNWEpYYkdoV1RXcFdURlpFUm10U2JFNTBVbXhrYUUxV2NFMVdSbEpIVm0xV1IxcElVbE5pV0ZKVVZtdFdZVll4V2xkWk0yaHBUV3RhU1ZadE5VdFhSMHBKVVd4b1YyRnJOWFphUjNoelRteEtkRkpzVWxOaE0wSmhWMWQwYTJJeFZYbFRhMXBxVWpKb1dGbHNhRU5WUm14eFVWaGtiRkp0VWpGVmJYaFBZVmRHTmxac2NGZFdNMEpJVjFaYVNtVkhUa1pYYkdocFYwWktWMWRYZEdGak1EVnpZa1phVm1KVldsbFZiWGgzWld4WmVVNVZaRmRXTUhCSlZsZDBiMVp0Um5KWGJFSmhVbXh3VkZwRlpFOVNNVkowWWtaU1UxWllRbUZXYlRFd1dWZEdjazFXWkZkWFIzaFVXVlJLVTJOR1ZYZFdibVJZVm0xNFZsWkhkRTloYlVwSFUyeGtWMVl6YUhKV2FrRjRWMGRXUjFwR1pFNWhhMVl6Vm0xd1FtVkdTbGRTYmtaWFlraENXRlpxUVhkbFJscDBZMFYwVkUxWFVsaFZiVFZMWVVaS2MyTklUbHBXUlZveldXcEdZV1JIVGtaYVIyaE9Za1Z3V1ZaVVNURlVNVnAwVTJ4b2JGSnNTbFpXYlhoaFRURlNWVkp0Um10U01EVkhWa2N4YjFSdFJYbGtla1pYVmtWYWRsbHFSbXRUUms1MVZHeFNhV0V4Y0ZoWFYzUnJWVEZhUjFkWWFGaGlhelZ4VkZaa1UwMUdWblJsUms1V1RXdHdXRlV5Y0ZkWFJscHpWMjFvV2xaRldtRmFWVnBQVjFad1NHTkdUbWxXYTNCYVZtdGFhazFYU1hoWGEyUllWMGQ0VDFac1duZGpNVnB4VVcxR1UwMVdjRmxhVldRd1lVWmFjbU5FUmxaV2VrRXhWakJhWVZKc1pIUmhSbHBvWVROQ1ZWWlVRbUZXTWs1MFVtdG9hVkpyTlZoVmJYaDNWMnhhZEUxVVFscFdiWGhZVmtjMVQxZEhTbk5UYmtaV1lrZG9WRlpWV2xkalZrWjFWR3M1VTJKSVFscFdSM2hXVGxaa1IxTllaRmRoYkVwaFZGVmFkMWRHV1hsTlZWcHNVakExU1ZsVldtdGhWbVJJWVVjNVdHRXhXbkpXYWtaUFZqSk9SbUZIYUZOaGVsWjNWMVpTUTJReGJGZFhXR3hzVW0xU1lWWnFSa2RPVmxWNVpFZDBXRkp0VWtsWlZWcHpWMnhhUm1OSVdsZE5WbkI2Vm14YVQyTXhVblJrUjJ4VFltdEtXRlpzVWt0TlIwVjRWVmhzVkdFeVVuRlZNR1EwWVVaV2MxZHVaR3BpUm5CNFZUSjBNRll3TVZaalJuQllZVEZ3ZGxacVFYZGtNVTV5WWtaa2FHRXlkekJXYlhCSFYyMVdSMVp1VmxkaVJscHdWbXBPYjFaV1drZFpNMmhwVFZad1dGWXlkR3RYYXpCNVlVaENWVlp0VWxSVk1GcGFaVmRTU0dSR1pFNWhNMEpZVm1wSk1WTXhXbGRYYmxKV1lrWktWMVJWV25kWlZuQldXa1ZrVkZJeFNraFpNRnByWVVVd2QxSnFUbGRpV0doeVZHdGFWbVZHY0VsVmJFNVlVak5vZGxaWGVHRlRNVmw0WWtab2ExSXdXbGRVVm1oRFZqRlplVTFVUW1oTlZXdzBWVEowYjFZeVNsVlNibkJYVmtWd1RGa3llRXRqVmxaeldrZHNVMkpyU2pWV2ExcFhZVEZTZEZaclpHRlNiWGh3VlcxNFMySXhVbGhsUlhSWFlrZFNXRlpYY3pWaFZURlhZMGh3V21FeGNGaFdWRXBMWkVaV2MxZHNWbGRpVjJoRlZtMXdSMWR0VmxaTlZsWlNZa2RvVkZsclpETmxiRnB4VTJwQ2FVMVhVbnBXTW5odlZtMUtkVkZzYUZkaE1WcElWR3RhWVdSRk1WWlBWazVYWWtad05sWXlkR3RqTVZWM1RWWmFWMkZyTlZoVVZtUlRUVEZXY1ZKcmRHdFNiSEI1VjJ0a2QxVXhXblZSYlRsWFZucENORlpVUm10V01WcDFVbXhPYUUweFNubFhWM1JoWkRGa1YyTkdXbGhpVlZwV1dXdGFkMlZzYTNkWGJUbFhUV3R3VmxadGVGTldNVWw2WVVkb1ZtRnJXbEJaZWtwSFVqSk9TR0ZGTlZoU1ZYQXlWbTEwWVZZeGJGaFZXR2hVWW1zMWNWVnNXbUZWTVd4eldrYzVWMUpzU2xkV01qVkxZa1phYzJOR2JGVldiRXBVV1ZWVmVGZEdWblZpUmxaWFlrWndNbGRXVm1GVE1VcHlUbFprYUZKc1dsaGFWM2hoVFd4a1YxWnRSbHBXTURWWVZrYzFTMVZHV25OVGJHaGFWMGhDV0ZSdGVGcGxWMUpIVjJzMVYySkdXVEZXVkVreFV6RmFTRkpxV2xkaVIyaGhXV3RhUzFJeFVsWlhiWFJYVFZkU01WWkhlRzlWTWtwR1kwZEdXRlpzV21oWlZFcEhWMFpLY1Zkc1pHbFdSM2haVm0xd1QxRXhVa2RWYmtwWVlsaFNXRlJXV25kTlZsWjBaVVpPYUZac2NFbGFWVnAzVjBaWmVsVnRhR0ZTUlhCWVZXcEdZV1JXVm5KT1ZtUlhUVlZ3WVZZeFpEQlpWMUY1Vm14a2FFMHlVbGRaVkVFeFYwWlNXR1JJWkZoaVJuQlpWR3hXTUZkR1NuTmpTSEJhVFVad1JGWnRNVXRXVmtwelVXeGFUbFp1UWtsWFdIQkhZVEpTU0ZKcmFHaFNWRlp2V1d4a2EwNXNXblJOU0dSc1VsUkdTRmxyV210WFJtUklaVVprV2xaRmNIWldha1p6VmxaT2NWVnRhRk5pUm05M1ZrWmFhazVXV1hoVGJsSnNVMGhDV0ZSWE5WSmtNVmwzV2tWMFZGSnNXakZaYTFwcllWWmFSbGRyYkZoV2JGcFhXbFZhYTFJeFduVldiWEJUWWxaS1VGZFdaRFJaVmxaWFdrWmtXR0pWV2xWVVZsWnpUa1phU0U1Vk9XaFNhM0F4VlZjMVExWnRTbGxWYWs1WFRWWndhRnBGWkZOVFJrcDBZMFUxVjJKclNscFdiRkpLVFZaTmVWSllhRlJYU0VKVFdXeFNjMkZHV25GVWJUbG9VbXhzTkZZeU1VZGhiRnB5VGxob1YxWjZSblpXUnpGR1pVZE9SMkpHWkU1aWJFcFpWMVpTUjFsV1NYaGpSVnBwVW10d2NGVnFTbTloUm1SWVpFZDBhVTFWY0VoV2JHaHJWMGRLU1ZGdVRsZGlSa3BJVmpCYWEyTnNaSFJQVmxwT1lUTkNTVmRVUWxOV01WbDVVbTVLYVdWclNsZFdhMVpoV1Zad1YxZHJPV3BOV0VKSVZsY3hjMkZXV25KalJuQlhZbFJCZUZwRVJrZGtSbHB5V2taa2FWSnNjRlJXYlhSWFdWZE9WMVZzWkdGU2F6VlBWbTE0WVUxR2NGWlhhemxYVFVSR1Yxa3dXbTlYYXpGSVlVaGFWMkZyV2t4WmVrcFBVMVpPYzFwR1pGTldWbXQzVm14a2QxSXlSWGxWYkdSWFltdHdVVlp0TVZOWFZsWjBaRWhrV2xac2NIcFhhMmhyVldzeGMxSnFUbFZXYkZweVdWZDRTMk15VGtoaFJscHBZbXRLTmxacVFtRmpNazE0VjI1T1lWSlViRlJaYTJRelRWWmFSMWR0Y0U5V2JHd3pWRlphWVdGc1NuUmhSMFpWVmxkU2RscFhlR3RXTVdSMFVtMTBVMkpHY0RaWFZsWmhXVmRHVjFwRldrNVRSMmhZV1ZkMFMyTnNXa1ZTYTNScVlYcFdXRmRyWkVkVk1ERjFZVVpXV0dKSFRqUlVWVlV4WXpGa2RWVnRjRk5YUmtwUlZsY3hOR013TlVkaVNFcFlZbFJzV0ZWdE1WTlRWbXhXVjIwNVYwMUVSa2xXVjNoVFZqRktSbGR0Um1GU1JWcHlXVEl4VTFOSFNrWk9WbVJwVTBWRmVWWnRNWGRUYXpGWVVsaG9ZVkpYVWxWWmJYaExZekZWZDJGRlRscFdiSEI2VjJ0Vk1WUnNXblJsUm1SWFRXNVJkMWxVUmt0ak1XUjFZMFp3VjFadVFubFdhMk40VXpKU1IySXpjR3BTYldoWVZGUkdTMkl4V2xsalJYUlZUV3MxZVZSc1dtdFpWa2w2VVd4U1dtSllVa3hXTVZwaFpFVXhSVkpzU2s1aVJuQlpWakowWVdFeFdYbFRhMlJxVTBVMVYxbHNVa2RXUmxsM1YyeGthMUpVVmxoWGEyUnZZVlpLV1ZGWVpGZGlSMUV3V1dwR1lWWXhaSEpYYlhCVVVtNUNiMVp0TVRSa01rWkhZa1JhVTJKSFVuRlphMmhEVTBacmQxZHRkR2hTVkVZeFYxUk9iMVl5U2tkVGEzaFZWbGRTUjFwVldtdFhWMHBIVlcxb1RsZEZTalJXYkZKRFZqRk5lR0pHWkdsVFJYQlpXVzB4VTFac1ZuUmxTRTVPVFZac05WUldWbXRXYXpGRlVteHNWMVl6UWtSV2JURkxWbFpLV1ZwR1pGTmxhMXBOVmxkd1MxUXhTbGRhU0U1aFVqSm9iMVJYTlZKTlJscDBaRVpPVkUxVmJEUlZNV2h2VmxkS2NsZHNiRnBpUjFFd1ZteGFWMk14V25WYVJtaFRZbFpLV1ZZeWRGTlJNVnBHVFZWV1VtRnNTbGhaYTJSdlkyeFpkMXBGZEZSV2Exb3hWa2Q0YTJGSFJYaGpSemxYVmtWYWFGWlhNVmRTTVhCSlZXMTBVMkpHY0hkV2JYaGhWMnN4YzFkc1pGcE5NbWhVVkZaYWMwNVdWWGxrUnpsWFZtMVNTVmxWV210WlZsbDZWVzFvV0Zac2NETldiWGhyWkVkU1NHTkdaR2xXYTI4eVZtMTBhbVZIU1hoVmJrcE9WMFpLYjFWdE1UUlhSbEpYV2taS1RsSnRlSGhWYlhoUFlURktjMk5JYkZoaE1YQnlXVlprUjA1c1duTmpSbWhYWWtWd1VWWnNVa3RVTWsxNFYyNVdWbUpZVWxWVmFrWkxaV3hrV0dSSGRGWk5iRnBZVmpGb2MxUnNXa1pUYlRsV1lsaG9NMXBXV2xOak1WcDBaRVprYUdWcldYaFdhMXBUVWpGWmVWSnVTbXBTV0doWVdXdGFkMVJHV25OWGEyUnFUV3MxU0ZkcldrOVdNVnB6WVROa1YySllhSEphUkVaT1pVWlNXV0ZHVWxoU01taDRWbGQ0YTFVeVNYaFdia1pVWVd4S2NGUldhRU5YVm5CV1drVmthRTFyY0VoWk1HaDNWakZaZWxWc1FsZGhhMFkwV1hwR1MyTldXbk5hUms1c1lrWndVbFp0TVhkVE1VMTVWRmhvVldKc1dsWlphMXAzWWpGc1ZWRnVaR2xOVm5CNFZWY3hSMVl3TVhOVGEyeFhZbGhTZWxkV1drdFdWbHB6Vld4d2FWZEdTazFXYWtKaFlURlplRmR1VW10U1ZGWlVXV3RrTTAxR1dsVlRWRVpWVFd0YWVsWkhkSE5WYlVwV1YyeGFWMkpHY0ROVVZFWjNVMGRXUjJOSGRFNVhSVXBJVm1wSmVFNUdWWGxTYWxwWFlXeHdXRmxyWkZKTlJteFZVbXh3YkZKck5YcFdNbmh2VmpGS1ZtTkdiRmhXTTJoMlZWUkdVMUl4WkhKV2JFNW9aVzE0V2xaWE1UUlRNbFpYV2toS1lWSlhVbGRVVjNSM1YwWlZlV1ZGVGxkTlZYQXdWa2R3VTFkdFNsbFVhbEphWld0YWNscEdXbGRqYXpWWFdrWk9hRTB3U1hsV2JYUmhXVlphZEZacldrOVdWMUpZVmpCa05GVkdXblJqZWtaWVVteHdlRlZYZUd0VU1WcHpZMFpzVlZaV1NsaFdha3BMVm0xT1IxZHNXbWxYUjJoVlZtcEtlbVZHU1hsVWEyUm9VakJhVkZadGVGZE9SbHAwVFZSU1ZVMXNTa2xXYlhSdllWWktjazVZUWxwV1JVb3pXVlZhWVdOV1RuRlJiR1JPWVRGWk1GWlVSbTlpTVd4WFZHdGFUMVp0ZUdGWmJHaE9aVVpyZDFkc1pHcGlSMUl3VlcxNGExUnNXWHBoUkZwWVZteGFhRlpFU2t0VFJrNXlXa2R3VkZORlNscFhWbEpIV1ZkT2MxZHJWbFJoTTFKWVdXeFZNVkl4YkZaWGJYUlhUVVJDTlZkcVRuZFdNa3BaVVd0b1ZtVnJXbUZhVmxwUFYxZE9TR05HVG1sV2EzQldWako0YTAxR1duUlZXR2hZVjBkb1dWbHNWbUZpTVZKWFZtNWtiRlpzU2xoV01qRXdWakF4Y21ORmFGcE5SMmhFVm0xemVGSXhaSEpsUm1ST1ZtNUNlVlpxUW10Vk1VNUdUMVprVkdGNlZsaFVWbFoyVFd4YWRHTkZkRTlTTUd3MFZsYzFUMVpIUlhoalJteGFZVEZ3YUZadGVHRmpWbEp6Vkcxb1UySnJTbHBYYkZaaFdWZEtSMWRzVmxkaVIxSldWRlphZDJOc1dsVlJXR2hVVm10YWVWa3dXbTlXTWtwSFkwYzVXRll6UWtoWlZFcE9aVVp3U1ZOc2FHbFNNbWgzVmxkd1IxTXlTWGhYYmxKc1VqQmFjbFJWVWtOT1JscHpZVWQwV2xacmNEQldWM2hUVmxaYWRHRkZVbFpOUm5CeVdUSjRhMlJIVWtoaFJrNVhVbFZzTmxac1VrZFZNVTE0VjFoc1UySnJjSEJVVkVwVFYxWmFkRTFXVGxOTldFSlhWako0YTJFeFduTlRibkJhVmxkU2VsbFdXa3RrVmtaelZteGtUbFp1UW5sV1IzUmhZekZaZUdORldtRlNiSEJ3VldwS2IxVldXblJOV0hCT1ZqQnNORlp0TlZOaVJrNUlWV3hTV21FeGNHaFVWVnAzVm14d1JscEhhRmRoTTBJMVYxUkNVMUV4V1hoWGFscFhZbTVDV0ZSWE5XOWhSbGwzVjJ4a2FtSlZXa2hYYTFwUFZHc3hSVlZxV2xkTmJsSlVWV3BHVW1WV1VsbGlSbEpvVFd4S2IxWlhNWHBOVjA1SFYyNU9WbUV4Y0U5VmJYaDNUVVp3Vmxkck9WWk5SRVo1Vm0xd1UxWnJNVmhoU0ZwWFRVZFNURmt5ZUd0ak1rcEhZMGRvVGxac1dUQldNVkpEV1ZaWmVWVnJXazlXYkhCV1dXeG9iMk5HVm5ST1ZVNVlZa1p3U0ZZeU1EVmhNREZYVTI1d1YwMVhhSFpXTUdSR1pWZEdSMkZHVmxkaVZrb3lWMnhrTkZsV1RraFdhMmhyVW1zMWIxcFhlR0ZYVmxsNVpFZEdWMDFXYkRWVk1uUnpWV3hrU1ZGc2JGcGhNWEF6V1ZWYWNtVlZNVmRUYlhoVFltdEtTMVpzWTNoTlJsVjVVMnhrVkdKRlNsaFpiRkpEVGtaU1ZWRllhR3BOV0VKSVYydGFhMkZXWkVkVGJtUlhVbXh3Y2xaVVJrOVNNV1JaWWtVNVYxWkhlSFpYVjNSWFpESldWMVpZYkd4U00xSlpXV3RhYzA1c1dsaE5WemxZWWtad1dGa3dhSGRXVjBwWllVWkNXazF1YUROVmFrWlhZekZTY2s1V1pHbGhNSEJNVm0wd2VFMUhSWGRPVldoVFYwZG9WMWx0Y3pGWFZteHlXa1JTVmsxWGVIcFdiVEZIVjBaS2RHVkdiR0ZTVjFKSVdWVmFTMlJIVmtsaFJscE9ZbTFvVFZkWGRHRlpWMDE0Vkc1T2FsSnVRbGhXYlRWRFYxWmtWMWR0ZEZOTlJGWjZWakkxVDJGc1NuUmhSbWhhWVRGYU0xWkdXbXRYUjA1R1pFWldhVlpzY0VsV2Fra3hWakZhV0ZOc2FHaFNiRXBoVmpCb1ExZEdXWGxsUjBaWVVsUkdWbFpYZUZOVWJGbDRVMnRzVjJGclduWlpla1pTWlVaa1dXTkdXbWxTTTJoWVYxZDRiMVV3TUhoVmJGcFlZbTFTVkZscldtRmxWbEY0VjIxMFZXSlZWalpWVnpGSFYwWmFjMWR0YUZaV1JWcGhXbFphUzJSV1RuTlViV2hwVWxoQ1dsWXhXbXROUjFGNFZtdGtWMkpzU25OVk1HUlRWa1pTVjJGRlRsTk5Wa3A2VjJ0b1QyRkdXbk5pUkZaYVZsWmFjbFpxU2t0V1ZrWnhWV3hXYUUxc1NraFhiRlpoVkRKU1YxWnVUbUZTTW1oUFdXeGtiMWRHV1hoWGJFNVRUV3hHTlZaR2FHOVdNa3B6VTJ4Q1YySkdWWGhaTVZwVFZqRndSVlZzWkdsU2JHOTNWa2Q0YTAxR1dYaFhiazVxVWtWS1dGWnFUbTlOTVZsNVl6Tm9VMDFYVWpGVk1uaDNWakZLVmxkVVFsZGlWRVkyVkZaYVlXUkdUbkphUjBaVFlYcFdVRlpHV2xka01EVlhWMjVTVGxaR1NtOVVWbFY0VGtaYVNHUkhkRmROYTNCNVZHeGFhMWR0UlhsVmJGSmFUVVp3YUZreWVHdGtSa3B6Vkd4a2FWTkZSak5XTW5SWFlURkplRnBJVGxoWFIxSlFWbTB4YjFkR1ZuVmpSbVJVVW14d01GUldWakJYUmtsM1YydHNWVTFYVWtoV2FrRjNaVVpPZEU5V1pHaGhNWEJ2VmpGYWExUnRWa2hUYTFaWVlrVTFjRlZ0ZEhkVlJscDBUVlJDYTAxRVZucFdNalZMV1ZaS1JsTnVRbFZXTTFKb1ZUQmFWbVZWTlZkVWJXaFRZVEozZWxacVNYaFNNVmw1VWxob1dHRnJOVmhaVkVaM1lVWnJlV1ZIZEdwTmF6VkpXa1ZWTVZZd01WWmlSRkpYWWxoU2NsUnJaRVpsUm1SWllrWk9hR0pJUWxsWFZtUTBaREZrUjJKR1ZsUmhlbXhRVlcwMVExSnNWblJsUjBacFVteHdlVlJzYUhOWFIwVjVWV3BPVjFaRldreGFSbHBIWXpKS1IyRkdaRTVOVlhBMVZtMTRhbVZHVm5SV2EyUmhVMFZ3V0ZsclZURmpSbFp6Vld4a2JGSnRVbGhaVldoclZUQXhXRlZyYUZoaE1taE1WakJrUzFkV1ZuUlBWbHBvWVRCdmVsWlhjRWRqYlZGNFkwVm9VRlp0VWs5WlZFNURXVlprVjFadGRHbE5WbXcxVlRKNGMxWlhSbk5UYkdoYVZqTlNhRmt5ZUhkU01XUnlaRWR3VGxac2IzZFhWbFpXVFZkR1YxTnNiRkppUlRWWVdWZDBZV05zVWxaWGJIQnNWbXhhV2xscldtdGhWa2w0VTIwNVYxWkZTbGhhUkVaclZqSktTVlJ0YUZOaGVsWlpWMWQwYTA1SFZuTlhibEpQVmpOU2NGVnFRbmRUUmxwMFkwWmtXbFpzY0ZoV01qVkxWakpHY2xKcVVscE5ha1pRVldwS1QxSXhaSE5hUlRWT1ZsYzVOVlp0TVhkVE1EVkhZa1prVkdKck5XaFZNRlV4VlRGc2NsZHVaRlZOVmxvd1ZHeFdUMWRHV25SVmJGcFdZbFJHU0ZsVlZYaGphekZWVld4a1UyVnNXbFZYVmxwaFV6Sk9jazVXYkZKaVNFSllWV3hXZG1Wc1dYaFhiVVphVmpGS1NWWlhkRzlWTWtwSFkwVTVWMkpHU2tkVVZscGhWbFpLZEU5WGJFNVdia0phVmxSS01HSXhXblJUYTJoc1VqQmFZVmxyWkc5a2JGcEdWMjFHVTFacmNEQlZiVEYzWVZaSmVGTnFWbGhoTVZwb1dWUkdXbVZXVG5KWGJYQlRZbXRLV2xacVFtOVJNVlpIWWtoR1UySkZjSE5WYlhNeFRWWmFTR1ZIT1doU01GWXpXVEJhYTFkR1dYcFZiV2hYVFdwR1UxcFZXbXRrVmxKMFVteE9XRkpyY0ZaV2ExcHJaV3N4VjFSdVRtbFRSWEJaV1d0a1UySXhXblJrU0dST1ZteGFXVmt3VmpCV01ERnlZMFp3VmxZelVUQldiVEZYWTJ4a2RHRkdaR2hoTVhCNVYydGFZVlF5VFhoYVNGSnBVbXMxY0ZsVVFuWmxiRnAwWlVkd2EwMUVSbGhWYkdoelZrWmtTR0ZIYUZaaVZFVXdXVEZhVjJNeGNFZFViV3hPVm10d1dsZHNWbGROUmxwSFUyNU9WMkZzV2xaWmExcFdUVlpaZVdWSFJtcGlWVFZJVmpKNGEyRldaRWhoUkVwWFlXdHZNRmRXV2t0a1JrcHhWMnhPYVZKc2NGbFdWM2hoWkRKSmVGcElTbGRpV0ZKWFZGWlZNVk5HVlhsT1ZrNW9WbXR3VmxadE1EVldWbG8yVm01R1lWWldjR2haZWtaeVpXeHdSazVXWkdsU1ZtdDNWbTF3UzAxSFNYaFhhMmhVWW10d2NWVnRkRXRYUmxKV1YyMUdhRkpzY0hoVmJUVlBZV3N4Y2xkcmJGVk5WbkJZVmxSS1MxWXhUbk5pUm1Sb1lUSjNNRlpYY0V0U01sSkhWRzVLWVZJelFsVlZhazV2WWpGYVdHVkhSbGRpVmxwSVZqSjBiMkpHU1hkWGJrcFhZbGhTYUZwVldtRlhSMVpJWkVaa1RtSkdjRFZXVkVaVFVURlplRmRZY0ZKaE0yaFhXVmQwZDFaR1ZuRlNiRTVyVm14S2VsbFZaSE5WTURGMFlVUktWMkV4Y0hGYVZXUktaVVp3UjFwR2FHbFNNbWg0VmxkNFUyTXlUa2RWYkdSaFVtczFWVlZ0ZUhOT1ZuQkdXWHBXYUZacmNIbFphMUpQVmpBeGNWWnJhRmRpUm5CaFdsZDRVMWRYUmtkWGF6VlRZbXRKTWxZeFVrdE9SMFY1Vld0b1ZtRXlhRzlWYlRGVFkwWlZkMVpyZEZSV2JIQXdWRlZvYjJFd01WZFNhbEpZWVRGYWNsWXdaRXRqYXpWWFZteHdWMUpZUWpKV2FrWmhXVmRTUmsxV1pGVmlSbHBQVmpCV1MxZEdXbkZUVkVab1RWWndTRll5TlU5V1IwWnlVMjFHV2xaRldqTldWVnBoVTBVeFZtUkdhRk5OUm5CSlZtcEtOR0V5UmxkWGExcFlWMGhDV0ZacVRrTlRSbHBJVFZaa1UwMXJOVWRXTWpGSFZUQXhSMk5HVmxoV00yaHlXV3BLVjJNeFpITmhSVGxZVWpGS2VGWkdXbUZqTURWSFYyeG9iRkl6VWxsVmFrSlhUbXhhV0dWR1pGZGlWWEJhV1ZWb2QxWlhTa2RqUkU1WFlsaG9lbFJ0ZUdGa1IwWkhXa2RvVGsxRmEzaFdha1pyVFVaVmVGVllhRmhYUjFKUFZqQmFZV0l4VlhkaFJVNVlVbTE0ZWxaWGRHdFdSa3AwWkVSV1lWWlhVWGRaVnpGTFZqRmtjbUZHWkU1aWF6RTBWMVphYTFNeFpFZGpSRnBUWWtkU1QxbHRlRXRXVmxwWVkwVjBVMkpXV2xoV2JUVkxXVlpLYzFOdVFscFhTRUpZV1dwR1lWZEhWa2RVYkdST1lUSjNNRlpzWkRSV01WWjBVbGh3Vm1KR1dtRlpWRVozWld4U2NsZHRSbGhTTVVwSFZERmFhMVJzU2taWGFsWlhVbXh3VkZaVVJscGtNREZYWVVkb1ZGSnVRbGxXUmxaclZURlNSMkpFV2xOaGVteHhWRlpvUTFOR1pISmFSemxWWWtad01WVlhjekZXTWtwVlVtcE9WbUZyY0U5YVZWcDNVbTFHUjFkdGFFNVhSVXBoVmpGa05HSXlTWGhYYTJScFUwWktjbFZzYUZOV1ZsWjBaVWhrYkZKc1ZqVlpNRnBQVmpGYVZWSnViRmROYWxZelZtcEJlR05XV25OVmJHUnBWa1ZhU1ZkVVNqUlVNazE0WTBWa2FsSXllRlJVVnpGdVpWWmFkR1ZHWkZwV01ERTBWakkxVDFkSFNraGxSMmhXWVdzMVZGWkVSbUZqTVZaeldrVTVhVkl4U2xkV1ZtTjRVakpHUmsxWVNsaGlSMmhZVkZjMVUyRkdXbkZTYlhSVVVteGFlbGxWV2xkV01rcEpVVmh3V0ZaRmJ6QlhWbHByVW1zeFYxcEhSbE5oZWxaUVZtMHhNR1J0VmtkWGJsSk9Wa1pLV0ZSWGRHRlhSbGw1WlVkMGFHSkZjSHBXTW5oelZqSkdjazVXVWxwV1ZuQXpWV3hhUzJSR1NuUmpSVFZZVWxWd1NsWnFTakJoTVVsNFZsaG9WR0pHY0hGVmJYaDNWMFpXZEdWSVpHaFNia0pHVlcweE1GVXdNWEpqUlhCV1RXcEdkbFpVUm1GVFIxWkhZa1prVTJKSVFubFdiRkpIVkRGWmVWTnJaRmhpUjJodlZGVlNWMWRXWkZobFJtUnJUVmRTZWxscldtRldiVVkyWWtkR1YySllhSHBVYlhoelZtMUdTVnBHWkU1aE0wSmhWMVpXVTFReFduUlRhMlJxVWxkb1lWcFhkR0ZOTVZWM1drVmtWRkl4V2tsWlZWVXhWakpXZEZwNlFsZGlWRUl6V2tSS1VtVldXbkpoUmxwWVVqSm9XVlpxUW10aU1XUlhZa2hTYTFOSFVsWlVWbHB6VFRGWmVVMVZaR2hXVkVaWVZqSndRMWxXV2xkWFdHUlhUVVp3VEZwRlpGZFNNa3BJVW14T1YwMVZjRXBXTVZwWFdWWk5lVlJZYUdGVFJWcFRXV3RvUTFReFVsVlJhM1JVVm14d2VGVlhNVWRYYkZsNFUydG9WMkpVVmxoWlYzaExaRVpXZFZGc1pFNVNNVW95VjJ4YVlWbFhUbk5qUld4cVVqTm9WRlJXVm5kVGJGcFlUVlJDYUUxclducFZNalZUVm0xS2NsTnNhRlZXVm5Cb1ZrVmFWMk14WkhSa1JtUk9WbXh3TlZZeWRHRmhNa1pYVjI1T2FsSlhlRmhaVkVwT1pVWmFjVkp0UmxoU2F6VjZXV3RhUzJGV1NuSmpSbXhZVm0xUmQxZFdXbE5TTVdSMVZXMTRVMDB4U2xwV1YzQkhXVlpPVjJORldsZFdSbHBYVkZkMGQxTnNWbGhrU0U1WFRXdGFlVmxVVG05V01WcEdWMnhPWVZaV2NISlpla1pyWTJzNVYxcEhiRmROYldoWlZtMHdkMlZGTlVoVldHeFhZbXMxVjFsdGN6RlhWbXgwVFZaT1dGSnRlSGxYYTFwUFZHeEtkVkZyWkZkTmFrVjNWbXhrUzFKdFRrWmFSbVJPWW0xb01sWnRjRWRUTWsxNVZHdGtWbUpIVWxoVmJGcDNZVVprYzFkdFJsVk5hekUwVmpJMVQxbFdTWGxsUmxKWFlrZG9SRll5ZUdGamJHUnpXa2RvVGxac1dUQldiR1F3WVRGWmVWTnVTbGhpUmxwaFZqQm9RMlZzV25KWGJFNVlVakZLU2xkcldsTlZNa3BaVlZod1YyRnJiRFJVVlZwaFkyc3hWMXBIY0ZOV01taFpWa1pqTVdJeVJrZFhia1pVWVROU1dGWnRkR0ZsUmxwWVpVWmthRkpVUmxwVlZ6RnZWMGRLUjJOSGFGZFdSVnB5VmpCYVMyTnRSa2RVYld4VFlUTkNWbFp0TVRCWlZteFhZa1prV0ZkSGFGbFpiRkp6WTJ4U1YxZHVUazlTYlZKNVZtMHhNR0ZHV25KT1ZXUmFUVVp3ZWxZeU1VdFdWa3B6Vld4a1RsWnVRalpYVkVvMFpERkplRlZ1VW14U01uaFVXVzEwUjAweFdYbGxSbVJvVFVSR1NWVnRkR3RXUjBwSFYyeFNXbUV5VW5aWFZscHpWbFpLY21SR2FGTmlTRUYzVjFod1QySXlSWGhYYms1WVlXdEtZVlpzV25kTk1WcHhVVmhrYkZZd1drZFVWbHB2WVVVeFdWRnRPVmRXTTBKTVZrY3hWMVl4VG5WVGJVWlRZbGRvZDFadGNFdGlNbEp6V2toT1lWSkdTbGxaYkZwaFYwWlplVTVXVG1sU2EzQXdWbGN4UjFZeVNsVlNWRUpYVFZad2FGVXdaRmRUUjFKSFdrWk9UbE5GU1RKV2JGSkxUa1pWZUZwSVVsTlhSM2hYV1d0YVMxZEdWbkpXYlVac1lrWnNORmRyVlRWVk1ERlpVV3RvVjFZemFGQlpWbHBQVW14T1ZWTnNaR2hoTWprelZteFNSMVp0VmxkVGJrcFlZWHBXV0Zsc1drdGtNVnBZWkVkR1dsWnNiRFJXVjNodlZERmFjazVZVGxwaE1YQXpWakZhVTFZeFduRlJiRnBPWVROQ1NsWnNZekZrTVdSelYyeGthbEl5YUdGV2JHUlRVMFpTZEdWSFJtcE5WbkI2V1ZWYWEyRldTblZSYmxwWFlsUkdNMVY2UmxKbFJtUlpZVVphYVdKR2NGWlhWbWgzWXpGa1IxVnNWbFJpVkd4WVZtMHhVMWRHYkZaaFIzUlhUV3R3V0ZZeWRHOVdNREZ4Vm10NFdGWnNjRXhWYWtaUFpGWkdjMVpzWkU1TlZYQjJWbTF3UTFsV1duUldiR2hYWVRKU2FGVnRNVk5VTVd4VlZHdE9UMkpIVWxaVlZ6RkhZVlV4VjJORVFsWk5ibWg2V1ZWYVMxSnJOVmRoUmxaWFZtNUJlbFpHVWtkV01rMTRXa2hLYTFJelFrOVdiRkpXWkRGa2MxWnRSbFZOYTFwWVZqSTFTMkZYVm5KalJtaFZWbXh3TTFZd1dtRmtSMDE2WVVaa1RsWXhTalZXTW5SaFZURmtSMU5ZY0doVFJuQllWbTV3UTA1R2JIRlNiWFJUVFZad01WWlhNVFJXUmtsNFUyeHdWMVo2UlRCYVJFcFhVakZhYzFwR1dtaE5iRXBZVmtaV1UxSXhaRmRYYkdocVVsZFNXRlJXV25aTmJGWnpWV3RPVjAxV2NFZFZiWEJQV1ZaYVYyTkdRbHBsYTNCUVZXcEdkMUl4Y0VaT1ZUVlRWMFZLU0ZadE1IaGtNVTE1Vm01U1YyRXlhRlpXTUdSdllVWlZkMWR0UmxkTlYzaGFXVEJvVDFkR1NuTmpTR2hXWWxoUmQxWXdXbUZqTWs1RlVXeFdWMkpGY0ZWWFZsSkNaVWROZUZwSVZtcFNiVkpQVm1wS2IwNXNXbkphUkZKYVZsUldNRlV5ZEd0aFJrcHpWMnhvVlZaRldreFpha1pyWXpGa2RGSnNhR2xXYkhCYVZtMHhNR0l4VmtkWGJsWlNZa2RvWVZaclZURlNSbGw1WlVkR2FrMVlRa1pXVjNoaFZHeGFkVkZZWkZkV1JXOHdWbXBHVm1WV1RuSmFSbEpwVWpGS2FGWnRjRTlWTWtaSFlUTnNiRk5IVWxSWmEyaERVakZ3Umxkck9WVmlSMUpIVlRKMGQxZEdXWHBWYldoWFZrVmFWMXBWV210ak1rcEhVMjFvYUUwd1NscFdNV1EwVlRGSmQwMUlhRmRpYTFwVVdXMXpNVmRHVWxkYVJrNVlZa2Q0VjFZeU1EVlhSa3B5WWtSV1dsWldjSFpXYWtwSFkyeE9kVk5zY0doaE1YQjVWbTF3UzFNeFRsZFdibEpxVWpOb2IxUldhRU5aVmxwMFRVaGtiRkpVVmtkVVZsWnJZVVV3ZWxGdVJsWmlSMUpVVmpGYVYyUkhWa2xhUlRWVFltdEtXRlpxU1hoU01WbDVVbXBhVTJKdGFGZFdiWGhMVTBaYWNWRllhRk5OYXpWSFdsVmtSMVV4V1hoVGJHeFhWa1ZhY2xaRVJrcGxWbEp5V2tkR1UySldTbmRYVmxKRFpERlJlRmR1VWs1V1JVcHZWRlZTVjFOR1drZGhTRTVYVm0xU1NWbFZXbk5YYlVwWlZXMW9WMkpZYUhwWk1uaDNVakZTYzFack5WZE5NbVF6VmpKNFYxWXlSWGhWYmtwT1ZtMW9WMWxyWkc5WFZscHlWbFJHYTJKR2NIbFdiR2h2VmpKS1ZrNVZjRnBoTVhCWVdWWmFTMlJXUm5GWGJHaFhZbFpGZDFaWWNFdFViVlpYVlc1S1dHSkZTbGhaYlhSTFpERmFkR1JHWkZwV1ZFWjZWMnRvVDFkSFNsWlhiVVpYWVd0YVRGVXhXbUZUUjFKSVVteHdWMkV6UVhoV1ZtUTBZakZhVjFkc1pGUmhNbEpXVm0xNGQyRkdXbk5YYXpsclZtNUNTRmt3V210aFZrNUdVMnQwVjJKR1NreFVWV1JLWlVaa2RWVnNVbWxTYkhCM1ZsZHdRMWxXWkVkaVJsWlRZbFZhYjFWdGVFdFdiRlowVGxVNWFHSkdjSGxaTUZKRFZtMUtWVkpZWkZkV1JVWTBWV3hhWVdOdFJrZGFSVFZwWWtWd2RsWnRlRk5UTVVsNFYxaG9ZVk5HV2xaWmJHaERWa1phY1ZSdE9WaFdiVkpZVmxkME1GWlhTbGRYYTJoWFlsaENhRlpVU2t0amF6VlhZVVpXVjJKR1ZqUldha28wWXpKT2MyTkZWbFppUm5CUFdWUk9RMU5XWkZWUmJVWnBUVmRTU0ZZeGFIZFdiVXBZWVVac1YySllhRmhVVkVaM1ZteHdSazlXVGs1aE1YQktWMnhXWVZReFVuTlRibFpTWWxWYVdGbHJaRk5OTVZaeFVtNU9WMDFXU25sWGEyUkhWa1pLV1ZGdE9WZFdNMUpZVlhwR1lXTXlTa2xUYkdocFlsWktlbGRYZEdGak1EVkhWMnhvYTFKVWJGaFVWVkpIWlZaWmVVNVlUbGhpUm5CSFZHeG9ZVll5Um5KWGEzaFdZbGhvY2xwRldrdGtSa3B6V2tkc1ZGSlZjRk5XYWtadlpERkplVkpZYkZWWFIzaFVXVlJLYjJOR1ZuUmpla1pWVFZaS1dWUldZelZYYkZwelkwaG9WbUpVUlhkV1JFWktaREpLUlZac1drNVdNbWd5Vm0wd2VGSnRWbGRXYms1b1VtNUNjRll3V2t0aU1WcDBaRWRHYWsxck5UQlZiWFJoVmxkS1dWRnJPVmRpVkZaRVZHMTRZV014Y0VWVmJXaE9WbTEzZWxaR1dtRmhNVlY1VW01T1ZHSkhhRlpXYWs1RFUwWlZkMWR1VGxkaVIxSXdWVzB4ZDFSdFJqWldhMnhZVmtWS2FGZFdXbHBrTURGSllVWlNhR0V6UWxsWFYzaHZVVEZTUjFadVJsUmhlbXh5Vlcxek1XVkdXWGxsUlhSb1ZtczFSMVV5ZUhOV01WbDZZVWRvWVZKRmNFaFZha1ozVTFaU2MxcEhiRmRXYmtKWVZtdGFhMDVHVFhoYVJXUllZbXhLVUZadGN6RmlNVlowWkVoa2JGWnNTbnBYV0hCWFZqRmFjMk5HYkZwV1ZscFVWbXBCZUdSWFJraGhSMFpUVm14Wk1GWnFSbUZrTVVsNFYyNUtUMVl5YUU5WmJURlBUa1phZEdWSGNHeFNWRVpKVld4b2IxbFdTbGhoUmxaYVlsaE5lRlpzV25Oa1IwNDJVbXhrVGxZemFGcFhWRTUzVWpGWmVGTnVVbXRTUmtwWVZGZHdWMVZHYkZoTlZYUlVVbXhhTVZsclpFZFZNVmw0VWxoa1dGWnNjR2hWZWtwVFUwWldjVmRzVG1sU01taFpWbGQ0VTFadFZuTlhiR2hxVWxkU1dWbHNXa2ROTVZKWFYyMTBXbFpyYkRaVlYzaFRWakpHY21OSVdsZE5SbkJ5VmpCa1YxTkZPVmRUYXpWWFlraENTbFp0Y0VwTlZrbDRWMnRvVTFkSVFsZFphMXBMVm14YWNWUnJOV3hTYkZZMVdsVmFZV0pHV1hoWGEyaFlZVEpTZGxaVVJtRlNiR1IwVW14a1YySldSak5XUjNSaFlURk9SMVJ1U21GU2JXaHdWbXBLYjJGR1duUmtSbVJyVFZad1NGWXlOVWRWTWtwSVZXNUtWMkpZYUV4YVYzaGFaVlV4V1ZSc1pFNVNSVWt4VjFaV1UxTXhXWGxTV0docVVteEtWMVpyVm1GVU1YQldXa1YwVTAxWVFraFpWVnB2VlRBeGRHRkhSbGROVjFFd1ZsUktUbVZXVW5WVWJGcHBVakZLV1ZkWE1YcE5WbFpIVm01U2JGTkZOVkJXYlRWRFVqRmtjbFZyVGxoU2EzQjVXV3RTVDFkck1VaGhTSEJYWWtkU1RGVnFTazlUVjA1SFdrVTFhR0V4Y0U1V2JURTBXVlpOZVZSWWFGZGlhelZvVldwS2IxUXhXWGRXYTNSWVlrWnNOVnBGV210aFJURlhZa1JTVjFJemFISlpWM2hMVjBaV2RFOVdXbWxYUlRFMFYxUkNZVlp0VVhoWGJrcHJVbTVDV0ZsclpETk5SbHB6V2tod1QxWXdWak5VVmxwcllWWktSMWRzWkZwaVIyaFVXVEo0V21ReGNFWmtSazVPVmpGS05sWnNaRFJrTWtaR1RWaE9WR0pHV2xoWlYzUkxZVVpzTmxOck5XeFdhM0I1VmpKNFYyRldTblZSYkZaWVZqTm9hRlY2Um10V01XUjFVbXhTV0ZJeWFGVldSbHBoWXpBd2VGVnNaRmhpVkd4WVdXeFdZV1ZXVlhsTlZXUlhUV3R3U0Zrd1VrOVhhekYxWVVkb1drMVdjRXhaTWpGVFVqSkdSMXBIYUU1WFJVVjRWbXBHWVZZeGJGaFRXR3hUWVRGd1QxWnRlSGRqVmxaelZXdGtXRkp0ZUZaVmJYUXdWa1pLYzFacVZsVldiSEJ5VmxSQmVGWXlUa1ZTYkdScFYwZG9XVmRXV21GVGJWWkhWRzVXWVZKdFVsaFVWRUpMVTFaYVdXTkZaR2hOVm13MFdUQldhMWxXU25OalJ6bGhWbnBGTUZacldtRlNNV1IwVW0xMFRtSkdjRFpXYWtadllqSkdSMVJyV2s5WFJVcFhXV3hvVTJWc1VuUmxSMFpZVWpGYVIxWkhlR3RoVmxwWlVXMUdXRlpzV25aYVJFWmhWMFpLV1dGSGNGTk5SbkJ2Vm0xNGExVXhUa2RXV0dSWFZrWmFXRlJYZEdGVFJscElZM3BHVjFKcmNGZFpWRTV2VmpKR2NsZHNVbFpXUlhCSFdsWmFUMWRYUmtkaFIyeHBVbGhDVjFZeFpEQmhNRFZIVjI1T1dGZEhVbWhWYm5CelYxWldkRTFVVWxkaVJsb3dWR3hrTUdGV1NYZGpSV2hhWVRGS1ZGWXdaRVpsUmxwVlVteGtWMUpWV1RCV2FrWmhVakpPYzJORlpGZGlWM2hVV1d0YVdrMUdXblJOV0dSU1lsWmFTRll5TlZOV1IwWnpZMFpXV21FeVVsUlpNRnBoWTJ4YWNtTkZOVk5pU0VKS1YydFdhMDFHVlhsVGJHUllZVEpvV1ZsVVNtOVVSbGwzV2tWa1QySkdjSHBaVlZwM1lWWktkVkZyTVZkaGEyOHdXVlJHYTFKck1WWldiRTVwVWxoQ1VGWnRjRWRUTVU1WFYyNU9ZVkpHU25CVVZscEhUa1paZVdOSFJtaFdhMjh5V1d0YWExZHRTa2hoU0ZwaFZqTm9WRlpzV2t0a1IxSklZMGRzVTJKclJqTldiR04zWlVkTmVGWlliRk5YU0VKVFZqQmtVMWRHYkhKYVJUVnNVbTVDUmxWdGVIZGhNREZGVW14d1YySlVSblpXVkVwTFYwZEdSMkpHYUZkaVZrWXpWakZhWVZVeFNYaGFTRlpWWWtkb2NGWnNXbmRsUm1SWVpFZEdhMDFzV25wWGEyaExWMGRHTm1KSVFsWmhhMHBZVkd0YVlXUkhUa1pQVm1ST1lUTkNZVmRXVm1GVk1WcDBWbTVLV0dKRk5XaFdiRnAzWTJ4WmVGcEZaRk5OVm5Bd1dXdGtjMVV5U25KVGJHaFhZV3RhY2xScldscGxSMHBIV2tab2FFMXNTbmRXVkVKV1RWWmtWMkpHVmxWaVJUVnhXV3RhUzFkR1dYbE9WM1JZVW14d01WVlhlR3RYUm1SSlVXeG9WMkpVUmtoVWJYaExZMnhrYzFwSGJGaFNNbWQ1Vm0weGQxRnRWa2hVYkdSWVltdHdiMVZ0TVZOaU1WSllaVVYwVkZadFVscFpNRlpyVmxVeGNrMVVVbGhoTW1oUVZtcEtTMU5HVm5WUmJGcE9VbXh3VFZkclpEUlhiVlpZVm10b1UySklRbGhaYTFwYVRVWmFjVk5VUmxaTlZsWTFWV3hvYzJKR1NuTmpSMFphWVRKU1ZGcEhlR0ZqYkdSMVZHeGtWMkpGY0RWV2EyUTBZakZaZVZOcmJGSmlSMUpZVm10V2QwMHhXbFZUYTJSWFlYcEdXRmRyWkhOVk1VcHpZMFpvVjFKdFRYaFpha3BYWXpKS1IxZHNhR2hOTVVwVlYxWm9kMVl4WkVkaVJscFlZa2RTV0ZSV1duZE5WbFpYWVVoa1YwMXJXbmxWTWpGdlYyc3hjVkpzYUZaaGExb3pWVEZhVDJSSFVrZFVhelZPVWxoQ1VsWnRNSGRsUlRGSVZXNVNWbGRIYUdoVmJYaGhWVEZzYzJGR1RtcFdiRXBZVmpJMVQxUXhXbk5XYWxaaFVsZG9VRlp0TVV0V2JGcHhWbTFHVjFadVFqSldha2w0VXpGT1NGSnJXbFppUjFKVVZtMDFRMVpXWkZWVGFsSm9UV3MxZWxkcmFGTmlSa3B5VGxoQ1YySllVak5aVlZwYVpVWmtjMXBHY0ZkTlIzY3hWbGN4TkdFeFdrZGFSV3hTWWxSc1YxbHNhRzlVUmxsNFYyMUdhbFpzU25wV1J6RnZWVEpLUjJFemJGZFdla0kwVkZWYVZtUXdNVmxUYlhCVFYwVktXVlpYTlhkU01sSnpWMnhXVkdKSFVuSlZha1poVTBac2NsZHRkRlpOYTNCS1ZWZHdTMVl4V25OVGEyaFhUV3BHV0ZWcVNrOVNiVXBIVlcxc1UwMXRhRE5XYlhCRFdWWk5lVlZ1VG1GU2JWSnZWVEJrVTFaR1VsZGFSazVVVW0xNFZsWkhNVEJoUmtweVRsVnNWMVl6YUhwV2JURkhZMnhPYzJGR1ZtaE5XRUkxVjJ0U1MxSXhTblJWYTJSb1VqSjRWRmx0ZEV0WGJGcDBUVWhvYTAxV1ZqUlhhMmhUVmpKS2NtTkdiRnBoTVZwTVYxWmFkMWRIVWtoU2JHaFRZbGhqZVZaVVNqQmhNVlYzVFZac1VtRXlVbFpaYTFwV1pVWmFjVkp0ZEZOaVJUVmFXV3RhYTJGV1drWldXR1JYWWtaS1NGWkhNVmRXTVdSMVZteGFhVkl4U25aV1JtUTBVekZrYzFkdVJsSmlXRkpRVlcxNGQyVnNiSEpYYkdSWFVqQndSMVJzV25OV01rcFZVbFJDWVZac2NISlpNbmh6VG14YWRHRkhiRk5YUlVreVZqRlNRMkl5VVhoWFdHUk9WMFZhV0ZsdGRIZFhSbEpXVjI1a1ZWSnVRa2RXTW5ocllXc3hjbU5GYkZaaVdHaFFWbXBCZUZadFRrWmpSbVJPVm01Q1ZWWldZM2hXTVVsNFdrWnNhVkpzU205VVZscDNWMFprV0dSSGRGWk5Wa1kwVmpJMVIxWkhTbFZpUmtKYVlUSlNWRll3V21GWFIxSklaRVprVjFaRldsaFhWRUp2WXpGYVdGTnJaR3BUUlhCaFZteGFkMVJHY0VaWGJHUnJWbXRhZWxkclZURlZNa3B5VTJzeFYwMXVhSEpVYTFwelYwWlNjMXBHVG1saVJYQlZWMWQwYTJJeVRrZFhibEpzVTBkU1dWbHJXbmRsYkdSeVZXdE9hRlpVUmxoV01uUnZWakF4Y1Zac1VsZGlWRVpNV1RKNFQyTXhjRWRqUjJ4VFlUTkNTVll5ZUd0T1JsVjRXa1ZvVjJFeWFISlZiVEZUVkRGYWRFNVZUazlpUm13MVdrVmtNR0ZyTVZkVGJuQlhUV3BXVkZsVVNsZGpiR1J6WVVaa2FFMVdiM2xXUmxaaFl6QTFjMU51VWxOaVIxSlBWbXBHUzA1V1duRlRhbEpwVFd0YVdGVXhhRzlXUjBwSVZXeG9XbUpHU2tkVVZWcDNVbFpHV1ZwSGVGTmlWa2w0VmxSS05HSXlSbGhTYWxwWFlrVmFXVlpxVGxOWFJuQkZVMnhrVjAxV1dscFpWV1JIVmtaSmVGTnNaRmhXTTFKeVZsUkdTbVZHV2xsaVIzUlVVbFJXV1ZaR1ZsTlNNREZYVjJ4b1RsWjZiRmxaYTFwM1VqRnJkMVp0T1ZkTlJFWklXVEJXTkZZd01WZGpSRTVXVFVkU1VGVnFSbE5qTVhCR1RsWmtXRkpWY0c5V2JURjNVakpGZDA1VlpGZFhSMmhWV1cxMGQxUXhXbk5hUms1b1VteGFNRlJXV2s5aFJrcHpWMjV3V2xaV1dsQlpWM040VmpKT1JWRnRSbGRXYkd3elZtcENhMU14VGtoV2EyUmhVbTFTVDFsdE1XOWxWbVJYVm0xR1dHSldSalZXUjNSaFdWWktkVkZyT1ZaaVZGWkVXbFphWVdSSFRrWmtSazVPWVhwV05sWnJZekZXTVZwSVUydG9WbUpIYUZkWmEyUnZVa1phVjFkdFJsaFNNRFZIVjJ0YWQxWXlTbGRUYkd4WVZrVktXRmxVU2tkU01VNVpZa2Q0VTJKWGFGbFhWM2hUVmpGS1IxZFliR3hTYmtKelZXMDFRMUpzVmxoTlZ6bFZZa1Z3U0ZZeWRHOVdNVXB6WTBab1dsWkZjRWhaZWtaUFpGWlNkR05HVG14aVdHaFpWakZhYTJWck1WZFhhMlJwVTBWYVZGbHRjekZqVmxKWFYyNWtUbFp0VW5sV01uaFBWbXN4Y21OR2NGcFdWa3BZVm1wS1MxTkdWbkZYYkZacFVtNUNhRmRyVWtKbFJtUlhWRzVTYWxKck5YQlZNRlpMVjJ4WmVGcEVVbFpOVm13MFZsZDBhMWRHWkVobFNFNVdZbFJXUkZsNlJuTmpNVnAwVW14U1YySllhRmhXTW5SWFlURmFjazFXWkdwU1JWcFhWbXBPYjJWc1dYZGFSVnBzVWpBMVNsVXllR3RWTVVwWFkwVjRXR0pHY0doV1ZFcFBZekpPUm1GR1RtbFNWRlozVm0weE1HUXdNSGhYYms1YVRUSm9VRlZ0TVZObFZsSlhWbTEwV0ZJd2NIcFZNbk0xVmpKRmVHTkZlRmRoYTFwVVZtcEdZV1JXVW5KUFZrNXBVMFZLUzFaclpEUlpWbEY0VjFoc1ZHRXlhRmRaVkVvMFlVWmFjMWR1WkZoU2JHdzFXbFZrUjFVeVNraFZha0phVmxad2NsWkhlRXRrVmtaeFYyeG9WMUpYT0hkWFZsSkxWVEZKZUZSdVZsWmlXRUpVV1Zod1YyUXhXbGhOU0dSUFZsUkNORll4YUhOaE1VcDBWVzVDVlZZelVsaFVhMXBoWXpKR1NFOVdhRk5OU0VJMVZrZDRiMUV4V25SU1dHaHFVbGhvV0ZSVlduZFdSbGwzV2tVNVUySklRa2hXVjNoUFlWWkplbGt6YUZkTmJtaFlXVlJHU21WR1pGbGhSbWhwWVhwV2VGWlhkRmRaVm14WFZXeGFXR0p0VW5GWmExcDNVMVpTVjFacVFtaE5WV3d6VmpKMFlWWXdNWFZoU0VwWFVqTm9hRnBHV2tka1JUbFhXa1pvVkZKVmNFNVdiWFJxWlVaWmVGTllhRmRpYkZwWVdXdGFZV05HV25GVGJUbFhWbTFTV1ZwRlpFZGhNREZZVld4b1YwMXVhSFpaYTFwTFpFWldkVk5zVmxkaVNFSk5WbFJDWVdFeVRuUlNhMXBRVm01Q1dGbFVUa05UVmxwVlUycFNhazFYVWpCVk1uUnJZV3hKZVdGR1pGVldWbkF6V2xaYWQxSldTblJTYlhCT1YwVktTVlpxU1hoak1WbDRXa1ZhVkdKWGFGaFphMXAzWTJ4d1dHTjZSbGROV0VKS1ZrY3hSMVV4V1hwaFJsSllWbXhLVEZaVVJtRmpNV1IxVlcxNFZGSXhTblpXVnpCNFRUQXhjMVp1VWs1V1JVcHZWRlpXZDFac2JISlhiazVZWVhwR1NGWnNhRzlYYkZwWFZtcFNWMDFXY0VoWmVrcFBVakZ3U0dKR1RtaE5NRXBMVm1wR2EyUXhUWGhXYmxKWFlUSlNhRlV3V21GV01XeHlWMnQwYVUxV1NsbFVWbU0xWWtkS1IyTkdiRlZXVjJoMlZtMXplRmRIVmtkaFJuQm9UVmhDV1Zac1VrdFRNbEpIVm01T1dHSkdjSEJXTUdSdlRteGFSMVZyWkZoaVZscFhWR3hhYjJFeFNuUmhSbEphVmtWdmVsUlZXbUZqVms1eFVXMXNUbFp0ZDNwV1JscHZVakZWZUZkcldsUmlSMmhZV1ZSR1lVMHhXa1pYYkZwc1VtMVNlVmRyV205V01rcHlVMnRzVjAxdVVtaFdSRVpXWlVaa2RWWnNTbWxpU0VKWlYxZDRVMUl3TUhoV2JrWlRZa1p3YzFadGVFdFhiR3hXVjJ4a2FGWXdWalpWVjNoM1YwWlplbFZ1U2xwaGEzQkxXbFZhVjJNeFduTlRiV2hPVFZWd1lWWnRNSGRsUmxWNFdrVmtXR0pIYUhKVmExWkxWMFphY1ZGdVpGaFNiR3cxV2tWak5WWXdNVVZTYWtaYVZsWndkbFpxU2tabFZsWnlXa2RHVjJKSVFsbFhXSEJMVWpGSmVGZHVUbUZTTW5oVVdXdGFjbVF4V25STldHUlVUVVJXU1ZaSE5WTldiR1JJWVVkb1ZrMUdXak5aTW5oWFkxWk9kRTlXYUZOaVJYQllWbXBLTkdReFVuUlRhMlJxVW0xb1dWbFVSa3RXUm14WFZsaG9XRkpzV25sWlZWcHJWR3haZVZvemNGaFdiRnBvVlhwS1RtVkdVblZVYldoVFltdEtXVlpHVWtkVGJWWnpWMjVPVjJKVlduRlVWVkpYWld4YVNFNVZkRmhTTUhCYVdWVm9RMVpyTVVkWGEzaFdUVlp3Y2xacVJtRmtSMUpJWTBVMVYySkdhM2RXYlhCTFRVZEZlRnBGYUZSaE1YQnhWVzB4YjFac1duUk5WazVXVFZoQ1JsVnRNVWRoYkZweVRsaHdWazFxUlRCV2FrcExVMVpHY1Zac1pFNWliRXB2VjFkd1MxSXhXWGhVYkd4cFVqSm9WRmxVUW5kWFZtUllaVWM1VmsxWFVraFdiWEJoVlRKS1dWVnNVbFZXYkhCb1dsZDRjMVpzY0VWUmJHUlRZVEozTUZaVVNqUmtNVmw1VTJ4V1VtRnNTbFpaVkVaM1dWWndWbGR0ZEd0V2JGcDVWREZhYTFSck1WWmpSbkJYWVRGd1dGWlVSa3BsUm1SWllVZHNWRkpZUWxoWFYzaFhXVlprVjJKSVNsaGliVkpaVlcweE1FMHhXWGxsUlRsWFRVUkdlVmt3V21GV2JVcFpZVWhhVjAxdVRqUmFSbVJIVTFaT2RGSnNUbWxUUlVwU1ZqRm9kMU14VVhoVWEyaFhZVEpvYjFWc1VsZFhSbkJZVFZod2JGWnNjREJVVmxKVFlVZEtWMWRyWkZWaVJscDJWbFJHYTFOSFZrZGFSbkJYVWxoQ01sWnRlR0ZqTVZwWFZHNU9WV0pIVW5CVmFrNXZUbXhrVjFadGNFOVdNRnA2VlRJMVQxZEhSbkpUYkZwYVlURndhRlpWV2xwbFYxWklVbTF3VG1GNlZrZFdWbVEwVmpGWmVGZFliR2hUUjNoWVdWUktVazFHV1hsTlZtUlRUVlUxTVZWdGVHRmhWa3AxVVd4Q1YySllRa3haYWtGNFl6RmtXV0ZHYUdsV1ZuQldWa1phYTFVeFRrZFhibEpQVm0xU1YxbHNWbmRUUm10M1lVVk9WMDFFUmtsV1Z6VlhXVlpaZW1GSGFGcE5WbkJNV2tWYVMyUkhUa1pPVjJ4VFYwVktURlp0TVRSaE1ERklWRmhvYVZKdFVsVldNR2hEVlRGc1dXTklUbGhTYlhoWldUTndSMkV5U2tkVGJuQlhUV3BHU0ZsWGVHRmphelZYWTBad1YxWnVRbEZXYTJRMFYyMVdSMVJ1U21sU2JWSnZXVlJLTUU1R1duTlZhMlJhVmpGS1NGWkhOVmRXYlVwWllVWlNXbUpIVW5aV2FrWmhaRVUxV1ZwR1pFNVdia0pKVjFaU1QyTXlTa2RUV0dSWVltdGFXRmxzYUU1bFJuQlhWMjEwYW1KR2NGWldiVEZ2VmpKRmVsRnRSbGRXYlZJelZtcEdXbVF3TVZsV2JGcHBWakpvYjFaWGRGZGtNVTVIVjFoa1dHRjZiSEpXYlhNeFpXeGFXRTFYT1ZWaVZYQXdXVlZhZDFZd01WaFZWRUphWVd0YVIxcFZXa3RYVjBaSVkwWk9hVk5GU25aV2JHTjRaV3N4VjFwR1pGZGliRXB5VlRCa1UyTXhXblJOVkZKc1ZteHNOVlJWVWxkaFJrcHpZMGhzV2sxR1NraFdiWGhoVG14YWRHRkdaRTVTYmtKdlYxaHdSMVF5VG5OV2JrNWhVbFJXY0ZsWWNGSmtNVnB6V2toa1UwMXJWalZXVjNoclZrZEtjazVXVmxwaVIxRXdWakJhWVdSRk5WWlViR1JPVm01Q05WWnFTWGhOUjBwSVUyeGtXR0V5VWxaWmExcDNZMnhhY1ZKdGRGUlNNVnBLVlRKNFlXRkhSalpXYkZaWFlXdEthRmw2U2s1bFJtUjFWbTFHVTJKWGFGbFhWekV3VXpGa1IxZHVSbFJXUlZwV1ZGWmFjMDVXVlhsbFIwWllVakJ3TUZwVlpFZFdWbHBZVlc1YVdsWldjR2haTVZwTFkyMVNSMVJ0YkZOTlZXd3pWakZhVjFsWFVYbFRhMmhUVjBkb2NWVXdaRFJYVmxsM1lVVk9WRkpzY0ZaVk1uTXhZa1pLYzJORVJsWk5iazB4Vm1wS1MxWXhUblZhUm1SWFpXdEpNRlpHVWtKbFIwMTRXa2hXVm1KWVVsUlVWRVpMVlZaYVdFMUlhRTlTYlZKWVZtMDFUMkZHU2paaVJ6bFhZbGhTTTFSVldtRlhSMVpJVW14b2FWSnVRa2hXYWtwM1ZERlplRmRzWkdwU01taGhWRlphZDFWR2NFWldWRlpYVFZoQ1IxUnNXbXRVYXpGMFdUTm9WMkpZUWt4VVZWcHpWakZXV1dGR2FGaFNNbWhXVjFjeE5GTXlUWGhXV0dSaFVucHNXRlJXWkRSbGJGcFlaVWQwVjJKRmNEQmFWVnB6VjIxV2NrNVlXbGROUm5CTVdYcEdhMk5XU25OalIyaE9Za1Z3U2xadGVGTlNNV3hZVld4a1UySnJOVlJaYTJSVFkwWlpkMVpyZEZWV2JIQmFXVEJXYTFkSFNsZFhhMmhYVm5wV1dGWnNaRXRXYkdSelZXeHdhVkp1UWsxWGEyUTBXVlpKZUdORlZsWmlSVFZQVld0V1NrMUdXbkZUVkVaVVRWWndNRlZzYUhOV2JVcFdWMnhvV2xZelVraFVhMXBUWTJ4a2RGSnNVbE5XUmxwWVZrUkdZV0V4VW5SU1dIQlNZVEpvV0ZWcVRtOWtiRlpWVW0xR2FtRjZSbGRYYTFwdllVVXdlV0ZIYUZkaVdHaG9Xa1JLUjFJeVRrWlhiVVpUWWxaS1ZsWlhNVEJrTWxaelYyeG9hbVZyV2xoVVZscDNVMFpaZVdSSVpGZE5hMXA1V1dwT2ExZEdXblJWYTJSaFZsWndNMVZ0TVVkU01WSnpZVVpTVTFaWVFscFdha1pyVFVaWmVGUllhR2xTYlZKd1ZXMTRZVlpHYkhOV2JVWlZUVlpLV0ZsVlZrOVhSa3B6WWtSV1ZXSkdWVEZXYWtGNFkyMU9SbU5HV2xkTk1VcDVWbXBDYTFKdFZraFVhMnhVWWtkU1ZGcFhkR0ZUUm1SeldrUlNVMDFyTlRCVk1uUnJZVVpLZEZWc1VsZGlSMmhFVm0xNFlXTldTblJTYkhCWFlsWkpkMVp0TVRCaE1XeFhWR3RhYWxKdGVHRlpWRVozVkVacmQxZHRSbXBXYXpVd1ZERmFiMVl5U2tsUldHUllZVEZhYUZsVVNrWmtNREZYV2tkd1UxWXlhRmxXUm1SM1ZqRk9SMWRzVmxSaE0xSlZWVzE0WVUxV1ZYbGxSM1JvVm0xU1NWbFZWWGhXTVVwelYyMW9XazFxUmxOYVZWcDNVMVpPYzFGc1pFNWlWMmhhVmpGa01HRXdNSGROVm1SaFVtMVNXRmxzVm1GWlZscDBaVWhPVDFac1ZqVmFWVnByVm1zeFdGVnJiRmRXTTJoNlZtcEtTMWRYUmtWVWJIQlhWbTVCZWxaWE1UUmhNbEpIVTI1U2FsSlVWbGxWYkZaM1UyeFplRmRzWkdoTmF6RTFWVzE0YTFaSFNraGxSazVhVmpOb2FGWXdXbk5qYkhCSFZHczFUbFp1UWtkV1Z6RXdXVmRLUjFkdVRsUmlTRUpoVm14YWQyTnNiRmRhUlhSVFlsVTFTbGxyV210V01VcFdZMFpvVjFKc2NHaFdha1pLWlVad1NWWnNXbWxYUjJoV1ZsZHdSMU14WkhOWGJsSk9Va1ZhVTFSV1ZuTk9SbVJ5WVVWMFYySlZWak5VYkdNMVZtMUtXVlZ1Y0ZWV1JWcDVXa1JHWVdSSFVrZGhSMmhzWVRGd1NsWnNVa3ROUmxWNFdrVmtXR0pyTlhGVmFrcHZWMFpzV0dSSVpGWlNiRll6VjJ0V2ExVXdNVmxSYTJ4YVZsZFNkbFpIYzNoU2JVNUdaRVprYUdFeGNGVldWRWw0VmpGSmVGWnNiR2hTYkVwWlZXcEtiMWRXWkZoTldIQk9WakJhU0ZadE5WTlViRnB5VGxaYVZWWnNjRXhXTVZwVFZqRnNObFp0YUU1aE0wSkpWMVJDVTFFeFdsZFhiazVVWWtaS1dGUlhOVzloUm10NVRWVjBVMVpzY0hwWGExcFBZa2RLUjJOR1dsZGlWRUl6V2xWYVMyUkdXbkpoUmxab1RXeEtWVmRYZEd0Vk1rNUhWMjVLVjJKVldsaFdiVEZUVm14V1dFMVZaRmhpUm13MFZUSjBjMVl4V1hwVmJuQlhUVWRTU0ZSdGVHRmtWa1p6VjIxc1YxSldXVEpXYTFwWFdWWnNXRlJzWkZWaWExcFhXV3hrYjFReFduUk5WRTVzWWtad1NGWXlNRFZXUlRGWFlrUldWbUpVVmxCV2EyUkxVMGRHUjJGR2NHbFdSbHBGVm1wQ1lWbFdXbk5hU0U1cVVqTlNUMVpxUmtwa01XUnlWbTFHVmsxV1ZqVlZNblJyWVd4S1IyTkdiRmRoYXpWVVdWVmFkMUpXVG5KYVJrNW9aV3RhWVZac1kzaGlNVlY0VjI1T2FsSnRlRmxXYWs1dlpHeFdWVkpyT1ZOTlYxSjZWbTE0VDJGV1pFZFRiRnBYVm5wRk1GVjZTbGRXTVdSWllrZDRVMlZ0ZUhaV1YzQkhXVmRXYzFkWWJHeFNiVkpaVlcxNGMwNXNXbGhPVjBaWFlrWndSMVl5ZUVOV2JVWnlWMjVLWVZKc2NFeFpla1pYWkVkR1NHRkZOVlJTVlhBeVZtMHdkMlZIVVhoU1dHeFdWMGRvVmxsVVNsTlhWbGwzV2tSU1ZsSnNjSHBXVnpWUFYwWmFjMWR1YUZaV2VrWklXV3RhWVdNeVNrVldiVVpYVmpGR00xWnFRbXRUTVZwMFZHdGFhVkp1UWxoV2FrcHZZakZhZEdWSFJscFdhM0I2VjJ0b1YyRnNTblJWYmtKWFRVZFNkbGxxUm1GalZrcDBaRVpPVGxaVVZrcFdhMlF3V1ZaUmVGZHVVbFppUjJoWFdXeG9iMlZXY0ZaWGJVWnFWbXR3TUZwRlZURlZNa3BaWVVad1YxWkZXblpaZWtaV1pWWk9jbUZHV21sU2JIQlpWa1pXYTFVeFdrZFhiRnBZWWtkU2NWbHJXbmRsVm5CR1YyMDVWazFyY0ZwWlZWcHJWakZhUm1ORVdsVmlSbkJUV2xWYVQyUldVblJqUmxKVFRXMW9XVll4WkRSVk1VbDRWR3RrYVZKdGFFOVdiR1JUVlVac2NsZHVaR3hpUjNoWFZqSXdOV0ZHU2xWU2JuQldUVzVDVEZacVNrdFNNVTV5VkcxR1YxWXhTbFZXVkVKaFV6Sk9jMk5GWkdGU01uaFVWRlpXZDFac1dYaGFSRkpYWWxaYVIxUnNWbXRaVmtwMFlVaEdWbUpIVWxSWmFrWlRWakZrZFZSck9WTmlWa28xVjFaV1YwMUdaSE5YYmtwcVVrVktZVlpzWkc5U1JscHhVMnQwVTAxck5VWldSekZIVmpKS1NWRnViRmRpV0VKTVZXcEdUMVl5VGtaYVJsWm9aV3hhZDFaWE1ERlJhekZ6VjI1U2FsSllRazlXYlhoSFRsWldkR1JIZEZkV01GWTBXVEJhUTFZeVNsbGhSRTVYWWxob2FGcEZWWGhXTVZKeldrWk9hVkp1UVRCV2JHTjRUa1pSZVZKdVNrNVhSWEJaV1ZSS1UxZFdiRlZTYm1ScllrZDRXRll5ZEhkaVJrcHlUbGhzWVZKV2NISldha3BMVmpGS1dWcEdaR2xTYTNCSlZqRmFZV0V4U1hoVWJrNXBVakpvVkZSVVFrdFdiRnBWVVd4a1ZFMVhVbGhYYTFwdllrWktObUpJUWxWV00xSm9WVEJhY21ReFduUlNiR1JPVm01Q1NWWnFTalJpTVZwWFYyNU9hbEpGTldoV2JYaDNWa1pzTmxKdGRHdFNNVXBKV1ZWYWEyRldXbkpqUlhSWFlsaG9hRlpVUms1bFJtUlpZa1pTYVZJemFGaFhWekV3WkRGYWMySkdWbFJpUlRWVlZGWm9RMVl4V1hsa1JFSllVbXhzTTFZeWRITldiVXBaWVVaU1YxWkZjRWRhVjNoSFl6RndSMXBGTlZkaWEwcFdWbXhvZDFJeFduUldiR1JXWW1zMWFGVnRNVk5qUm14VlZHdE9XRlp0VWxsVVZXaHZWbXN4Y21KRVVsZGlWRlpVV1d0YVQxTkdWblZVYkhCb1RWaENObFpIZUdGVk1rMTRZMFZXVW1KWGFGaFpWRW96Wld4a1ZWRnNaR3ROVm5CNlZqRm9kMVp0U25KalJtaGFWak5TTTFaRldsWmtNWEJHV2taU1YySldTalpXTW5ScllqSkdSazFJWkZSaE0wSllXVlJLVDAweGNGWlhhelZzVW1zMVdsbFZaSGRWTVZsNFUyeHNXRll6YUhKVWExcGhVakpLU1ZWdGRGTlhSa3BZVjFkMFlXUXdNVWRqUlZwaFVrVktWbFJXVm5kbFZsSlhWV3hrVjAxV2JEWlpWV2hMVmpGYVJtTkZlRnBsYTFwUVdYcEdWMk15VGtoaFJUVnBVbGhDVjFacVJtdGtNVWw0Vmxob1dGZEhhRmxaYlhoaFlVWldkR1ZGZEZoU2JYaDZWakowTUZkSFNraFZiRnBXVmpOb2NsbFZWWGhYUmxaeVlrWmFUbUp0YUhsV2FrSnJVbTFXV0ZKclpHaFNiVkp3V1cxMFMxZFdXbkZSYlVaYVZqQXhORmt3Vm1GaE1VcHlUbFU1VjJKR1NsaFViWGhyVjBkU1NGSnNjRmROUm5CS1ZsY3hkMWxXV1hsU2JrcHFVbTE0WVZsVVNsTlZNVkpXVjIxMFYwMVhVakJhUlZwVFZUSktSMk5FVmxoV2JGcG9Wa1JLUjFZeGNFWmFSbEpwVWxWd1dWZFhlRzlSTVU1SFZtcGFVMkY2YkZoVVZtUlRUVlphV0dONlJsWk5WWEJZV1RCYWMxWXhTblJWV0dSWVZtMVNXRmw2Um1GWFYwcElaVVpPVGxKdVFqSldNV1F3VmpKUmVGZHVUbWxUUlhCWldXeFNjMWRXYkhOV2JtUlVWbTE0VjFsVlpFZFdNREZXWTBab1drMUhVblpXTW5ONFZqSk9SbVZHY0d4aE0wSlJWbFJDYTFZeFNYaGpSVnBQVm0xU2NGbFVRbmRVYkZwMFRWaGtWRTFFUmtsVmJHaHpWbFprU0dGR2FGZE5SMUV3Vm14YWMxWldUblJQVjNCcFVtdHdWMVpyWkRCVU1XUkhWMjVPYWxOSGVGaFpiR2hTWkRGWmQxZHJkR3RXYTFwNVZqSjRZV0ZXWkVoYU0zQllWak5TYUZkV1pFOWphelZYWWtkd1UySldTbmRXYWtKcllqRldWMXBHWkZoaVdGSlZWRmR6TVdWc1draE9WazVvVW10d01GWlhOVU5XTWtWNFYyeGtZVkpGV25KWk1uaFhZMjFTUjFSck5WZFdNMk40Vm14U1MwMUdXWGhhUldoVVlUSlNWVmxzVW5OV2JGcHlWbTFHVlZKc2NGaFdNakV3VjBaSmVGTnJhRmhoTWxGM1ZrY3hTMUl5VGtWWGJHUm9ZVEZ3TWxkWWNFZFZNazE0V2toS1lWSnNTbkJXYTJRMFYwWmtXR1JIUmxSTlZUVklWbXhvYzJKR1NuUlZiR2hWVmpOU2FGVXllR0ZUUjFaSVpFWldhVlpXV1RKV1ZtUTBZVEZaZUZkcVdsTmhhelZZVld0V1lXRkdjRVpYYlVaclZtczFlbGxWWkhOV01WcDFVVzVhVjJKVVFqUlVhMlJTWlVaa2NscEdhRmhTTW1odlZsZDRiMVV4V2tkVmJHUllZbTFTVDFWdE1UUldNVnB6Vld0a2FGSnNjSGxaTUZwM1ZteGFkR0ZFVGxkaGEzQk1WakZrUjFOV1NuUlNiR1JYWWtaWk1GWnNaSGRTTVZWNFdrWm9VMkV5YUZSWmExVXhZMFphZEdSSVpGaGlSbXcwVjFST2IySkhSalpTYkdoWVlURmFjbGxXV2s5U01VNXlUMVprYVZkRk1UUldha0poWXpKT2MxcElVbE5oZWxaVVdXMTBTMWRHWkZkV2JYUk9VbXhzTTFSV2FFdGhiRXBZWVVab1ZWWjZWblphVjNoaFl6RmtkRkpzWkU1V1ZGWTJWMVpXWVdFeVJraFNXSEJTWVRKNFdGVnVjRVpOUmxZMlUyeE9XRkpyTlhsWGEyUkhWVEZhUjFkdVdsaFdNMUpvV1hwQk1XTXhaSFZWYlhCVFYwVktlbFpYTVRCa01ERkhWMjVTYkZKNmJGZFVWM1JYVGxaYVdHVkhkRmhpVlZZMVdWVldVMVl3TVVkalNIQmFUV3BHU0ZWdGVGTmpNVnB6V2tkc1ZGSlZXWHBXYlhSaFZqSkplVk5ZYUZoaVJuQlBWbTE0ZDFWR1duTmFSRkpYVFZkNGVsbFZXazloYlVwSFkwaG9WazF1VVhkV2ExcExZekZrZFdKR1ZrNVdia0paVm0xd1IxbFhUblJVYTFwb1VtMVNWRmxyV25kaU1WbDRWMjEwVlUxck1UUlpNRlp6VmxkS1ZsZHNVbHBpV0ZKTVZqRmFhMWRIVmtoUFYyeE9WakZLTmxacVNURlVNV3hYVTJ0YVZHSnJTbFpXYlhoM1RURlplRmRzWkdwTmExcEpWREZrYjJGV1NsbFJhbHBZVmtWS2NsVnFSbXRrUmtwWllrWmFhVkpyY0c5V1YzQlBZakpHUjFadVRsaGhNMUp5VlcxMGQwMUdhM2RYYlhSb1VsUkNNMVV4VWtkV01ERjFWV3hvV0Zac2NGZGFWVnBoVjFkS1IxVnRiRk5OVlhCWFZqRmtNR0V4VlhoYVJXUllZbXhLVDFadGRIZFVNVlowWlVoa1UySkdXakJhVldSSFlVVXhSVkpyV2xaaVdHaDJWakJrUm1WV1ZuRlViR1JYVWxad2FGZHNXbXRTTVVsNVUydGtZVkpyTlhCV2JGSkdUVVpaZUZwSVpGUk5WbFkxVmtab2IxbFdUa2RYYkdSYVYwaENXRll3V2xwa01XUnlaRVprYVZKdVFscFhWRUpYVkRGa2MxZHVTazlXVjJoWVZGWmtiMlZzYkhKWGEzQnNZa1phTUZReFdtRmhSMFYzWTBkb1YxSnRVVEJYVm1SVFUwWlNjbGR0ZEZOaVZrcFFWbTE0YjFFd05YTlhiRlpVWVd0S2NGUldXbk5OTVZKWFlVVmtWazFyY0VkVWJHUnZWakpLUjJORVRscE5ibWg2VkcxNFMyUkdTblJqUlRWWFlUSTVNMVl4WkRCWlZsRjRWVzVPV0dKSGVGTlpiRlpoVjBac1dHUkhSbWhTYkhCV1ZXMTBkMkpHV25OWGJIQllZVEZWTVZacVNrdFdNVTUwVDFaa1YyVnJWWGRXTVZwaFZtMVdTRk5yYkZWaVIxSndWbXhhZDFkV1pGaGtSMFpVVFZkU1NGWXhhSE5pUmtsNlZXeGFWVlpzV2pOYVYzaGhaRWRPUjFwR2NGZGlTRUphVm14a01HSXhXWGROVldScVVsaFNhRlZyVm1GamJIQkhXa1U1VTAxWVFrZFViR1J6WVZaWmVWcEVWbGRpVkVJMFdrUkdUbVZHVG5WVmJHUm9UV3hLYjFaVVFtRlRNa2w0Vm01U1RsWnJOVlpVVmxwaFRVWlNjMVpyT1doV1ZFWllXVEJhYzFsV1dsaFZhMmhYWVRGV05Ga3ljekZXVmtaeldrWk9UazFWYjNsV01XUXdXVlpOZVZWclpGZGliRXBSVm1wQ1lWZEdVbFZUYlRsb1VteHdTRll5TVVkWFIwcFhWMnRvV0dFeWFGQlhWbHBMWkZaR2MyRkdjR2xTTW1neVZtcEtORmxXWkVaTlZsWldZbGQ0VDFadE5VTlRiRnBZWlVjNWFVMXJXbnBXUjNSaFYwZEtTRlZ0UmxwaE1YQk1WV3BHVTFac1pITmpSM2hUWWxaSmQxWlhNSGhOUmxsM1RWVldWMkV5YUZoWlYzUjNUbXhTVjFkc1dteFdhelY2VjJ0YVUyRldTWHBoUm14WFVtMU5lRlpVUmxwbFJsWjFWRzFHVTFZeFNuaFhWbWgzVWpGa1IxcElTbUZUUjFKWVZXMXpNVkl4VlhsTlZ6bFlVbXh3ZWxVeWREUldNVnBHVW1wT1lWWldjSEpaZWtaaFl6RldkR0ZGTlU1V1dFSllWbTB3ZDJWRk1VZGlSbHBPVm0xU2IxUlVTbE5YVm14elZXNU9XRkpzU2xkV1YzUlBWREZLYzFacVZsVmlSMmhRVm1wQmVGWnRTa1ZYYkdSWFpXdGFNbFpxU2pSWlZrcHpXa2hLYTFJd1dsaFdha1pMVlZaYVdFMVVVbXROVlRWSlZUSjBhMVpYUmpaV2F6bFdZa2RvUkZacVJtRmtSVEZKWVVkMFRsWlhkekJXYTFwdll6RmFkRk51U2s5V2JYaGhWbXRXZDFaR1dYaFhiazVxVFZad01GVnRNWGRoVmtweVkwWm9WMkpIVVhkWlZFWnJVakZPZFZSdGNGTlNWWEJ2Vm0xNGExUnJNVmRpUm1SWVlUTlNjVmxZY0ZkV01XeHlWMjEwVjAxRVFqVlpWVkpMVmpKR2NtSjZRbHBXUlZwUVZtcEdTMlJXVG5SaFJrNXBWbXR3VVZadE1IZE5Wa1YzVGxoT1dHSnNTazlXYTFwTFlqRlNXR1ZGZEZOTlZrWTBWakl4TUdGR1NuSmlSRlpoVmxad1ZGWXlNVXRYVmxaeVpVWmtUbUp0YUdoWGJGWmhWakpPYzFWdVVtaFNWRlp2VkZjMWFtUXhXblJqUlhSUFVqQnNORll5ZEc5V1IwVjVZVWhPVm1KdVFucFdha1p6VjBkU1NWcEhkR2xTTTJoWVZtcEtOR0V5UlhoVFdHaFlZVE5DV1ZsVVJuZFhSbHBWVTJ0MFdGWnRkRFpaYTFwclZqRktXVkZVU2xkU00yaG9WMVphU21WR1VuTmlSMFpUWWxkb2RsWkdaRFJUTVZsNFdrWm9hMUl6VWxkVVYzaGhaV3haZVU1VlpGWmlSMUpKV1ZWb1MxWnRSbkpUYldoV1RWWndlbFp0ZUd0a1IxSklZVVprYVZacmNFbFdiRkpMVFVkTmVGZFlaRTVXYlZKeFZXcEtiMWRHYkhOVmEyUllVbXhhZUZWdGVFOWhhekZ5WTBWc1dtRXhjRkJaVmxwUFVteE9kRkpzWkdsU01VbDZWbGh3UzFOdFZsZFViR3hvVW0xb2NGVnFTbTlWUmxwVlVXMTBhVTFXYkRSV1YzaHJWMGRLY2s1V1FsWmlWRVV3V2xaYWMxWnNXbkZSYkdocFVtNUNOVmRYTlhkVE1XUjBVbGhvYWxORmNGaFpWM1IzVkVaWmVGcEZaRk5XYkVvd1ZXMTRhMVl5U25KVGJscFhZa1pLUkZsVVJscGxSazUxVTJ4Q1YySldTblpXVnpGNlRWZE9SMVpZWkZkaE0wSlBXV3RhZDAxR2EzZFdibVJWWWtac05GVnRjRk5XTURGWVlVaGFWMDFHY0hKVk1WcEhaRVU1VjFkck5WTmlSemsyVm1wR1lWbFhUWGhYYkdSVlltczFWbGxyV21GV1JteHlWMnh3YkdKR2NIaFZNbkJUWVVVeGNsZHViRlZXYkhCMlZtMHhTMlJXUm5OaFJsWlhaV3hhVUZkc1ZtRmpNVnB6WTBWYWExSnJOVTlaV0hCWFUwWmFTR1ZIUm1oTmExcFlWMnRXYTFaSFNuUmxSbWhXWVdzMVZGbFZXbk5XVms1elZHeE9UbFl4U1hoV1ZFbDRVakZWZVZOclpHcFRSMUpaVm0weGIwMHhXbkZUYkU1cVRWZFNlbGxWVlRGVk1VcFhZMFpTVjFKdFVYZFpla0V4VWpGa2MyRkhlRk5OTVVwMlZsY3hNR1F4V1hoVmJrNVhWa1phV1Zsc1ZsZE9SbXQzVldzNVdsWnNjSHBaTUdoTFYyc3hkV0ZHYUZwbGExcFVXWHBLUjFJeFVuSk9WbEpUVmxoQ2FGWnRNSGhrTVUxNVZWaG9VMWRIYUZsWmJYaExWbFpzY2xwRVVsZE5WM2g2VjJ0ak5WZEdTbk5YYm1oWFVucEJNVmxWV2t0a1ZrWnlXa1prVG1KdGFIbFhWbEpIVXpGYVdGTnJaR2hTYlZKd1ZqQmtiMlZXWkZoa1IzUlRZbFphU1ZVeGFIZGhWa3AwVlc1Q1YyRXhXbGRhUkVaYVpVWmtkR1JHVG1sV2JIQkpWakowWVdNeVJrZFRXSEJTWWtaS1dGbHNhRzlOTVZsM1YyMTBXRkl4V2tsVU1WcExWR3hhY2xkVVFsaFdNMUoyVlhwR1dtVldUblZWYkZwcFVteHdXRmRYZUc5aU1EQjRWbGhvV0dKdFVsaFphMlJUVFVad1JscEhPV2hTTVZwNVZqSndWMVl5Um5KaU0yUmFZV3RhYUZreWMzaFhWa3B6V2tkc1UwMXRhRnBXYlRBeFpERkplRlJyWkZaaWJFcFBWbXhvVTFaV1ZuUmtTR1JzWWtkU2VWZHJZelZXVjBwSFkwaHdWMDFXU2tSV2FrcExVMFpXV1ZwR2FGZGlTRUpZVjJ4YVlWWXlUblJTYTJSaFVqSm9UMWxzWkc5T1ZscHpXa2hrVlUxVlZqUldWbWh2VjBkS2MxTnNRbGRpUmxveldUSjRVMVl4WkhWYVJrNXBVbXh2ZDFaR1dsZGhNa1pIVTJ4V1UySkhhRmRVVjNCWFRURmFjVkZZYUZoU01GcEdWa2Q0ZDFZeFduVlJhekZZWVRGd2FGVnFTazVsVmtweVdrZEdVMDF0YUZCV2JUQXhVV3N4VjFkWWJHeFNiVkpoVm0weE5GZEdWWGxsUjNSWFVqQndlbFV5TlV0V2JVcFpZVVY0VjJFeGNIcFdiRnBUWTJ4T2RHVkdUbWxUUlVwWVZteFNTMlF4VlhsU2JGcE9WMFZ3V1ZsclpHOVdNVkpYV2tjNVRrMVhlRmRXTW5Rd1lURkplRmRyYUZwaE1YQnlXVlphYTFOSFJrWk5WbVJYVWxWd2IxWXhXbXRWTVVweVRWWmtZVkl3V2xSWldIQlhWVVphZEdORlpGUmlWbHBJVmpKNFYxWkhSbk5UYmtKVlZqTlNhRll4V2xkak1rWkpXa1phYVZaWVFYZFhiRlpoWWpGYWRGTnNiR2hTUlRWb1ZXcE9iMWRHV25OWGEzUnFZbFUxU1ZwVldrOVViRXB6WVROc1YyRnJiM2RaVkVaS1pVWmFXV0ZHVW1saE0wSjRWbGN3ZUU1R1pFZFdibEpzVTBkU2IxVnROVU5TYkZaMFkzcFdWazFFUmxsV1YzaDNWMjFGZVZWWVpGZGhNWEJMV2xWYVQyTXlTa2RhUms1cFVtNUNWbFpzWkhkUmJWWkhWMWhvWVZORk5XOVZiRkp6VjBaWmQxZHJkRmhpUjFKWldsVmtSMWRzV1hoWGJHaGFWa1UxY2xacVNrdFdWMHBIWVVaV1YwMHhTbTlYYkZwaFYyMVdWazVXV210U2JrSllXVlJPUTA1c1pGVlJiVVpXVFZkNFdGVXllRzlXYlVWNllVWmtXbUpIYUU5YVZWcGhaRWRPTmxKc2FGTk5TRUpKVm10a05HSXhWWGhYYkd4U1lteHdXRmxzVWtOTk1YQldWbGhvVTAxcmNFaFpWVnBQWVZkRmVsRnNRbGRpVkVJMFdXcEdZVll4WkZsYVIwWlRVbXR3V1ZaR1dtdE9SVEZIWVROd2FsSlhVbGxWYlhoM1RVWndWbGR0UmxkaVZYQldWVzEwYjFZeVJuSlhiV2hoVWxkU1dGVnFTazlTTWs1R1RsWk9UbUpYYUZOV2JUQjRaREZKZUdKR2FGVlhSMmhvVlRCV1lWVXhiSE5XYlVaWVVteHdNRnBWYUU5VWF6RlhZMGhvVmxaNlJYZFdhMVY0Vm1zMVZtRkdaR2xXUmxwWlYxWmFZVk15VWtkV2JrcFFWbTVDY0ZaclZtRk5iR1J6VjIxR2FFMVdiRFJXTWpWVFZUSktTR0ZJUWxkaVdGSmhWRlphWVdOc2NFVlJiSEJYVFVad05sWlVTVEZVTWtaelUyNVNhRkl5YUZoWlYzTXhaR3hzVmxkc1RtdFNNVnBKVlcweE1GVXdNVVZXYTJoWVlURmFhRlpVUmxOak1XUjFWbXhLYVZJemFGbFhWbVF3WTIxV1IxWnVSbE5pVlZwWlZXMXpNV1ZXYkZaWGJVWm9WakJXTTFrd1duTlhSbHB6VTJ0b1dGWnRVa2hWYWtaclpGWk9jMkZIYkZoU2EzQTBWbXRhWVZsWFVYZE5WV1JYWW14S2MxVnFRbUZXYkd4eVYyNU9UMUpzVmpWYVZXaFBWMFpLYzJORlpGWk5ibWgyVmpJeFIyTnNaSE5hUjBaWFlraENVVmRVU2pSaE1rNXlUMVprWVZJeWVGaFVWekZ2VjJ4YWNWSnRSbWhOYkZwNVZGWmFiMVp0U25KT1ZtUmFZbGhOZUZZeFduTmpiVVpHVkcxd1RsWnNiM2RXUjNoWFZERlZlVk5yWkdwU2JYaG9WbXhrYjJOc1duRlJXR2hxWWtkU1ZsVXllR0ZoVmtweVkwVldWMkpZUWtOYVZXUlRWakZhZFZWdGFGTmlhMHBaVmxkNFlXUXlTWGhhU0VwWFlsVmFWbFJYZUV0WFJscElUbFYwVmxKc2NEQldWelZEVmpKS1dWVnFUbHBoYTFwb1drVlZlRlpXUm5OYVJUVlhWMFZHTTFadE1IaE5SMFY1VW14a1ZXRXhjRmxaYTFwTFdWWnNjMkZGTld4U2JYUTBWako0VDFZd01WbFJhMmhYVWpOTmVGWlVTa3RTTWtsNldrWm9hVkpzY0hoV1IzaHJVakZKZUZwSVZsUmlWM2hVVlcxMGQxZEdXa2RaZWtaU1RWZFNTRll5TlVkVmJHUklZVVpzVm1GclNtaFZiWGhoVTBkV1NGSnRhRk5OUmxrd1YxUkNiMk14WkVkYVJXeFNZVEpvWVZaclZuZFdSbHB4VW14T2ExWnNXakJaTUZwUFlVZFdjMWRzV2xkaVZFVXdXV3BHUm1WV1RsbGhSbWhwWWtWd1VGWnRkR0ZUTVd4WFYyNUdVMkV5VWxCVmJYaFhUbFp3UmxwRVFsaFNhM0F3VmxkMGMxbFdXbGRXVkVaWFlXdHdURlZxU2s5U1ZsSnpZMGQ0YUUxWVFuWldNblJYWVRGWmVGUnJaRlJpYkVwelZXcEtORlpHYkhKaFJVNWFWbXhzTlZwVldtdGhWVEZ5Vm1wU1YwMXVhSFpXYTJSR1pVZE9TVkZzV21oTldFSk5WbTF3UjFVeFpFWk9WbVJWWWxoU2NGVnRNVE5sYkZsNVpFWmtUbEpzVmpOVVZtaExWREZhV0dWSFJsZGlSMUpVVlRCYVlWWldTbkprUm1ST1lYcFdTVlpYTVRSaE1WbDRVMnhhYWxKNmJGaFVWbHAzWTJ4YVJWTnJOV3hTTURWSFdXdGFVMkZXU2xaalJteFlWak5vYUZWNlNsSmxSbVIxVlcxd1UxZEdTbmRXUmxwaFpESldjMWRZYkU5V1dGSlpWV3BDZDFkc1ZsaE9WVGxYWWxWd1dsbFZaRzlaVmxwelkwWlNWMkZyV21oYVJXUlRVakpHUjFSck5WUlNWV3Q0Vm0xMGEwNUdiRmhTV0doaFUwVTFXVmxVUm5kalZsWjBaVVYwV0ZKc1NsZFdNalZyVmpGS2MyTklhRlppVkVWM1dWY3hTMU5XUm5KYVJsWk9WbTVDVVZkV1dtRlRNbEpYVW14V1ZHSkhVazlXYlRWRFYxWmtXR05GWkZaaVZscElWMnRvVjFaSFJqWldiR3hXWWtkb1JGcFZXbUZXVmtaMFQxWktUbFp0ZHpCV2JHUTBZakZSZUZkcVdtbFNiWGhYV1d4b2IwMHhjRlpYYkdSWFRXdGFTVlF4V210Vk1rVjZVV3BhVjJGcmJ6QlhWbHBoWXpGa1dXTkhhRlJTV0VKWlYxWmtNRmxYUmtkalJXUllZVEpTY2xWcVFtRlRSbXhXV2tjNVZXSkdjRnBWVjNNeFZqSktTRlZxVGxaaGExcFBXbFphVTFkWFJrZGFSMnhwVW01Q1dWWXhaRFJpTVVWNFYydGtWbUpIYUZCV2JuQnpWMFphZEUxV1RsaFdia0pIVjFod1YxWnRSalpTYkd4WFZqTlNkbFpxUVhoalZscHpVV3hrVGxJeFNrMVdha1poVmpKT2NrOVdaRmhpVjNoVVdWUk9RMU5zV25OVmEyUmFWbXhzTlZaR2FITlZNa1Y1WVVaR1YySlVSbFJXYTFwVFZtMUdSbFJyT1dsU2JrSlhWbFJHVTFJeFdsWk5WbVJxVWtWS1YxUlhOVzlYUmxwVlUydDBhazFyTlVoWlZWcFhWakpLU1ZGWWNGZE5WbkJvV2tSR1MxWXhVblZUYlVaVFlYcFdkMVpYTVRCa01EVnpWMjVPWVZKR1NsWlVWM1JoVjBaa2NsWnRPV2hTYTNBd1dsVmFiMWR0U2tkVGEyUlZWbFp3ZWxreFdrOWpiVTVJWlVaT2FWWnJiekZXYWtvd1dWWlZlRnBGWkZSWFIzaHZWVzAxUTFkV1duUmxSWFJWVW14d1ZsVnRNVEJWTURGWFYyNXdXbFpXVlRGV2FrcFhaRWRXUjJOR1pGZGxhMVYzVjJ0U1MxWXhTWGhYYmxaV1lsaG9WVlZxUmt0a01WcFlUVlJDYTAxc1dsaFdWelZQVm0xRmVWVnNiRnBpUmxwWVZHdGFjbVF5Umtaa1JtaHBVbTVDV2xac1pEQmhNV3hYVjJ4b1ZtSkZTbGRVVm1SVFZFWldjVkp1WkZSU01IQklXVlZhVDFZeFpFWlRhM2hYWWxSR00xVnFSbk5XTWtwSFdrZEdWRkpyY0ZsWFZsSkxWVEpPVjFadVRtRlNSa3BaVlcweE5HVldaSEpYYXpsb1lrVndlbFl5Y0VOV1YwcEhWMnhDV2xaRlJqUldha3BQVWpGa2MxZHNaRTVOYldnMVZtMHhNRlp0VmtkYVJXUlhZbXMxYjFWdE1XOWlNVkpYWVVWT1RtSkhVbGxhUldSSFZrVXhjazFVVmxkU00xSjZWbXhrUzFJeVRrbFJiRnBwVjBaSmVsWnFSbUZaVmxwWFVtNVNVMkpYYUU5WldIQlhUbXhaZVdSSE9WWk5hMVkwVlRJMVUxWnRTbkpUYkdoYVlURndNMWRXV25kWFIxWklVbXhTVTAxV2NFbFdha3A2VGxaWmVWTnJiRkpYUjFKWVZtdFdkazFHYkRaU2JVWlhUVmhDUjFsVlpHOVZNa3BYVTJ4a1YySllhR2hhUkVGM1pVZEtSMWRzYUdsVFJVcDVWa1phWVdReFduTldibEpzVWpOU1ZsbHJaRk5TTVZWNVpFaE9XRkpzY0hwV01qRnZWakZLUmxkc1VscGxhMXBVV1RKNGEyTXhWblJpUm1ST1lsZG9ZVlpxUm10T1IwbDVVMWhzVldKck5WZFpiWFIzWVVaV2MyRkZUbXBOVmxwNFZWYzFhMVpHU25SVmJteFhUV3BCTVZZd1drdGphelZXV2taYVRtRnNXbTlXYlhCSFdWVTFjMUp1UmxaaVNFSnZXVlJHZDJJeFpGbGpSV1JvVFd4S1dGWkhOVTlaVmtsNVpVWm9WMkpVVmtSVWExcGFaVVp3UlZGc2NGZE5WVmt4Vm0wd01WUXhaRWRhUldoc1UwVTFWMWxyV2t0bGJHeHhVbXhPVjAxWFVqRlhhMlEwWVZaS2MxZFVSbGRTTTJoMlZrUkdXbVZHWkZsYVIzQlRWakpvV1ZkWGRHdGlNbEp6VjI1R1ZHRXlVbkZaYkZVeFUwWnNWbHBGWkZaTlZtdzBWVEo0UTFkSFNraFZWRUpoVWtWYVMxcFZaRTlTYlVaSVlVWk9UbUpYYUZGV01WcHFaVVV4Ums1WVRsaGliRXBQVm10YVMxWXhVbGRXYms1UFVtMVNlVmxWV2s5V01ERnlWbXBXV2xaV2NGaFdNbmhoVW0xT1IxVnNjRmRXYmtKWlYydFdhMVl4VGtkVGJsSnBVbFJXV0ZsVVRrTlpWbGw1WlVaa1YwMUVSa2hYYTFadlZrZEZlV0ZHWkZwaE1sRXdXVlZhWVdNeFpIVmFSM0JwVW0xM01WZHNWbXRTTWtWNFUyNU9XR0p0ZUdGV2JGcDNUVEZzVmxaWWFHdFNNRnBJVm0xNGEyRkZNVlpqUld4WFRWWndhRmRXWkU5amF6VlhXa2RHVTJKV1NuZFdWekF4VVRKUmVGZHVVbXRTYlZKWVZGVlNWMlZzV1hsa1IzUmFWbXR3U0ZVeWVHOVdWbGw2WVVWNFZrMVdjR2hWTUdSUFUwWktjMXBGTldoTk1FcGhWakZhVjFack5WZFhXR3hVWWtaYVZGWXdhRU5oUmxweFZHMDVhbUpHY0hwV01uUnJZV3N4V1ZGcmFGcE5SbkJ5V1ZaYVNtVnNhM3BhUm1ScFVtdHdUVmRyVWtkak1WbDRWMnhzYVZKck5WbFZhazV2Wkd4YVdFMUlhR2xOVm13MFdXdG9VMVF4V2xaT1ZsWldZbGhvTTFWcVJscGxWMVpJWkVkb1RsWllRbGRXVnpFMFlURmFWazFXWkdwU2JFcFlWbXRXZDFJeGNGaGxSV1JxVm0xU2VsZHJWVEZoVjBwR1kwUldWMDFYVWpOVmFrWldaVlpXY2xwR1VtbGhNWEJhVjFkMFlXUXhaRmRXYmtaVFlUTlNXVlp0TVZOWFJscFlaRVJDVjJKVmNGaFZiWEJUVjIxRmVHTkdhRmRXUlhCSFdsZDRSMlJXVW5OYVIyeFlVakpvZGxZeWVHRlpWMFY1Vkc1T1lWTkZOV2hWYWtwdlYwWlNWbGRzY0U1aVJuQllWMnRTVTJGck1WaFZhMmhYVFZkb00xWnRNVXRUUjBaSVlVWmFhRTFXYjNwV2JGWmhWakpPVjFSdVNtdFNiRXBZV1d0V2QwNXNaRmRXYlhScFRWWktlVlJXV21GaGJFcDFVV3hvV2xaRldqTlpWVnB6VmxaS2MxZHRlRmRpU0VGNFZtdGplRkl4V2tkVGJHeFNZa2RvV1ZadGVFdFJNVkpYVjIxMFYwMVdjREZWYlhoTFlWWk9SbE5zUWxoV00xSm9WMVpWZUZJeVRrWlhiSEJzWWtad1dsWlhjRU5YYXpGelZtNVNhMUo2YkZoVVZWSkhaVVphZEdSRVVsZE5hMXA1Vlcxd1UxWnJNVWRqUm1oYVRXcEdXRlZxUm5kVFIwcEhWR3MxVjFkRlNsQldiVEUwWVRKUmVGTllhR2xTYldoV1ZqQmtiMkZHVlhkWGEzUnFVbXhhTUZremNFZGhWVEZYVTJ4YVZsWXpVWGRXTW5oaFl6Sk9SVkZ0UmxkV2JrSlJWbXhTUW1WR1pFaFdhMlJwVW14d2NGVnFTbTlPYkZwMFpVZDBWRTFyTlhsVWJGcHJZVlpLZFZGdVFsZE5SMUoyV1dwR2ExWXhXblJTYkdST1lrVndTbFp0TVRCak1XeFhVMjVPV0dGNmJGaFpiR2h2VFRGU2MxZHRSbXRTVkVaV1ZsY3hNRlJ0UlhwUmEyeFhWa1ZyZUZaVVJtRmtSazV5WVVkb1UySlhhR2hYVjNScllqSlNjMWRzV2xoaVZWcFpWV3BCZUU1c2JGWlhiWFJWWWxWWk1sWnRkREJYUmxsNlZXMW9WMkZyV21GYVZscFBZMjFLUjFOdGJHbFhSMmhhVmpGYWEwMUdUWGxVYms1WFlXeHdWRmxVVGxOalZsSlhWMnQwVGxac2NGbGFWVlUxWVVaYWNrNVZaRlpOYm1oNlZtcEdTMk14VG5KaFJscE9ZV3RhV1ZkWWNFZGhNbEpYVkc1T1lWSXllRmhXYlRWRFdWWlplRnBFVWxwV2Eyd3pWR3hXYTFsV1RrWmpSemxXWWtkb1ZGbHFSbE5XTVZwMVZHczVhVkpzY0ZwWFZFNTNWakZrU0ZOclpHcFNWMUpZVkZjMVExVkdXblJqTTJoVFRXczFTVmxWV21GaFZrcDFVV3N4V0dFeFdtaFZla3BUVTBaS2NsZHJPVmRpVmtwMlZrWlNRMUp0VmtkWGJsSnJVakJhWVZadE1UUlhSbXh5VjIwNVZrMXJjSGxVYkZwWFYyMUZlR05IYUZwTlJuQllXa1ZWZUZkRk9WZGpSbVJwVjBkbk1WWnFTakJoYXpWWVVsaHNWR0V5VW5GVk1HUTBWMFpTV0U1WE9XcGlSbkI0VlcweFIyRnRTbFpPVlhCYVlURndXRlpIZUZwbFJrNVpZMFpvVjJKR2NIbFdiWEJMVkRKTmVHTkZiRlJpV0ZKVVdXeGtiMWRXWkZoa1IwWnJUV3hhV0ZZeWVHOWhiRXBZVld4b1dtSkdjR2hWTUZwclkyMUdSMXBHWkU1aE0wSklWMVJDYjFFeFdYbFNia3BxVTBad1dGUlhOVzlqYkZsM1drWk9WRkl4U2toV01qRnpWakpGZUdFelpGZGlWRUkwV2tSR2MxWXhaSEpoUms1WVVqTm9XRmRYZEdGVE1WcHpWMjVTYkZOSFVtOVZiVFZEVjFad1ZsZHVaR2xTYkhCV1ZXMTRhMWRIUlhoalIyaFhVak5vYUZZeFdrZGpWbHB6WVVaa1UxWllRblpXYlRGM1VqRmtkRlpzWkZWaWF6VllXV3RWTVZkR1ZuTldibVJZWWtad01GUldVbE5oTURGeVRsaHdWMkpVVmtoV1ZFcExaRVpXYzFac1pHbFhSVEUwVmtaV1lWWXlVa2hXYTFwUVZteHdUMVp0TlVOWlZscFhXVE5vVTAxV2JETlVWbHB2Vm14a1NGVnNiRmRpVkVaVVZrUkdkMUpXUmxsaFJsSlhUVVp3U2xkV1ZsWk5WbEowVTJ0YWFsSXdXbGhVVm1SUFRrWndXR016YUZkTmEzQklWMnRhYjJGWFNrWmpTSEJYVmtWS2NsWlVSbXRXTVZwMVZXMTRVMkpXU2xGV2JUQXhVVEZKZUZwR2JHcFNiVkpZVkZWU1IxSnNWblJrUjBaWFlsVndXbFpYTlhkV01rWnlWMjFHWVZZemFGaGFSbHBQWXpKR1IxcEhiRlJTVlhCUFZtMTRhbVZGTlVkVVdHeFZZa2RTV0ZsdGN6RlhWbXhaWTBaa1dGSnNTbGhXYlRWclZrZEtSMk5JY0ZoaE1taHlWbXRWZUZZeFNuRlZiRnBPVmpKb01sZFdaRFJUTVdSSVVtdHNWV0pHY0c5WlZFNURUV3hhY2xWclpGaGlWa1kwVmpJMVMyRXhTbk5YYXpsWFlsUldRMXBFUm10V1ZrWnpXa1UxVTJKRldUQldWRVp2WVRGWmVWSnVTazlXYkhCaFdWUkdkMkZHYTNsbFNFNVhUVmRTZVZwRlpEQlZNREZIWTBWc1YwMXVVbWhhUkVwSFVtc3hXVlJzVW1sU2JIQlpWMVprTUZsWFJrZGlSRnBVWWtVMVZWVnRlSGRsVmxsNVRWUkNWazFFUWpOVk1qVnJWakZhTmxKVVFtRlNla1pUV2xWYWQxTldUbk5hUjJ4WFVqTm9NbFpyV21GWlYxRjRWMWhvVm1KSFVsbFpiR2hUVjFaV2NWRnVaRTVXYkZwWldsVmpOVll4V25OaVJGcFdWak5vZGxZeWVHRldNazVJWVVaYVRsSXhTbGxXVkVKaFV6SlNTRlJyV2s5V01taHpXV3RhZDFSV1duRlNiRTVTVFZkNFdWVnNhSE5WTWtwSVZXeHNXbFpGV2pOV01WcHpWbFpPY1ZWc2FGTmlXR2cyVjFaV2FrNVdXWGROVm14U1lrZFNXRlJYY0VkVFJteFlZek5vV0ZacldubFpNRnBoWVZaa1NHRkZNVmhXYkhCb1ZUSXhWMUl4VW5WV2JVWlRZbFpLZGxkV1VrTmtNa2w0VjJ4c2FsSllVbFZaYkZwaFUwWmtjbUZHWkZkV01IQkpWbGMxUTFZeVNrZGpSRTVYWVd0YWFGVnFSbXRqTVdSeVRsWmthR1ZzV2xwV2JUQjNUVlpWZVZKWWFGVmhNWEJRVm0weGIxZEdiRmhrUlhST1RWWldNMVl5TlV0aE1ERlhZMFphVjJKWWFISlpWbHBoVjFaR2MxcEdaR2xXUlZZelZteFNSMkV5VWtkVGJsWlVZa2RvY0ZacVNtOVhWbHBIVjIxMFZrMVdXa2hXYlRWVFlrWk9TRlZzVWxWV2JXaEVWV3BHVTJNeFpIUmtSMmhYVFVaWmVsZFVRbXRTTVZsNVUyeHNhRk5GV21oVmExWkhUa1phY1ZKc1RsaFdNRnBKV1d0YVQyRldXbkpqUm1SWFlsaENSRmxVUVRGVFJsSlpZVVprV0ZJeFNsbFhWbEpQVlRGa1IxVnNaR0ZTUmtwelZtMTRjMDVXY0VaVmEwNVlVbXR3ZVZrd2FIZFhiVVY0VTJ4Q1YyRnJSalJaTVZwTFYxWndSMXBIYUdoTlJtdDNWbTB4ZDFNeFVYaFViR2hWWVRKU2IxVnFTbTlVTVZwMFpVWndUbEpzY0RCYVZWcFBWVzFLVjFkcmFGWk5WMmg2Vm14a1JtVldWblZSYkZwcFZrVmFWVlpxUW1GV01rMTRXa2hXWVZKVVZuQlZha1pMVjJ4a1ZWRnNaR2hOVjFKNlZqSTFTMVF4V2xoaFJtUlZWbnBXZGxwWGVITlhSMVpHWkVkd2FWWlVWa3RXVm1RMFdWZEdTRkpZY0ZKaGEzQlpWbTE0WVdGR2JGVlNiWFJVVW14YWVWbFZXazloVmtweVkwWkNWMkpZUWtoVmVrWlBWakZ3UjFac1NtbFdWbkIzVmtaa01HUXhUa2RYYTJoclVqQmFWbFJXV25kTlJteFdWMjFHVjAxcmNGWlZiVFZoVm0xRmVHTkdhRnBOVm5CTVdrVmtVMU5IVGtoaVJrNU9WbGQzZWxacVNqQldNa1Y1VTFob1dGZEhlRlJXTUdoRFZURnNjbHBHVGxoU2JYaDZXVlZqTldFeVNraGxTR2hXWWxob00xbHJXa3RrUmxaMVlVWmtUbUp0YUZGV2JYQkhVekZhZEZScmFGQldiVkpZVkZSR1MxZFdaSEpWYTJSVlRWVnNORll5ZUhOWlZrcDBZVWM1VlZaRldreGFWVnBoWkVVeFNXRkdXazVpUm5BMlZqSjBiMU14YkZkVWExcFBWbTFTVmxac1drdFNSbEp6VjI1T1YySklRa2RYYTFwclZHeEtSbGRzYkZoV1JVcG9WbFJHWVdSR1NuVlRiWEJUWVhwV2IxWnRNVFJrTVZwSFkwVmtXR0pGTlhGVVYzUmhVMVpzY2xkck9XaFdhelZIVlRKNGExWXlSbkpYYldoYVlXdHdVMXBXV2xOWFYwWklVbXhPVjAxVmNGbFdNV1F3WVRGVmVGcEdaR2xUUlRWWVdXeFdZV05XVWxkYVJGSnNWbXhzTlZSc1pEQldWMHBHWTBod1ZrMXVhSFpXYWtwTFZsWktXVnBHWkdoaE0wSkpWa2N4TkZNeVVsaFRhMlJxVWxSV1ZGbHRkRWRPYkZwMFkwVjBUMUp0ZUZoV01XaHpWbGRGZVZWdE9WWmlWRVpVVmtSR1YyTldTbkprUmxaWFlraENWMVpXWTNoU01WbDNUVlprYWxKdGFGZFpiRkpYVlVaWmQxcEZkRmhXTUZwSlZERmFWMVl4U2xaalJURlhZbFJGTUZkV1pGTlNhekZYWWtkR1UyRjZWbEJXYlhCUFlqRmtWMWRZYkd0U01GcHdWRlphVjA1V1ZuTmhTRTVYWWxWd1dWbFZXbXRYYkZsNlZXcEtWVlpXY0dGYVJFWnJZekZ3U0dSR1RrNVdia0pNVm1wS01GWnJOVmhTYkdSVVlteGFVMWxYZUhkWFJsSlhWMnQwVmxKdGVGWlZNblF3VlRBeFZrNVljRmRpV0doUVdWVlZlR014VG5OYVJtaFhUVEZLYjFkclVrdFVNazE0V2toV1UySkZOWEJXTUZwTFZteGFXR05GWkZwV2F6VklWbTE0YjJKR1NYcFZiVGxYWWxoU00xcFdXbkprTVZaMFVteG9VMkpJUWtoV1ZFbDRZakZaZVZKdVNtcFNiRXBYVkZWYWQxWkdhM2hYYlhScVRWWktNRmxyV2s5aFJUQjNVMnhrVjJGclduSlVWV1JHWkRBeFNWcEZOVmRpVmtwdlZsUkNWMlF4WkVkaVNFcFhWa1ZhVjFSV1drdFhSbGw1VGxVNVZVMVdjSHBXYlhCWFdWWktXRlZZWkZwV1YxSk1WVzB4VDFJeVNrZGFSbVJPVFcxb05WWnRNVFJaVm14V1RsaE9XR0pyTlZaWmExcGhWMFphZEU1VlRtbE5WMUphV1RCV2EyRXdNVlpqUkVKWFZqTlNjbFpzWkVkT2JGcDBUMWRHVjAweWFHOVdhMVpoV1ZkTmVGWnVTbXRTVkd4VVZGWldXazFXV2xWVGFrSnBUVlpXTkZkclZuTlZiVXBHVGxkR1YyRXhXakpVVlZwYVpERmtkRkp0Y0ZkaVJYQTFWbXRrTkZVeFZYbFRhMnhTWWtkU1dGWnJWbmRPYkZKeldrVmthMUpyY0hoV01uaHJZVlpKZVdGR2NGaFdiRXBNVmxSR1QxSXhaSE5XYkU1cFZsWndWVlpHV210Vk1sWnpWMjVTYkZJelVsaFVWM2hoWlZaYWMyRkhkRmROYTFwNVdXdFNVMVl5Um5KalJUbGhWbFp3TTFVeFdtRmpNV1IwWWtab1UyRXpRbGRXYlhSaFZURkplRlJZYUZkaE1sSlpXV3RrYjJOV1ZuTldWRVpZVW14S1YxWlhlR3RYUmtwelkwUkNWV0pHVlRGWlZWcExZMjFLTmxOc2NHaE5iRXBKVm0xd1MxTXhaRmRWYkd4b1VteHdiMWxVUm5kT1ZtUnlWV3RrV2xac2NGaFdNalZQV1ZaS1ZWWnNVbFppUm5BelZUSjRZV1JIVGtaalIzaFRUVWQzTUZZeWRHOVZNVlY1VTI1S2FsSnRlR0ZaVkVaM1ZFWlpkMWR1VG1waVIxSXhWMnRhWVZVeVNuSlRhMmhYWWxob1ZGWnFSbHBrTURGWlUyczVWMVl5YUZwWFZsSkxWVEpXYzFkWVpGaGhNMEp6Vm0weE1FNXNiSEpYYlhSb1ZteHdSMVpzYUd0WFJscHpVMnRPVlZac2NGQlZha1pQWXpKS1NHRkdUbWxXTW1oaFZteGtkMU15U1hoWGJrNWhVbTFvVDFacldrdFpWbHAwWlVaa1QxSnRlSGxaVlZZd1YyeGFjbU5GYUZaTmFrRXhWbTB4UzFkWFJraGhSMFpYVFRKb2FGZHNXbXRWTVVwWFVtNU9ZVkpVVmxoV01GWkhUVEZaZVdWR1pGcFdiWGhZVmpJMVUxWkhTa2hsUm1SWFRVZFNWRmRXV21GalZsSnlUMVU1VTJKSVFYZFhWRTUzVWpGa1IxZFlaRmhoTW1oWVZGZHdSMlZzV1hkWGEzQnNWakJhUmxadGVHdGhWbVJIVTI1b1dHSkdXbWhWTWpGWFZqRldkVlpzVm1sV1ZuQldWbGQ0WVdReFpITmFSbWhyVWpOU2NGUldaRk5UUm14eVlVVjBhRkpyY0ZkVWJHaERWbFphYzJOSWNGVmhNWEJoV2xaVmVGWnNjRWRoUjJ4VFltdEpNbFl4WkRCVk1WVjRXa1ZvVTFkSGVHOVZiVEZ2VjBac1dHUklaRlZTYkZZelYydFdhMVpHV25KWGJuQlhUV3BHZGxsVlZYZGtNVTVaWWtaa1RtSnNTbmxXUjNSaFl6RlplRlJzYkdoU01GcFZWVzEwZDFaV1pGaGxSemxXVFZaR05GWXlOVk5pUms1SVZXeHNWMkpZYUhwVWJGcDNVbXh3UmxwSGFGZFdSVm8xVm1wSk1XUXhXbkpOV0Zab1VqSm9ZVlpxVG05VVJscHpXa1YwVTAxWVFraFpNRnByVkdzeFZtTklXbGROVm5CWVYxWmFhMlJHVmxsaFIwWlVVbXR3VlZkWGRHRlRNVnBIVjI1S1dHSlZXbGxXYlhoelRsWndSbHBGWkdoU1ZFWjVWako0YjFZd01YVmhTSEJYVm5wR1IxcFdaRWRTTWtaSFYyMW9hR1ZzV1hsV01uUnJUa1paZUZkc1pGUmliRXB5VldwT1UxWkdiRlZVYTA1YVZtMVNXRlp0TVVkaFZURnlWMnRzVm1KWVFtaFdha3BMVjBkR1IySkdaR2xXUlZwVVYydFNSMkV4V1hoalJWcGhVbXMxVDFsWWNGZFRSbHB4VTFob1UwMVdWalZWYlhCaFZqSktSMk5HYUZkaGF6VkVWVlJHVTFZeFpISmpSM2hUWWtad1lWZFdWbUZpTWtaWFdrVmtWR0pIVWxsV2FrNVRWakZTVjFkcmNHeFNiSEJhV1ZWYVlXRkZNSGhUYkd4WFVteGFWRlZxUm10U01WcFpZa2QwVTJGNlZsbFdSbVF3V1ZkV1YyRXpaRmRpV0ZKaFZtMTRkMlZzYTNkV2FsSllZWHBHTVZsVlVrOVdiVVp5VjJ4b1lWSlhVa3hWYWtaVFpFZEtSMVZzVGxkV00yTjVWbTB3ZDJWRk5VZFdXR2hUVjBkb1dWWXdaRzlXYkZsM1drYzVXRlpzYkROWGEyTTFZV3hLYzFkcVFsVldiVTB4V1ZjeFMxSXhaSFZqUm1ST1lXeGFlVmRXWkhwbFJsbDRXa2hHVW1KR1duQlZiWGgzVlZaYWMxVnJkRlJOVld3MFYydG9SMVZ0U2tkWGJrSldZV3RhU0ZSVVJtRmtSVEZaWTBkNFUySkhkekZXYTJRd1l6SkdWMU51VGxoaWEwcFhXV3hvVTAweFZuTlhiSEJzVW0xU01GVnRlRk5VYkZwMFpIcEdWMkV5VVhkWmVrWnJVMFpPY21KR1NtbFNNbWhaVjFaa01GbFdVa2RYV0doWVlsaFNXRlp0Y3pGbFJscFlUVmM1VldKVldUSldiWGh6VmpKS1ZWRllhRmRTUlhCSVZXcEdUMlJXVm5OWGJXeG9UVWhDV1ZZeFpEQmhNa2w0VTJ0a1dHSkhhSE5WYlRWRFl6RldkRTVWVGxSaVIxSjVWakp6TlZaWFNsWldhbEpYVFZaS1NGWnFTa3RUUmxaWldrWndWMUpXY0c5V2FrSmhWREpTVjFSdVNsQldiVkp3Vm1wS2IySXhXWGhYYkU1VVRWWldORll5ZEd0aFJUQjVWV3hzV21FeVVsUlpNVnBUVmpGa2RGSnRlR2xTTVVvMVZtcEplRTFHV2xoVGEyUnBVa1pLVjFSWE5XOU5NVmwzV2tWMFUwMVhVakZWYlhoWFlWWktkVkZ0T1ZoV1JYQTJXbFZhYTFZeFZuVlViV2hUVFc1b2QxZFdVa05rTVdSelYxaG9ZVkpHU2xkVVZscHpUa1phZEdSSGRGaFNiVkpKVmxjeGIxWnRTa2RqUkU1YVpXdGFlbGt5ZUd0a1JrcHlUbFprYVZKdE9UTldNbmhYWVRBeFNGSnJaRlJYUjFKWVdWZHpNVmxXYkZoamVrWk9UVlp3ZUZWdGVIZGlSMHBHVjI1c1dsWlhVa2hXVkVaTFZqSk9TRTlXYUZoVFJVcEpWMnRTUjFReFdYaFhibFpXWWxoU1ZGbFljRmRWUm1SWVpVZDBhVTFYVW5wV01qVkxWMGRLU0ZWdVFsVldiRnBZVkd0YWEyTnRSa1pQVm1oVFlsWktTbGRzVm05VE1WcDBVMnhzVlZkSGFGaFpWM1JoVmtaYWNWSnRkR3RXYkVwNVZERmFhMkZXU25SUFZFNVhZVEpSTUZacVFYaFNNV1JaWVVaU1dGSXhTbmhXVjNoclRrWnNWMWR1VG1GU2F6VlZWVzE0ZDJWR1ZYbGtSM1JvWWxWWk1sWnRlRzlXYkZsNllVWm9XbFpXVmpSV01WcEhaRVU1VjJGSGFFNVdia0kxVm0xMFUxRnJNVmhVV0doaFUwWmFWbGxzVm1GV1JscHlWMjFHV0dKR2NGbGFWVnByWVRBeFZrMVVVbGROVjJoMlZqQmtTMU5HVm5SU2JHUnBWMGRvU1ZaSGRHRlhiVlpJVW10b2ExSnNXbkJWYWtaTFUxWmFWVk5ZWkU5V2JIQXdWVEo0YzFadFJuSk9WbWhWVmxad00xcFhlSE5PYkVweldrZHdhVk5GU2toV1IzaFdUVlpaZVZOcmJGSmlWVnBZVkZaa2IwMHhXa1ZUYTNCc1VtNUNSMWRyV2xOaFYwWTJWbXhhV0ZaNlFqUlVhMXByVmpKS1IxWnNVbWxTVkZaNlYxZDBZV1F5VmxkWFdHeHJVa1ZLV0ZSV1duZGxiR3QzWVVoa1dHRjZSa2haTUdoaFZqSkdjbU5HYUZwTmJtaG9WakZhZDFJeVJraGhSVFZYVjBWS1QxWnRNVEJoYlZaSFYxaG9WRmRIYUdoVk1GcGhWMFpzY2xkdVpHbE5XRUpaV2xWa1IxZEdXbk5qUm14VlZteEtSRmxVUVhoV01XUnlZVVprVG1KdGFESldhMlEwV1ZaSmVGUnVUbGRpUmxwWVdXeGFTMVpXV2xWUmJVWllZbFphVjFSc1dtRlZSbHAwVlc1Q1YySkhhRVJWTW5oaFl6RndSVlZ0YkU1V2JYY3hWbGN3TVZNeFdraFNia3BQVm0xU1lWWnFUbE5oUm5CWVpVaEtiRll4V2toWGEyUjNZVWRXZEdWR2JGZE5ibEpYVkZaYVZtVkdUbk5hUjJ4VFVtdHdXVlpHV21Ga01XUkhZa2hHVkdKRmNITlZiVEZUVjJ4c2NsZHNUbWhTVkVaNlZUSjRjMWRHV25SVlZFSldaV3RhY2xWcVJsZGpNV1IwVW14T2FHVnNXbGRXYkdONFRrWnNXRlpyWkZkWFIzaHlWV3BPVTFZeFVsWlZhMlJZVm14d1dWUnNhRTlXTVZsM1kwVnNWMVo2VmpOV01uaGhZekpPU0ZKdFJsZGlWa3BKVmxjeGVrNVdXWGhqUldocFVtMW9WRmxVVGtKTlJscHhVMnBTVjAxV2NIbFVWbHByVmtaa1NHVkdWbHBXUlhCVVdXcEdWMlJIVmtsYVIzQlRZa1p3TkZaWE1UQk5SbVJIVTI1U1ZtSkhlRlpXYlRGdlRURmFTR1ZHY0d0TlJGWllXVlZhYTJGV1drZFhhMnhYWWxoU2NsVnFTazVsUmxKMVZHMW9VMkpJUW5kV2FrSnJZakZTVjFkdVJsSmlWVnBoVm1wR1MxSXhVbk5YYlRsb1RWVndNRmxWV2xOV1ZscFlZVVZTVmsxV2NISldNR1JUVWpGU2MxcEZOVmROTW1oYVZtMXdTMDVIU1hoWGJsSlRZbXR3VUZacVFtRlpWbHB5Vm0xR1RrMVdjRWRXTWpWTFlrWmFWVkpzWkdGU1ZuQlFWbXBLUzFJeVRrVlhiR2hYWWtad2VWZFhjRWRWTWsxNFkwVmFXR0pHU205WmExcDNWMVprV0dWR1RsSk5SRUkwV1RCYVlWZEhSalpXYms1WFlsaG9URlJXV2xabFYwNDJWbXhrVG1FelFsbFdWRW8wWWpGa1IxZFljRlppYkhCWFZtdFdkMVZHVm5GU2JVWnJWbXR3ZWxaSE1XOVVhekZXWTBaR1YwMVhVWGRYVm1SU1pWWmFjbHBHWkdsU01taFFWbTE0YTFVeFpFZGlSbXhxVWxkU1dWVnRNVEJOTVd4V1lVZDBWMDFFUm5sWk1GcGhWakpLV1dGRlVsZE5SbkJvV1hwS1QxSnRWa2RhUjJ4VFRWVndUbFpzWkhkVE1VbDRVMWhzVldFeWFHOVZiRkpYWTBaV2MxZHVTbXhXYkhBd1drVmtSMWRzV25SbFJteFdZa2RvZWxac1dtdFRSMFpIWWtad2FWZEhhRTFYVkVaaFZqSk5lRlp1VmxWaVIyaFVXV3hvYjA1V1pGZFdiR1JWVFZad1NWVXlkR3RoYkVwelkwWmtWVlo2VmtSV2ExcGFaVmRXUjJOSGRFNVdNVW8yVjFaV1lWbFdVblJUYms1VVltMTRXRmxYZEV0amJGWTJVbXM1VTAxV2NERldSM2h2WVZaSmVGTnVXbGhXYldnelZtcEdTMVl4WkhWU2JFcHBWbFp3YUZadGNFSk5WMVp6V2toS2FGSnJOVmRVVjNSM1YyeFdXR1ZIT1ZoaVIxSktWVmQ0YjFaWFNrZGpTRXBhVFc1b2FGcEZaRk5UUjFKR1RsWmthRTB3UlhsV2JURjNVekExUjFkWWFGaFhSMmhvVld4a2IxWXhiSEphUkZKWVVtMTRlbGxWWXpWaFJrcDBaVVprVjAxcVZsQldha1poWTIxT1NXTkdaRk5sYTFsNlZtdGtORmxXV2xkWGJHeG9VbTFTYjFSWGVFWmtNV1JYVld0MFUwMVZOVWhXUnpWTFYwZEtXVkZzVWxwaVdGSk1Wako0WVdSRk1WVlZiRkpPVmxSV1NWWnRNWGRaVmxWNVVtcGFhVkpzU2xaV2FrNVRUVEZXZEdWR2NHeFdNVnBIVkRGa2IxWXlSalpXYTJoWFZrVnJlRnBFUmxwbFJtUnhWMnhPVjFKVmNGcFdiVEUwVmpBMVIxZHVSbE5pVlZweVZtMTRZVTFHY0ZaWGF6bG9WbXh3ZVZrd1VrdFdNa3BWVVdwU1ZXRXlVbE5hVlZwM1VteHdTR0ZGTlU1aVJYQmhWakZhVTFGck1WZGFSbVJYWW14S2MxVXdaRk5qTVd4eVYyeGtUMVp1UWxkV2JYTTFWakF4Y21ORmFGcGlia0pNVm0weFMxZFhSa2RSYkdoWFlraENiMVp0Y0V0VU1VNVhWRzVTVTJKRk5YQlZNRlpMVjJ4WmVGVnJkR3hoZWtaWVZqRm9iMVp0U25KT1ZscGFZVEpTVkZrd1duTldWa1oxV2tad1YySklRWGRXUmxwVFVURmtjMWR1VW14U2JYaFhXV3RrYjJOc1drVlNiVVpZVW14YU1GbFZXbUZoVmtsNFUyeFdXRlpzV21oV2JURlNaVVprZFZadFJsTmlWMmhWVjFkNGIySXdOWE5YYmxKT1UwZG9WRlJXV25OT1ZsVjVaRWQwVjFJd2NFbFpWVnB6VjJ4YVJsZHFUbGRXVm5Cb1dUSjRhMlJHU25SalJUVm9aV3hhU2xZeFpEQlpWbGw0VjFoc1ZHRXlVbkZWTUdRMFYwWnNjMkZGVGxSU2JWSllWMnRWTVdKR1duTlRibXhYVFdwR1NGWlVTa3RqYkU1MVdrWm9WMlZyVmpOV1dIQkhVekZaZUZwR2JHaFNiV2h3Vm14YWQyRkdXblJqUlVwc1VsUldXRll5ZEc5aE1VNUdUbFpvVm1GclNqTlZNbmhYVjBkT05sWnNaRTVoTTBKWFZtMHhNRlV4V1hoWGJrNXFVMFZ3V0ZSV1pGTlZSbFowWlVoa1ZGSXdXa2RVYkdSelZURmtSbE5yZUZkaVZFSXpXbFZWZUZOR1NsbGhSbWhwVWpKb1ZWZFdaRFJrTVdSSFlraEtZVko2YkdGV2JURTBaV3hzVmxkck9WZFdhM0I2V1RCV2IxWXdNWEZTYTJoYVZrVmFURlpzV2t0amJVNUhZVWRvVG1KRlZqTldiWGhUVWpGc1YxTnVUbUZUUlhCeFZXMHhVMk5HVm5ST1ZVNU9Za2RTV1Zrd1ZtdFhSMHBYVjJ4b1YxSjZWbGhXYTJSTFYxWkdjMVZzWkdoTmJFVjNWbXBHWVdFeFpFaFZhMmhUWWxoU1QxVnJWa3BOUmxweFVtMDVhVTFYVWtsVk1qVkxWREZrUm1OR1pGcFdNMUpvV1ZWYVZtVkdaSE5hUjNSVFRWWndTbGRyVm1GV01rWlhVMjVXVW1Gc1dsbFdhMVpMWVVac05sSnNjR3hXYTNBeFZUSXhjMVV4U25KalJtaFlWbTFSZDFwRVJrOVNNazVHVjJ4b2FHVnRlSGhYVjNoWFdWWk9WMk5GV21GU1JrcHZWV3hTUTAweFZYbGxTRTVYVFd0V05Ga3dhRWRXVmxwelkwWm9ZVkpXY0ZoV01XUkhVakpHU0dKSGFFNVhSVXBZVm1wR1lWVXhVWGhXV0doaFVsZFNjRlV3VlRGWFJscHlWbTFHVjFKc1NsaFhhMXBQWWtaYWMySkVWbFZXYkVwRVZtcEJlRkpXU25WalJtUk9ZV3hhTmxadGNFSmxSMUpYVW01S2JGSnRVbTlaVkU1RFZGWmFjVkp0UmxkTmJFcEpWVzEwYTFkSFNsbGhSemxWVmtWS1RGWldXbHBsVjFaSVVteHdWMkpHV1RGV2EyTXhWVEZWZVZKWWJGWmlSVFZoV1ZSS1UxWkdhM2RYYlVaclVqRktTbGRyVlRGVWJGcDFVVmhrVjFKc2NGUlZWRVpyWXpGa2RWVnNXbWhoTUhCWlYxZDRVMVl4VmtkWFdHUmhVbGhTVlZWcVFtRlRiRlowWlVkR2FGWnJiRFZaVlZwWFZqSktWVkpVUWxwbGEzQlBXbFZhZDFOV1ZuTlViV3hUWVROQ1dsWXhaREJaVm1SeVRWWmtZVk5GY0ZoWmJGWmhZakZTVjFwR1RsUlNiRlkwV1ZWa01HRkhTa1pqUm14YVZsWndjbFpzV2xwbGJFWnpZVVphYUUxWVFtaFhiRnByVmpGT1NGVnJaRlppUjFKdlZGWm9RazFzV1hoWGJHUm9UVlZzTkZZeGFHOVhSMHB6VjJ4T1dtSkdTbnBXTUZwelYwZFNSbVJIY0dsU2JrSTBWbGN4ZWs1V1ZYbFNhbHBwVW0xb1lWWnNaRk5sYkZwVlVtMUdVMDFYVW5wV2JYaHJWakF3ZVdGSE9WaGhNVXBJVmtSS1RtVkdjRWRpUjJoVFlraENkbFpHVmxOV01rWkhWMjVTVGxOSGFGQlZiVEZUVTBac2NtRkZkRmhTTUhCYVZsZDRiMVp0Um5KVGJHaFZZa1p3YUZZd1pGZFNNWEJIWVVkc1YxZEZTa3BXYkZKS1RWZFJlRmRZWkU1V1YxSnhWVEJvUTFkR1VsWmFSazVYVW14YU1GUldXazlWTWtZMlZteGtWV0pHY0hKWlZscHJVMFpTY1ZSc1pHbFdSVmw2VmxSSmVGWXhTWGhVYkd4b1VtMW9XVlZxUmt0VlJscHhVV3hrYTAxWFVsaFphMXBYVmtkR2MxTnRPVlppV0dob1dsZDRXbVZWTlZoa1IyaE9ZVE5DU2xkc1ZtRmlNVmwzVFZoV1ZsZEhVbUZXYTFaaFlVWnJlV1ZIZEd0V01EVklXVEJhYTFZeVNuSlRhbFpYWWxob1ZGVlhNVkpsVmxwellVWk9hRTFzU25kV1Z6QjRWVEpKZUZWc1pGZGliVkpWVm0xNGMwNUdXWGxOVldSWVlrWnNNMVJzYUhOV1ZscHpZMGhLV0Zac2NFdGFSRVpyWXpGV2MxWnNaRk5XV0VKT1ZtMHhORmxXYkZoVmExcE9WbXhhVTFsc2FGTlVNVnB4VW10MFdGWnNiRFZhUldSSFlWVXhjbFpxVWxaTlYyaHlWakJrUzFOSFJrZFhiR1JwVW01Q1RWWnFRbUZXYlZGNFdraFNVMkpZUWs5WlZFWjNVMnhrY2xadFJtbE5WbFl6VkZaV2MxVnNaRWhWYkdoYVlUSlNVMVJWV21GV1ZrcDBaRWR3VGxkRlNraFhWM1JoVXpKR1YxTlliR2hTYlhoWVZXMTRZV0ZHY0VWU2JIQnNVakExU0ZkclpFZFZNVnBJWlVaR1dGWXpVbGhhUkVGNFVqSktSMWRzYUdsWFJrcFhWMWQwVmsxV1NYaFdXR3hyVTBVMVdGUlZVa2RYVmxwWVkwVTVWMDFWY0VkWk1GWXdXVlphVjJOSVNsZE5WMUpNVldwR1UyUkhTa2hoUlRWT1VsYzVObFp0Y0V0T1IwVjNUVlZrVlZkSGFHaFZiR1JUVjFac2RHUklaRmhTYlhoNlZtMHhSMVl4V25OVGJHaGFWbFphVUZaVVNrdFNNV1J6WVVaa1YwMHhTbmxXYlhCQ1pVZE9kRlJyWkdGU2JWSlBXVzE0UzAxc1duUmpSVXBzVWpBMVdGVXlOVmRoYkVwMFZXeG9WbUpIYUVSV1JscHJWbFpPY1ZWc1ZrNWhlbFpaVm14ak1WUXhiRmRUV0d4c1VteEtWbFp0ZUdGWFJsSlZVbTFHYWxacmNEQlZiWGgzVmpKS1JtSXpaRmRpVkVWM1dWUkdhMU5HVG5KaFIzaFRaVzE0V0ZkWGVGTlNNbEp6WVROa1dHSnJOVmhXYlhSM1RWWmtjbGR0ZEdoV2EydzBWVEo0ZDFkSFJYaFhiV2hZVm14d1ZGbDZSbXRrVmxKMFkwWk9hVll5YUZwV2JURjNWREpKZVZSdVRsaFhSMUpvVld4b1UxZEdiSEphUms1c1lrZDRWMVl5Tld0aFJrcFZVbXh3VmxaNlFURldha3BIWTJ4a2RHRkhSbE5TVm5CTlYxaHdTMVF4U25OWGJrNVVZbGQ0V0ZSWE1XOVdiRmw0V2tSQ2FFMUVRalZXYlRWUFdWWktjMWRzVGxwaE1sSlVXVEZhVTFZeGNFVlZiR2hUWWtkM01WZHNWbXROUmxsNFUxaGtWMkZzU2xkVVZ6VnZaR3haZVUxVldteFNNRFZHVmtkNGQxWXhXblZSYWxwWFVucEZNRlpFU2s5amF6bFhXa1phYVZJeFNuWlhiR1EwVjJzeGMxZFlhRlpoTURWaFZtcENWMDVHV25OaFJ6bFlVakJ3ZWxZeWVFOVhiR1JKVVd4b1YwMUdjRlJXTUZVeFZqRlNkR0ZHVG1sV2EzQmFWbTF3UzAxSFVYbFRhMlJZWW1zMVZWbHJhRU5aVm14VlVtNWtXRkp0ZUZkV2JHaHZZV3N4Vms1VVFsVk5WbkJ5Vm1wS1YyTnNaRlZUYkdSVFlraENlVlpyWTNoV01VNUhWRzVLYVZKc1NuQlZha3B2WkRGa1dHVkhSbFJOVm5CWVYydGFiMkV4U1hkWGJrWlZWbFpLV0ZVd1dscGxSMFpKVkcxc1UyRXlkekpXYkdRMFl6RmtkRkpZYUdwU1JUVm9WbXBPYjJWc2EzbGxSbVJxWVhwc1dGZHJXbXRVYkU1R1UydDBWMDFXY0ZoWFZscEdaVVprV1ZwRk5WZFdNbWhZVjFaU1QySXhiRmRWYkdoUFZucHNjVmxyWkROTmJGWjBUVlJDYUdGNlJubFViRlp6VjIxRmVHTkdRbHBXYkhCUVZXMTRUMk5XVG5OYVIyeFhVbFZyZDFacldsZFpWMDE0V2tWa1ZtSkhlSEJWYlhoaFYxWldjVk50T1d4U2JIQlpXbFZrTUdGVk1WZFhiR2hYVFdwV1ZGbHJXazlUUmxaellrWmFhVlpGVlhkWGJHUTBWMjFXV0ZWclZsSmlSMmhVVkZWb1ExTnNXbk5hUkZKYVZteHdlbFl4YUhkaFJrNUdZMFpvV21FeGNGaFVhMXBoWTFaS2NrOVhkRmROUkZaSlZtcEtlazFYUmtoVGEyUnFVbFJXV0Zsc2FGTldSbFp4VW01T1YwMVlRa2RYYTFwcllWZEdObFpzY0ZoV00xSjJWVlJLU21WR1ZuTmFSMmhUVmxoQ2VsZFhkR3RWTWxaWFdraEtWbUpGTlc5WldIQkhaVlpTYzJGSVpGaFNNRlkxV1ZWV05GZHNXWHBoUlhSaFZucEdTRlZxU2tkU01WcHpXa2RzVkZKVldUSldiWGhUVWpGc1dGSllhRmhYUjJoWldXMTRTMVpHYkhKYVJrNVZUVlp3TUZSV1VrOVViRnB6WTBaYVZrMXVRa1JaVjNONFZqRmtkV05HYUdoTlZuQXlWMWQwWVZNeVVraFNhMlJoVW01Q2NGVnRkSGRUVmxwelZXdGtWazFXY0hwWGEyaFhWbGRLU0ZWc2FGcFdSVFZFVkcxNGExWldSblJrUlRsVFlrWlpNVlpVU1RGVE1WcElVbGh3Vm1KSGFHRlpWRXBUVlRGU1ZsZHNaRmRXYTNCNldUQmtORll5UmpaV2FsWlhUVzVTY2xwRVJtRlNNVTVaWVVaU2FWSXphRnBXYlhCUFlqSlNjMkpJUmxOaVZWcFVWRlprVTAxV1ZuUmxSVGxvVWpGYU1GcFZXbk5XTVVwelkwaGFWbFpGV2xCVmFrWjNVMVpPYzJGSGJGaFNhM0F5Vm0wd2VFMUhUWGRPVldSWFYwZDRVRlpxVGxOWFJsSlhWbTVrYkdKSGRETlhhMk0xVmpKS1ZsZHViRlppUjJoMlZtMHhSMk5zWkhSaFJtUk9WakZLU1ZaVVFtdFNNVWw0Vm01T1ZXSkhVbFJaYTJoRFlVWmFkR05GWkdoTlJGWklWakZvYjFkR1pFaFZiRUpYVFVaVmVGWXhXbk5qYkhCSVQxZHdUbFpzY0RSV2EyUTBWREZrUjFOdVRsUmlSM2hvVld4YWQyTnNXa1ZTYTNScVRXdHdSbFp0TVVkVk1WcHlZMFpXVjJKWVFreFZha0V4WXpGT2RWTnRhRk5pYTBwUVZsZHdTMkp0Vm5OWFdHaFlZbFZhVlZSV1pGTlRSbHAwVGxVNWFGSnJjSHBaTUZVMVZqSktWVlpyVG1GV00yaG9WbXhhUjJSSFVrZFdhelZYVjBWSk1WWnJaRFJaVjBWNFlrWmtWRmRIZUc5VmJGSnpWbXhhYzFkdFJsaFNiRXA1VmpJeFIyRXhTbFZTYTNCYVZsWlZlRlpVUVhoU01rbDZXa1prYVZaRlZqTlhWM0JIV1ZaWmVHTkZXbWhTTW1oVVdXeGtiMWRXV2tkV2JYUldUVlp3U0ZZeWRGZFZNa3BXVjI1R1ZWWnRhRVJWYlhoaFYwZFdTRkpzVm1sU2JYY3lWMVpXWVdFeFdYbFNXR3hXVmtWS1dGVnJWbUZqYkZaeFVtczVhMVpzV2pCYVZWcFBZVlpPUmxOc2JGZGhNWEJ4VkZaYVUyTnJNVmRhUm1ob1RWWndWVmRXVWs5Vk1rNVhWV3hrVjFaRldrOVdiVEUwWlZaWmVVMVVRbGRXTUhCWFdUQm9jMVpXV2xoaFNGcFhUVVp3YUZwRldsZGpWbVIwVW14a1YySnJTblpXTVZKTFpXc3hWMWRZYUdwU1YyaHhWVzF6TVdOR2JGVlJibVJPWWtad2VWWXlNVEJVTVVweVkwUkNWMVp0YUhaV01HUkxZekZPZFZOc1dtaGhNSEJ2Vm0xNFlWVXhaRWhVYWxwVFlYcFdWRmxyYUVOVGJHUnlWbTEwVGxKdFVraFZNV2hyWVd4S1dHVkdhRmRpYmtKWVZXdGFZV05XUmxsaFJsSlRZa1p2ZUZacVNqUmhNVkp6VTI1V1VtSlViRmhXYWs1RFUwWnNWVk5zVGxSU2JGcDVWMnRhYjJGSFZuTlhibHBZWWtkUmQxWnRNVmRTTVdSMVZXMTBVMDB4U2xCV1Z6QjRUa1prUjJKSVNsaGlXRkpZVldwQ2QyVnNWWGxOUkZaWFlYcEdTRll5ZERSWFJscHpZMGh3V2sxdWFISmFSbHAzVWpGYWMxUnRiRk5OTWs0MFZtcEtORll5UlhoVFdHaGhVbGRTVlZZd1pHOVhWbXhWVTIwNVdGSnNXbmhXUnpBMVZteEtjMk5GYkdGV1ZuQXpXV3RhUzJOck5WbGpSbkJvVFZoQ01sWnRjRWRUTVZwMFZHdG9VRlp0VWs5V2JUVkRZakZrV1dORlpGaGlWbHBJVm0wMVYxWkhTbGhoUmxKYVlUSm9SRnBFUm1GWFJURkZVbXhLVG1FeGNFbFdNblJoWWpKRmVGTllaRmhpVlZwWVdXdGFTMUpHVW5KWGJIQnNVakJhU2xaSE1YTlZNa1kyVm10b1YxSXphR2haYWtaclpFWktXV0ZIY0ZOTmJXaHZWbTB4TkdReFZYaGpSbHBZWWxoU2NsVnFSa3RUUmxwMFRWaE9WMDFXY0hwWlZFNXJWakF4VjFOclVsZFdSVnBoV2xWYWExZFhSa2RWYkdoVVVsVndNbFpzWTNoT1JrMTRXa1ZrVjJKcmNGaFpiRlpoWWpGV2RFMVVUazVpUmxvd1ZGWlNRMkZIU2xaalJXeFhWbnBXTTFZeWVHRlhSbFoxVjJ4d1YxWXhTbGxYV0hCSFlUSk5lVk5yWkdGU1ZGWllWRlpXVjAweFduUmxSazVUVFZVMU1GWnRkR3RoYkVwWFkwZG9WbUpVUmxSV01WcFhZMVpPZEU5V2FHbFNNVXBhVjJ0V2EwMUdXbkpOV0VwUFZtMW9XRlpxVG05amJGbDNXa1YwYTFKc1dubFVNVnBoWVZaYVJsWllaRmhpUm5Cb1dWUktUMlJHU25KWGJFSlhZbFpLVUZadGVHOVJNRFZYV2taV1VtSlZXbTlVVm1SVFRVWlZlVTVXWkZaaVZWWTFXVlZhYjFkc1dYcFZhazVYVWxad2FGbDZSbXRqYkhCSVkwWmthVkpZUVRKV2JUQjRUa2RGZVZKc1pGaGlhM0J4VlcxNFlWZEdVbGhPVnpsWVVtMVNXRmRyVm1GaVJscHpWMjV3V0dFeGNISlpWbVJIVG14YWMyTkdhRmROTVVwNVYxZHdSMWxXU1hoV2JrNW9VbFJXV0ZwWE1UUlhiRnBZVFZSU2FrMUVWa2hYYTJoTFZtMUZkMDVXYkZwaE1YQjZWR3RhVjJSSFRrZFViR1JPVWtWYVdsZFdWbTlaVm1SelYyNU9hbEpZYUdoVmJHUlRVMFpWZUZkcmRHdFNhM0I2VjJ0Vk1WUnNXbGxSYWtwWFlXdGFjbHBFUmtwbFJtUlpZa1phYUUxdGFGbFhWbEpIWkRKT2MxWnVVazVXZW14WlZXMHhORTFHY0VaV2FrSlhVbXR3TUZaWGVHOVdNa3BWVWxoa1YxSXphRXhaZWtwUFVqSktSMWRyTldsaVJYQjJWakZhYTA1R1VYaFViR1JUWW14S1ZGbHJXbUZYUmxwMFRsVk9WVlpzY0ZsYVJXUkhWMnhaZDAxVVVscE5SbHBvV1ZSR1MyTnJOVlpQVm5CWVUwVktXVlpVUm1GWlZsbDRZMFZXVm1KWGFFOVdiWFIyWkRGYVZWTlVSbFpOYTFwSVZUSndZV0ZXU25SbFIwWlhZVEZhYUZsVlduTldiR1IwVW0xd1YyRjZWalZXUkVaclpERlNkRkpxV2xkaE1taFlWRmMxVTJGR2JGVlRhMlJYVFZkU1dsa3daRzlWTWtwSFkwWnNWMVo2UWpSV1JFRXhVakpLU1ZKc1NsZFNWbkJaVmtaYWExVXdNVmRYYkdoT1YwZFNWMVJXWkZOVFJsVjVUbGhrV0ZKc2JEWlpWV1J2Vm0xR2NsSllhRmRoYTFweVdrWmFWMlJIVmtkVWJYaHBWMGRvWVZadE1IZGtNbFpIVmxob1ZXSnJOVmhaYTJSdlZERldjbGR0UmxoU2JYaDZWbTAxYTFZeVNrZGpSRUpoVWxad1VGWnFRWGhTVmtweVlVWndUbEpyY0ZGV2JYQkNaVVpPUjFadVRsWmlSbkJQVlcwMVExUldaRmxqUldSYVZqQXhORlpYTlZOaFZrcDBWVzA1VlZZelFuWlViRnBoWkVVeFdWcEdVazVTUlZwSlZtMTRiMkl4V1hoYVJXaG9VakpvVjFSVldsWmxSbGw0VjJ4d2EwMVlRa2xVTVZwclZqSktXV0ZFVmxkTmJsSnhWR3hhYTFJeFRuVlViRkpwVWpOb2FGWkdWbUZrTWs1elYyNUdVMkV6VW5KVmFrWmhVMFpaZVdWSFJtaFdiVkpJVlcxd1QxZEdXblJVYWxKV1pXdGFhRmt5Y3pGV01XUjBVbXhPYVZKdVFsRldiVEIzVFZaR2RGWnVUbUZTYlZKWldXeFdZV0l4VWxkV1ZFWlVWbXhhTUZwRlpFZFdWMHBIWTBSQ1YxWXphRlJXTWpGR1pWZEdSbFZzY0doaE1YQnZWMVJHWVZReFpGaFNhMlJoVWxSV1dGUldWbmRUYkZwMFkwVndUbFpyTVRSWmExcHJWa2RLY2s1V2JGcGlXRkpNVm1wR2MyTnNaSEprUm1oVFlraENXRlpxU1hoU01XUkhVMWhvVkdFeWVGZFpiR2h2VFRGYWNWTnJaRTlpUm5CNFZqSjRhMkZIUlhsa1JGSlhZVEZLU0ZsNlJscGxSbEoxVTIxR1UySkZjSGRXYlhoaFpERmtWMXBHWkdGU1JVcFZWRmQwWVZOR1dYaGhSM1JZVWpCd1NGa3dhRTlXTWtaeVYyMW9WazFXY0ROVmJYaHJaRWRTUjFkck5WTlNWbkJNVm14YWEwMUhTWGhYV0doVVYwaENiMVZxU205WlZteFlaRWRHYW1KSGR6SlZiVEV3VjBaWmQwNVZhRmROYWtaMldWVmtWMk14WkhOalJtUk9WbTVDVlZaWGNFdFZiVlpIWTBWYVlWSnNjSEJaYTFaM1pXeGFXR1ZIT1ZaTmF6VllWbGQ0YTJGR1NsWk9WbFpXWWxSR1ZGcFdXbHBsVlRGVlVXMW9VMkV6UWxkV1Z6RTBaREZhYzFkdVRsUmhNbWhZV1ZkMGQxTkdhM2xOVlhCc1lraENTRmt3V210Vk1XUkdVMnhHVjAxdWFHaFhWbHBPWlZaU1dXRkhjRk5XTVVwWVYxZDBhMkl4V2xkV2JrNVhZbTFTY2xsclduZGxWbGw1WlVVNVYxSlVSbGhXYlhCVFYwZEZlRmR1U2xkaGEzQk1XWHBHVDJSV1VuTlhhelZUVFZWd1ZsWXhaSGRTTVZsNVZXdGFUbFpzV2xkWmEyUlRZMFpXZEdWR2NFNVdiVko1Vm0weE1GVXdNWEpYYkdoV1RXcFdURmxYZUU5VFIxWkhWMnh3YUUxWVFrMVdWRUpoV1ZkT1YxUnVTbXRTYldoWVZGVmFkMU5HWkhOV2JVWnJUVlpzTlZVeWRITlZiVXBHVjJ4b1YySnVRa2RVVlZwaFVsWk9jazVYZUZkaGVsWTFWakowYTFJeFZYbFRiR1JVWW01Q1dWWnFUbE5oUm13MlVWUkdhazFYVWpGV1YzTXhWMFpKZUZOc1ZsZFNiSEJYV2xWVk1WSXhXbGxoUjJoVVVsUldXVlpYY0VOV01EVlhWMnhvYkZORk5WbFpiRlpYVGxaYVdFNVhSbGhoZWtaSVdUQmFiMWxXU2xkV1dHaFhZbGhvVkZwRlpGZFNNWEJJWWtaU1UxWllRa3hXYlRCNFpERk5kMDVWYUZOWFIzaFVWakJrVTFReFduUk5WazVxVm14V00xbFZWazlYUmtwelUyeHNXazFHY0hKV2FrWkxaRWRXU1dKR1pFNWliRVl6VjFaamVGSXdOWE5YYms1b1VtNUNXRlp0TlVOWFZscDBZMFYwVkUxVk5WaFZiWGh6WVd4S2RGVnNVbHBoTVhBeldXcEdZV014YTNwaFJtUk9WbGQzTUZacVNURldNVnBJVTJ0YVZHSkhhR0ZaYTJSVFpHeGFjMWR0UmxOTlZuQXdWVzE0YjJGSFZuSlhhMnhYVFc1U2FGWnFSbGRrUms1ellrWmFhV0V3Y0ZkV2JUQjRWV3N4UjFkWVpGaGlSbkJ6Vm1wR1MxTldWblJsUnpsV1RVUkdTbFZYY0ZkWFJscEdVMjFvV2xaRlduSmFSVnBQWTIxR1NHRkdUbWhOU0VKWVZqRmFVMUl5VVhsU2EyUm9UVEpvV1ZsWWNITmpWbXh5WVVWT1ZGSnNjRmxhVlZVMVZsZEtSMk5FUmxaV00xSXpWbXBLUzFkV1ZuVlRiVVpYVFRBME1GWnRjRWRXTWxKWFZXNU9WbUpYZUZSVVZFcHZWbFpaZUZwRVFsZE5iRVkwVjJ0V2EyRldTblJoU0VwV1lXdEthRmt4V25OamJHUnlaRWQ0VjJKV1NqVldiVEF4WVRKR1YxTnVUbXBUUjNoV1dXdGFTMU5HV25Sak0yaHJWbXhLV2xsVldtdFViRXAxVVdzeFYySllhR2hYVm1ST1pWWlNjbHBIUmxOTmJXaDJWa1pXYjFFd05WZFhibEpzVW1zMVZGUlhkRmRPUmxsNFlVaE9WMUl3VmpWYVZWcFhWMjFGZVZWc1VsZE5SbkJZV1hwR2EyUldjRWRhUlRWWFltdEtTbFp0Y0VwbFJrbDRXa2hPV0dKR1dsUlpWRXB2VjBaYWNWUnRPV3BpUm5Bd1ZGWldZV0V3TVVWV2JHaFhUVzVvV0ZacVNrdFRWa1paWTBab2FWSXhSWGRXTVZwclZURk9SMVZ1U21GU01GcFVXV3hhUzFkV1drZFdiVGxTVFZVMVdGWXlOVWRXUjBaelUyeE9WVlpzY0hwVWJGcFdaVmRXUjFwR1drNWhNVmt5VjFaV1lXRXhaSE5YV0hCV1lXczFXRlZzV25kWFJtdzJVbTEwYTFKcmNEQlpNRlV4VjBaS1ZtTkZjRmRoYTI5M1ZtMXplRll4Vm5WVWJHaHBVakZLZDFaWGRHRmtNV1JIWWtoT1ZtRXdOVTlVVm1oRFZqRmFjMVZyWkZaTlJFWjVXVEJXYjFkSFJYaGpSbEphVm0xU1NGUnRlR0ZqTVhCSFlVWmtiR0V4V1hwV01uUlRVekZSZVZSWWFGaGliRnBYV1d4b2IxWkdVbFpYYm1Sc1VteHdXVlJXVWxOWGJGcFZVbXRvVjFaNlZsQldha3BIVG0xS1IyRkdjR2hOV0VGNlYyeGtOR050VVhoV2JrcFZZa2RTV0ZscmFFTk9iRnBWVTJwU1ZrMVhVbnBXTW5SaFZUSkdjMU5zYUZwaVJrcElWa1ZhVjJNeFpITmFSM0JPWVhwV1NGWkhlR0ZVTWtaWFZHdGFVMkZzV2xoWlYzUmhZVVpzVlZGVVJsTk5Wa3BhV1ZWYWIyRldTWGhUYkhCWVZucEZNRlY2UmxkV01XUjFVbXhLYVZaV2NGcFdWekUwVXpGYWMxWnVVbXRTUlVwWlZXMTBkMDFHV2xoT1dHUlhUV3R3VmxWdGRHOVdNREYxWVVkR1lWWldjRkJaTW5oM1VqRmFjMXBIYkZSU1ZYQmhWbTB3ZDJReVZrZFVXR2hoVWxkb1ZGbFVSbmRWVmxwMFRsVk9XRkpzV25wV01qVnJZVVpLYzJORmFGZE5ha1pJVmpKNFlXUkdWbkphUmxaWFlraENXVlpzWTNoVE1XUklVbXRhVUZadFVtOVpWRVozVkZaYVZWSnRSbGhpVmxwWlZsZDBhMWxXU1hsbFJUbGFWa1ZhTTFVeFdtRmpiSEJGVVd4d1YySklRa3BXVkVvd1lqRmFkRk5zV2xoaVZWcGhXVlJHZDFSR1dYZFhiR1JxWWtkU2Vsa3daREJVYkZsNFUxaGtWMVo2UWpSYVJFWlRZekZrV1dGR1VtaGlTRUpaVjFaU1MxVnJNVWRpUmxaVVlUSlNXRlJXV2t0bFZsbDVaVVpPYUZKVVJqQlpWVnB6VmpGWmVsRnNRbHBoYTNCUVdYcEdWMlJXVG5OaFIyeFRZbXRLTmxadE1IaGxhekZZVm01T2FWTkZjR2hWYm5CelZqRlNWMVp1Wkd4aVIzUXpWakkxVDFZd01WWmpSRUpYVW0xb2RsWnFSbUZTYkdSMVUyeGFhR0V4Y0ZsWFdIQkhZVEpOZVZKcmFHbFNiV2hVV1ZST1ExWXhXblJrUjBaYVZteHdlVlJXV21GVWJGcDBWV3hzV2xaRmNIWldSRVphWkRGd1IxUnNaRTVXYTNCWlZtMHdNV0V4WkVkVGJsSnJVa1UxV1ZsVVNrNU5WbHB4VVZob1YySlZOVXBaTUZwclZHMUdjMWRyTVZkaVdFSklWMVphUzJSR1VuSmFSbHBwVTBWS2VsZFdVa2RrTWxaWFdraEtXR0pWV2xWVVYzTjRUa1phU0U1Vk9XaFNhM0I1Vkd4Vk5WZHRTa2hWYmxaVlZteHdhRnBGVlhoVFYwWklaRVUxVjFac2EzZFdNV1F3V1ZkRmVGZHNhRlJpYTNCUVZtMHhiMWxXYkZWVGJFNXJZa2QzTWxWdGVHdGhiRnB6VTI1d1YxSXphSEpXUjNoaFkyMU9SMk5HYUdoTlZuQXlWMVpTUjFsV1NYaFVibFpXWWxoU1ZGVnNVbGRYYkdSWFZXdDBWV0Y2UmxoV01XaHJWMGRGZWxGdVNsVldiSEF6V2xWYVlWZEhWa2hTYkZacFZsaENObFpYZUc5aE1WbDVVMnhzVW1FeWFGbFdiWGgzVkVac05sSnVaRlJXYkZwNlZrY3hjMVl4V25WUmJIQlhUVmRSZDFscVJrWmxSbFp6V2tab2FXRXhjRlZYVjNodlZURmFjMVZzWkZkV1JWcFZWbTE0VjA1V2NFWmFSRUpYVFZac00xa3dXbk5YYkZwWFZsUkdWMkpZVGpSVmFrWnJZMjFXUjJGR1pHbFRSVXAyVmpKMFYyRXhXWGhVYTJoV1lURndVVlp0Y3pGalJsbDNXa2M1V2xac2NEQmFWV1JIWVZVeGNrMVVVbGROYWxaUVYxWmFTMWRIUmtoUFZscG9ZVE5DTWxadGNFZGpNazE0Vm01S1lWSXpVbkJWYlRWRFVqRmFXRTFJYUZOTmExb3dWVEowYjFadFNuUmxSMmhXWWtad00xa3llR0ZXVms1eVpFWk9hVlpVVmtsWFZFSmhZakpHUmsxV1pHcFNSWEJaVm0xNFMxUkdWalpTYXpsVFRWWktNVlV5TVVkVk1EQjNVMnhXVjFZemFGaGFSRXBLWlVaa2MyRkhlRk5OTVVwWVYxZDRZVkl3TlVkWFdHeFBWbGRTV0ZWcVFsZE9iRnBZWlVaa1YySlZjRnBaVldSdldWWmFjMk5JY0ZwTmJtaHlXa1ZrVTFJeGNFWk9WazVUVmxkME5GWnFSbUZXTVZsNVZGaG9XRmRIZUZWWmEyUTBWVEZzVlZSdE9WZE5XRUpaV2tWa1IxWnNTbk5YYm1oV1lsUkdTRmxYYzNoV01rNUpZMFphVG1GcldqWldiRkpMVXpKT2MxUnVUbE5pUjFKd1ZtdFdTbVZzV2tkWGJVWlRZbFphU0ZkcmFFOVpWa2wzVjJ4U1dtSkhhSFphVlZwaFYwZFdTR1JHV2s1aGVsWTJWbXhrTkdFeFdYbFRibEpXWWtkNFYxbHNhRzlOTVZKV1YyeE9hazFYVW5sVU1XUnZWVEpGZWxGcVZsaFdSVXBVVlZSR1dtVkdaSEZYYkdSb1RWVndXVmRYZUZOU01VNUhZVE5zYW1WcldsbFdiWFIzVFVaV2RHVkZPVlpOVm5BeFZWYzFZVll3TVhWVmJHaGFWa1ZhVTFwVldrOWtWbFp6VjIxb1RtSlhhRFZXYkdRMFZURlplRnBGWkZaaVJscFZXV3hTYzFkV2JISlhibVJzVW14V05Wa3dWazloUmxwVlVteG9WbUpZUWxSV01HUkdaVVprZFZkc1pHaE5iRXBOVjFSS2VrMVdXWGhYYms1cVVqSjRWRmxVVGtKTmJGcDBUVmhrVTAxck1UVldSelZQV1ZaT1JtTklTbFpoYXpWMldUQmFWMk5XVW5SUFZtaFRZa2hDTkZaVVNuZFZNa1pHVFZoS1YyRnNTbGRVVm1SdlpHeFpkMXBGV214aVJWcDZXV3RhZDFZeFNsbFJiRkpYVW14YWFGZFdaRTlXTVZKMVUyMTBVMDB3U25kV1YzaFRWakExYzFwR2FHdFNNRnB2VkZkMFlWZEdaSEpXYlRsb1VtdHdlbFl5ZUc5WGJVcElZVVZTVmsxR2NHRmFWbFY0VmpGd1IxUnJOVmhTVlhCTVZtMHdlRTVHVlhsU2JHUmhVbFp3VlZscldtRlhSbHB4VkcwNVdGSnVRa1pWTW5SclZUQXhXVkZyYUZoaE1YQm9XVlZWZDJWR1RuTmhSbVJUWWxaRmQxWXhXbXRXTWsxNVUydHNWR0pIYUhCV01GcExWMnhhV0dORlRsZE5SRlo2VmpKNGIySkdTalppUm1oWFlsaG9lbFJ0ZUdGWFJUVlpXa1prVjAxSVFtRlhWbFp2WXpGc1YxTnJXbGhpYTNCb1ZXeGtVMVpHVm5GU2JtUlRZWHBXV0ZkcldtOVZNVnBaVVcxb1YySllRa2hXVkVaR1pVZEtSMkZHVmxoU01taHZWbGQ0YTFVeFpGZFhXR1JvVWxVMVYxUldaRFJXYkZaWFZXdGthRkpyY0hwWk1HaDNWakF4Y1ZadVNsZGhNVlkwVmpGYVIyTXlSa2RhUlRWcFlrVlplbFp0Y0VOWlZtUjBWVmhrVDFac2NIQlZiVFZEWWpGU1YyRkZUbFpXYlZKWVZqSXhSMVpGTVZoVmJHaFdZbFJXU0Zac1pFdFRSbFp5VDFaa2FWWkdXa1ZXYlhoaFdWWlplRlp1U210U2JIQndWbTE0ZDFOV1dYbGtSemxVVFZkNFdGVXlOVk5oUms1R1UyMUdXbFpGV21oVVZFWjNWbXhrZEZKc2FGTk5WbkJLVmtSR1lWbFdVbk5YYmxKclpXdEtXRmxyWkZKTlJteFZVbXh3YkZKdVFrZFpWV1J2VlRKRmQyTkdhRmhXTTJoMldXcEJkMlZHVm5OWGJHaHBZbFpLV1ZkWGRHdFZNREZIWTBWYVdHSllVbTlXYlhoM1YyeFdXR1ZIT1ZkTmEzQldWVzF3VDFZeVJuSlhiVVpoVmxad2Nsa3hXbXRqTVhCSVlVVTFWMWRGU21GV2JYUmhZVEpSZUZOWWFGUlhSMmh4VlcxNGQxZFdiSE5XYlVaWVZteHdlRlZYTVVkV1JrcDBWVzVzV0dFeVRURlpWVnBMVmxaS2MyTkdXbGROTUVwWlZtMXdTMU14WkZkU2JrcG9VbTVDV0ZWc1duZFdSbVJ6Vm0xR1ZVMXNTbGhXVnpWVFlXeEtjazVXYUZWV2VrWjJWRmQ0WVdNeGEzcGFSM2hUWWtaWk1WWlVSbTlpTVZwMFUydG9hRkpyU2xoWlYzTXhWa1phVmxkdVRtcGlSMUl4Vmtkek5WVXlTa2xSYkhCWVlURmFWMVJzV210VFJrNXlXa2RzVTFKVVZsZFdiVEUwVXpGYVIxZHVSbEpYUjJoWlZXcENZVk5zYTNkWGJYUm9VbFJHZWxVeWMzaFdNVmw2VVd0b1dsWkZjRTlhVmxwTFkyeHdTR05HVG1sV2EzQlJWbXRhVjFVeFNuSk5WV1JZWW10YVZGbHNWbUZaVmxwMFRWUlNXRlpzY0VoWlZXTTFWMnhhY2s1VmFGZE5ha1oyVm0weFMxWldXbkpWYkdST1VtNUNObGRyVm10Vk1VcDBWV3RrYUZKdFVuQlZhazVxWlVaWmVXUkdaR2hOVld3MFZqSjRZVlJzV25SVmJHaGFWak5vVEZZd1dsTlhSMDVIV2taV1UySllhRnBYYkZaV1RsWmFSMWR1U2xoaGEwcFhXV3hvYjFkR1duRlNiVVpyVm10YWVsbFZXbTloVmtwelkwYzVWMDFXY0doWFZscGFaVVpPZFZSdGJGTk5iV2hWVmtaU1IxTXhXbGRYYTJSWFlsVmFjbFJXVlRGWFJtUnlWMnhrVm1KVmNGZFdNakExVmxaYWMyTkZlRlZXVm5CWFdsWlZNVll4VW5SaFJrNW9aV3hhUzFZeFdsZFpWMDE0V2toU1UxZEhhSEZWYWtwdldWWmFjMWR1WkZkTldFSllWbXhvYjFZd01WbFJhMmhYVWpOTmVGWnFTa1psVlRsVlZXeGthVkpyY0V4WGJGWnJVMjFXUjFkc2JHbFNhelZ2V1d0b1ExZFdaRmhOVkZKclRWZFNTRlp0TlZOVWJGcFZWbTVPVm1KVVJUQmFWVnBYWkVVeFZWRnNaRTVTUlZwaFZsWmtNR0l4WkhOWGJHaFdWa1ZLV0ZaclZuZFVSbHB4VW1zNWExSXdXa2hYYTJSelZqRktWbUV6WkZkaVdHaFVWV3BHVW1WR1RsbGlSazVZVTBWS2IxWlhNSGhpTWs1SFYyNUtZVkpHU25KWmExcDNVMFpaZVdWSGRHaGhla1pHVlZkd1UxWXdNVmhoU0hCWFVrVmFhRlpzWkV0U01rcEhZMGRzVTJKSVFscFdhMlEwV1Zac1YxcEZhRmRoTWxKV1dXdGtVMVF4Vm5KV2JIQnNVbTFTV0ZadE1EVmhhekZZWlVab1ZrMXVVbWhXTUdSTFYwZEdTRkpzVmxkaVNFRjZWbFJDWVdReFNuTmpSVnBoVW14S1ZGUlZXbmRUYkdSelZtMTBhVTFXU25wV01uQmhZVVpLUjFkc2FGcGlSa3BFVkd0YWQxSldTbkpQVjNCb1pXdGFXVmRXVm1GV01XUkhVMWhzYUZOSFVsaFdibkJEVGtaYVZWSnRSbGROYTNCS1ZUSXhSMVV5UmpaV2JtaFhZbFJGTUZacVFYZGxSbVIxVldzNVYwMHhTbHBYVjNSaFpEQXhSMk5HV2xoaVZWcFlXV3hXZDFac1duUk9WWFJYVFd0d1dsbFZWalJYYlZaeVYyNUtZVkp0VWtoVmFrWnJaRWRLUjFwR1RsZGlSM2N5Vm0xd1IxbFhSblJXYTJSVlYwZG9XVll3Wkc5V2JHeDBaRWhrYVUxV1dqQlVWbHBQVmxVeFdHVkVRbFZXYlUweFdXdGFZV015VGtsalJtUlhUVEZLZVZacVNqUlpWMUpIVm01T2FGSnNjSEJXYTFwaFZGWmtWMXBFVWxSTmJFcElWbTAxUzFWR1duUlZiVGxhVmtWS1dGUlVSbUZTTVZwMFVteHdWMkY2VmtwV2JHUXdZakZWZVZOclpHcFRSVXBZV1d4b2IwMHhWWGhYYkhCc1ZqRktTVlF4V210VWJGcDFVV3h3VjFaRmJ6Qlpha3BMVWpGT2MxWnRiRk5pU0VKWlYxWlNSMWxXVWtkWGExcFlZbTFTVlZWcVJtRlRWbFowWlVjNVZrMVdjRWRXTW5SclZqRmFObEpVUWxabGExcFVXWHBHYTJSV1RuTmhSbVJUVmxoQ1lWWnRNWGRVTVZWNVVtdGtXR0pyV2xSWmJGWmhWMVpXZEdSSVpGaGlSMUo1Vm14U1YxWXdNWEpXYWs1YVRVZFNkbFl3V21Gak1VNXlaVVprVjFKV2NHOVdWM0JMVkRGSmVWSnJhR3hTYXpWUFZXMDFRMDVXV25OYVJGSldUVlZzTkZVeU5VOVhSMHB6VTI1T1ZtRnJOVlJXYlhoelkyeGFkVnBHVGs1V2JYY3hWMnhXYWs1V1dYZE5WbHBwVWtad1lWWnNaRzloUm1SWFYydDBVMkpIVWpCWlZXUkhWVEZhZFZGc1JsaFdSV3cwVldwR1QxTkdTbkphUmxwcFVsUldXbFpYZUZka01XeFhWMjVTVGxOSGFFOVZiWGh6VGxaYVYyRkhPVmRpVlZZMVZsZDRjMWR0U2xsVVdHaFhUVlp3ZWxsNlJtRmtSa3AwWTBaa2FWSllRbHBXYlhCS1RWZEZlVk5yYUZSaE1taFhXVzB4TkZkV2JGVlRiVGxXVW14d01GbDZUbTlWTVZweVkwaHdXR0V4Y0ROWlZXUkhUbXhhY1Zkc1pHbFhSVXBOVmxod1IyRXhXWGhYYmxaVllsZG9WRmxzWkc5WFZtUllaVWRHVkUxV1draFhhMmhQVjBkS1ZsZHNaRlZXTTJoTVZqQmFZVmRGTlZkVWJXaHBVbGhDTlZaSGVHRmlNVnBYVjI1T1dHRnJOVmhVVlZwM1dWWndWbGR1WkZOV2ExcDZXVEJhYTJGSFZuSldXR1JYWVd0dmQxWnFTa1psVmtweldrWldhRTFZUW5oV1Z6VjNZekZaZUdKSVNsaGlWVnBQVkZaa00wMXNWblJsUjNSb1RWVndWbFZ0ZUc5V01VbDZZVWhhVjJGcmNFeFpNbmhQWTIxR1IxcEZOV2xpUlhCV1ZteGFVMU14U1hoVWEyUlVZbXRhV1ZsclZURmpSbXh6WVVjNVdGWnNjRWhYV0hCSFZtc3hjMU51Y0ZkTmFsWklWbGQ0YTFOSFJrbFRiR1JvWVRCd2IxWlVSbUZqTVZweldraFdZVkp0VWs5WlZFNURVMVphY1ZKdE9XdE5WMUpKVlRKMGEyRnNUa1pqUm1SYVZqTlNhRlY2Um5kV01XUnlaRWR3YVZORlNrbFdNblJyWXpGVmQwMVdXbXBTUm5CWVZGWmtVbVF4WkZkYVJrNXJVbXh3ZWxkcldtOVhSa2w1WVVab1dGWnNTa3hXVkVaelZqRmtkVkpzVG1oTmJFcFJWbGN4TkdNd05WZFZiazVYVmtaYWIxVnFRbmRTTVd0M1YyMDVXR0Y2UmtsWlZWWTBWakpLVlZKcmVGZE5WMUpJVlcweFYxSXhjRWhoUlRWWVVsVnJlVlpxUmxOVE1EVkhZa1pvVm1KSFVuRlZiR1JUWTFaV2RFMVdUbXBTYkhBd1drVm9hMWRzV25OaVJGWmhVbFp3Y2xsVlZYaFNWa3B5WWtaYWFWWkdXazFXYTJRMFdWZFNSMVp1VmxOaVJuQndWV3BHUzAxc1duUmpSV1JXVFZkU1IxUnNXbTlWUmxsNVlVWlNXbUpIYUhaV01uaHJZekZhYzFwRk5WTk5SbTkzVmxSS05GbFdVWGhYYkdob1VqQmFXRmxyV25kTk1XeFdWMjVPVjAxWFVqQmFSVnBUVlRKS1ZXRjZTbGhXUlVwb1dXcEtSMUpyTVZsVWJFNVlVakZLV2xacVFtOVJNVkpIVjJ0V1UySklRbk5WYlhNeFRWWmFTRTFZVGxaTlJFWXdXVlZhVjFkR1dYcGhSMmhXWld0YVdGVnFSbmRTTVhCSVlVWlNVMDFWY0ZwV2ExcGhWbTFXUms1VlpGaFhSM2hRVm14b1UxbFdXblJrU0dSVVVteFdOVlJzVms5V01WcHpZa1JhVjFaNlJuWldiWE40VmpKT1IxcEhSbGRpVmtwVlZsUkNZVk15VWtoU2EyaHBVbXMxV0ZWdGVIZFVSbHB4VTJwU1YwMVhlRmxWTVdodldWWk9SMU5zVmxwV1JYQlVWbXhhYzFaV1NuSmtSbVJwVWpOb1YxWlhNREZoTWtwSVUydG9hMUpHU2xoVVZ6VlNaREZzV0UxVlpFOWlWWEJJV1ZWYWIyRkZNVmRXYWxKWFlsaENURlY2Ums5U2F6bFhWbXhhYVZJeFNuZFdWekV3WkRGU1IxcElUbGRpV0ZKVldXeGFZVk5HV1hsbFNFNWFWbXR3VmxadGVHOVdNa1p5VjJ0NFlWWldjR2hXTUZWNFUxZEdSMWRyTlZkTlZYQktWakZrTUdJeFVYbFNhMlJVWWtad1VGWnRlR0ZXTVd4elZXdGtWMUpzYkROV01uaDNZa1paZUZkcmNGaGhNbEo2VmxSS1JtVnNSbkZYYkdoWFVsVndiMWRyVWtkaE1sSkhVMnhzYVZKc2NGbFZha1pMVjFaYWRHUkdaRk5OUkVJMFdUQmFZVmRIUmpaaVNFcFdZV3RLYUZVd1dtdGpiSEJKVkd4a1RsWllRbGxXYlRGM1ZERlpkMDFZVmxaaVJrcFhXVmQwZDFJeGNGWlhiWFJZVmpCd1NGWlhNVzlVYlVwR1kwZEdWMDFYVVhkWlZFWldaVlpTY2xwR1pHbGhlbFpZVjFkMGExVXhaRmRpU0VwaFVtczFXVlp0TlVOV01WbDVUVlJDVjAxRVJrWlZiWFJoVmpKS1dXRklXbGRoYTBZMFdrWmtSMU5XWkhOalIyaE9WMFZLVGxadE1IaGxhekZYV2tWa1ZHSnJOV2hWYWtvMFYxWldkR1JJVGs5aVJuQXdXVEJXYTFkc1duUmxSbWhZWVRGYWRsWnRNVVpsUm1SeldrWndhRTFzU2xWWFYzQkhaREZrU0ZWcmFGTmlSMmhZV1d4YVMxWXhXbGRaTTJoVFRXdGFWMVJXV205aVJrcDBZVVprVlZaNlZuWlpNbmh6VjBkV1JtUkdhRmROUm5CS1ZsY3dlRkl4V1hkTlNHaFVZbFJzV0ZWdGVFdFRSbHAwVFZaS2JGSXdOVWRYYTJSSFZUSktSbU5HVmxkU2JGcDJWVlJHVDFZeFpIVlRiSEJPVFcxb2VGWkdXbUZXTURCNFZXeGFhRk5GTlZoV2FrSmhaV3haZVdWSE9WaGlWWEJJVlRKMFUxWlhSWGhqUmxKYVRXNW9jbGw2Um10a1IxWkhWRzFvYkdKR2NHOVdha1poVmpGc1dGTllhR0ZTVjFKVlZqQm9RMkl4Vm5SbFNHUllVbTE0V1ZwRlZqQmhiVXBJWlVob1ZtSlVSWGRXVkVGNFYwWldjMk5HYUdoTmJFcEpWbXhTUjFNeVRuUlVhMlJwVW0xU1ZGbHJhRU5sVmxwSVpFWmFiRkpyYkRWV1IzUmhWMGRLV0dGR1VsVldSVnBNV2tkNGExZEhVa2RhUjNST1lrWndObFpxUm05ak1WRjRXa1ZvVm1KSGVGZFpWM1JMVjBaU2MxZHRSbE5OVmxwNVYydGFhMVJ0UlhwUmEyeFhZbFJHTTFaVVJscGxWa3AxVTIxd1UyRXdjRmhXUmxwclZURk9SMVp1UmxOaWJWSlVWRlphUzAxR2NGWmFSemxWWWtWd2VsbFVUbXRXTWtwWlVXdG9XRlp0VWtkYVJFRXhWbXh3U0dKR1RtbFdNbWhaVmpGYVUxTXlTWGhhUldScFVteGFWVmxYZUV0alZscDBaVWRHVGxKc1NsaFhXSEJYWVVaYVZWSnNhRlpOYm1oMlZqSjRZVll4WkhOUmJHUnBWMGRvYjFkclZtRldNazE1VW10a2FGSXlhRTlaYkdSclRteFplRnBFUWxwV2F6RTFWa1pvYzFaWFJYbGxTRUpXWWxob2FGa3dXbGRrUlRWV1ZHMTRWMkpIZHpCV2FrbDRVakZhUmsxWVRsUmlSMmhYV1d4U1YxVkdiRlpYYTNSclVteGFNVlZYZUd0aFJURlpVVzA1VjFZemFHaFhWbVJPWlVad1NWVnNUbWxXTW1oUVZtMHdlRTB3TVVkWFdHeHJVbnBzVmxSV1pGTlRWbFY1WlVoT2FGSnJjSHBWTWpGSFYyMUZlR05FVGxkU1ZuQmhXbFZhYTJSR1NuTmhSazVYVWxad1NGWnNZM2hPUmxsNFZXNU9XR0pzU25KYVYzUmhWMFphY2xadVdtdE5WM2hXVlRKMGEyRnJNVlpPVkVaWFZucEdkbFpVUVhoa1IwWkhZa1pvVjJKV1NUSldSbHBoV1ZaSmVGZHVSbGhpUlRWd1ZXeFNWMWRXWkZoa1IzUldUVVJHU0Zrd1ZtRlhSMHBaVld4YVdtRXhjRE5VVmxwWFZqSkdTR1JHWkU1V2JUaDVWbFprZDFVeFpIUlNia3BZWWtaS1lWcFhkR0ZqYkd3MlUydDBVMDFWTlhwWlZWcFBWR3hhV1ZGdFJsZGhhMXBvVmxSR1RtVkdXblZWYkZwWVVqSm9XbGRYTVRCWlZscEhZa2hPYUZKck5WaFdiWGhoVFVacmVtTkZaR2xTTUhCSVdXdFNWMWxXV2xoVVZFWmFWbFp3YUZreU1VOVRWMHBIWTBVMVUySnJTVEpXYlhCRFdWWmtkRlp1VGxkaWJFcHZWVzE0ZDJNeGJGVlNibVJzVm14d1dWa3dWbXRYYkZsNFUyeG9WMVo2VmxCWlZWcEtaVmRXUjJKR1dtbFhSa2w2VmpGYVlWbFhUWGhqUld4aFVtczFUMVpxVG05WFZscHlXa1JTYUUxclducFZNbmhyWVd4S2RHVkhSbGROUjJoRVdsZDRZV1JIVmtsVWJYQnBVakZKZUZaclpIcE9WbFY1VTJ0a1dGWkZXbGxaVkVaaFpHeHNWVkpzY0d0TlJFWmFWVEl4ZDFVeVNrbFJiR2hZVmpOU2NsbHFTazlqTVdSMVVteFNhRTFzU25oWFYzUnJWVEpXYzJKR1dtRlNWMUpYVkZaYWQwMVdWbGhsUldSWVVtMVNTbFZYZEc5WGJGcEdZMFU1WVZac2NFeFpNakZIVTBkS1IxUnRhR3hpUm5CU1ZtMTBZV0Z0VmtoVFdHaGhVMFUxV1ZsdGRHRldSbXh6WVVaT1ZVMVdXbmhWVjNoclZERktjMk5FUWxWaVJsbDNWbXhrUzFJeVRrZGlSbVJYWld4YVNWWnRNSGhUTVU1SFZtNU9WbUpIVWs5V2JUVkRUbXhrVlZOWWFGTk5WWEI2VmxjMVUyRnNTbFZXYkdoYVlUSk5NVlJVUm1GamJHUjBVbXh3VjJKRldUQldiR014VkRGYVNGTnVUbFJpYTNCWFdWUkdWbVZHV1hkWGJrNXFZa2RTZVZwRldsTlZNa3BKVVdwU1YxWnNjSFpaYWtaV1pVWmtkVk50Y0ZSU00yaG9WbTE0WVdReVRuTlhhMmhzVW01Q2MxWnRNRFZPYkd0M1YyMTBhRkl3VmpOWk1HTTFWakpHY21KRVVsZGhhM0JQV2xWYWEyUldXbk5XYld4WFRXMW9WbFl4WTNoTlJrMTVWVzVPWVZKdFVsZFpWRXBUWTJ4U1YxZHVaRmhTYlZKNVZqSTFUMkZIU2taalJteFhWbnBCTVZac1dtRmtSbFp6Vld4a1RsWnVRbGhYYkZwclZURk9SazlXYUdoU2F6VnZWRlJDU2sxc1duTlZhM1JQVW14V05GWXhhSE5XUjBwSFYyeG9XbFpGV2t4V01GcFRWakZrZFZwSGFGTmlhMHBJVm0xNGIySXhXWGhYYmtwWVltNUNXVmxVUmxabFJscHhVbTFHVTJKR2NGcFhhMXByWVZaa1NHRkliRmRTYkZweVZXMHhWMUl4Y0VsV2JGcHBVbXR3ZGxaR1kzaGlNbEp6VjJ4V1VtSkdjRTlXYlhoelRrWnNjbGR0T1doaVZscDVWako0YjFadFNsVlNXR1JWWWtad00xWnRlR3RrUjFKSVlVZHNVMkpyU1RGV2JYQkxaREZKZUZwRmFGTlhSMmh4VlcxMFMxZEdWbkZVYlRsb1VtNUNTRll5ZEd0aGJVcFdUbFZvV0dFeGNGQlpWbHBQVW14T1dXSkdaR2xYUmtwVlZsZHdSMkV5VWtkV2JHeGhVbFJXV0ZscmFFTlhWbVJZWkVaYVRsWXdiRFJXVjNodlZHeGFObUpIT1ZaaVdHZ3pWVEJhWVdSRk1WWmFSMmhPVWtWYVIxWldaSGRWTVZsM1RWaEdWMkV5YUZoV2ExWjNVakZ3V0dWRlpHdFdiRXA2V1RCa2MxVXlTa2xSYmxwWFlrWktURlJyV21Ga1JscHpZVVprYUUxc1NtOVdWekI0VlRGUmVGZHVVazlXVlhCelZXMTRkMWRHWkZWVWJYUlZUVlp3ZWxsclVsZFdiVXBWVm10NFYyRXlVa3hXTUdSSFVqSkdSMWR0YUU1V2JUazJWbTEwVTFJeVVYaFhiazVxVWxad1VWWnRjekZqUmxWM1ZtdDBWR0pIVWxoV2JURkhWbFV4VjFOcVFsWk5ibWgyV1ZWYVMxSnRUa2RoUm5CWFVsWnZlbFpxUW1Gak1rNVhVMjVLV0dKWWFGUlVWV2hEVTFaWmVXUkhSbWxOVjFKSVZURm9jMkZHU2paaVJtaFhZV3MxVkZZd1dsZE9iRTV5WTBkNFUySkdjRFpYVmxaclRVWmFSMU5zVmxkaVJWcFlWbTV3UmsxR2NFVlJXR2hUVFdzMVIxWXlNVWRWTVVwV1kwaGFWMVo2UlhkYVJFWmhZekZhYzJGSGNGTmlWa3BaVmtaYVlXUnJNWE5XYmxKUFZqQmFXRlJYZEhkV2JGWjBaRVJTVjJKVldubFdNbmhEVjIxV2NtTkZhRlpoYTNCUVZUQmtWMU5IUmtaT1ZtaFRWbGhDYjFadE1YZFNNVlY0VTFob2FWSnRVbFpXTUdRMFZqRnNWVk5zVGxkV2JYZ3dXVE53UjFZd01WaGxTSEJZWVRGS1ZGWnFSa3RrUjFaRlVXMUdVMVpzY0hsV2EyUjZaVVpaZVZOclZsWmlTRUpZVm1wS2IyVldXblJsUmxwc1VqQTFNRlV5ZEZkV01rcEhZMGhDVjAxSFVuWmFWbHBoWkVkU1NHUkdVazVoZWxZMVZrZDRZV014VlhsVGEyUnFVMFZLVjFsWGRHRlNNWEJGVW14d2JGSnRVakJWYlhoM1ZqQXhSVkpVUWxoV1JVcFlXV3BHVjFJeFpIVlZiV2hUWWtWd2FGZFdVa3RpTVVwSFZXNUtXR0pWV2xoVVZtUlRUVVpSZUZwSVRsVmlWVlkwV1RCU1lWWXlSbkpoTTJoV1pXdGFjbFV3V2s5amJVcEhVMjFzVjFadVFscFdNV1F3V1ZkUmQwMUlhR2hOTW5oelZUQlZNVmRHYkhKaFJVNVRUVlpzTlZSV1VsTmhSbHB5WTBab1drMUdTbWhXYWtwTFZsWktWVkZzY0ZkU1dFSkpWbTF3UjJReFNuTmFTRTVXWWxkb2MxbFVSbmRYYkZwMFRVUkdhMDFWVmpOVWJGWnJWMGRLY2xkc1ZscGhNVlY0Vm10YVUxWXhaSFJTYXpWWFlrWlpNVlpHV2xkaE1WcHlUVmhLYWxKdGVHRldiR1J2WTJ4YWNWTnJkRmhXYTFwNlZWZDRkMkZIUlhwUmJGWllWMGhDU0ZsVVNrOWpNazVHV2tkR1UwMXVhRmxXVjNCUFlqRmFWMWR1U2xoaVIxSlhWRlpXVjAweFVuTldiWFJZVW0xU1NWcFZXa05XTWtwSVlVWlNWMDFXY0ZoWk1WcEhaRlp3UjJGSGJGTmlhMHBoVm10a05GWXdNVWRYV0doWVltczFjVlV3YUVOWlZsSldWMjVrYTJKR2NIcFhhMVl3VlRBeGNrNVZhRmhoTWxKSVZtcEtTMUl4V25GVmJHUnBWa1ZaTWxaSGVHRlhiVlpYVlc1S1lWSXdXbFJVVnpGdlpXeGtXR1JIUm10TlZURTBWakkxVTJKR1NuSk9WbFpWVmpOb2FGcFdXbE5qTVdSMFpFWm9VMkpXU2twV2JHUjZUbFpaZVZOcmFGWmlSa3BZVkZWYWQxbFdjRVZTYm1SVVVsUnNXRmt3V210aFZrcFpVV3h3VjJKWVFrdFVWbVJHWlVaa1dXRkdVbWxoZWxaM1ZsZDBWazFXWkZkaVJsWlRZbTFTY1ZsclduZFdiRlY1WkVSQ1YwMUVSbGRVYkdoelYyeGFWMk5JU2xkaGEwWXpXbFprUjFOWFNrZGhSbVJwVTBWS2RsWnRkRk5TTVUxNVZGaG9WV0pzV2xSWmExcGhZMFpXY1ZKcmRHdGlSbkJJVjJ0U1UxVXlTbGRTYWxKWVlURndkbGxYZUV0WFJsWnpXa1p3YVZKdVFtOVdWRUpoWVRKT2MxcElWbFZpVjJoVVdWUk9RbVF4WkZkV2JUbFNUVmRTZWxkclZuTlZiVXBJWVVkb1ZtRXhXbWhaVlZwYVpERndSMVJzVGs1V01VbzFWa2Q0WVdFeVJsZFhia3BxVWxoQ1dGbHNhRzlqYkZKeVdrVndiRkpzV2xwWlZWcHZZVlpLZFZGc1JsZGlWRUkwVmxSR1dtVkhTa2xVYldoVFpXMTRVRlpHV205Uk1XUkhWMWhzVGxaWFVtOVpXSEJIWlZaWmVXUklUbGRXVkVaWVdUQm9TMVl4V2taalJXUmhWbTFTVTFwWE1VOVNNWEJJWVVkb1RtRnRkRFpXYWtaclpERkplVkpZYkZWWFIyaG9WVEJWTVdJeFZuUmxTR1JwVFZaS1dWUldZelZYUmxwMFZXeG9XR0V4U2tSV1ZFRjRVbFpHY1ZWc2NFNVNia0o1Vm1wQ2ExTXlUWGxVYTJ4VllraENjRlZ0ZUZkT1JscFZVVzFHYUUxck5YcFpNRlp2VlVaWmVXRkdVbGRoTVZwb1YxWmFZVll4YkRaU2JIQlhZa2QzTVZaVVNqUmpNVnAwVTJ0a1ZHSkhVbUZXYWs1VFRURldjVkp1WkZkaVIxSXdXa1ZhYjFZd01VZGpSV3hYWWtkT05GbDZTa2RXTVU1MVZteEthVkl4U2xsV1JscHJWV3N4UjJKSVJsTmhNWEJ6VlcweFUyVldaSEphU0U1WFVtdHdXbFZYZUhOWFJsbzJVV3BTVjFaRlduSlZha3BMVTFaT2MyRkhiR2xXYTNCaFZtMHdlRTVHVFhoYVJXUllZa2RvY2xWc1VuTmlNVlp6Vld0a1UySkdXakJVYkdoclZqQXhSVkpxUmxkV2VsWm9WbXBLUjJOc1NuRlZiR1JPVWpGS1NWWlVSbUZoTWsxNFkwVmFUMVl5ZUc5YVYzaEtUV3hhY1ZOcVVscFdNRlkwVlRGb2IxWlhTa2hWYkZaYVlsaE5lRmt4V2xka1JURllUMVprVjJKR2NEWldiVEF4WVRGa1NGTnJaR3BUU0VKWVZtcE9VMk5zV1hsbFIwWnJVakZhU0ZsVldtOWhSVEZYWTBjNVYyRXhTa2hYVm1ST1pWWlNjbUpHVW1sU2JrSjJWMVpTVDFFd01YTlhia1pTWWxWYWNWUldXbmRYUmxwWVRsVjBWMVl3Y0VsWlZWcHZWMjFGZVdGRlVsZGhhMXBvVm14YVQyUldjRWRYYXpWWFltdEtXVlpyV21GWlYwVjVVbXhrVkdFeVVsbFphMlJUV1Zac2NsZHJkRmhTYkhCSFZqSTFUMWRHU1hoWGEyUmhVbGRTTTFaSGVHRldWbHBaV2taa1YyVnJWWGRXYlhCSFYyMVdWMVJ1U21sU2EzQlpWVEJXUzFkc1pGaGtSM1JXWVhwR1NGbHJVbUZWYkZwR1YyNUdWVlpzVlhoVVZscGhWMFV4VlZGc1drNVNSVWw2VmxSS05GRXhaRWRYYmxKb1VrVTFXRmxYZEdGVlJtdzJVbTVrVkZack5YcFhhMlJ6VlRKS2NsTnNSbGRpVkVJeldsVmFWbVZHVW5KYVJtUllVak5vZWxaWGNFTlpWMGw0WWtoS1YySnRVbGxaYTFwaFYxWndWbGw2VmxkTlZuQjZXVEJvZDFkck1VZFRiRUpYWVd0R05GVnFTazlUUjBaSFkwVTFWMkpyU2twV2JYQkhZVEZKZUZOWWFGZGlhelZXV1d4a2IxUXhVbFpXYm1ScFRWWndlRlZ0TVVkV01ERllaVVpzVmsxWGFIcFdWRXBMVTBaV2MxWnNaRTVTTVVWM1YxZHdSMVp0VVhsU2ExcFZZa2RvVkZscmFFTk9SbHB5V1ROa1QxWXdXa2hWTWpWVFZtMUtTR0ZHYUZWV00wSllWbFZhWVdOV1JsbGhSbWhUWWtad05GWlhNVFJoTVZWNVZtNUtXR0V5ZUZoWmExcExWRVpXY1ZGVVJtcE5WMUl4Vm0weGMxVXlTbGhoUm14WFVteEtTRlY2U2twbFJuQkhZa2R3VTFaWVFsQldiVEUwWXpBMVYxWlliR3RTYlZKWlZXcENkMU5HV1hsT1ZVNVhUV3RXTlZaV1VrTlpWa2w2WVVoS1YwMUhVbGhWYWtaM1VqSkdTR0ZIZUdoTlZ6aDVWbTB3ZDJRd01WZFdXR3hVWVRKU1ZsbFVTbTlXTVd4eVdrUlNXbFpzYkROWlZWWlBWa1pLYzFacVRsZE5hbFpNV1ZSQmVGZEdWblZqUm1SVFRUSm9lVlpyWTNoU2JWWklWR3RXVjJKSFVtOVpWRW96VFVaYVdHTkZaR3BOVm13MFYydG9UMWxXU1hwUmJGSmFWa1ZLTTFsVldtdGpNWEJGVVd4d1YySkZjRWxYVjNSVFdWWlZlVk51VWxaaVJrcFdWbTE0ZDFSR1VsWlhiazVxWWtkU2VsWkhlR0ZVYkZwMVVXeHdWMUpGU25aWmFrWmFaVlpPYzFac1NtaGlSWEJYVm0xNFlXUXhXWGhqUmxwWVlrVTFXVlpxUW1GVFJsbDVaVWM1VmsxRVJqQlpWVnB2VmpBeFYyTkdVbFpsYTFwWFdsVmFhMk14Y0VoaVJsSlRWMFZLZGxac1pEQlpWazE1Vkd4a1YySnNTbk5WYWtKaFl6RldkR1ZIUmxoV2JFcFlWbTB4TUZZd01VVlNiR1JhVFVaS1JGZFdXbUZXTWs1SVlVWmthVlpGV2sxV2JYaGhXVmRTVjFSdVRtRlNWRlpVV1cxMFMyUnNXWGhoU0dSVVRWWkdORlV4YUhOV1IwVjVZVVpTV21FeFZYaFdNRnBUVmpGYWRWcEdVbWxTYmtGM1ZrWmFVMUV4V1hsVGJHUllZVEo0V0ZWdE1XOWtiRnB6V2tWMGFtRjZWbGxVTVZwaFlWWmFSbGRxU2xoV00wSklWbFJHYTFKck1WZGhSa0pYWWtoQ1dWZFhkRzlSYlZGNFYydGtWMkpVYkhCVVZscFhUbFpWZVdWSGRGaFNNSEJKV1ZWYWIxZHRTa2RUYkdoWFZsWndhRll3VlhoV2JWSkhWR3MxYUdWc1drdFdhMUpIV1ZkUmVGZFlhRlJpUjFKd1ZGUk9RMWRHYkZWU2JtUm9VbTFTV0ZkcldrOVdSa3B6VTI1c1YwMXFSa2hXVkVGM1pVWk9jMUZzWkdsV1JVWTBWbFpTUWsxWFRYaGFTRlpXWVhwV1ZGVnNXbmRXTVZwSFYyMTBUMUp0VWtoV2JHaHpWREZhVldKSE9WcGhNVm96V2xkNFZtVlZNVlphUm1ST1lURlpNRlpxU25kVE1XeFhWMWh3YUZKc1NsaFpWM1JoWTJ4d1JsZHJkR3RTTURWSFZHeGFiMVV4V2xsUmEyeFhZbGhvYUZsVVNsZGphekZYV2taa1dGSXphRlpYVmxKTFRrWlZlR0pHYUd4VFIxSlpWVzB4TkZkV2NFWmhSMFpvVFVSR1dWWlhlRzlXTURGeFVtdG9WMkV4Y0V4Wk1qRlBVakpPUjJOSGFFNWlSVzk1Vm0xNFUxRnRWa2RUV0d4VllUSm9iMVZ0TVc5WFJsSlZVbXQwYkZadFVsbFpNRll3Vm1zeGNrMVVVbGhoTW1oUVZqQmtTMU5IUmtsUmJHUnBVbTVCZWxkc1dtRlpWbVJJVkd0YVlWSnVRbGhaV0hCWFRteFplV1JIT1ZSTlYxSkpWVEowWVZReFduUmhSbHBYWVdzMVZGUlVSbGRqVmtwMVZHMXdWMkpGYjNkWGExWmhZakZWZVZOcmFHdGxhM0JZV1d0a1QwNUdiSEZTYlhScVRWZFNlVll5ZUc5aFZscFhZMGM1VjFZelVsaFZha0V4VWpGYVdXRkhSbE5YUmtwV1ZsZHdRMWxXVGtkWGEyaHNVak5TVmxsclduZFhiRlpZVFZWa1YwMXJXbmxXTWpGdlYyeGFSbEpxVWxaTlJuQllWakZhZDFKck5WZFZiRTVPWWxkb1lWWnFSbUZoTURWSVZWaG9XR0pIVW5CVmJYaGhWbXhzVlZGVVJtcFdiRXBZVmpJeFIxUnNTbk5UYm5CWFlsaE5NVlpxUmtwa01rNUdZVVprYVZkRlNsbFdha3A2WkRKV2MxSnVTbWhTYlZKdldWUkdkMVJXWkZWVFdHaFVUVlZ3V0ZZeU5VOWhiRXAwVld4b1dtSllVa2hVYlhoaFpFZE9SbFJzY0ZkaVdHaGFWbXhrTUdFeFdYbFRhMlJZWWtVMVlWbFVTbE5rYkZsM1YyNU9hbUpWV2tkV1J6RnpWR3haZUZOdFJsaFdSVXBZV1ZSR2EyTXhaRmxoUmxKcFVqSm9XVlpHWkhkV01WcEhZa1pvYkZKWVVuRlpXSEJYVjJ4V1dHVkhkR2hXYlZKSVZURm9kMVl4U1hwVmJXaFhUV3BHV0ZWcVNrOVNiRnB6VTIxc1YwMXRhRkZXYkdRd1ZqRnNWMVJyWkZoaE1sSllXV3hTYzJOR1VsZGFSRkpZVW14d1NWcEZaRWRoUjBwR1kwUkNXbFpYVWtoV2FrcEhZMnMxVjFWc1pGTldia0kyVjFSR1lWTXlUWGhWYms1aFVsUldXRmx0ZEVkT1JscHhVMnBDV2xZd1ZqVlZiWGhyVmtkS2MxZHNUbGROUjFKVVZqRmFjMk5zWkhSU2JYUnBVbTVDUjFaWE1IaE5SMFp5VFZab1ZtRnJXbGhWYm5CSFRURmFWVk5yZEZoV01GcElXV3RhYTJGV1pFWlRiRVpYVm14S1NGWnFSa3BsUm5CSFlrZHNVMDB5YUZWV1JsWmhaREZrVjFkclpHRlRTRUpQVm0xek1WZEdiSEpYYlVaWVVqQndWMVl5TURWV2JVWnlVMnhvVldFeGNIbGFSRXBIVTFaU2MyRkdUbWxUUlVwSlZtMXdTbVZIU1hoWFdHaFlZVEZ3Y1ZWc1VuTmhSbHAwWlVoa1ZWSnRkRFZhVldoclZrWktjbU5JY0ZkU00wMTRWa2N4UzFkR2IzcGlSbVJwVjBaS2IxWnRjRXRTYlZGM1RWWmFXR0Y2VmxWVmFrcHZWMnhrV0UxVVVsUk5Wa1kwVmpJMVMxWXlSWHBWYkdoVlZteHdURll3V21Gak1rWklUMVpXVGxaWVFqWlhWRUpoWXpGYVdGTnJaR3BTYTBwWVdWZDBSMDVHYTNsTlZUbFRZbFZ3U0ZkcldtdFVhekYwV2pOc1YySllRa3RhVlZwT1pVWndSMXBHV21sU00yaDJWbGN3TVZFeVNYaGlSbFpUWW0xU1dWWnRNVk5sVmxwMFRWUkNWMDFFUmxkVWJGcHZWMnN4UjFkdVdscFdNMmhNV1RKek1WZFdSbk5YYldob1pXeGFOVlpyWTNoT1JteFlWR3hrVldKcldsTlpiR1J2WWpGd1dHVkhSbGhpUm5CV1ZUSndRMkZGTVZkalJXeFdUV3BXVUZaclpFdFRSbFowVW14d2FWSnJjRmxXVjNSaFYyMVJlRnBJVGxWaVIyaFVWRlZTVjFOR1duRlRXR2hPVW14S2VsWXhhSGRoUmtwMFpVWm9WVlo2VmxSV01GcFRWbXhrYzJOSGRFNVNSVnBaVjFaV1lWbFhSbGhUYkd4b1VqSm9XRmxzYUc5aFJuQkZVVmhrYkZJd2NFaFdNbmhyVjBaSmVXRkdiRmhXTTJoWFZGWmFUMVl4VmxsaFJtaHBWMFpLZGxadE1IaFZNVTVIVmxoc1QxZEZOVmhVVm1SVFUyeFdXR1JIT1ZkTlZYQkhWakowTUZsV1dsZGpTRXBoVW14d2FGbDZSbmRUUjBwSFZHMXNWRkpWYkRaV2JURTBZVEpSZUZOWWFGVlhSM2hYVmpCa2IxZFdiSEphUnpscVZteGFlbGxWV2s5aGJFcHpVMnhrVjFZelVuSlphMlJMVWpKS1JWWnRSbE5XTVVZelZtMXdRbVZIVG5SVWEyUmhVbTFTVDFsdE1XOWxWbHAwWlVkR1dHSldXbnBXVnpWSFZtMUtSMWR0T1ZWV2JXaEVWR3hhYTJOc1ZuSmFSbkJYVFZWd1NGWkVSbUZoTVdSSVUydGFUMWRGU2xkWlYzTXhZMVp3Vmxkc2NHeFNiVko2VjJ0YWQxWXdNVWhrZWtKWFRXNVNkbFpVUmxabFJuQkdZVWQ0VTJKV1NsbFdSbFpyWWpGS1IxZHVVbXhTTUZweFZGWmtVMDFXWkhKYVJ6bFdUV3R3ZVZVeWRHOVdNa3BaWVVoYVdtRnJXbGRhVlZwclpGWk9kR05HVGxOV1dFSnZWbTB4TkZsV1duUldhMlJZWW10YVZWbFVUbE5qVm14eVZsUkdiRlp0ZUhsV01qRXdZVVpLVlZKc2NGWldla0V4Vm1wQmVGWXlUa2hoUm5Cc1lURndhRmRzVm1GWlYwMTVVMnRvYUZKck5YQldha3B2VFRGYWMxcElaRk5OVlRFMFZqSTFUMWxXU25SaFNFcFdZV3RLYUZreWVGTldNWEJGVld4b1UySkhkekZXUjNoWFlURlplRmRZWkdwU1YxSldXV3RrVGsxV1duUk5WWFJYVm14d2VWWlhlR0ZVYkZwMVVWaHdWMkpVUlRCWlZFcFRVakZPZFZWdGFGTldSbHBWVmxkNFlXUXhaSE5YV0doV1lUQTFZVlp0TVRSWFJsbDVUbFpPVjFJd2NFbGFWV00xVm0xS1dXRkZlRmROUm5CNlZqQmtVMU5XY0VkV2JFNXBVMFZKTUZac1kzaGxhelZZVW01T1dHSnJOWEZWTUdoRFYxWnNWVkp1WkZaU2JYaFlWakp6TlZVeVNrWk9XR2hYWWxob2NsbFZWWGhqTVVweFZHeGtUbFp1UW05WFZsSkxWVEZKZUZwSVZsUmlWVnBVVkZWYWQxWnNXbGhsUms1WFRXdHNORll5ZUc5aGJFcFZZa1pPVlZac2NETlZNRnBoWkVVMVZrOVdhRk5OU0VGM1ZteGtOR014V1hsVGJHeG9Va1UxVmxac1duZE5NVlowWlVkMGExSXhTa2haVldSelZUSktjbEpxVGxkaVdHaHlWRlZrU21WR1pGbGFSVFZZVW14d1dGZFhkR3RpTVdSSFYyNUtWMkp0VWxSVVZtaERWMFpaZVdWSGRHaE5WbkI1V1RCb2QxWXlTbGxoU0VwWFVqTk9ORlp0TVV0T2JFNXpXa2RvVG1GNlVYZFdhMlF3WVRGS2RGWnNaRlppYkZwV1dXeG9RMVpHV25GVWJUbFhUVmRTV1ZwRlpFZGhNREZYVW1wU1YwMXFWbFJXUkVaaFZtczFWMUZzWkdsV1JWcFZWbTB4TkZZeFpFWk5WbHBoVW0xU2IxcFhkR0ZYYkZweldrUkNhVTFXYkROVVZscHZZVVpLUms1WFJsZGlSbkF6VmxWYVYyUkZNVlpQVmxKVFlUTkNObGRVUW1GaE1WSnlUVlphYWxOR2NGaFVWelZ2WTJ4U2NsZHVUbGhTYkVwNlYydGFVMkZYUmpaV2JUbFhWak5DVUZWVVJsSmxSMHBIVm14T2FXSldTbFpYVjNSclZURmFjMVpzYUd4U01GcFdXV3RhZDJWc1ZYbGpSVTVYWVhwR01WbFZhR0ZYYkZwWFkwVjRXazF1YUhKWmVrcEhVakpPU0dKR1RtaE5NRXBIVm0xMFlWVXhTWGxWV0doWVltczFXVmxyWkRSaU1WWjBZM3BHYVUxWVFsbGFSV1JIVmtVeFdGVnNhRmRpVkVWM1dWZHplRll4V25GV2JGcE9ZbXhLTmxac1kzaFRNVTVYVW01T2FWSnRVbTlaV0hCWFRXeGtjbHBFVWxwV2JIQllWa2MxUzFWR1duSk9WVGxYWWxSV1ExcFZXbUZYUlRGVlZXeFNUbUV4Y0ZwV1ZFbzBZVEZhU0ZOcmFHeFNiV2hYV1d4b2IwMHhiRlpYYms1UFlrVmFWbFZ0ZUd0VWJVWTJWbXRvVjJGcmJ6Qlpha3BIVmpGd1JscEdVbWxUUlVwWlZtMXdUMUV4U2tkalJWWlRZWHBzVkZSWGRGZE9iR1J5VjIwNWFGWXdXVEpXYlhoelZqRktjMk5IYUZwbGEwVjRXWHBHWVdNeVJraGxSazVYVmtaYVdsWnJXbGRWTVVsM1RWWmthVkpzY0doVmJuQnpWMFpzYzFadVpGaGlSM2hYV1ZWV01GZHNXbkpqU0hCYVRVWndSRll5TVZkamJHUjFVMjFHVTFZeFNrMVdWM0JIWkRGSmVGVnVUbUZTTW5odlZGVm9RMVZzV25STlNHUnNVbFJXU1ZWc2FHdFVNVnBZVlc1Q1ZtSlVSbFJXYlhoYVpERndSVlZzWkU1V00yaFhWbFJLTkZReFdYaFhibEpzVWtWS1lWUlVUa05UUmxweFUydDBWRkl4V2twWmExcHJZVlpLY21ORmJGZGhhMHBvVjFaa1RtVkdjRWxXYlhCVFlsWktkMVp0ZEdGWlZsSlhXa1pvYTFJd1dtRldha0Y0VGxaYVNHUklUbWhTYTNCNldUQlZOVmR0U2xsVmEzaFdZa1p3YUZreFdrOWpWbFp6WVVkc1YyRXhhM2RXYlhCS1RWWkplRmR1VWxSaE1taFhXV3RhUzFsV2JISmFSazVyWWtaS01GcFZaRWRoTVVwVlVtdHdXbFpXY0ZCWlZscGhZekpPUjJKR1pHbFdSVVkwVm10U1MxSXhXWGhVYmxaWFlrVndjRmxVUW5kWFZscEhWbTEwVmsxc1NucFphMmhIVlRKS1dWVnNhRmRpV0ZKb1ZGVmFWMlJIVmtoa1JsWnBWbFpyZVZaWGVGTlNNVmw0VjJwYVUxZEhVbUZaVjNSaFYwWldjVkp0ZEd0V2JGb3dXVlZhVDJGV1NsbFJiVGxYVFZkUmQxbFVTa3BsVmxaeldrZHdVMVpzY0ZWWFYzaFhXVlphUjFWc1pHRlNhelZQVlcweE1FMHhXbk5WYTJSWFRVUkdSbFZ0ZEhkV2JGbDZWVzV3VjJGcldtaFZiVEZHWlcxR1IxcEdUbE5YUlVwS1ZqRm9kMUl4VVhsVVdHeFRZVEpTV1Zsc1pEUlhSbHAwVGxWT1dHSkdiRFJYYTFKRFlVVXhWMVpxVmxkV2VsWlFWakJrUm1WSFRrZGlSbkJwVW14d2IxWnRkR0ZaVjFKSVZXdHNZVkl6YUZoWmJYUkxVMFpaZVdSR1RsSk5WbkI1VkZaYWEyRnNTbGhsUjJoWFlrWndNMWt5ZUdGalZrNXlWMjE0VjJKR2NGZFdWbU40VWpGVmVGTnNiRkpoTW5oWVZtNXdSMDVzY0ZaWGJIQnNVakExUjFsVlpIZFZNa1kyVm01a1YxWjZRWGhWVkVacll6RmtXV0ZIUmxOU1ZYQjJWa1phWVZsWFZsZFZiR1JYWWxoU1dWVnRNVk5UVm5CV1ZsUldWMDFyY0ZaVmJYaFRWakF4UjJOR1VsZGhhMXB5V2taYWQxSnJOVmRhUjJ4VFlrZDBORlp0ZEdGWlZsVjRVbGhvV0dKcmNFOVdNRlozWTFaV2MyRkZUbGROVm5CNFZrY3dOVlV4U25OalNHaFdZbFJHU0ZaRVNrdFNiVTVIWTBab2FFMXNTa2xXYkZKSFV6RlplVlJyWkZOaVIxSndWakJXUzFOV1pISlZhMlJVWWxaYVNWWkhkR0ZoUmtweVRsaENWbUpHU2xoV2JGcHJWakZXY2s5V1NrNVNSbHBKVm1wSk1WTXhaRWhUYkd4V1lrVktWMWxzYUU5T1JsSnlWMjFHVkZJeFdrbGFSVnByVkcxRmVsRnFXbGRXUld0NFZXcEdZV1JHU25WVGJGSnBWakpvV1ZaR1ZtRmtNbFp6WWtSYVUySlZXbkpXYlRWRFUwWnNWbHBJVGxaTmEzQjVWVEl4UjFZeVJYaGpSbWhYVmtWYVlWcFZXbXRYVjBaSFlVZHNhR1ZzV2pOV01uaHJUVWRSZUZwRlpHbFRSVFZYV1d0a1UySXhWblJsU0dST1VteEtXRlp0Y0VOWFJrcHpZa1JPVjAxdVVucFdNbmhoVmpKT1NWTnNjRmRXTVVwSVYyeFdhMVF4VGxoVGEyUm9VakpvVDFadE5VTk9WbHAwWlVaT1UwMVdSalJXUjNSclZrZEtjbU5HYkZwWFNFSjZWakJhYzJNeFpISmtSbWhYWWtoQ1dsWkdXbE5WTWtaMFUyeGtXR0pIYUZoVVYzQlhWa1pzY2xkcmNHeGlSbHA2VlZkNFlXRkhSWGRqUkZwWFVqTm9hRlpxU2s1bFZrcHlZVVpDVjJKWGFGVldSbFpoVjJzeFYxcEdaRmRpVlZwWFZGWmtVMDFHVlhsbFNFNVhWbTFTU1ZsVldtOVdWbHB6WTBST1lWWXphSGxhVm1SWFUxWndSMVJzWkdsU2JrRXlWakZTUTFsWFJYbFNiR1JoVWxkb2IxVnRNVzlYUm14eVYydDBWVkpzU25sV01uaExZa1phY21OR2NGcGhNWEJVV1ZWVmVHTXhUblZoUm1SWFVsVndlVlpIZEdGaE1VbDRWbTVPYUZKVWJGaGFWekUwVjBaYVdFMVVVbXROYkZwSVZtMTRhMkZHU2paaVJteFdZbGhvTTFwV1dscGxWVFZaVkd4b1UwMUdXVEJYVkVKaFlqRlplRk5ZY0doU01GcG9WbXhhZDFSR2EzaFhiRTVxVFZoQ1NWbHJXazloUlRCM1UydDBWMkpZUWtoWFZscHpWakZTZFZWc1pHaE5iRXA0VmxkNGEwNUdXbGRpU0U1b1VsVTFXRlZ0TVRSbGJGbDVaRVJDVjJKRmNEQldWM2h6VmxaYWMxTnNVbGRoTVZZMFdUSXhTMUpXVm5OaFIyaE9ZbGRvVGxadE1IZGxSa3AwVm14a1YySnJOWEJWYlRWRFkwWldkRTVWVGxSV2JIQklWbGQwYTFack1WZGlSRkpZWVRKb1ZGWlVTa3RUUmxaeVQxWndWMUpVVmtWV1ZFbzBXVmROZUdKRVdsTmlSWEJQVm1wR1NtUXhXbFZUYWtKcFRWWndNRlV5TlU5aGJFcDBZVVphVjJKWWFETlVWRVp6Vm14a2RGSnRjRTVXTVVvMVZqSjBhMDFHVlhoWGEyaHNVbTE0V0ZaclZuZE9iRkpYVjJ4d2JGSnRVbmxYYTFwdllVVXdkMU5zYkZoV00yaDJXV3BLVDFZeFZuTmFSbWhvWld4YWVsWlhjRU5rTVU1SFdraEtXR0pGTlc5V2FrSlhUbXhXV0dWRlpGZE5hM0JXVlZkd1UxZHRSbkpYYm5CWFlXdHdURlV4V2s5ak1rWklZa2RzVjJFelFYbFdiWGhxWlVVMVIySkdXazVXVjFKeFZXMTRkMkZHVm5OYVJrNXBUVlpLV0ZadE5VOVVNVXB6WWtSV1lWSlhVWGRXYWtGNFZtMUtSVmRzY0ZkV01Vb3lWbTF3UjFOdFZuUlNhMXBzVW14d2NGWXdaRzlsVm1SVlVtMUdhRTFyTVRSWk1GWnJXVlpLY2s1V2FHRldla1YzVkcxNFlXUkhVa2hrUlRWVFlsaG9XVll5ZEc5Vk1WbDVVbGhzVm1KWGFGZFVWVnAzWVVaYWRHVklUbXBpUjFKNVdrVmtjMVJzV25KalJteFhZbFJCZUZsVVJtdFNNVTUxVkcxd1UxWXlhRnBXYWtKdlVURk9SMWR1VG1GU1dGSllWRlprVTJWV2JGWlhiWFJWWWxWYWVsWXlkSE5XTWtwSFUydDRWbVZyV2xCVmFrWmhaRlphYzFSdGJGUlNWWEF5Vm10YWEwNUdUWGhYYkdSaFUwVTFhRlZyV2t0WlZscHhVbXQwVTAxV1NsaFdNakExVm14S2MyTkljRmROYWxaRVZtMHhTMU5IUmtaVmJGcE9WbTVDYjFkVVJtRlVNV1JYWTBWYVVGWnRVbkJWYWs1clRteGFjbGR0UmxwV01HdzBWakkxVDFsV1NsaGhSbVJhWWtaYWFGWXdXbk5XVmtwMFVtczFUbFpzYTNsV1Z6QXhZVEZaZVZOcmFGWmhhMHBvVld4a1UwMHhXa2hsUjNSVFlrVTFlVmt3V205V01EQjRVMjA1VjJFeFNreFZha1phWlVkT1JsZHRhRk5OYldoVlZsY3hNR1F4WkZkYVJtaHJVak5TVjFSVlVrTk9SbGw1WkVaa1ZrMXJjRWhaTUdoUFZtMUtWVlpyVWxaTlJuQnlXVEo0YTJSRk9WaGhSbVJPVTBWS1NWWXhVa05pTWsxNFYxaG9XR0V4Y0ZWWmJHUnZZVVpXY2xadFJsWk5XRUpYVjJ0V01GWkdXbkpPV0hCYVZsZFNlbGxXV21GamJVNUlVbXhrYVZaRlNYcFhiRlpXWlVaS2NrMVZiR2hTYldod1dXdFdkMlZHV2xobFJscE9WbTFTU0ZaWGVHRldiVVY1Vld4c1ZtSlVSWGRVVkVaelZtMUdSazlXWkU1V2JYZDZWMVJDVjJJeFdYZE5XRVpYWVdzMVdGUlZXbmRoUm13MlUyczVWRkl3V2toWGEyUnZZVVV4V1ZGcVZsZE5WMmd6VldwR1dtVldVbGxoUjNCVFZqSm9kMVpYTVhwTlYwNUhWbTVTVGxaRlNrOVVWbHAzVFVaU1ZtRkhPV2hOUkVaWFZGWlNVMVl4V25SaFNGcFhZa2RTVEZVd1dsZGtSMFpIVjJzMVUySkdXVEJXYlhCSFdWZE5lRnBHYUZWaE1sSm9WVzB4VTFaR2JITmhSemxQVm14d2VGVXljRk5oTURGWFUyNXdWazFxVmxCWlYzaExVbXhPZEZKc1ZsZFdia0p2Vm14V1lWZHRWbGhXYTJoVFlsaENUMVp0TlVOT1JscDBUVlJTYUUxV2JETlVWV2h2VmtkR2NtTkdhRnBpUjJoVVdUSjRWMlJGTVZkYVJtaFRZVE5DTlZkWGRHRlRNa1pYVTI1V1VtSnRVbGhaYkdoVFYwWmtWMWR0UmxkTldFSklWbTE0UzJGV1dsZGpSMmhYWWxoQ1ExUldaRmRqTWtWNldrWmthV0Y2Vm5aWFYzUlhZekExYzFkc2FHcGxiRnBZVkZkMGQxWnNXblJrUms1WFZqQldORmt3Wkc5V01ERkhWbXBTVmsxWFVraFZNR1JUVW1zMVdHRkZOVmRpV0dONVZtMHhNRmxXYkZoVFdHaFdWMGRvYUZWc1pHOVdSbGwzV2tSU2FVMVdXakJVVm1NMVYwWktkR1ZJY0ZkV00xSnlXVlJLUzFOSFVrVldiVVpYVmpGS1NWWnRkR0ZUYlZaSFdraEthVkpzY0hCV01HUnZUV3hhYzFWclNteFNhMncxVmtkMFlXRldTblJWYmtKV1lXdGFSMXBFUm10amJGWnlaRVpPVGxaWVFqVldSbHBoWXpGYVdGTnJaRlJpVkd4aFZtdFZNVkpHV1hoWGJYUllVakZLU1ZWdE1UQlViVVY0WTBWc1YyRnJXblpaZWtaVFl6RmtkVk50Y0ZSU1ZGWllWMWQ0VTFZeFNrZFdXR3hzVWpCYVdWVnFSbUZTTVZGNFdrYzVWMDFyVmpaVlYzQlhWMFphUmxOdGFGWldSVnBoV2xaYVQyTXhXbk5VYkdSVFZsaENkbFpzWkRCV01VcDBWbXRrVjJKcldsUlpiR2hUWTFaU1dHUkhSbE5OVmtwNlZqSnpOVlpyTVZkalJFWldWak5DVEZacVNrWmxSMDVKVTJ4V1YxWnVRbWhYYTFKQ1pVWk9XRkpyWkZoaVYzaFVWRlpXZDFsV1dYaGFSRkpXVFdzeE5WWkhkR3RXTWtwelUyNUtWazFIVWxSV2ExcFRWakZrYzFwRk9WZGlhMHBZVmpKMFYyRXhXWGROVlZaVFltMTRZVlJWV25kTk1WbDVaVWRHVjAxVk5YcFZWM2hyWVVkRmVHTkhPVmRpV0VKTVZrUkdUMU5HU25KYVIzQlRUVEpvZGxaR1dtOVJNbEp6VjI1U2FsSlhVbTlVVmxaelRrWlZlR0ZJVGxaTmExWTFWbGN4YjFadFJuSmpTRnBYVWtWYVlWcEVSbUZqYkdSMFpVWmthVk5GU1RCV2JHTjNaVVV4UjFWdVRsUmliRXB6VlcweGIxZEdVbGRhUnpscllrWnNNMVl5TVRCV1JrbDRWMnRvVjJKWWFETlpWVlY0WXpGT2MxWnNaR2xYUmtwdlZtcEplRlZ0VmtoVWExcGhVbXhhY0ZWcVNtOVhWbVJZWkVjNVVtSldSalJXTW5SclYwZEtWbGRzV2xWV2JIQklWR3hhVm1WWFVrbFViRnBwVmxoQ1NsWnNaRFJqTVdSelYydGFXR0ZyTlZoV2JGcDNZVVpyZVdWSGRHcGlWa3BKV1RCVk1XRkhWbk5YYTNoWFRWZFJkMWRXWkVabFZrcHpXa2RHVTFZeWFIWldWM1JYWkRGa1YxZHVVbXhUUjFKdlZXMTRXazFzVlhsamVsWm9UVlZ3ZWxVeU5YTlhSMFY0WTBWNFdsWnNjRXRhVlZwUFl6SktSMXBHVG1sU1dFSkdWbXhvZDFJeFZYaFhXR2hxVWxkU2IxVnFUa05XUmxweFVtdDBhMkpHY0VoV01qRkhZV3N4UlZacmFGcFdSVFZ5Vm1wS1MyTnJOVmRoUm1Sb1lUQnZlbFp0Y0VkWGJWWllWbXRrVldKSFVuQldiR2hEV1ZaYWMxcElaRlZOVjNoWVZqSTFUMkZzU1hsaFJtUmFWak5TYUZreWVIZFNiSEJIVkd4T1RsWXhTalZXUjNoaFlURlNjMWRzYkZKaE0xSllXV3hTUjAweFZqWlJXR2hVVW1zMVdsbHJXbE5oUlRGelUyeGtXRlpzU2toYVJFWlhVakZrZFZWck5WZGhlbFpvVm0wd2VFNUhWbGRYV0d4T1ZsZFNXVlZ0ZEhkbGJGVjVZMFZPV2xac2NGaFpNR2hMVmpBeFIyTkZkR0ZXVm5CeVdUSXhSMUl5UmtoaFJUVllVbFZ2TVZacVJtRldNa1Y0VjFoc1ZXSnJOV2hWTUZaM1kwWldkRTFYT1ZoU2JGcDZWbTAxYTFkR1duTmpSV3hoVWxkU1NGbFZWWGhqYXpWWllrWldWMkpJUW5sV01WcGhVMjFXYzFKdVRsZGlSbkJ3VldwS2IxSldXbkZTYlVaYVZtdHNORll5TlZOVk1rcElWV3M1Vm1FeGNHaFZNVnBoWTFaS2RFOVhiRTVXTVVwS1ZsUktNRmxXVVhoYVJWcFlZa1p3V0Zsc2FHOVdNWEJXVjJ4T1YySkhVakZXUnpGM1lWWkplRk5xVmxkU1JWcHlXWHBHVm1Rd01WWmlSa3BwVmxad1dWZFdVa3RWTURCNFYydFdVMkpJUW5OV2JYUjNUVlpWZVdWSE9XaFdiR3cxV1ZWYWMxWXlTbGxWYkdoWVZteHdWMXBWWkU5U01YQkhZVWRzVTFaR1dtRldiVEYzVVRGc1YxUnJaR0ZUUlhCb1ZXNXdjMVpzYkhOV2JtUlRUVmQwTTFsVlpFZFdNREZ5WTBWc1YxWnNTa1JXTW5oaFVteGtjMXBIUmxkV2JrRjZWbGR3UjJReFRraFRhMlJXWWtVMWIxUlVRa3BOVmxwMFpVZDBhMDFWVmpSWmExcHJXVlpLV0ZWdVFsWk5SbG96VmpGYWMyUkZNVmRVYlhCT1ZtNUJkMWRzVm05aE1WSnpVMjVPVkdKSGFGaFpiRkpHWkRGYWNWRllhRmRpVlRWS1dXdGFkMVJzU25KalJWWlhUVlp3YUZkV1dscGxSbEoxVTJ4YWFWSXlhRmxYVjNSdlVUSkplRmR1UmxKaVZWcFlWRlprVTFkR2EzZFdiWFJhVm10c05WbFZZelZXVmxwMFlVVlNZVkl6YUdGYVZWcFhZMjFTU0dWSGFHeGhNWEJhVm0xd1IySXlTWGhpUm1SVllURndVRlpxU205V01XeFlaRWhhVGxKc2JEUldNbmhyWVdzeFYxZHViRmROYmsxNFZsUktTMU5XUmxsYVJtUlRZa2hDTWxkV1VrZFdNbEpIVkc1T1lWSnRhRzlVVnpGdlYxWmFXR05GT1dsTmF6VjZWako0VjFaSFJYcFZiRlpXWVd0YWFGVXhXbEpsUm1SMFVtMW9WMkpJUWtoV2FrbzBWakZrUjFkcldsUmlWMmhZV1ZkMGQxVkdXbkZTYTNScVRXdHdTVmxWV2s5V01VbDZZVVphVjAxWFVUQlhWbHBPWkRBMVYxcEdhR2xoZWxadlZsZDBWMU15U1hoVmJHUllZbTFTV0ZSV1drdFhSbXhXVm1wQ1YxWXdjRWhaTUZadlZtc3hkV0ZJV2xkaVZFWk1Xa1phUjJNeVJrZGFSazVYWW10S2RsWXhVa2RaVmxGNVZHNVNWbUV5VWxaWmJHUTBWMFphY2xkdFJsVlNiSEI2VmpJeE1GUXhTWGRXYWxaV1lsaFNhRlpIZUdGa1IxWkhWR3h3YVZKcmNEWldha1poV1ZkT1YxVnVTbFZpUmtwVVdXeGFTMWRXV25GVFdHaE9VbXhXTlZWdGNHRlZNa3BJVlcxR1dsWkZjRlJhUjNoaFZsWkdXV0ZIZEZkTlJuQkpWbFprTkdFeVJsZFhhMXBYVjBkU1dWbFVSa3RUUmxwRlVteHdiRkl3TlVkWGEyUnZWVEF3ZUZOc1ZsaGlSMDQwVkd0YVlXTXhaSEphUm1ocFYwWktVVlpYTUhoVk1VNUhWMjVPYUZORk5YQlZiWFIzVFVaYVdFMUVWbGROYTNCYVZrWm9iMVp0Um5KWGJVWmhWbTFTV0ZVd1pGTlNNa1pJWWtaa1YySkhkRE5XYWtaVFVURlpkMDVWWkZoWFIxSlBWbXhrVTJOV1ZuRlJiVVpvVW14d2VsWXlOV3RoYlVwSlVXdG9WMDFxVm5KV1ZFRjRWMVpHY21KR2NHaE5XRUpWVm14U1IxbFdaRmRTYmtwcFVtMVNjRll3Wkc5aU1XUlhXVE5vVjAxVk5VaFdSM2h6WVVaS2RHRkdiRlpoYXpWMlZtMTRhMVl4Vm5Ka1JUbFRZa1paTUZkWGRHRmlNa3BIVkd0b1ZtSkhlRmhaYkdodlRURndWbGR0UmxSU01VcEhWREZhYTJGV1NsbFJXR1JZWWtaYWRsbHFSbUZrUms1elZteE9XRkl4U2xsWFZsSkhaREZTUjJFemJFNVdWR3hVVkZkek1WTkdhM2RYYlhSWFRXdHdlVlV4YUhOV01ERlhZMGRvV2xaRldrOWFWVnBUWXpGd1IxUnRiR2hsYkZvelZteGpkMlZHVlhoYVJXUnFVbTFvYzFWdE5VTmpNV3h5VjI1a1dGWnRkRE5XYlRFd1YwZEtSMk5JYkZwaE1VcFVWakJrUm1WWFJrZGhSbVJYVWxoQ1RWWlhjRWRVTWxKR1QxWm9VMkpIVW5OWlZFWlhUVEZhZEUxSWFFOVNiWGhaVmxkMFlWUnNXbk5YYkdSYVlUSm9SRll3V21GamJGcDBVbXhTVjJKV1NscFhhMVpxVGxaYVJrMVdhRlpoTW5oWFZGYzFVMkZHV2tWU2JVWnJVbXhhZWxZeWVHdGhWbVJJV2pOd1YxSnNTa2hXYlRGU1pVWndTVlJ0Y0ZOTk1taFpWa1pXVTFZeFRsZFhXR3hyVWpCYWIxUldXa3ROUmxaellVaGtWbUpWVmpaVlYzaHZWMjFGZVZWc1VsVldSVnBvVld4YVMyUkdTblJrUms1b1RUQkdORlpzVWt0T1IwbDVVbXhvVkdKcmNGVlphMlEwVjFaYWNWUnRPV3RpUm5CSlZGWmFhMVV3TVZoVmFrWldZbGhvVUZsV1pFdFdNVTV6Vm14a1UySklRbTlYYTFKTFZqSk5lVk5yWkZoaVIyaHZXbGN4TkZZeFpGaGtSMFpyVFZkU2VsWnRlRzloYkVwWlZXeG9WVll6VWpOV01uaHpWbXhrYzFSc1pHbFNia0pJVm1wSmVHSXhaSEpOV0ZaVllXeEtXRmxYZEhkVFJsWnhVbTFHYWsxcldraFdSM014WVZaWmVWcEVXbGRpVkVVd1ZsUkdSbVZHWkZsaVJscFlVakpvYjFaWE1IaFZNazVIVm01U2JGSXdXbGhaYTJRMFpWWmFjMVZyWkZkTmEzQklWVEo0YjFZd01YRlNhMmhYVWpOb1RGcEdXa2RqTVhCSFdrZHNWMUpXV1hwV2JURTBWbTFXUjFkdVVsVmhNbmh4VlcwMVExUXhWblJPVlU1UFlrWnNORll5TVVkV1JURlhZa1JTVjAxdWFGaFdWRXBMVTBaV2RFOVdjRmRTVlhCb1ZrWldZVmxXWkVoV2EyaFRZa1pLVDFsWWNGZE9iRmw1WkVjNVZVMVhVa2xWTW5odllrWktkR1ZHWkZwaE1YQm9WRlJHVjJSSFZraFNiWEJYWVROQmQxWlhNVFJrTVZsNVUyeHNhRkp0ZUZoWlYzUmhaR3hzY1ZKdFJsaFNhelV4VlRJeGQxVXlWblJsUm1oWVZqTm9WRlZxUm1GU01XUnlWbXhPYVdGNlZscFdWM0JIVXpGT1YxWnVVbXhTYlZKWVZGZDBkMU5zVmxkaFIzUllVakJ3U0ZZeU5VdFdiVVp5VjIxb1ZtSllUalJXTVZwUFkyczFWMXBHVG1sVFJVcGFWbXBHYTA1SFNYaFdXR3hXWW1zMVdWbHJXbUZXVm14VlZHeE9WMVpzV2pCYVZXUkhWR3hhYzFkc2JHRldWMUpJV1ZWYVlXTXlUa1phUm1ScFYwVktiMVpxUW10VE1VNUhWbXhXVW1KSGFGaFpiRnBMVlVaa2MxWnRSbHBXTVVwWVZrYzFVMVV5U2taT1dFSmFWa1ZLTTFZeWVGcGxSbkJGVlcxc1RtRXlkekJXTW5SdlZERmtTRk51U2s5V01taFhXVlJHZDFSR2EzZFhiRTVYVFZkU01WZHJXbTlXTWtwSFkwUmFXRlpzV25aV1JFcEhVakZPZFZOdGNGUlRSVXBZVmtaa2QxSXhUa2RYV0d4c1VqQmFWRmxzVlRGVFJscFlUVlZrVmsxRVFqVlpWV00xVjBaYVJtSjZRbHBXUlhCVVZXcEdUMlJXVm5SalJrNXBWbXR3TTFac1pEUmhhelZXVFVob1dHSnJjR2hWYTFwTFlqRlNWbFZzWkZSV2JGb3dXbFZrTUZZeFNYZGpTSEJYVFc1b1VGWXlNVXRTTVdSMFlVWmtUbFp1UW05WFZFbzBXVmRPZEZWclpHaFNhelZ3VmpCa2IxZEdXbk5aTTJSc1VsUkdTVlZ0TlV0VWJGcDBZVVprV21KVVZrUldNRnB6WXpKR1NFOVhjR2xTTTJoWVZtMTRiMkl5UlhoWFdHUllZVEpvWVZsVVJuZGpiR3hYVjIxMFUySkZOWHBWYlhodlZqQXdkMU5yTVZkV00wSklWVEl4VjFZeFVuVlRiVVpUVFVad1ZWZFhlR3RpTWxKelYydGtWbUV5VWxWVVZtUlRWMFpaZVdSSGRGaFNNSEJJV1RCVk5WWXlSbkpYYldoaFZqTm9ZVnBXWkZOVFJUbFlZa1pPYUUxdVkzbFdiWGhxWkRBMVYxZHVVbE5pYTNCVldXdGtiMVpzYkhOaFJ6bFlVbXhzTTFkcldtdFZNREZaVVd0b1dHRXhWWGhXYWtGNFZtMU9SbVZHWkdsU2JrSjVWa1pXYTFOdFZrZGFSbXhwVW1zMWNGbFVUa05YYkdSWVpVZDBhVTFYVWtoWmExcHZZVEZKZDFkc1dsWmlWRlpFVlRCYVdtVlhUalpXYldoT1ZsaENOVmRVUW05a01WbDRVMWh3VlZkSGFHRldiVEZUVkVaWmQxZHVXbXhpVlRWSVYydGtjMWRHU1hsaFJGWlhZVEpSZDFkV1dtRmtSbHB5V2tkR1UySllhSFpXVjNCRFdWWmFSMWR1UmxOaE0xSlpXV3RrVTFkV1VsZFZhMDVvVFVSR2VWWXlkRzlXTWtwVlZtdDRWMkZyY0VkYVYzaFhZekpHUjFwSGJGaFNNbWhPVm0xd1ExbFhSWGxVYms1WFltczFWbGxyWkZOVU1WWnlWbTFHV0Zac2NGWlZNbkJUWVZVeFYySkVWbFpOYm1oWVZsZDRZVkpzWkhSU2JHUnBWMGRuZWxaclZtRmpiVlpXVFZaYVVGWnJOVTlaVkVaM1UxWlplV1JHV2s1V01GcFpWVEo0YjJGR1NrZFhiR2hhWWtaS1NGUlVSbGRPYkVweVRsZDRVMkpXU2paV01uUmhWVEpHV0ZKcVdsZGlSMmhaVm1wT1UyUnNWbFZTYkVwc1VqQndTbFpYY3pGV01sWjBaVVp3VjFaNlFqUldWRXBYWXpGa1dXSkZOVmRTVlhCWlZrWldVMUl4V1hoaE0yUm9VMGRTV1ZWcVFsZE9WbXhXVjJ4T1dHSkdjRWRXTW5RMFZqSktSMk5IYUZwbGEzQklWV3BHZDFKck5WZFViV3hVVWxWd1RGWnRNVEJaVmxWNFUxaG9hVkp0YUZaWmJYTXhZMVpXYzFkdFJsZE5WM2g1V1ZWV1QxZEdTblJsU0d4WFRXNW9NMVpIZUV0ak1rNUpZVVphYVZaRlJYaFhWbHBXWlVaa1IxWnVTbWxTYkhCUFdXMTRTMlZXV25GUmJYUlVUVlUxU1ZWdGRHOVZNa3BJVlcwNVZWWnNjRE5aYWtaaFkyeGFkRkpzYUdsV2Exa3dWakowYjFReFdsaFRhMmhvVW14S1dGbFVSbmRoUmxsM1YyMUdhbUpJUWtaV1YzaFhWR3hhYzFkVVJsZFdSVzh3V1hwR2EyTnJNVWxpUjNoVFlsZG9XVmRYTURGUk1VbDRZMFZXVTJKRk5WaFphMlJUWld4WmVVMVVRbFZpUlhCSFZqSjRjMVl5Um5KaVJGSmhVa1ZhYUZWcVJsTmpiR1J6Vlcxc1YwMXRhRnBXTVdRMFlqSkplVlJ1VGxoaVJscFVXVmh3YzFaR1VsZGFSazVzWWtad01GcFZWVFZoUmxwMFZXdG9WazF1YUZoV01GcGFaV3hXYzFwR1ZsZGlWa3BaVjFod1IyRXlUWGxTYTJoc1VtczFUMVJXVm5kWFZscHlWMjEwVGxJeFJqUldSM1JyWVVVd2VWVnNiRnBpV0UxNFZqQmFVMVpzVm5KYVJtaFRZbGhSZWxkV1ZsZE5SbGwzVFZaa2FsSlhVbGhVVjNCSFUwWmtWMWR0UmxkTmF6VktWVEo0ZDJKSFJYcFJhekZYVmtWS2NsVnFSa3BsUmxaMVZXMXNVMkpXU25aV1JsSkRVakExVjFkdVVtcFNXRkpRVldwQ1lVMUdXblJrUjBaVlRWWndXVlpYZUhOWGJGcEdZMFpTV2xaV2NGaGFSVlY0VjBVNVdHTkhiRk5pU0VFd1ZtMTBhMDFHVVhoWGJrNVVZbXMxY1ZVd2FFTlhSbHB4Vkd4T1ZsSnNjRVpWYlhRd1lURkplRmRyY0ZwaE1YQXpWbXBHWVdNeVNrVlViR1JwVjBWS1JGZHNWbXRVTWxKSFZXNUtXR0pWV2xSWmExcDNaREZhV0UxRVJsSk5iRnBZVmpJMVIxWkdaRWhoUmxKYVlrWndhRlV4V21GVFIxSkpWRzFvYVZKWVFqWldha2t4VVRGYWRGTnNWbGRoTVVwaFdWZDBZV0ZHYTNoWGEyUnJVakZLU0ZZeWN6RldNV1JHVTJ4d1YySkhUak5VVmxwU1pVZEtSMXBHVWxoU00yaDZWbGN4TkZNeGJGZGlTRTVvVW1zMVZsVnRlRmRPUmxsNVRWVmthR0Y2UmxoV01qVnpXVlpLVjFaWWFGZFdSVVkwVlRCa1UwNXNSbk5hUjJob1RXcG9NMVl4V2xOU01rVjRWR3RrVldKc1dsVlpXSEJ6VjFaV2MxZHVaRmhTYkhCSVZtMHhNR0ZWTVZaalJXaFlZVEZ3Y2xZd1pFdGtSbFp6WWtaYWFHRXhjRTFXVkVaaFZqSlNTRlJxV2xOaVJscHdWVzAxUTA1c1pGaGpSVGxvVFZkU1NWVXlkR3RYUjBwelkwZEdWMkV4V21oWlZWcFhZMVpLY2s5V2FGZE5SbkJKVm14amVHSXhVblJUYTFwcVVtMW9XRlJXWkZKa01XUlhXa1pLYkZKdFVubFhhMXB2WVZaS2MyTkdXbGhXYkVwSVdrUktUbVZIU2tsVGJHUnBWbFp3ZWxadE1IaE9SbGw0VjFoc1RsWkZTbTlWYlhSelRURmFkR05HVGxoaGVrWkpWa1pTUjFZeVJuSmpSWGhYVFZad1NGa3lNVWRTTVhCSVlrWmtVMVp1UW1GV2JUQjRaREZKZUZWWWJGVlhSM2hWV1ZSS2IyTkdWblJqZWtacFRWaENXVnBWWkVkWGJGcHpZMGh3V0dFeWFISldWRUY0Vm1zeFZWVnNaR2xYUmtwNVZtcENhMU15VG5OYVNFNVZZa2hDY0ZWdGVIZGlNVnAwWlVkR1ZrMVhVa2xXUm1oM1lVWktWV0pHVWxwaE1taERXa1JHWVZOSFZrZGFSVFZUWWtkM2VsWkdXbTlUTWtaelUyNVNWbUpIYUZaV2FrNURVMFpWZDFkdFJtcFdhelY1V2tWYWExWXlSWHBSYkdSWFZtMU9ORlZxUmxwa01ERkpZa2RvVTJWdGVGbFhWbVF3VXpKT2MxZHNWbE5oZW14VlZXMTRZV1ZXWkhKYVJ6bFdUV3RaTWxadE5XRldNVXB6VTJ0U1ZtRnJSWGhWYWtaclpGWlNjMkZIYkZoU2EzQlNWbXhrZDFFeVRYZE9WV1JoVTBWd1dGbHNVbk5XTVZKWFdrWk9WRlp1UWxkV01qRXdWMGRLUjJORlpGcE5SMmhvVm1wQmVGSXlUa2xqUm1ST1VqRktWVlpVUW1GVE1rMTRWbTVLVDFadGFGUldiR2hEVTFaYWRHVkhjR3ROYkZwSVZURm9jMVV5U25KT1ZteGFZbGhOZUZreFdsWmtNa1pHVkd4d1YySklRalpXTW5SaFZESkZlVk5yWkdwU1YzaG9WbXhrVW1ReFdsVlRhM1JUWVhwV1dsbHJXbmRVYkVwMVVXNXNXRlpzY0doWFZscExZekZ3UjJKSGNGTmlWa3BaVmtaU1ExTXhUbGRYYmtwYVRUSm9XRlJXVm5OT1JscFlUbFU1YUZacmJEVlpWVnBUVjIxRmVHTkVUbUZTUlZweVZqQmtVMU5HU25Sa1JUVlhUVlZ3V2xacVNqQlpWMGw1VWxob1ZGZElRbGRaYlhSTFZteGFjVlJzVG14aVJrcDVWakl4UjFkR1NYaFhhMnhoVWxad2NsWkhNVVpsYkVaWldrWmthVkl4UlhkV01WcGhWMjFXVjFSdVRsZGlSVFZ3VlcxMGQxZFdXa2RaZWtacFRXeGFXRmt3VmxkVk1rcFdWMjVHVjJKWVVtaGFWM2hyWTJ4d1NFOVhiRk5OUmxrd1YxUkNhMUl4V1hsVGJHeG9VMFZ3Vmxac1pGTlRNWEJXVjIxMFdGWXdXa2hXVnpGdllWWk9SbE5zY0ZkTlYxRjNXVlJLU21WR2NFWmFSMnhVVWxSV1dGZFdVa3RWTVZwelZtNVNiRkp0VWs5VVZscHpUbFp3VmxwRVFtaFNWRVpZV1RCb2MxWXdNWEZXYWs1WFRXNU9ORlV3V2xka1YwNUhXa1prVTFaV2EzZFdNblJYV1ZkU2RGWnVVbFJoTWxKb1ZXcEtORmRXVm5Sa1NHUlBWbXh3ZVZkclVrTlhiRmwzVFZSU1dHRXhXbkpXYWtwTFkyMU9SMkpHY0ZoVFJVcFpWbXBDWVZsWFVraFdhMnhoVW0xU1dGbHNXa3RYYkdSelZtMTBUbEpzUmpSVk1qVlBWVEpHYzFOc2FGcGlSa3BZVmtWYVlXTldUbkprUm1ScFVqRktObGRYZEdGaE1rWlhXa1ZvWVUwelFsbFphMXAzWVVac1ZWTnJPV3BOVm5BeFZrZDRWMkZXU1hsaFNHUlhWbnBCZUZWVVFURmpNWEJIVm14S2FWWldjSGhXUmxwaFpEQXhSMVpZYkd0U2VteHZWVzF6TVZJeGEzZGFSV1JYVFd0YWVWUnNhR0ZXYlZaeVYycE9WMkZyV2pOVmJYaDNVakZTY2s1V1pFNVdWemg1Vm0xd1MwMUhSWGxVV0doWFYwZFNUMVp0ZUhkalZsWjBaVWRHV0ZKdGVGWlZiVFZyVjBaS2RGVnNhRmROYm1neldXdGFZV014VG5OalJuQlhWakZLU1ZadGRHRlRNVnBYVjI1U1VGWnRVbGhhVjNSS1RVWmFjMVZyWkZaaVZscElWMnRhYzFsV1NuUlZiVGxWVmtWYVRGWnRlR3RYUjFKSVpFWmFUbUpHY0ZsV2Fra3hWVEZTYzFkc2FGWmlSMmhoVmpCb1ExTkdjRmRYYkhCc1ZqRmFTVlF4V210aFIxWnlWMWhvV0Zac1duWlZla1phWkRBeFZscEhjRlJTV0VKWVZrWmFZV1F4VGtkaVJGcFVZVEpTVkZSV2FFTlRWbXh5V2toT2FGSlVSa3BWVjNSclZqSktXVlZ0YUZkV1JWcExXbFZhWVZkWFJrZGhSbWhUVFcxb2RsWnNVa05aVmsxNFYydGthVk5GY0ZoV2ExWmhWbXhTVjFkdVpHeFNiRm93V2tWU1ExWlZNWEpqUldoYVRVZG9kbFp0YzNoalZscHhWR3hrVTFKV2NHOVhXSEJMVXpGS1YxWnVUbUZTVkZad1dXeGtiMWRzV25STldHUlVUVlV4TkZaSGVHdFZNa3B5VGxoQ1ZtSlVSbFJaTUZwaFkyeGFkRkpzWkZOaVZrbzFWbXhrTUdFeFdYZE5WVlpYWW01Q1dGVnVjRmRWUm1SWFYydHdiR0pGV25sVU1WcHJZVlphUjFkclVsaGlSbHBvVjFaYVlWWXhVblZTYkZwcFZqTm9VRmRXVWtka01VNUhWMnRrV0dKVWJGWlVWbHAzVTFaVmVXUklUbFppVlhCSldWVmFiMWR0U2xWV2ExSldWa1ZhTTFadGVHdGpNWEJIV2taa2FFMHdTVEZXTVZKRFlUQTFSMVpZWkU1V1YxSlpWbXRXZDFkR1VsaE9WazVvVW0xNGVGVXlkR3RWTWtZMlVtdHdXbFpXY0ZSWlZscEtaVVpPYzJOR1pHbFhSVXBSVm14U1IyRXhTWGxVYTFwWFlrVTFjRll3V2t0V1ZscEhXa1JDVjAxRVZucFhhMmhMVjBkS1ZsZHRPVlppUmtwSVdsZDRWbVZYVmtsVWJHUk9WbGhDTmxkVVFtdGlNV3hYVTJ0YVdHRXpVbWhXYkZwM1kyeFplRnBGZEZSU01WcElWa2N4TkdGV1pFaGhSMFpYWWxoU2FGZFdXbHBsVmxaWllVWlNXRkl5YUZwV2FrSnJUa2RPYzFadVZtcFRSVFZaVm0weE5HVnNXWGxOVldScFVteHdNRnBGVWs5V01rcFpVV3RTVjAxdWFHaFpla3BMVWxaa2MyTkdaRmRoTTBKU1ZtMHdlR1Z0VmtkVWEyUlhZbXR3YzFWdGVIZGlNV3hWVW01a1YxWnRVbHBaTUZacllUQXhWazVWYkZaaVdGSm9Wa1JHWVZaV1duTlZiR1JPVW14d1RWWnFSbUZaVjFKR1RWVnNZVkl6VWs5WmExWmFUVlphZEUxVVFtbE5WbkI2VjJ0V2IyRkdTbk5qUm1oVlZsZFNWRnBIZUZwa01XUnpZMGQwVGxkRlNrcFdSRVpoWVRKR1YxTnVVbXROTTBKWVZGYzFVMk5XVW5OWGJYUlRUVlUxTVZaWE1UUldSa2w2WVVac1YxSnRVak5WYWtaUFVqRmtkVlZ0Y0U1TmJXaGFWbGR3UjFsV1RrZFhXR3hzVWpCYVZsbHNWbmROUm14V1YydGtXRkpzY0RCV1ZsSkRWbTFXY21OR1VsWk5SbkJvV1RJeFMxTkhTa2RVYld4WFlUTkJlbFp0ZUdwbFJURklWVmhvVldKSFVsbFpiWGhMWTFaV2MxWnVaR3BOVmxvd1dsVm9UMVF4V25OalJXeGhVbGRTU0ZsVldtRmpiVXBGVkd4a1RtSnRhRlZXYlhCTFV6RmtXRkpyYkdwU2JGcFlWV3hhZDJJeFpGVlNiVVpWVFdzMVdGWnROVTloYkVwMFZXNUNWazFHV2t4V01uaGhZekZXY21ORk5WZGhla1V4VmxjeE5HRXhXa2RhUldoV1lrZDRZVmxVU2xOa2JGbDNWMjVPYWsxcldrbFVNVlV4Vkd4YWRHUjZRbGRoYTJ3MFZXcEtSbVZHVG5OV2JFNXBVbTVDV1ZadGNFOWlNREI0VjI1R1VsZEhhRmhaYkZVeFVqRnJkMWR0ZEZkTmJGcDVWbTF3VDFkR1duTlRhM2hXWVd0YVMxcFZXbE5rVmxweldrZHNVMWRGU2pOV2JHUjNVekpKZVZOWWFGaGliRXB4Vld4U2MxWXhVbGhrUjBaVVVteHNOVnBGWkRCWFJrbDNZMFprVjAxcVZreFdiVEZIWTJ4S1dXRkdXbWhoTVhCNVYxUktOR1F4VGtaUFZtUlhZbGQ0V0ZZd1ZrdFRWbGw0Vld0T1dsWXdNVFJXTVdoelZURmtTR1ZHV2xkTlIxSjJWakJhWVdOc1duUlNiR1JPVjBWS1dWWnFTbnBPVjBaMFUydG9WbUp0ZUZaVVZscDNaR3hhVlZKdFJsaFdhMXA2V1RCYWExUnNXWGhTV0dSWVZqTkNTRlp0TVZKa01ERldZa2RvVTJKWGFIZFdWM0JMWWpKV2MxZHNhRTVTUlZwVFZGZHplRTVHV25ST1ZrNVZUVlp3VjFSc1dsTlhiVVY0WTBkb1YwMVdjRE5XYlhoM1VsWkdjMXBHWkU1VFJVcEpWakZTUTFZeVJYaFhXR1JPVjBaYVYxbHROVU5YUm14WVpFZEdhRkpzV2pCVVZsWjNZa2RLU1ZGcmFGcE5SMUoyV1ZWVmVGZFdSbk5pUm1ST1ltMW9iMVl4V21GVWJWWkhZMFZrYUZKc1NtOVVWekZ2Wkd4YVdFMVljRTVXTURFMFdXdG9UMkZHU2paaVJteFhZbGhvZWxScldtdGpiRlp5Vkd4b2FWSnVRalZXUmxwVFZURlplRk5ZY0ZaaWEzQllWRlZrVTFSR1ZuRlNiWFJxVFZaYWVsa3daRzlVYkZwelYxUkNWMkpZUWtSWFZtUk9aVlpTZFZSdFJsUlNiSEJ2VmxkNFUxWXhaRWRpU0U1WVlUTlNVRlp0ZUhOT1ZuQkdWMnM1Vm1GNlJsaFpNRnB6Vm1zeGRWVnVTbHBXTTJoUVZURmFSMlJHU25OYVIyaE9WbXhaTUZZeWVHdE9SbXhZVkd4a1ZHSnNTbFJaV0hCelkwWldjMkZGVGs5U2JIQjRWVEp3VTFZd01YSlhiR2hXVFdwV1dGWlhNVXRUUjFaSFlrWndWMUpXY0c5WFZsWmhWakExYzFSdVNsQldiVkpQVmpCV1MxTXhXbk5aTTJocVRWWldOVlZ0Y0dGV01rcDBWV3hvV21KSGFFUldSVnB6WTFaS2RHUkdaRTVXTVVsNFZteGtlazFXVlhoVGJHUnFVMGQ0V0ZWdGVIZGhSbXcyVVZSR1UwMVdjRnBaYTJRd1ZUQXdlRk5zY0ZkV00wSkVXa1JHVDFZeVNrZFhiR1JYVW14d1dWWkdaREJrTVU1WFlrWmFXR0pGTlZoVVZWSkhWMFpyZDFkdE9WaGhla1pZV1RCV2IxbFdTbGRqUlhoYVpXdGFWRmt5Y3pGV01YQklZVVUxVGxKV1dURldiVEIzWlVkUmVGUnVTazVXYldoVVZqQmtORlpHYkZWVGJFNVlWbTE0TUZwRmFHdGhiRnB6Vm1wT1dsWldXbEJXTUZwTFpFZFdTV05HY0ZkV2JIQlJWbTF3UjFNeVRYbFVhMnhvVW14d2NGWXdXa2ROTVdSWFZXdGtWRTFyTVRSWGEyaFBWMGRLUjJOR2FGVldSWEIxV2xkNGExZEhVa2hrUms1cFZteHdObFpYTURGVU1WbDVVMnRvVm1KSGFHaFdhazVUV1ZaU1dHVkhkR3BOVm5Bd1ZXMTRiMkZXV25OalJXeFlWa1ZLV0ZsNlJtRlhSazV5VjIxd1ZGSlZjRmhYVm1Rd1dWWlNSMWRzV2xoaVdGSlpWV3BHWVZOV2NFWmFTRTVWWWtad01WVlhjR0ZXTWtaeVlUTm9WbVZyV25KVk1GcFBZekZrYzJGSGJGTk5iV2hZVm0weGQxUXlTWGhVYTJSV1ltdHdXVmxyV25kak1WcHpWV3hrVjAxV1JqUldNalZyVmpBeGNsWnFXbFpXYldoeVZtcEtTMU5HVmxWUmJIQm9ZVEZ3ZVZkclZtRlVNazUwVW10b2FGSnJOWEJWYkdoRFlqRmFjbGR0UmxwV01VWTBWakowYTFkSFNuSlhiRkphWWtkb1ZGa3hXbk5qTVdSeVpFWlNVMkpJUWxwWGJGWldUbGRHUjFkdVNrOVdWMUpYVkZaYVMxUkdXbkZSV0doWFRXczFTRmxWV25kaFIwVjZVV3RvV0dKR1dtaGFSRVpQVmpGV2RWUnRhRk5OYm1oMlZrWlNRMU13TUhoWFdHeHNVak5TVDFWcVJrZE9SbVJ5Vm0xMGFGWnJOVWRVYkdNMVZtMUtkVkZ1Y0ZwTmJtaDZXVEo0ZDFJeFVuTmhSazVwVWpOamVGWXllRmRpTWtWNVVteGtWRmRIVW5GVmJHUnZWMFpTV0dOR1pFNU5WbXcxV2xWa1IxWXdNWEpPVldoYVZsWndjbGxWWkVabFIwNUdUVlprYVZkRlNrMVdhMUpIVXpGWmVGcElWbFZpVjJoVVZGY3hiMVZHV25SbFJ6bFNUVlUxZWxZeGFHOVhSMHBHVGxaV1ZWWnNjRmhVYTFwV1pWVTFWbVJHV2xOaVNFRjNWbXhqZUdJeFduUlRiR3hvVWtVMVlWUlZXbmRYUm13MlVteGthazFZUWtoWlZWcHJZVlpPUmxOdFJsZGhNWEJvVmxSR1ZtVldTbGxhUlRWWFlraENVRlp0ZEdGVE1XUkhWV3hvYWxKdFVsVlZiWGgzWlZaa2NsWnRkR2hpVlhCSFZHeG9kMWRzV2xkalJtaFhZV3RHTTFwV1pFZFNiVXBIV2taT1RrMVZjSFpXYWtaaFlURlZlRk51U2s5V2JWSlpXV3hvVTFaR2JISlhibVJyVFZad1dWUlZVa2RWYXpGWVZXeG9XR0V4Y0ZoV1Z6RkxWbXhrZFZKc1ZsZGlWa3BWVmtaV1lWWnRWbGhXYTJ4VllsZG9WRmxVU2pOTlZtUlhWbTFHYVUxWFVucFdNV2gzVm0xS1dHRkdhRnBXUlZveldWVmFjbVZHWkhKa1IzUlRUVlZ3U2xkclZtRlVNa1pHVFVoa1ZGWkZjRmhaYkdoRFZFWlNjbGRzU214V2EzQjZWMnRhVTJGWFNrZGpSbEpZVmpOb1dGZFdXbXRTTVZaellVVTVWMlZ0ZUZwV1Z6QjRUa2RXUjFadVVrOVdWR3haVlcxMGQyVldhM2RYYm1SWVVqQldORlpzYUc5V01ERkhZMFY0VjAxV2NFaGFSbVJIVWpGd1IxcEZOVTVpVjJjeFZtMHhORlV4U1hsU1dHaFVWMGRvYUZVd1dtRldSbXh5VjIxR2FsSnNjSGxYYTFKVFZqQXhWMk5HYkZWV2JFcFVXVlJCZUdNeFpISmhSbVJwVjBkb2VWZFdWbUZUTURWMFUydG9VRlp1UWxsVk1GWkxVMVphZEdORlpGWk5hekUxVlcxMGMxWlhTa2xSYkdoYVlUSm9SRll4V210V1ZrWjBUMVpTVGxadGR6RldWekF4VXpKR2MxTnNiR2hTYlZKaFdXdGFTMU5HV2xaWGJHUnJVakZhU1ZWdE1YZFViR1JHVTJ0c1YwMXVVbGRVVmxwVFl6Rk9jMkpHU21obGJYaFpWMWQ0YjJJeVVuTmpSVlpUWVhwV2MxVnRlR0ZOVmxwWVpVZDBhRkpVUm5wVk1uaHpWMFphTmxKVVFsaFdiSEJvV1hwS1MxTldUblJTYkU1c1lsaG9ORlpzWTNoT1JteFdUVlZrYWxKc2NHOVZhazVUWWpGU1dHUklaRlJTYlhRelZtMHdOVll3TVhKalJscFdWbXhLU0ZacVJscGxiRkp4Vld4d1RtRnJXazFXVjNoaFZqSk5lR05GV2s5V01uaHdWV3hvUWsxV1duUk5TR2hyVFZVeE5GWkdhRzlaVmtwMFZXeG9XbUpZVFhoV1ZFWnpZMnhrZFZwSGNGTmlSM2Q2Vm1wS01HUXlTa2hUYTJScVUwZG9WMVp1Y0VkVFJsbDVaVVp3YkZKck5YbFphMXByWVZaa1IxTnFTbGhXYkVwSVZYcEtVMVl4U25WVWJXaFRZbXRLV1ZaWGVHcE9WVFZ6VjJ0a1lWSkdTbUZXYWtGNFRrWnJkMVpzWkZkaVZYQkpWbGR6TlZZeVJuSlhhM1JoVWtWYWFGWXdaRmRUUlRsWVlrVTFWMDFWY0V0V2JGSkxUVWRKZVZKclpGUmlhelZ4VlcweGIxbFdXbkpXYlVab1VtMTRWMVl5ZUhkaE1ERllWV3BHV0dFeGNGQlpWbHBMWkZaR2RGSnNhRmRpUm5CdlZtdFNSMWR0VmxkVGJHeHFVbXR3YjFscmFFTlhWbHBIV1hwR1ZrMXJXa2hXTW5SWFZrZEZlVlZzYUZWV2JIQk1XbFphV21WWFZrZFViV2hYWVRKM01sZFdWbUZqTVdSSFYyNU9WR0V6YUZoV2FrNVBUa1pXY1ZKdGRHdFdhM0I2VmtjeGMxVXhaRVpUYWxwWFlrZE9NMVJXV2tabFJrNVpZVWRzVTJKSVFscFhWbWgzWXpKSmVGZHVSbEppUjFKUVdXdGFZVmRXY0ZaYVJXUllVbXR3ZWxsdWNFdFdiRnAwWVVoYVYySllhR2hWYlhoclpFWktkRkpzWkZkTlZYQk9WbXhrZDFJeGJGaFVXR2hXWW14S2NGVnFTalJYUm14VlZHdE9XRkpzY0RCYVZXUjNZa1pLVlZacmJGZFNiV2h5VmtkNFQxTkhSa2RpUm1ST1VqRkZkMVpzVm1GWlYwNVhWVzVPVldKSFVrOVdiWFIzVjJ4a2NsWnRPV2hOVm13elZGWmFhMVpIU25WUmJHaGFZa1pLUTFSV1dtRmpWazV5V2tVNWFWSllRalJXVnpFMFlURlZlVk5zYUdoU1JYQllXV3hvUTFOR1pGZFhhM1JxVFZoQ1NsWlhNVzlWTURGSFkwWldXRll6VW5aVlZFWlBWakZrZFZKc1RtbFhSa3BWVmtaYVYyTXdOVWRoTTJSWFlsUnNiMVp0ZEhkbFZsSnpXWHBXVjFac2NFZFZNblEwVm0xV2NsZHRhR0ZTVmxZMFZURmtSMU5IVWtaT1ZtUlhUVEpPTTFadE1IaE9SMGw1VkZob1dHSkhhRlZaYlhSM1kxWldjMVZ1VGxoU2JYaDZWbGQwYTFZeFNuUmxTR2hXWWxob2NsbFVSa3RXVmtwellVWmtVMlZyV1hwV2JGSkxVekZKZVZSclZsWmlSMUpZV2xkMFYwMHhXa2RXYlhSVVRWVnNORlpITlZkV1YwcFpVV3hTV21KSGFIWldha1poWkVkV1NHUkhiRTVpUlhBMlYxZDBZV0V4V1hoYVJXaG9VbTFvVmxacVRsTk5NVlowWlVkR1dGSXhXa3BYYTJSdlZURmFSbGR0UmxkV2JWSXpWWHBHYTFJeFpIVlViRkpvVFcxb1dGWkdaSGRTTVZWNFkwWmFXR0p0VWxWV2JYaGhaV3hhU0UxWVRsWk5SRVpYV1RCU1QxWXlTbGxSYTFKYVZrVndTMXBWV2xkak1YQkhZVWRzYUUxWVFsWldNV1EwVmpGc1dGUnVUbFppUjFKWldXMHhVMk14YkhKYVJrNXNWbTE0VjFZeWN6VmhSa3BWVW14a1dtRXhTbGhXTW5oaFZqRmFWVkpzWkU1aWJXaHZWbGN4ZWsxV1duTldiazVZWVhwV2NGbHNaRzlPVmxsNFlVaGtVMDFYZUZsV1JtaHZWbTFLY2s1V1ZscFhTRUpZVmpCYWMyUkhVa1prUm1ocFVtNUJkMWRVUWxka01WSnpWMjVPVTJGc1dsZFpiRkpYVlVaYWMxcEZXbXhTTURWS1ZXMTRZV0ZIUlhkalJ6bFhZV3RLYUZsNlJtRldNVTUxVld4T2FWWXlhRlZYVjNSdlVURk9SMWR1UmxSV1JWcHZWRlphVjAweFVsZFhiVGxYWWxWd01GcFZXbk5YYkZwR1kwWlNWVlpGV21oVk1GVjRWbXh3Ums5WGJGTmlhMGt4VmpGa01GbFhSWGhWYmxKVVltczFWVmxzVW5OWFJteFZVbXQwVlZKc1dUSlZiWE0xVlRBeFYxTnFSbFpOYWtaSVZsUkJkMlF4VG5OV2JHUnBWa1ZHTkZaV1VrZGhNVmw0V2toS1lWSnRhSEJXYkZwM1pWWmFSMXBJY0U1V01WcDZXVlJPYTFkSFNsVmlSbHBhWVRGd00xUlZXbUZYUjFaSFZHeGtWMkpJUWpaV2JYaHZZakZhVjFkdVRtcFNiVkpvVm0weFUxVkdVblJsUjBacVRWaENSMVJzWkc5VWF6RkdZMFYwVjJGcldsUlZWRVp6VmpKS1IxcEhSbE5XTVVwYVZtcENiMUV5U1hoV2JsSk9WbnBzV1ZadGVIZE5SbkJXWVVkMGFGSnJjSHBXTWpWdlZtc3hkVlZZWkZkaE1YQm9XWHBHVDJSWFRrZGhSMmhPVjBWSmVWWnRlRk5SYlZaSVZXdG9VMkV5VWxWWmEyUlRZMFpXY1ZGVVFrNVNiSEJKV2tWa01GWnRTbGRYYTJoWFZucFdURmRXV2t0a1IwWkpVV3h3YUUxV2IzcFhiR1EwV1Zaa1NGUnJXbEJXYkhCUFZtMDFRMDVzV25OYVJGSm9UVlpzTlZVeU5WTldiVXB5VGxab1dtSkdTa2RhUkVaVFZsWktkRkp0ZEZOV1JWcEhWbTB4TkdFeFVuUlNXSEJTWWtkb1dWWnJWa3RoUm1SWFYyeHdiRlpyTlhwWmEyUnZWVEpLUm1OR2JGaFdiVkYzV2tSR1NtVkhUa2RhUm1ocFVqRktlRmRYZUdGWlZrNUhWMWhzYW1WcldsZFVWVkpIVmpGcmQxZHVaRmROYTNCSlZsZHdUMVp0Um5KalJrNWhWbFp3VUZZeFpFZFNNa1pJWWtkb2JHSkdjREpXYlhoclpERlJlVk5ZYkZWaE1sSllXVzE0UzFWR1duTldWRVpYVFZkNGVWWXlOV3RpUmtwelZtcFdXazFHY0ZCWlZWcExWbFpLY2xkc1pHbFhSa295Vm1wQ2ExSnRWbGhTYTJSV1lrZFNjRll3Wkc5bFZscFZVVzEwVTAxVmJEVlZNblJyWVd4SmVXVkdiRlpoYTNCMlZrZDRXbVZHVm5KYVJuQlhZa2QzTVZacldtOWlNVmw1VTI1S1QxWXlhRmRaYkZKSFpHeGFjbGR1VG1wTmExcEpWREZWTldGV1NYaFRiR3hYWWxSQ05GVnFSbUZTYXpGWFdrWlNhV0pyU2xsV1JtUjNWakZXUjJKR2FHeFNXRkp4VkZkek1WTkdaSEpYYkdSWFRXdHdTbFZYYzNoV01WcEdVMjFvV0Zac2NISlZNRnBUVjFkT1NHRkdUbWxXYTNCUlZtMHhkMUl4VG5SV2EyUmhVbXhhVTFsc1ZtRmlNVkpYVjJ0MGJHSkdiRFJaVldoUFlVWktjbU5GYUZwTlJuQjJWakl4UzFJeFRuSlZiRlpvVFZoQ1dWWkhNVFJUTWxKSFUyNVNhbEpVVmxsVmJGWjNWRVphZEdSSGRFOVNNR3cxVlcxNGExWkdaRWhoUmxaYVlsaG9NMVl4V21Ga1JURllUMVUxVGxadVFqUldWekV3VFVaWmQwMVdiRkpoTTBKWVZXNXdSMU5HV2xWU2EzUnFZbFUxU0ZsVldtdFZNa3BKVVcwNVdGZElRa05VVmxwS1pVZE9SbUpHVW1sV01taFZWMWQ0WVZNeFpGZFhibEpxVWxVMVdWbFljRWRsYkd4eVlVVjBhRkpyY0ZkVWJGcHZWMjFLUjFkcVRsZE5ibWhvVmpCa1QxSnJPVmRhUm1ST1UwVkthRll4V2xkaE1rbDRWMWhzVkdFeVVuRlZiWFJMVjBaU1YxcEdUbFJTYkZwNFZXMTRUMkZ0UmpaV2JHaFlZVEpTZGxaSE1VZGtSMUpGVjJ4a2FWWkZWWGRYVmxKQ1RWWk9SMVJzYkdsU2JIQlpWV3BLYjFkV1pGaE5XSEJPVmpCYVNGWnROVTlaVmtvMllrWm9WVlp0VVRCYVZscHJZMnhzTmxac2FHbFNia0YzVjJ4V2IyTXhXWGROV0ZaV1YwZFNXRlpxVGs5T1JsbDRWMnRrYWsxWVFraFhhMVV4WVVkRmVHTkZjRmRpVkVZelZXcEdjMWRHVW5WVmJGWm9UVlp3VlZkWGRHdFZNVnBIVld4V1ZHSlViSE5XYlhoM1pWWmtjbFZzVG1oU1ZFWlhXVEJvZDFZeFNqWldhM2hhVmxad1RGcEZXbGRrUlRsWFkwWmtVMVpHV2tWV2ExcHJUa1pzVjFScmFGZGhNbWhVV1d4a2IxUXhXbk5hUkU1T1VteHdlVmRyVWxOaGF6RnlWMnRvVmsxcVZsQldhMlJMWTJ4T2MyRkdjRmROTVVsNlYydGtORmR0VmtkYVNGSnJVbTFvVkZSV1duZFRWbHB5V2tSU1ZVMVdTbnBWTW5SclYwZEdjMk5HYUZwaE1sSlRWRlZhYzFaV1NuUmtSbEpUWVROQ1lWZFdWbXRrTVZwSFUyeFdWMkpIYUZsV2FrNXZaR3hzY1ZOclpGTk5WMUphV1d0a05GWkdTbFZXYkd4WVZqTlNjbFpVUVhoU01rNUdWMjFHVTJWdGVGbFdSbFpUVWpGT1IySkdWbFZpYXpWWVZGZDBkMVpzVm5OVmEwNVlVbXh3ZWxrd1pFZFpWbHBYWTBoS1drMVdjSEpaZWtaVFl6RndSMVJzWkZoU1ZYQmhWbTF3UzA1SFJYZE5WV1JVVjBkU1VGWnNaRk5YVm14MFpFZEdWMUp0ZUhwWlZWcFBWMFphYzJOSWFGWldlbFp5VmxSQmVGWXhUblZqUm1ST1lXdFdNMVp0TVhwbFJsbDVWR3RrYWxKc2NGaFVWRXB1Wld4YWRHTkZkRk5pVmxwSlZrZDBjMVpIU2tkWGJUbFZWbTFvUkZSdGVHRmpWa1owVW14d1YwMVZjRmxXYkdNeFZESkdSMU5ZYkd4VFJVcFhXV3RrYjFKR1VuSlhiVVpxVFZoQ1JsWlhlR0ZVYlVZMlVsUkNWMDF1VW1oWlZFWmFaVlpPZFZSc1VtbGhlbFpZVmtaV2ExVXhXa2RYYmtwWVlrVTFXRlJXWkZObFZuQkdXa1JTYUZacmJEWlpWVnB2VjBaYWMxZHNaRlZpUm5CaFdrUkJlRll4Y0VoalJsSlVVbFZ3YjFacldsZFpWazE0VTJ0a1dHSnJXbFJaYTJoRFl6RnNjMVp0UmxSaVJtdzFXbFZrTUdGR1NYZFdhbHBXVmpOU2VsWXdXbUZTYlVwRlZXeGtVMUpXY0V4WGJGWmhVekpTVjFWdVRtaFNNbmhZVkZjeGIwMXNXbkpYYkU1U1RWVXhORlpITlU5WFIwcHlUbGRvVmsxSFVsUldhMXBUVjBkU1IxcEZPVmRpU0VKYVYydFdhazVXV25KTldFcFhZV3hhWVZac1pFNU5WbHAwVFZWMFUwMVZOWHBaVlZwclZHeGFkVkZzYkZoWFNFSklWMVprVTFZeVRrWlhhemxYVFc1b1ZWZFhNVEJTTURCNFYyNUtXR0pWV2xkVVZsWlhUa1prY21GRk9WaFNiVkpKVmxkNGIxZHNXWHBVV0doWFlsaG9lbGt5ZUd0a1JrcDBZMGRzVTJKWVpEWldiWEJLWlVVeFIxZHJaRlJYUjJoWldWUktiMWRXYkZWU2JtUk9UVmQ0V0ZZeU1UQlZNa1kyVW14YVYxWXphSFpXYWtaTFZtMU9TRTlXWkdsV1JVa3dWbXhqZUZZeFNYbFVhMXBwVW14S2NGWXdXa3RXVm1SWVpFZEdhMDFXV2toV01qVlRWR3hLUmxkc1RscGlSbkJJVkd0YVdtVlhVa2hrUm1oVFRVaENXRlpxU2pSWlZscFhWMWh3Vm1KWGFGWldiRnAzVmpGd1YxcEdUbFJTTVVwSVdWVmFUMVJzU25WUlZFWlhZa1pLVEZSclduTldNWEJKVld4T1dGSXlhSGhXVjNCTFlqRmtSMWR1VGxoaWJWSmhWbTAxUTFKc1ZuUk9WM1JXVFd0d1dGVXlkRzlXTVVsNlZGaG9XbFpYVWxoWmVrWnJZMjFLUjFwRk5WZE5WVmw2Vm1wR1lWbFdaSFJXYkdSVVltczFhRlZ0ZUV0alJteFpZMFprYkZKc2NGbFVWbEpEVjJ4YWRGVnNhRmROYWxaVVdXdGFTbVF4WkhWU2JIQm9UVmhDYjFkc1ZtRldNVmw0Vm01S1lWSXlhRzlhVjNSaFYwWmFTR1ZHVGxOTlZtdzBWVEp3WVZVeVJYbGhSbWhYWVRGYU0xWkZXbFpsUm1SeVdrZHdUbFpXY0RaWFZsWmhZVEpHVjFkdVNsZGhhelZZV1ZkMFlXRkdiRlZTYkhCc1VtMVNXbGxWWkVkV1JrcHpZMFpXV0ZZelVsaGFSRXBQVWpGa2RWUnNhR2xpVmtwMlZsY3hOR1F3TVVkVmJHUldZVEExYjFSVlVrZFNiRlowWkVjNVYwMXJjRWxaVldoaFYyeGFWMk5HUWxaTlJuQllXa1ZhUzJNeGNFaGlSbWhUWVRKM01sWnRkR0ZaVm14WFYxaG9ZVkpXY0U5V2JGcGhWMFpzY2xwR1RsaFNiWGg1VjJ0U1QxUnRTa2hWYkdoWFlsaG9jbFpFUmt0ak1rcEZWV3hrVG1Gc1dsRlhWbVEwVkRGS2RGUnJaR2hTYmtKdlZGWm9RbVZzV2xWUmJVWnJUVlZ3ZWxrd1ZtdFdWMHBHVGxVNVYyRnJXa3RhUkVaclYwZFNTRkp0YUU1aE1YQlpWbXRrTUZsV1draFRiRnBZWWtkb1lWWnFUbE5oUmxweVYyeGtWMVpyY0hwWk1HUTBWakpGZWxGdFJsaFdNMUpvVmtSS1IxSnJNVmxVYkZKcFVtNUNXbFp0Y0U5Vk1rWkhXa1prV0dKWVVsUlVWM1IzVTJ4VmVVMVZaRlpOYkZvd1dsVmFjMVl4U25OalNFcFZZVEpTV0ZacVJtdFhWMHBHVGxaa1YwMVZjRmhXTVdRMFZqSlJlRlJ1VGxkaVIyaHpWVEJWTVZsV1duUmxTR1JZVm14d1dWcEZZelZYUjBwSFlucEtWbUpZVVRCV2FrcExWMWRHU1ZOc2NFNWhhMXBSVmxkd1MxSXhUa2hTYTFwUFZtMW9WRlpzYUVOV1JscDBUVWhvVGxJd1ZqTlViRlpyVmxaa1NHRkdWbGROUjFKMldWVmFWbVF4V25WYVIzQlhZa1p2ZDFaR1dtRlVNa1p6VTI1T1dHSnRhRmRaYkdoVFlVWnNWVkZZYUZoU2JGcDZXVlZhYTFZd01IaFNhazVYWWtaS1ExcFZXbUZrUms1eVZteGFhVkl4U2xWWGJHUTBXVlpXVjFwR1pGZGlWVnBWV1d4YVlWZFdWblJrUjNSWFlsVndTbFZYZUc5V2JVcEhWMnBLWVZZemFHaFpNVnBIWkVaS2RHRkZOVmRpV0dOM1ZqRlNRMVl4V1hoV2JsSlVZa2Q0VjFsWWNITlhSbXh6Vld4a1UxSnNWalJXTWpGSFlURktWVkpzY0ZoaE1YQXpWbXBLUzFJeFpGVlNiR1JYVWxjNU0xZFhjRWRaVjFKSFZHNVdWR0pIYUhCVmFrcHZZVVprV0dSSGRHbE5Wa1kwV1RCYVlWZEhTblJWYkdoYVlUSlNWRlJWV2xka1IxWklUMVphVGxadVFraFdha28wWVRGWmVGZHVVbFpXUlVwWlZtMTRkMVpHY0VaWGEzUllWakJhU1ZsVlZURlViVXAwWVVad1YwMVhVVEJXVkVaTFkyc3hWbHBIYkZSU1ZuQlZWMWQwYjFFeVRYaFhibEpyVTBkU1dWbHJaRFJsVmxsNVpVZDBhRkpyYkROV01WSkxWakpLV1dGSVNsZE5SbkJoV2xkNFYyUldUbk5hUm1SVFZtNUNUVll5ZUZkaE1WRjRVMWhvWVZORk5XOVZha28wVjFaV2RHUklaRTlXYkhBd1ZGVm9iMVF4U1hoU2FsWlhZbFJXVUZacVJtdFRSMVpHVDFaa1RsSnNWalJXYlhCSFZURmFjMVp1U2xWaGVteFlXV3hvYjFkR1duRlRXR1JQVm14c00xUldhRXRoYkVwelkwWmtWMkZyTlVSV1ZWcHJWakZrZEZKc1pFNWhlbFpKVjFaV1lXUXhVblJUYmtwUFVrVktXRmxzVWtaTlJuQkZVbXM1VkZKck5YbFhhMXBYWVZaWmVtRkdiRmRTYlU0MFdXMXplRkl4WkhWVmJYUlRUVVp3V0ZaR1dsWmxSVFZYVmxob2FGTkZOVmhXYWtKM1pWWlNjMWR0T1ZoaVZYQmFWbGN4YjFZeVJYaGpTSEJhWld0YWFGcEZXa3RqTVhCSFdrZHNXRkl5WTNoV2JYQkxUVVpzVjFWWWJGUmhNbEpaV1cxek1XTkdWbkpYYlVab1VteHdlbGRyV2t0aE1ERlhZMGhvVmsxdVVuSldSRXBMVW0xT1JWSnNjRTVTYmtKNVZtdGplRkl5VFhoYVNFWllZa2RTY0ZZd1ZrdFVWbHBaWTBWa1ZVMVZOVWhWTWpWTFlWWktjMU51UWxaaGExcE1WbFZhWVZkRk1VVlNiRXBPWVRGd1NWWXlkRzlVTVd4WFUydGtWR0pIYUZaV2FrNXZWRVpaZDFkdFJsUlNWRlpYVkRGYWIxVXdNVWxSYlVaWVZteGFjVlJzV21GV01XUnlWMnhTYUUweWFGbFhWM2h2WWpKR1IySkVXbE5pYlZKVlZtMDFRMU5HV2xoamVrWlhUV3RXTkZsVVRtdFdNa3BIVTJ0MFZWWnNjRk5hVlZwM1VtMUdSMVZ0YkdoTk1FcFNWbTB3ZUU1R2JGZGlSbVJwVTBWd2FGVnRkSGRVTVZaMFpVaE9UazFXYkRWYVZWVTFWMFpLY21OR1dsWmlXR2g2Vm14VmVGWXlUa2xUYkdSb1lUTkNUVlpVUm1GU01rNVhWMjVPWVZJeWFHOVVWM0J2VFRGWmVGZHNUbE5OVjFJd1ZsWm9hMVJzV25SVmJXaFdZV3MxUkZac1dsZGpWbEowVDFaa1RsWnVRWGRXUmxwVFZUSkZkMDFZU2s5WFNFSllWRlprYjJOc1pGZFhhM1JZVm14YWVsWlhlRmRXTURCM1RWUlNWMVpGU21oWmVrcFBZekZ3U1ZadFJsTk5iV2hWVm0xMFYxbFdaRmRhUm1ocVVsUnNjbFJXWkZOVFJsbDVaRWRHYUZZeFdubFZNbmh2VmpKRmVGZHRhRmhXYkhBelZtMTRkMUp0VWtkVWJHUnBWbXR2TWxacVNqQmhNa2w1VTJ0b1ZHRXlVbkZWYlhSaFYwWnNjMVZyVGs5U2JFcFhWMnRhUzJKR1NuVlJhMmhZWVRGd2RsbFdaRXRTYlU1SFVXeGthVmRHU205V1dIQkhXVmROZUZadVRtaFNNMUpVVkZWYWQxWnNXbGhOVkZKWFRVUldXRmt3V21GWFIwcFpWV3hvV2xkSVFraGFWbHBhWlZVMVdWUnNaR2hsYTFsNFYxWldiMWxXV1hsU2JrcHFVbGhvYUZWdGVIZFRSbXcyVTJ0a1UwMVlRa2hYYTFwcllWZEZkMk5FU2xkaGExcDJXa1JHU21WV1NsbGlSbHBvVFd4S1ZsZFhNVFJUTWs1elZtNVNhbVZyV2xaVVZscGhUVVpTYzFack9WZFdhM0I2V1RCU1ExZHJNVWRYV0dSWFVrVmFURmw2U2t0U1ZsWnpXa1UxVjAxdFp6SldiVEV3WVRGS2RGWnNhRmRoTWxKV1dXdG9RMkl4VWxkWGJtUnBUVlp3ZUZWWE1VZGhhekZ5VFZSU1YySlVWa3hXTUdSSFRteGFjMVZzY0doTmJXaEZWbTF3UjFsV1dsZFVibFpxVWxSc1dGUlZXbmRPVmxwSFYyMUdhRTFXY0VsVmJUVkxWMGRLU0dGR2FGcFdNMDE0V2tkNFlWWnNaSFZVYkdScFUwVktTVll5ZEd0a01WSnpWMWhvVkdGc2NGaFpiRkpHVFVac1ZWSnNXbXhXYXpWNVZqSXhkMVV4V2taWGJIQlhZbGhDVUZWVVJrOVNNV1J6Vm14T2FFMHdTbnBXVnpBeFVURk9jMWR1VW14U2JWSnZWbTEwZDAxV1ZsaE9WMFpYVFZWd2VsVXlkRk5XYlZaeVkwWm9XbVZyV25KWmVrcEhVMGRXUjFSdGFHeGlSbkJoVm0xMFlWbFdXbkpOVm1SaFVsZFNXVmx0ZUV0VlJscHpWVzVPYVUxV1dqQmFSV2hoVkcxS1NHVkliRmROYWtFeFZtcEJlR05zWkhWaVJscE9ZbTFvTWxadGVHdFRNVWw1Vkd0b2FGSnRVazlWYWtaTFYxWmFWVkp0UmxaTmF6RTFWVzEwYjJGV1NuSk9XRUpYVFVkU1VGUnNXbUZqVmtwMFVteGtUbUV4V1RGV1ZFWnZZakZzVjFOc2FGWmlSM2hoV1d4b1RtVkdhM2hYYkZwclRXdGFSMVpIZUhkV01rcHlVMnh3V0dFeFduSlZha1pUWTJzeFYxcEdhR2xpYTBwWlZrWmpNV0l5VG5OaVJtaHFUVEpvV0ZSV1ZURk5WbXQzVjIxMFZrMXNXbmxXTW5CaFZqSktXVkZyZUZaaVZFWllXWHBHUzJSV1VuUmlSazVwVm10d00xWnRjRU5oTWtsNVUxaG9ZVkp0VW1oVk1HaERZekZXZEdWSVRrOVNiSEF3V2xWb1QyRkdXbkpqU0d4VllrZG9SRll5ZUdGU2F6VldWV3hrVjFadVFtOVhhMVpXWlVaT1dGSnJXbEJXYXpWd1ZXMTRjbVF4V1hoYVJFSmFWbXhzTkZZeWVHOVZNV1JJVld4Q1YySlVSVEJXYWtaell6SkdTRTlXVmxOaVIzY3dWbXBKTVZNeVJYZE5WbVJxVWtWS2FGVnNaRk5sYkZwVlVWaG9WRlpyV25sWk1GcHZZVlpLYzJOSE9WaFdiRXBJVmpJeFVtUXdNVmRpUms1cFVsUldkbFpHWTNoaU1XUlhXa1prWVZKRlNuSlVWbHBMVTBaWmVVNVdUbWhpVmxwNVZqSjRiMWR0U2tkV1dHaFdUVVp3ZVZwRVJtRldWa3B6VjJzMWFFMHdTVEZXYkZKSFlqSk5lRmRZWkU1V2JWSnhWVzB4YjFkR2JITlZhMlJZVW14V00xWXllRTloTVZweVRsaHNWVTFXY0hKV2FrcExVMVpHYzFac1pFNVdNVVl6VjFaU1IxWnRWbGRWYmtwaFVtMW9XVlZxUmt0WFZtUlhWV3M1VmsxV2NIcFdNalZUWWtaT1NGVnJPVlppVkVWM1ZGUkdZV1JGTVZWUmJXaFRZVE5DVjFaWE1UUmhNV1IwVWxob1ZHSkdTbGhVVldSVFVqRndWMXBGWkZOTmExcElWMnRrYzFVd01WWmpSVFZYWWxoQ1JGbFVSbHBsUms1WllVWmthV0Y2Vm5oV1YzQkxZakZSZUdKSVRtRlNlbXhVV1d0YWMwNVdjRVpYYXpsV1RVUkdXVnBWV25OV01WbDZWVzVhVjJKVVJrZGFWbVJIVTFaT2MxZHRiRk5oTTBFeVZtMHhNRmxXVlhoWFdHaFlZbXhhYUZWc1VuTmpSbFowVGxWT1QxSnNjRlpWYlhoUFZUQXhWMk5JYkZWV2JIQnlWbFJLUjJNeFRuTmlSbkJYVWxad2IxZHJaRFJaVjFKR1RWWmFhMUpzU2xSVVZWcDNVMVphY1ZOcVVtaE5hMXBKVlcxd1lWWXlSbkpqUm1oYVZrVmFhRmxWV2xwbFZURlhVMjE0VTJKclNrdFdiR040VFVaVmQwMUlaRlJpYlZKWVZtNXdRbVZHVmxoTlZrcHNVbTFTZWxsVlZURldNVXB5WTBoYVYxSnNjR2haZWtGM1pVWldjMXBHWkdsWFJrcGFWbGN4TkdReFNYaGhNMlJZWWxSc1dGUlhkSGRXYkZaMFpVVTVWMVpzY0ZoWk1GcHZWakpLUjJORmVHRlNWbkJNV1hwR2QxSnJOVmRhUlRWWFZqTmpkMVp0TUhoT1IwVjNUbFZrYVZKdGFGUlphMlJ2Vmxac1ZWTnFVbFpOVjNoNVYydGpOVmRHU25OWGFrSmhWbGRvY2xsVldrdGtWa1p5VjJ4YWFWWkZXa2xXYkZKQ1pVZE9jMWR1UmxoaVNFSnZWRmQ0Um1ReFduUmtSMFpVWWxaYVNGWkhOVTlYUjBwSVZXeG9WVlpGU2t4Vk1WcGhWMWRPUmxwR1ZrNVdWM2N3VmpKMGIxUXlSa2RUYkZaWFlrZDRWMWxyV2t0WFJsbDNWMjFHVTAxWFVqQlZiVEV3Vkd4YVZWWnJiRmRoYTFwMldYcEtSbVZHVG5GWGJXeFRZbGRvVjFadGNFOVZNREI0Vmxob1dHSlZXbFZWYWtFeFVqRlJlRmR1WkZkTmEzQktWVmQ0ZDFZeVNraFZWRUpYVWtWYWVsWnFSbXRqTVhCSVkwWk9VMVpHV2xsV2ExcGhXVmRSZUZwRlpHbFNSbkJVV1d0a1UyTnNWbkZSYm1SVVVteHdTVmt6Y0VkV1YwcFdZMFpzV0dGck5YcFdha3BMVjFaR2NtVkdWbWhOYkVwSVYydFNRbVZHV25OalJXUlhZa2RvVkZSVVNtOVdiRmw0VjJ4T1ZFMVdWalJYYTFacllWWk9SMU51VGxaaVIyaFVXVEZhVTFZeFpIUlNiWGhUWWtad1dsWkdXbGRoTWtaSVVtcGFVMkpIZUdoV2JHUnZaV3hhY1ZGWWFHcFdhM0I1V1ZWYWQyRkZNVmxSYlRsWVYwaENURlY2Umt0V01XUjFWV3hPYVZKVVZsbFdSbHBYVjIxV2MxZFlhRmhpUjFKWVdXeGFZVk5HV1hoaFNFNVhVakJXTkZZeWVHRlhiVVY1WVVWU1YxSkZXbGhhUldSWFUxWndSazlYYkZOaWEwWXpWbXRhVjJJeVNYaFhhMXBPVm0xb1YxbHJaRFJXTVd4ellVWk9iR0pHYkROWGExWXdWa1pLYzFkdWNGcFdWbkJvV1ZaYVNtVlhSa1pXYkdSWFVsVndiMWRXVWt0VWJWWkhZMFZzVm1KWVVsUlphMmhEVlVaYVdHUkhSbHBXVkZaNlZqSjRiMVJzU2taWGJGcFZWbTFSTUZZd1dsWmxWMVpIV2taa1RtRXpRa3BYVmxaclVqRlplVkpZYUZkWFIyaFhXVlJHZDJGR1ZuRlNiWFJxVFdzMVNWcFZXbXRVYkZwWlVXdHdWMkpZVW5KVWExcE9aVlpLYzFwR2FHbGhlbFo0VmxkNGEwNUdaRWRYYmtwWFlsVmFjbGxyWkROTmJGWjBUVlZrVmsxRVJscFZWM1JyVjIxRmVHTkZlRnBXYlZKSFdrUktUMUl5UmtkaFJtUk9UVzFuZVZZeFpIZFNNVlY0VTFoc1UxZElRbWhWYlRGdlkwWnNXV05HWkd4U2JWSlpXa1ZrUjJFd01VVlNiR2hZWVRKb1RGWXdaRXRXVjBwSFlVWldWMDB4U1hwV2FrSmhWbTFXV0ZacmJHRlNiVkpQVm14b1EwNXNaRlZSYlVaV1RWWnNORll5ZEdGWFIwcFlZVVprV21KSGFGQlVhMXBhWlVaa2NrOVhjRTVoTVhCS1YxWldWazFYUmxkWFdHeG9VakJhV0Zsc2FGTmhSbVJYV2tWYWJGWnJOVnBaYTFwWFlWZEdObFpzY0ZoV2VrVjNWMVphWVZJeVNrbFViR1JwVmxad1dWWlhNSGhPUjFaWFdraEtXR0Y2YkZaWmExcDNaV3hhZEdOR1pGcFdiSEJZV1RCb1MxWXlSbkpTYWxKYVRXcEdVRlZxU2tkU01XUjBZa1pPVG1KWFp6RldiVEI0WkRGTmVGTlliRlZpYXpWV1dXMTRTMkl4Vm5STlZ6bFlVbTE0ZVZsVlZrOVdWa3AwVlc1d1YySlVSa2hXTW5oYVpVWk9jMkZHWkZObGJGcFZWbXhTUzFNeFNuSk9WbHBRVm01Q2NGVnFSa3ROYkZwelYyMUdXbFl4U2tkVVZscFhWbTFLV0dWRk9WZGlSbkF5V2tSR1lXTXhaSFJQVjJ4T1ZqTm9XVlpyWkRCWlZsRjRWMjVTYUZJd1dtRlpWRVozWVVac1ZsZHVTbXhXTVZwSVZrZDRhMVJzV1hoVFdHaFhUVzVTY2xSclpFZFdNVTUxVlcxMGJHRXhjRmxXVjNCUFlqSkdSMWRyVmxOaVNFSnpWVzB4VTAxV1draE5XR1JXVFZac05GVXllSE5XTVVwMFZXcE9WbUZyV2xCVmFrWnJaRlpLYzFWdGFFNU5WWEJhVm0wd2VFMUhVWGxXYms1WVlrZG9jMVZxVGxOV01WSlhWMjVrVGxac1dsbFVWVkpYVjBaS2MyTkZaRmROYWtaMlZtMHhWMk50VGtkVmJGcE9VbTVDV1ZkVVNYaFNNVTVJVkd0a1ZXSlhlRmhaVkU1Q1pWWmFkR1JIUmxwV01HdzBWVzAxUzFSc1pFWk9WbXhYVFVkU2RsWXhXbk5qYkhCSFZHMXNUbFpyY0ZwWFdIQlBZakZSZUZOdVRtcFRTRUpoVm14a1VtUXhXbk5hUlhSVVVteGFlVmxWV21GVWJVWnlVbGhvVjJKVVFqUlZla1pyVmpGYWRWSnNWbWxTTVVwUVZsY3dNVkV4V2xkWGJsSnFVbGRTYjFSWGN6Rk5SbHBZWkVkMFYxWXdjRWRVYkdoRFZqQXhTRlZ1V2xkTlJuQm9XWHBHY21WdFJrWlBWazVvWld0VmVGWnNaRFJpTWtWNFZXNU9XR0pIVWxsWmEyUnZXVlpzVlZOc1RtdGlSbXcwVmpJMVQxWXhXbkpqUkVaWVlURndhRlpVU2t0WFYwWkhZa1prYUdFeU9UTldSbFpyVWpKT2NrMVdiRlJoZW14WVZqQldTMWRzWkZkVmEyUnJUV3MxZWxZeU5VZFdSMHBJVlc1R1dtRXhjRE5hVlZwaFUwZFdTR1JHVm1sU2JrRjRWbFpqTVdNeFdYaFhhMXBwVWtaS1dGbFhkR0ZUTVhCV1drVTVVMkpWY0VoWGEyUnpWVEpLU1ZGcVRsZGlSMUl6VldwR1RtVldWbGxoUjBaVFlsZG9lbFpYY0VOWlZscFhWV3hvYkZJd1dsbFZiWGh6VGxaU2MxZHJPVmRXTUhCSVdUQldiMVpyTVhWaFNGcFhZa1p3YUZacVJrOWpNa1pIV2tVMVUySnJTVEZXTW5SVFVqRnNXRlZyWkZSaWF6VnZWV3BLTkZkR2JISmhSVXBPWWtad01Ga3dWakJVTVVwMFpVWm9XR0V5YUZSV1ZFWnJVMGRHUjJKR2NHbFdSbHBGVm0weE5HTXhXbGRUYmxaaFVtMVNUMVl3Vmt0WFZsbDVaRWRHYUUxV2NFaFZNbmhYWVZaS2RHRkhSbGRpUjFKVVdrZDRjMk5zY0VaWGJYaFRUVVJXU0ZkVVFtRmhNVkp6VjI1S2FsSldXbGxXYWs1RFUwWnNObEpzY0d4U2JrSklXV3RrYjFVeVNrWmpSbkJYVmtWS1dGVjZTbE5qTVdSellVZHdVMVpVVm1oV2JYQkRXVlpPUjFkWWJFOVdiVkp2V1d0V2QxZFdXbGhsUm1SWFlsVndXbGxWV205V1YwVjRZMGRHWVZadFVsUlZiRnBIWkVkR1NHRkhlR2hOV0VKaFZtcEdVMUV5U1hsVldHaGhVbGRvVkZZd1pEUldNVnB5Vm10MFdsWnNjSHBXTW5oclZERktjMk5JYUZaaVZFVjNWakJhV21Rd05WWmhSbWhvVFd4S05sWnFRbUZUTWs1MFZHdFdWbUpIVWs5WmJURnZWMVphZEUxWWNHeFNiR3cwVmtkNGMyRkdTblJoU0VKV1lXczFkbHBIZUdGWFJURlZWV3h3VjAxSGR6QldiR1EwWVRKR1IxTnNXazlXYlZKWFdXeG9iMDB4VWxaWGJtUlhZa2hDUjFkcldtOWhWa3AxVVdwYVdGWkZTbGhaYWtaclpFWktXV0pIYUZOaE1IQmFWbTB4TkdReFVrZFZibEpPVmxoU1ZGUlhkR0ZUUmxsNVRWaE9XRkpyYkRWWlZWVXhWakpLVlZKcVRsWmhhM0JQV2xWYWEyUldVbk5oUjJ4b1RUQktVMVp0TUhkbFIwbDRWMnRrVm1KR2NHOVZiRlV4VmxaYWRFMVdUbGRpUmxwWldsVlZOVlp0UmpaU2JHaGFUVVp3ZGxacVFYaGpWbHB6Vld4d1YxWnVRbEZXVnpCNFZERk9SMU51VG1GU01taHZXbGQ0WVZWc1duSmFSRUphVm0xNFdWWlhkRzlXVjBaelkwWlNXbUV5VW5aV01GcFRWbXhXYzFwR1VsZGlTRUkwVmxSR2IySXlSbkpOVm1SWFlXczFWbFp0TVc5V1JtUlhXa1prYW1KVk5VaFpWVnAzVmpBd2VGTnRPVmhXYkZwb1dWUkdXbVZHY0VsVWJGSnBWMGRvVlZkV2FIZFdiVlpIVjI1T1lWSkdTbGhVVjNSaFVqRlNWMkZHVG1oU2F6VklXVEJhYjFZeVNuVlJhMUpWWVRGd2FGWnNXazlqYlU1SVpVWk9hVkp1UVRKV2Frb3dXVmRKZVZKc2FGUmlSMUpWV1d0V1lWZEdiSE5WYTA1UFVteHdWbFV5ZUd0aGF6RllWV3BHVjFZelRYaFdha1phWlVaT2RWZHNhRmRpVjJkNlZsZHdTMVl4V1hoV2JsWlZZbGRvVlZWcVJrdFhiR1JYWVVoa1UwMVZOVWhXTVdoelZHeGFObUpHYkZwaE1YQXpWV3BHV21WWFVrVlZiSEJYWVROQ1dsWnNaREJpTVZwMFVtNUtXR0pIYUdGYVYzUjNWVVpWZDFwRlpGTmhlbFpaV1d0YWExUnRTbGhoUldoWFlsUkdNMVY2UVRGU01XUlpZVWRzVTJKWGFGVldha0pyWWpGa1YySklTbUZTYXpWWVZXMHhORTFHY0ZaV2FrSm9ZbFZ3U0ZZeU5XOVdhekYxVVd4U1YySkdWalJXYWtwUFUxZEdSMWR0YkZoU2ExbDZWbTB4TUZsV2JGaFVXR3hWWVRKU1dWbHJXbmRVTVd4MFpFVjBWMVpzY0RCWk1GWkxZa1pLYzJKRVVsZE5hbFpJVm0weFMxTkhSa2hQVmxaWFlraEJlbFpHWkRSaE1WbDRWMjVTVTJKR1NrOVphMVozVTJ4YVdFMVVRbWhOVjFKSlZUSjBiMVp0U25KVGJHaFZWbGRTVkZwR1duZFhSMVpJVW0xd2FWSnVRWGRXVnpFMFlURlNjMU5yWkZoaGJIQllWbXRXY21WR1drVlNiVVpZVW1zMWVsbHJXa3RoUjFaMFpVWnNXRll6YUZSV2FrWkxVakZ3UjFwR2FHbFhSa3BaVmtaYVlXUXdNVWRXYmxKT1YwVTFWbGxyV25kbGJGbDRWV3RrVjAxV2J6SlZiWEJQVjBaYWMyTkhSbUZXVm5BelZXMHhSMU5IUmtkVWJXeFhUVzFvZGxacVJtdE5SbXhYVkZob1ZGZEhhRmRaYTFwM1YxWnNjMkZHVGxoU2JFcFlXVlZXVDFVd01WaFZibXhYVFc1b1VGWnRjM2hqYkdSVlUyeGthVmRGU205V2FrSmhWMjFXYzFadVZsUmlTRUp2V1ZSR2QxZEdaSE5XYlVab1RXczFlbGt3Vm10aFJrbDVaVVpTVlZaRmNIWlhWbHBoWkVVeFdWcEdWazVXYkZreFZsY3hNR0V4V1hsU2JrNXFVbXhLWVZaclZURldSbHB5VjJ4T1YwMVhVakZYYTJRMFZUSktTR1I2UmxoaVJscG9Wa1JLUjFJeFRuTldiRXBvWWtWd1dGWkdaSGRXTWxKelYyNUdVMkV6VW5GVVYzTXhVMVpzVmxkdFJtbFNNRlkwV1RCb2MxZEdaRWxSYTNoV1pXdGFTMXBWV25kVFZsSjBZVVpPVG1KdGFGcFdiVEIzVFZaRmQwMVlUbGhpYXpWb1ZUQmtVMVV4VWxkWGJrNU9UVlpLVjFsVll6VmhSa3BWVVdwV1YxWjZSblpXYlRGTFpGWkdkV05HWkU1U2JrSlZWbTF3UjFsWFVsZGpSVnBQVm1zMWNGVXdWa3RYYkZsNFYyeGthRTFFUmtoWGEyaFBWMGRLY21OSVJsWmlSMUpVVm1wR2MyTXlSa1pVYkdSVFlraENORlpVU2pCaE1rWjBVMnRvVm1KdVFtRldiRnAzVFRGc2NscEZXbXhTTUd3MldUQmFhMVl4U2xaalJ6bFhWMGhDVEZaSE1WZFNNVnAxVm14V2FWWldjRlZYVm1oM1ZqRldSMWRyWkZwTk1taHZWRlZTVjFkR1dYbE9WazVWWWtVMVNWWlhOVTlXYlVaeVYydG9WV0V4Y0ZoWmVrcEhVMVpTYzFwSGJGTk5WWEJMVmpGYVYxbFdiRmRhU0ZKVVlrZDRWbFl3Wkc5WlZsSldWMjVrV0ZKdVFrZFhhMXByVmtaYWRWRnJhRmhoTVZWNFZtcEJkMlZYUmtkaFJtUnBVbXR3VFZaSGRHRlZiVlpIWTBWYVlWSnRhSEJaV0hCWFYyeGtXRTFJYUdsTlZtdzBWakkxVjJGc1NuUlZia1phWVRGd00xcFZXbFpsVjFKRlVXeGFUbEpGV2pWV1IzaFhXVlphYzFkcVdsTmhNbWhZV1ZkMFlWbFdjRVZSV0doVVZqQmFTRmRyWkc5aFJURnhZVVJPVjJGcldtaFpWRVpTWlZaV2NscEdXbWxoTTBKM1ZsZHdUMUV4V2tkaVNGSnJVbGhTVjFWdGVIZFhWbXQzVm1wQ2FGWlVSa1pXYlRWM1ZqQXhXR0ZJV2xkTlIxSk1WbTE0YTJNeVNrZGpSMnhUWW10S2RsWnJXbGRaVmxsNVZXdG9WbUV5YUhKVmFrcHZWa1pzVlZOcVRteGlSbkI0VlRKd1UxWnJNVmhWYWtKV1lrZG9lbGxWV2t0V01VNXpXa1pXVjJKSVFYcFhWRW8wWTIxV1dGWnJhRk5pV0ZKVVZGWldkMU5XV25OYVNIQk9WbXhzTkZkclZtRldSbHBHVjJ4b1dsWkZjRk5VVlZwclZqRndSbU5IZUZkaE0wSTFWakowWVZVeFpFZFRXSEJvVTBoQ1dGWnVjRVpOUmxZMlVtMTBVMDFXV25wV01uaHZZVlphVjJOR1dsZFdla1V3VlhwS1YxWXhaRmxpUlRWWFZqRktkbFpHV2xka01WcHpWbTVTYTFOSFVsbFphMXAzVjBaYWMyRkhPVmROVm5CSFZXMXdVMVp0Um5KalJYUmhWak5vTTFWcVJuZFRSMHBIV2taT1YySkhkekpXYlhCSFdWWlZlRk5ZYkZOWFIyaFZWakJrYjJOV1ZuTlhibVJwVFZaYWVGWkhNRFZXTVVwMFpVaHdWMDF1VVhkWlZWcExZekpPUlZGdFJsTldia0o1VjFaU1FtVkdXWGxVYTFwb1VtNUNXRlZzVWxkTmJGcHhVVzEwVkUxVk5VaFdiVFZYVmtkS1IyTklRbFppV0ZJelZURmFZV1JGTVZWVmJIQlhZbFpLU2xadE1UQmlNa1Y0VTFoc2FGSnRhR0ZXYTFaMlpXeFNXR1ZHY0d4V01EVkhWREZrYjFSc1dYaFRhM0JYVmpOb2RsbHFSbXRUUms1eVlVZG9VMkpJUWxsWFYzUnJWVEZhUjFaWVpGaGlhelZRV1d0V2QwMUdjRVphUkVKWFRXdHdTbFZYY0dGV01WcEdZa1JTV21WcldsZGFSRUY0VjFaV2RHRkdUazVTYmtKYVZtdGFZVmxYVVhoWGEyUlhZV3h3VkZsclZURmpiRlowWlVoa2JGWnRVbmxXTWpBMVlVWktWVkpxUWxwV1YyaDJWbXBHUzJNeFRuSmxSbkJvWVRGd2VWWnRjRWRoTWxKWFZtNVNhMUpyTlU5VmJUVkRUbXhhZEUxSVpHeFNWRlpJVmpGb2IxZEdaRWhsUmtKWFlXczFWRll3V2xOV2JGWnlXa1pvVTJKWVVYcFhWbFp2WVRGWmQwMVlTbXBTVjNoaFZteGtiMkZHV25GUldHaFRUV3MxU1ZsVlduZGlSMFY2VVd4R1YxWkZTbkpWYWtaS1pVWndTVk5yT1ZkTmJXaDJWa1phYjFFeFduTlhia1pVWVd0S1YxUldWbUZsVmxKWFYyMTBXRkp0VWtsWlZWcHpWMjFLV1ZSWWFGZGlXR2g2V1hwR2QxSldWbk5hUms1cFYwZG5NVll4V2xkV01WRjRXa1ZvVkdFeVVuRlZhMVpMVm14YWRFMVhPV3BpUm5CNVZteG9iMkZ0U2xaalJWcFhWak5vYUZaSE1VdGtSMFpKWWtaa2FHRXdjSGxXV0hCSFUyMVdSMk5GYkZWaVIxSndWVEJXUzFkV1drZFZhM1JwVFZaS1dGWXlOVk5VYkZwSFUyeGtWVlpzY0hwVWExcGFaVmRXUjFwR1drNWhNMEpLVjFaV1lWVXhaSFJTV0d4b1VsVTFhRlZyVm1GaFJsVjNXa1prVkZKcmNIcFdiWE14WVVVeFdWRnJkRmRpUmtwTVZGVmFjMWRHU25WVWJGSm9UVmhDV2xkWGRHdFZNV1JIWWtoU1QxWlZOVmxWYlhoaFpWWlplVTFWWkdoaVJuQjVWR3hvYzFkSFJYbFZhazVhVmxkU1dGbDZSbXRrUmtweldrZG9hRTFxYUROV2FrWmhZVEZKZUZOdVNrNVdiVkp3VlcxMGQyTkdXbkZUYlRsWVlrZFNXVnBGWkVkaE1ERnlUbGh3VjAxdVVsaFdWRXBHWld4V2RWTnNXbWxYUjJodlYyeGFZV0V5VG5OYVNGSnJVakpvVkZSV1duZE9iRnB4VTFSR2FFMVdiRFJXTVdoM1lVWk9SMk5HWkZkaE1WcG9WbFZhYzA1c1NuUmtSM1JYWWtadmQxZFVRbUZVTVdSSFUyeGFhbEpyV2xoWmJGSkRUa1pTVmxwRk5XdE5SRlpYVjJ0YWIyRlhTa1pqUmtaWFlsUkdObFJXV210U01WcDFVbXhLYVdKV1NsWldiVEF4VVRGWmVGZFliRTVXUlVwWlZXcENkMVl4V25SalJtUlhUVlp3ZWxVeWRGTldNa1p5WTBWb1drMXVhSEphUm1SUFVqSk9SazVYYkdsV01sRXlWbTE0VTFFeFduSk9WbVJZVjBkb1ZsbHRkSGRWUmxwMFRWYzVWMUpzY0hwWlZWWlBWMGRLUjJORVFsVldiV2h5Vm10VmVGSldXbkpoUm5Cb1RWaENNbFp0ZEd0U2JWWlhWbTVPVjJKSVFuQldNRlY0VGtaa1ZWSnRSbGRpVmtZMFdUQldWMVp0U2toVmJrSldZbGhTTTFZeFdscGxWMUpJVW14V1RtRXpRa3BXVkVvd1lUSkdjMU5zYUd4U01taFlXV3RhZDAweFVsVlNiazVxWWtoQ1IxcEZXazlVYkZsNFUycGFWMkZyYnpCWFZtUkhWakZ3Um1GSGFGUlNNMmhaVjFkNGIxRXhUa2RXYWxwVFlsaFNWVlZ0ZUdGbFZscDBaVWRHYUZacmJEUlZNbmh6VjBaWmVsVnNhR0ZTUlZwUVZtcEdhMlJXVm5SalJrNVlVbXR3V0ZZeFpEUlpWbXhYVkd0a2FFMHlVbGhaYkdoVFlqRmFkR1JJVGs5V2JrSlhWako0VDFkSFNsWldhbFphVmxaYVZGZFdXa3BsYlVaSVlVWmFhR0V4Y0ZsWFZFbzBaREZKZUZadVNrOVdiVkpQVm14b1ExTXhXblJOV0dSVVlYcEdXRlpzYUhOVk1XUklZVVpXV21KWWFFeFdha1p6WTJ4a2RGSnNaR2xTYmtGM1YyeFdhMUl5U2toVGEyUlVZbTE0V0ZSWGNFZFRSbGwzVjJ0MFYxWnNjSHBYYTJSSFZURmFkVkZxU2xkaVJrcERXbFZhVDFZeFNuVlZiRTVwVWpGS2QxWlhjRUpsUlRWSFYyeG9hbEpYVW05VVYzaExVMFpWZVdWSVRtaFdhMncxV1ZWYVUxWXlTbGxWYWs1WFRVWndhRlZxUm5OT2JFcDBZa1UxYUUxWVFrcFdiVEUwWWpKRmVHSkdaRlJpUmxwd1ZXMTBTMWxXYkZWU2JVWk9UVlpLVjFZeU5VOVdNa3BJVlc1c1ZVMVdjSEpXUjNoaFYxWkdjMkpHYUZkTk1VcFZWbXhTUjFkdFVYZE5WbVJoVWpOQ1ZGbHNaRzlYVm1SWFdrUkNhMDFXVmpSWk1GcGhWMGRLV1ZWc2JGZGhhMG96VlRCYVlWTkhWa2hQVmxwT1VrVkpNVmRXVm1GaU1WbDVVMnhzVW1FeFNtRldhMVozVXpGd1ZsZHVaRk5pU0VKSVYydGtjMkZGTUhkVGJIQlhUVmRSTUZacVJuTlhSbEp6V2tkc1ZGSllRbTlXVjNSV1RWWlJlR0pJU2xoaVZWcFBWVzE0UzJWc1pISlZhMDVYVFd0Wk1sVnROWE5YYXpGSFYyNXdWMkZyV21oVWJYaGhaRmRPUjFwSGJGTmlSbXQzVm0weGQxTXhVWGhVYkdSVlltczFhRlZ0TVZOV1JsbDNWbXQwVldKR2JEUldWM1F3VkRGS2MxSnFWbGRTYldoNlZteGtSbVZXVm5SaFJscG9ZVEk0ZDFadGRHRlZNVnB6Vm01S1dHRjZWbFJaYTJRelRWWmtjbFp0UmxWTlZsWXpWRlphWVZReFdrWlRiR2hhWWtkb1ZGa3llR0ZrUlRGV1pFZHdhVlpVVmtwWFZsWmhXVmRHU0ZKcVdsZGhNVnBZV1d4b1UyRkdaRmRhUms1VFlYcFdXRll5ZUZkaFZrbDVZVWhrVjFZelFraFZla1pyWXpGa2NscEdaR2xXUjNoM1ZrWmFZV1F5VmxkVmJHUllZbFJzV0Zsc1ZsZE9WbXhXVjIwNVYxWnNiRFpWVjNodlZqRmFWMk5IYUdGU1ZsWTBWbTE0YTJSSFZrZGFSMnhUWW10RmVWWnFSbXROUm14WVVsaHNVMkpIVW1oVmJHUnZZVVpTVlZSclRsaFNiSEI1Vm0weFIyRkdTblZSYTFwV1lsaFJkMWxVUmt0amJVNUpZa1p3VjFZeFJqTldiRkpDWlVkU1NGSnJaRmRpUjJoWVZGUkdTMDFzV2xkVmEwcE9WakF4TkZrd1ZtdFdNa3BHWTBoQ1ZtRnJXa3hhUkVaaFVqRmtkRkp0Y0U1U1JVa3dWbXhrTkdFeVJrZFRiR2hXWWtkb1ZsWnFUbE5oUm5CWFYyeE9hazFYVWpCVU1WcHJWakpLU1ZGc2JGaFdSVXBVVmtSR2ExSXhaSFZVYlhCVFVsUldXVlpHVm1GV01EVkhWMjVTYkZOSFVsUlVWbHBoWld4a2NscEhPV2xTTUhCSVdWUk9jMVl5U2xsUmEzaFZWbGRTUjFwV1drOVhWMHBIVkcxb1RsZEZTbEZXYkZKRFlURlZlRmRzWkdsVFJYQnZWV3hWTVZkV1ZuUmxSWFJZVm14S2VsWXljelZYUmtweVkwUkNWMVl6YUhaV2FrRjRaRlpTV1dGR2NHaE5XRUp2VjFod1IxUXlUWGxVYTJScVVqSm9UMVl3Vmt0V2JGbDRWMnhrVjJKV1drbFdSbWh2VmxkS2NrNVlRbFppVkVaMlZqQmFVMVpXVG5SUFYzaFhZa2hDU2xkclZtdFNNa1pHVFZaYWFWSkdTbGxaVkVwdlYwWmFjbHBGZEZSU01GcEtWVmQ0YTJGV1NuVlJXSEJYWWxoQ1NGZFdaRk5TYXpGWFZteGFhVmRGU2xCV1YzUmhXVlpPVjFkdVJsTmlWR3h4VkZaYVMyVnNXWGxrUjBaWFVqQndWbGxyV21GV01rcEhZMFY0VmsxR2NHRmFSRVpyWkZaU2RHTkhiRk5pU0VFeVZtcEtNRmxYUlhsU2JHUllZa2Q0VTFsclpGTlhSbXh6Vld0YVRsSnNXbFpWYlRFd1lXc3hXRlZxUmxkU2VrWXpWbFJLUm1ReVRrZGhSbWhYWWxaR00xWXhXbUZXTVVsNVZHdGFZVkp0YUc5VVYzaExaVVphUjFkdGRGWk5SRVpJV1d0b1MxZEhSalppUnpsWFlsaFNNbFJYZUhOWFYwNUdaRVprVG1FeGNEVldha2w0WWpGWmVWSnVTbGhpYmtKWVdWZDBZV0ZHV1hoYVJXUlRUV3RhU1ZsclpHOWlSMHBIWW5wQ1YySllhSEpVYTFwelZqSktSMXBHYUZoU01taDNWbFJDVjJReFpFZFhia3BYWWxWYVdWWnRlR0ZOUmxKWFZXeE9hVkpzY0hwWmExSlhWbGRLU0ZWWVpGZE5SbkJNV1hwS1QxTlhUa2RqUjJoT1ZsaENXbFpxUm1GWlZrMTRXa1ZrVjJKSGVHaFZiVEZUVmtaU1ZWTnRPVlZXYlZKYVdUQldNRlpWTVZaalJFSldUVzVTY2xZd1pFZE9iRnAxVVd4d2FFMVdiM3BYYTJRMFYyMVdSMXBJVW10U1ZHeFVXVmh3UmsxV1duSlhiVGxxVFZad1dWVnNhSE5XYlVwVllrWmtXbUpHU2xoVmExcHlaREZrYzFwSGRGTk5WWEJMVmpKMFlXSXhXWGxUYTJ4U1lXeHdXRmxzVWtOT1JsWnhVbTEwVkZKck5YcFhhMXB2WVZaSmVGTnNaRmRpVkVVd1drUktSMUl5U2tkV2JFNW9UVEZLZUZaR1dsWk5WMVp6VjJ4b2JGTkhVbTlWYkZKSFYyeFdWMkZJWkZkTlZXOHlWV3hTUTFkc1drWlhiVVpoVmxad2NscEdXbGRrUjFKSFZHMW9iR0pHY0ZKV2JUQjNaREpXUmsxSVpFNVdiVkpaV1cxNFMxUXhWbkpXYlVaWFZteEtXRmRyV2s5V1JscHpWMjV3V2xaWGFGQlpWbHBMWTIxT1JWRnNjRmRXTVVwSlZtMXdTMUl5VG5KT1ZtUldZa2hDV0ZadE5VTk9iRnAwVFZSU2FFMXNTa2hWTWpWUFdWWktkRlZ0T1ZWV1JVcElWRlJHWVdNeGEzcGhSVGxUVFVaWk1GWnNZekZVTVd4WFUyeGthbEpzV21GV2ExVXhWa1paZDFkdFJtcGlSbkF4Vmtkek5WVXlTbkpUYTJSWFZucEZNRmRXWkV0U01XUjFVMnM1V0ZJemFGbFdSbVIzVWpBd2VGZHNWbFJoTTFKVlZtMTBZV1ZzYkhKWGJYUm9WbXh3U0ZZeGFIZFdNVm8yVVdwU1YxWjZSbGhWTUZwVFkyeGtkR0ZHVGxkU2JIQmFWakZhVTFReFJYbFdiazVZWWtkb1QxVXdaRzlXTVZKWFdrWk9iR0pIZUhsV01qRkhWMFpKZDJOR1dscGhNazB4Vm1wS1MxZFhSa1ZVYkdST1VtNUNOVmRyVWt0U01VNUhVMjVPYUZKck5YQlZNRlpIVFRGWmVGZHNaRlpOVmtZMFZqSTFVMVV5U25KalJteGFZbGhTTTFZd1duTlhSMUpJVW0xb1UySnJTa2xXYWtvMFZESkZlRk5ZWkZoaE1taFlWVzV3UmsxR2JGZFhiWFJVVWpCYVNWVnRlR3RoUjBWNFkwaHNWMUl6VW1oV01qRlhWakZhYzJKSGJGTmlWa3AzVjFab2QxWXhaRmRYYmtaU1lsaFNVRlZxUVhoT1JscDBUbFprYUdKRk5VZFViRnB6VmpKS1ZWSlVRbUZXTTJob1drVlZNVmRIVWtkaFJrNU9VMFZLUzFZeWVGZFpWMFY0VjFoc1ZHSkhlRk5aYTFwTFYwWlNWbHBHVGxWU2JGcDRWVEp6TlZVd01YSlhhMmhhVFVaVmVGWlVRWGhXYlU1R1kwWmthR0V4Y0c5V01WcGhWRzFXUjFSdVZsVmlWVnBWVlcxMGQyUnNXbGhOU0doV1RXczFTRlp0TlZOVU1WcFdUbFphVjJKVVJsUmFWbHBoWkVVeFZWRnNaR2hsYTFwWVYxUkNiMk14V2xoVGEyUnFVMFZ3V1ZadGVIZFVSbHB6VjIxR2FtRjZiRmhYYTJSelZUSktjbE50T1ZkaE1YQm9WMVphYzFkR1ZuSmhSbFpvVFZoQ2IxWlhjRXRpTVZGNFZtNUtWMkpWV2xWWmExcDNWMVpTVmxWclpGZFNWRVpZVlcxd1UxWXdNWEZXYkZKWFlsUkdURlV3V2xka1JrcHpZMGRzVTAxdGFGRldNbmhYV1Zaa2RGWnJaR0ZUUlRWeFZXcE9VMVF4V1hkV2EzUlVWbXh3ZVZkclVsTldNREZYVTI1d1YwMXFWbGhXVnpGSFl6RmtjMkZHY0ZkTk1VbzJWa2QwWVZZeVRsZFRibEpyVW1zMVQxWnNVbFpsUmxweldUTm9UMUpzY0VoV1IzUmhWa2RLU0dWR2FGcGlSMmhFVmxWYWMyTldUbkpQVjNCT1lUTkNTMVpVU1hoU01WVjRXa1ZrVkdKR1dsaFZiVEZUVG14U1YxZHJjR3hTYmtKS1ZUSjRiMkZXWkVkVGJHUllWak5vV0ZkV1pGZFdNV1IxVlcxd1UxWkhlRmxXUm1Rd1pERk9SMVpZYkd0U2VteFpWVzE0ZDAxR1dsaGxSVTVhVm10d1dGa3dXbE5YYXpGMVlVZG9XbVZyV2xCYVJXUkxVakZXYzFSc1pGaFNWWEJVVm0wd2VFNUhSblJWV0dST1ZtMVNWRmx0ZUV0WFJteDBZM3BHYUZKc1dqQlVWbHBQVjBaYWRHVkljRmRpVkVaSVZqQmFZV1JIVmtsalJtUk9ZV3RhU1ZaclpEUlRNazE0V2toR1VtSlZXbFJXYWtaTFUxWmFkR05GZEZSTlZuQXdWa2QwWVdGV1NuUlZiR2hWVmtWR00xcFZXbUZqVms1WllVWlNUbFl4U2xsV2JUQXhVekpLUjFOdVRtcFRSVXBYV1d4U1YxSkdjRmRYYlVacVZtdHdNRnBGV2xkVWJGcFpVV3BhV0ZaRlNsaFpWRVpoWkVaS2NWZHNaR2xTTW1oWlYxWmtlazFYVGxkalJWWlRZbFZhY1ZSV1dtRmxWbXQzVmxSR1YwMXJjRWRXTVZKRFZqSkdjbGR1V2xwbGExcG9WVEJhVDJOdFJraGhSazVzWWxob1dWWXhaRFJpTWtsNFZXdGtXRmRIVWxsWmJYTXhWMFphZEdSSVpFNVNiRm93VkZaak5WWnJNWEpqUlhCV1ZqTm9kbFpxU2tkamJVcEZWV3hXVjFadVFubFdWM0JIVkRGa1dGSnJaRlppVjJoUFdXeGtiMWxXV1hoWGJFNVVUVlphTUZaV2FHOVhSMFY1WVVoT1ZtSkhhRlJXYTFwelkyeGFWVkpzWkdsU2JIQmFWMnhXYTAxR1dsaFRiRnBxVTBoQ1YxUlhOVU5VUmxweFVtMTBWRlpyV25sWlZWcDNZa2RGZUdOSGFGaGlSbHBvVm1wS1UxWXhVblZWYkU1cFVsUldVRlpHVmxka01WcHpWMjVTVGxaRlNtOVVWVkpYVTBaa2NsZHRkRnBXYTNBd1dWVm9UMVp0U2xsVVdHaFhZVEZ3ZWxsNlJtdGpiSEJHVDFaT2FWTkZTbUZXYTJRMFZtczFWMXBGWkZSWFIxSnhWV3hrYjFsV1VsWmFSemxXVW14d2VGVXlkREJWTURGV1RsaHdXbFpXY0hKWlZXUkdaVWRPU0U5V1pGZFNWWEI1Vm0xd1IxUXhTWGhVYmxaV1lsZG9WRmxzV2t0a2JGcEhWV3RPVTAxRVFqUldNV2h6WVRGS05tSklTbFZXYkZwNlZHdGFXbVZIUmtsVWJHUlRUVVpaTVZkV1ZtRmhNV1J6VjFod2FGSkZOV0ZXYkZwM1lVWnNObEp0ZEd0V2JrSklXVEJhYTJGWFJYZGpSbkJYWWxoQ1RGUlZWWGhTTVhCR1drWm9XRkl4U25oV1YzaHJUa1pzVjFkdVRsaGliVkpYVlcweE5GZEdXWGxrUkVKWVVteHdlVll5Y0VOV1ZURlhZMGhLV2xac2NHaFZiWGhyVjFkT1IxcEhhRTVXV0VKT1ZteFNTbVZHV1hoWFdHaGhVMFphV0ZscldtRmpSbGwzVm10MFYxWnNjREJVVlZKSFZXc3hXRlZzYUZkTmFsWlVXVlJHUzJSR1ZuUlNiR1JwVjBkbmVsWnFRbUZYYlZaV1RsWmFZVkpzY0hCV2JHaERWMFphY1ZOcVVsZE5WbkF3VlRKNFYxVXhaRWhWYkZwWFlURmFhRmxWV25OT2JFcHpXa2R3YVZORlNrcFhWbFpoVkRKR1JrMUlaRlJpUjJoWVdXdGFkMk5zY0VWU2JFcHNVbTFTTVZVeWN6RldNa3BYVTJ4YVdGWnNTbEJaYWtaclVqSktSMkZIZEZOV01VcFJWbGN3TVZFeFRrZGFTRXBYWWxoU1YxUlZVa2RsVmxsNVpFYzVXR0Y2UmtsV1Z6VmhWMnhhVjFacVVsZE5WbkJJV2tWVk5WWXhjRVpPVjJ4cFZqSm9NbFp0Y0VkWlZteFhWVzVTVjJKSFVsZFphMlEwWWpGV2NWUnJUbGRTYkhCNFZXMTBNR0V5U2tkalJteGFUVVpaZDFsV1ZYaGphelZXWVVaa2FWSXlhSGxXYlhCTFVtMVdjMVp1U2xCV2JGcFlXV3RvUW1Wc1pITmFSRkphVm0xU1NWWlhkR0ZWUmxwMFZXczVWbUV4V21oVWJYaGhWMFV4V1ZwR1pFNVdia0YzVmxSS05HTXhXblJUYmtwcVVtMW9ZVlpxVGxOTk1WcEdWMjVPVDJKRmNIbFVNV1IzWVVkV2RHVkdiRmROYmxKeVdYcEdhMUl4VG5WVGJXeFRVbTVDV1ZkWGVHOVZNVnBIVm01R1UySklRbk5XYlhoaFpWWlplV042UmxkTmEzQklXVEJhYjFkR1dYcGhTRnBhWVd0YWNsVnFTa3RUVms1MFlVWk9WMWRGU2pWV2ExcGhZVEZWZUZkdVRsZGlSMmhQVm14a1UxZEdXbk5WYTJSc1ZteHNOVnBGWkRCV01WcHpZMGh3V2sxSFVuWldNbmhhWlcxR1IxRnNXazVXYmtKSlYydFdZVk15VFhoWGJrNWhVbTFTVDFac1l6Vk9WbHB4VTJwQ2FFMUVWa2haYTFwdlZsZEtTRlZzVmxwaVdHaE1WbXRhYzFkWFRrbFViWEJUWWtad05sZFdWbGRVTVZGNFUyNU9hbE5IZUZsWlZFWkxWa1pzVmxaWWFGZE5hM0JHVmxkNFlWUnRTblJoUkZwWFlrZE9ORlY2Ums5VFJscHlXa2RzVTJKclNsbFdWM2hoWkRKSmVGcEdWbFJoYkVwaFZtMTRkMWRHVm5SbFJtUldUV3R3V2xWWGN6VldNa3BIVTJ4a1lWWldjR2haTW5oeVpXMUdTR0pGTlZkaVJtdzJWbXRhWVdJeFZYbFNhMlJVWW10d1ZWbHJaRzlaVm14eVYydDBVazFZUWxkV01uaHJWMFpLVlZKc2FGaGhNWEJ5VmtkNFdtVkdUbGxoUm1ScFVqQTBNRlpHVm1GV2JWRjNUVlZzYUZKc1NuQlZiRnAzVjFaYWRHTkZPVkpOVlRWSVZtMXdZVlZzWkVoaFJsSlZWbTFTVkZSV1dtRlhSVEZWVVd4YVRsSkZTVEJXVkVvMFlqRlplRk51VWxaWFIxSm9WV3RXZDFkR1duRlNiR1JyVm14S2VsbFZaSE5YUmtweVkwZEdWMDFYVVRCV2FrWmFaREExVmxwR2FGaFNNMmg0VmxkNFUyTXhaRmRpU0U1WFlsVmFjMVp0ZUhOT1ZtdDNWbFJXVjAxRVJrWlZiWFJ2VmpKS1dWRnNVbGRoYTNCTVZXcEtUMUl5UmtoU2JFNVhUVlZ3VGxac1kzaGxhekZYVjFob2FsSlhhSEJWYWtwdlZERldkRTFVVGs1aVJuQXdWRlZvYjFSc1NYZFdhazVWWWtaYWRsWnJXbXRUUjFaSFZXeGtUbEl4U2pKV2FrSmhWMjFSZUdORlpGVmlSbHBQVm0weE0yVnNXblJOUkVab1RWWndWMVJXV210aGJFNUlaVVpvVlZaNlZsTmFSRVphWlZkV1NGSnRkRk5OVm5CSlZtcEtORmxYUmxkYVJXUlRZV3MxV1ZadGVHRmhSbFkyVTJzMWJGWnNTbmxaYTJSelZUSktXR0ZJV2xkU2JIQm9XWHBCZDJWR2NFZGFSbkJPVFcxb1ZWWkdWbE5XTWxaelYxaHNUMVpVYkc5WmExWjNUVVphV0dWR1RsZFdiSEJIV1RCb1YxbFdXWHBoUjJoYVRWWndTRnBGV2t0ak1WcHlUbFprV0ZKVmEzbFdiVEV3WVdzeFYxTllhRmhoTW1oVldWUktiMVl4YkhKWGEzUlhZa1p3ZVZadE1VZFdWa3AwWlVob1ZtSlVSWGRaVnpGTFVqRmtkV0pHYUdoTldFRjZWbTF3UW1WR1duUlVhMXBwVW0xU1dGVnNaREJPUmxwWlkwVmthazFXYkRSV1IzaHpXVlpLZEdGSVFsWmlXRkl6V1ZWYWExWXhWbkphUm5CWFZrVkpNRmRVUWxkV01WVjVVMnhhV0dKcmNGZFpWM1JoWVVaVmVGZHNTbXhTYlZKNVdrVmFWMkZXU25WUmJIQllZVEpvTTFWVVJscGxWa3AxVTIxc2JHRXdjR2hYVm1Rd1pERlNSMVp1UmxOaGVteHlWbTF6TVdWV1VYaFhiWFJvVm14c05WbFZXbTlXTWtwVlVXcFNWV0V4Y0doYVJWcGhZMnh3UjFkdGJGTmlhMHBoVmpGa01GbFhVWGxVV0doWVltdGFWRmxVVGxOV1ZsWjBUVlpPYkZac2JEVlVWbFpyVmpGWmQyTkZhRnBOUmtwSVZtMTRXbVZzVm5WalJtUm9ZVE5DU1ZkVVNYaFRiVlp6WTBWa1YySkhVbGhaYlhSTFRsWlplV1JHWkZwV2F6RTBWMnRhYjFVeVJYbFZiR1JhWWtkU2RsWkVSbk5qYkZwMVdrWm9VMkpIZHpCV01uUlRVVEZrYzFkdVVteFNiWGhZV1d4U1YxVkdiRmRYYTNSVFRXczFTRlpIZUd0VWJFbDRVMnBLVjJGclNtaFhWbVJQVmpGS2RWUnRSbE5XUjNoWlYxZDRiMkl3TlZkWGJrWlVWa1ZhVmxSV1pGTlRSbFY1VGxWMGFHSkZjRmxXVjNoclYyMUZlR05GZUZkTlJuQm9XVEo0YTJNeVRraGxSMnhVVWxWd1NGWnRlR3RPUmxsNFZXNU9XR0pHV2xoWldIQkhWMFpTV0U1V1RtcGlSMUpZVmpKNGEyRnJNVlpYYm5CWFlsaE5lRlpVUVhoa1YwWklVbXhrYUdFd2NGVldWbVI2VGxaYWRGTnJiRlZoZWxaWVZXcE9VMlF4V1hkWGJUVnJUVlZLVlZVeU1WTmlWbFpWVFVSc1NtSkVSVFZKYkRFNUlsMTkiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBjbGFzc05hbWVzID0gcmVxdWlyZSgnY2xhc3NuYW1lcycpO1xuXG52YXIgTmVtZXNpcyA9IHJlcXVpcmUoJy4uL25lbWVzaXMnKTtcblxuZnVuY3Rpb24gVXNlcih7ZXZlbnR9KSB7XG4gIGNvbnN0IG91dHB1dCA9IHVzZXJzTGlzdC5tYXAodXNlciA9PiB7XG4gICAgLy8gVE9ETzogRXh0cmFjdCB0aGUgd2hvbGUgd2lucywgbm8uIG9mIGV2ZW50cyBhbmQgd2lucmF0aW8gaW50byBhIGNvbXBvbmVudFxuICAgIGxldCB0b3RhbEdhbWVzV29uID0gMDtcbiAgICBjb25zdCB0b3RhbEdhbWVzUGxheWVkID0gdXNlci5ldmVudHMubWFwKHVzZXJFdmVudCA9PiB7XG4gICAgICBpZiAodXNlckV2ZW50Lndpbm5lci5pbmNsdWRlcyh1c2VyLm5hbWUpKSB7XG4gICAgICAgIHRvdGFsR2FtZXNXb24gKz0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgJHt1c2VyRXZlbnQuZ2FtZU5hbWV9LCBgXG4gICAgfSk7XG4gICAgY29uc3Qgd2luUmF0aW8gPSBNYXRoLnJvdW5kKHRvdGFsR2FtZXNXb24gLyB0b3RhbEdhbWVzUGxheWVkLmxlbmd0aCAqIDEwMCAqIDEwKSAvIDEwO1xuICAgIHJldHVybiAoXG4gICAgICA8bGkgY2xhc3NOYW1lPVwicm93IHVzZXItY2FyZFwiIGtleT17dXNlci5pZH0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5mb1wiPlxuICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJuYW1lXCI+e3VzZXIubmFtZX08L2gyPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2luLXJhdGlvXCI+e3dpblJhdGlvfSU8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIndpbnNcIj57dG90YWxHYW1lc1dvbn0gb2Yge3RvdGFsR2FtZXNQbGF5ZWQubGVuZ3RofTwvZGl2PlxuICAgICAgICAgIDxOZW1lc2lzIHVzZXI9e3VzZXJ9IC8+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhbGwtZ2FtZXNcIj5BbGwgR2FtZXMgcGxheWVkOiB7dG90YWxHYW1lc1BsYXllZH08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2xpPlxuICAgICk7XG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPHVsPlxuICAgICAge291dHB1dH1cbiAgICA8L3VsPlxuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXI7XG5cbi8qXG4vLyBjb25zdCB4ID0gaWYgKHRoaXMudXNlckV2ZW50cyh1c2VyKS5sZW5ndGggPiAwKSB7XG4vLyAgIC8vIGxldCBnYW1lcyA9IHRoaXMudXNlckJlc3RFdmVudCh1c2VyKS5tYXAodmFsID0+IHtcbi8vICAgLy8gICByZXR1cm4gPHNwYW4gY2xhc3NOYW1lPVwiZ2FtZXNcIj5cbi8vICAgLy8gICAgIHt2YWwubmFtZX0gPHNwYW4gY2xhc3NOYW1lPVwiY291bnRcIj4oe3ZhbC5jb3VudH0pPC9zcGFuPlxuLy8gICAvLyAgIDwvc3Bhbj47XG4vLyAgIC8vIH0pO1xuLy8gICAvLyBpZiAodGhpcy51c2VyQmVzdEV2ZW50KHVzZXIpLmxlbmd0aCA9PT0gMCkge1xuLy8gICAvLyAgIGdhbWVzID0gXCJObyB3aW5zIHlldFwiXG4vLyAgIC8vIH1cbi8vICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwicm93IHVzZXItY2FyZFwiPlxuLy8gICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5mb1wiPlxuLy8gICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb3N0LXdpbnNcIj5Nb3N0IHdpbnMgaW46IHtnYW1lc308L2Rpdj5cbi8vICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibmVtZXNpc1wiPk5lbWVzaXM6IHt0aGlzLnVzZXJOZW1lc2lzKHVzZXIpfTwvZGl2PlxuLy8gICAgIDwvZGl2PlxuLy8gICA8L2Rpdj5cbi8vIH1cbi8vIFdoaWNoIGV2ZW50cyBhIHVzZXIgaGFzIHdvblxuLy8gdXNlcldpbnModXNlcikge1xuLy8gICBsZXQgd2lucyA9IFtdO1xuLy8gICBldmVudHNMaXN0Lm1hcChldmVudCA9PiB7XG4vLyAgICAgaWYgKGV2ZW50Lndpbm5lciA9PT0gdXNlci5pZCkge1xuLy8gICAgICAgd2lucy5wdXNoKGV2ZW50LmdhbWVOYW1lKTtcbi8vICAgICB9XG4vLyAgIH0pO1xuLy8gICByZXR1cm4gd2lucztcbi8vIH0sXG5cblxuXG4vLyB1c2VyTmVtZXNpcyh1c2VyKSB7XG4vLyAgIGxldCBkaWROb3RXaW4gPSBbXTtcbi8vICAgZXZlbnRzTGlzdC5tYXAoZXZlbnQgPT4ge1xuLy8gICAgIGlmIChldmVudC5wbGF5ZXJzLmluY2x1ZGVzKHVzZXIuaWQpICYmICh1c2VyLmlkICE9IGV2ZW50Lndpbm5lcikpIHtcbi8vICAgICAgIGRpZE5vdFdpbi5wdXNoKGV2ZW50KTtcbi8vICAgICB9XG4vLyAgIH0pO1xuLy9cbi8vICAgY29uc3QgeHMgPSBkaWROb3RXaW4ubWFwKHZhbCA9PiB7XG4vLyAgICAgcmV0dXJuIHZhbC53aW5uZXI7XG4vLyAgIH0pO1xuLy9cbi8vICAgY29uc3QgY291bnRzID0geHMucmVkdWNlKChhLCBiLCBpLCBhcnJheSkgPT4ge1xuLy8gICAgIGNvbnN0IGZpbmQgPSBfLmZpbmQoYSwgWyd3aW5uZXInLCBhcnJheVtpXV0pO1xuLy8gICAgIGlmIChmaW5kKSB7XG4vLyAgICAgICBmaW5kLmNvdW50ICs9IDE7XG4vLyAgICAgICByZXR1cm4gYTtcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgcmV0dXJuIGEuY29uY2F0KHt3aW5uZXI6IGFycmF5W2ldLCBjb3VudDogMX0pXG4vLyAgICAgfVxuLy8gICB9LCBbXSk7XG4vL1xuLy8gICBjb25zdCBvdXRwdXQgPSBjb3VudHMucmVkdWNlKChhY2MseCkgPT4ge1xuLy8gICAgIGlmIChhY2MubGVuZ3RoID09PSAwKSB7XG4vLyAgICAgICBhY2MucHVzaCh4KVxuLy8gICAgIH0gZWxzZSBpZiAoYWNjWzBdLmNvdW50IDwgeC5jb3VudCkge1xuLy8gICAgICAgYWNjID0gW3hdO1xuLy8gICAgIH0gZWxzZSBpZiAoYWNjWzBdLmNvdW50ID09PSB4LmNvdW50KSB7XG4vLyAgICAgICBhY2NbMF0uY291bnQgKz0gMTtcbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIGFjYztcbi8vICAgfSwgW10pXG4vL1xuLy8gICBjb25zdCBmaW5hbCA9IHVzZXJzTGlzdC5tYXAodXNyID0+IHtcbi8vICAgICBjb25zdCBkID0gb3V0cHV0Lm1hcChkID0+IHtcbi8vICAgICAgIGlmICh1c3IuaWQgPT09IGQud2lubmVyKSB7XG4vLyAgICAgICAgIHJldHVybiB1c3IubmFtZTtcbi8vICAgICAgIH1cbi8vICAgICB9KTtcbi8vICAgICByZXR1cm4gZDtcbi8vICAgfSk7XG4vL1xuLy8gICByZXR1cm4gZmluYWw7XG4vLyB9LFxuLy9cbi8vIC8vIEdldCB1c2VyJ3MgbW9zdCBzdWNjZXNzZnVsIGV2ZW50XG4vLyB1c2VyQmVzdEV2ZW50KHVzZXIpIHtcbi8vXG4vLyAgIGNvbnN0IGxpc3QgPSB0aGlzLnVzZXJXaW5zKHVzZXIpO1xuLy9cbi8vICAgY29uc3QgY291bnRzID0gbGlzdC5yZWR1Y2UoKGEsIGIsIGksIGFycmF5KSA9PiB7XG4vLyAgICAgY29uc3QgZmluZCA9IF8uZmluZChhLCBbJ25hbWUnLCBhcnJheVtpXV0pO1xuLy8gICAgIGlmIChmaW5kKSB7XG4vLyAgICAgICBmaW5kLmNvdW50ICs9IDE7XG4vLyAgICAgICByZXR1cm4gYTtcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgcmV0dXJuIGEuY29uY2F0KHtuYW1lOiBhcnJheVtpXSwgY291bnQ6IDF9KVxuLy8gICAgIH1cbi8vICAgfSwgW10pO1xuLy9cbi8vICAgY29uc3Qgb3V0cHV0ID0gY291bnRzLnJlZHVjZSgoYWNjLHgpID0+IHtcbi8vICAgICBpZiAoYWNjLmxlbmd0aCA9PT0gMCkge1xuLy8gICAgICAgYWNjLnB1c2goeClcbi8vICAgICB9IGVsc2UgaWYgKGFjY1swXS5jb3VudCA8IHguY291bnQpIHtcbi8vICAgICAgIGFjYyA9IFt4XTtcbi8vICAgICB9IGVsc2UgaWYgKGFjY1swXS5jb3VudCA9PT0geC5jb3VudCkge1xuLy8gICAgICAgYWNjLnB1c2goeCk7XG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBhY2M7XG4vLyAgIH0sIFtdKVxuLy9cbi8vICAgcmV0dXJuIG91dHB1dDtcbi8vIH0sXG4vL1xuLy8gLy8gQ2FsY3VsYXRlIHBlcmNlbnRhZ2Ugd2luIHJhdGlvIG9mIGEgdXNlclxuLy8gdXNlcldpblJhdGlvKHVzZXIpIHtcbi8vICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy51c2VyV2lucyh1c2VyKS5sZW5ndGggLyB0aGlzLnVzZXJFdmVudHModXNlcikubGVuZ3RoICogMTAwICogMTApIC8gMTA7XG4vLyB9LFxuXG4qL1xuIl19
